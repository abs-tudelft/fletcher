<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Fletchgen: Fletchgen: The Fletcher Design Generator</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Fletchgen
   </div>
   <div id="projectbrief">The Fletcher Design Generator</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Fletchgen: The Fletcher Design Generator </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_README"></a> Fletchgen is a command-line utility that generates the upper layers of a hardware design, including simulation and platform-specific top-levels, based on Arrow Schemas and Recordbatches.</p>
<h3>What does Fletchgen generate?</h3>
<ul>
<li>For each <b>Arrow Field</b>, an <b>ArrayReader/Writer</b> is instantiated.</li>
<li>For <b>each Arrow Schema</b>, a <b>RecordBatchReader/Writer</b> is generated and wrapper around all ArrayR/W instances.</li>
<li>For <b>all Arrow Schemas</b>, a <b>Kernel template</b> is generated.</li>
<li>The Kernel is wrapped in a <b>Nucleus</b> that hides low-level control flow to RecordBatchR/W's and instantiates the MMIO component that handles AXI4-lite memory-mapped input/output.</li>
<li>All RecordBatchR/W's and the Nucleus is wrapped by a <b>Mantle</b>. The Mantle also instantiate the required memory bus interconnection logic.</li>
</ul>
<p>This can also be shown schematically as follows: <img src="./docs/fletchgen.svg" alt="Fletchgen output, schematically" style="pointer-events: none;" class="inline"/></p>
<h3>What does Fletchgen NOT generate?</h3>
<p>Fletchgen does <b>not</b> generate the kernel itself.</p>
<h3>What top-levels does Fletcher generate?</h3>
<p>It currently supports only two top-level platforms.</p>
<ul>
<li>One platform is a <b>simulation top-level</b> that uses a memory model that can be filled with RecordBatches.<ul>
<li>To enable this top-level, use the <code>--sim</code> flag.</li>
</ul>
</li>
<li>The other is an <b>AXI top-level</b> that has an AXI4 (full) master port and AXI4-lite slave port.<ul>
<li>To enable this top-level, use the <code>--axi</code> flag.</li>
</ul>
</li>
</ul>
<h1>Prerequisites</h1>
<ul>
<li><a href="https://clang.llvm.org/">C++17 compliant compiler</a></li>
<li><a href="https://github.com/apache/arrow">Apache Arrow 7.0+</a></li>
<li><a href="https://cmake.org/">CMake 3.14+</a></li>
</ul>
<h1>Build &amp; install</h1>
<p>Fletchgen is under heavy development, so for now we'd recommend to make a debug build using CMake as follows:</p>
<div class="fragment"><div class="line">git clone https://github.com/abs-tudelft/fletcher.git --recursive</div>
<div class="line">cd fletcher/codegen/cpp/fletchgen</div>
<div class="line">mkdir debug</div>
<div class="line">cd debug</div>
<div class="line">cmake ..</div>
<div class="line">make</div>
<div class="line">sudo make install</div>
</div><!-- fragment --><h1>Usage</h1>
<ul>
<li>Read the command-line options.</li>
</ul>
<div class="fragment"><div class="line">fletchgen -h</div>
</div><!-- fragment --><p>An example how to use Fletchgen can be found here.</p>
<p>A very gentle tutorial / introduction to Fletcher including how to use Fletchgen and how to generate input files for Fletchgen can be found here.</p>
<h1>Supported/required metadata for Arrow Schemas</h1>
<p>Fletchgen derives how to use an Arrow Schema from attached key-value metadata that is stored in Arrow Schemas. You can use this to, for example, prevent the generation of hardware structures for fields that you're not going to use in your kernel implementation.</p>
<h2>Schema metadata:</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Key   </th><th class="markdownTableHeadNone">Possible values   </th><th class="markdownTableHeadNone">Default   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">fletcher_name   </td><td class="markdownTableBodyNone">any string   </td><td class="markdownTableBodyNone">none   </td><td class="markdownTableBodyNone">The name of the schema. This is required for the schema to be identifiable after hardware generation.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">fletcher_mode   </td><td class="markdownTableBodyNone">read / write   </td><td class="markdownTableBodyNone">read   </td><td class="markdownTableBodyNone">Determines whether a RecordBatch of this schema will be read or written by the kernel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">fletcher_bus_spec   </td><td class="markdownTableBodyNone">aw,dw,lw,bs,bm   </td><td class="markdownTableBodyNone">64,512,8,1,16   </td><td class="markdownTableBodyNone">Key to set the bus specification of the RecordBatchReader/Writer resulting from this schema. aw: address width, dw: data width, lw: burst length width, bs: minimum burst size, bm: maximum burst size.   </td></tr>
</table>
<h2>Field metadata:</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Key   </th><th class="markdownTableHeadNone">Possible values   </th><th class="markdownTableHeadNone">Default   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">fletcher_ignore   </td><td class="markdownTableBodyNone">true / false   </td><td class="markdownTableBodyNone">false   </td><td class="markdownTableBodyNone">If set to true, ignore a specific schema field, preventing generation of hardware to read/write from/to it.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">fletcher_epc   </td><td class="markdownTableBodyNone">1 / 2 / 4 / ...   </td><td class="markdownTableBodyNone">1   </td><td class="markdownTableBodyNone">Number of elements per cycle for this field. For <code>List&lt;X&gt;</code> fields where X is a fixed-width type, this applies to the <code>values</code> stream.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">fletcher_lepc   </td><td class="markdownTableBodyNone">1 / 2 / 4 / ...   </td><td class="markdownTableBodyNone">1   </td><td class="markdownTableBodyNone">For <code>List&lt;primitive&gt;</code> fields only. Number of elements per cycle on the <code>length</code> stream.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">fletcher_profile   </td><td class="markdownTableBodyNone">true / false   </td><td class="markdownTableBodyNone">false   </td><td class="markdownTableBodyNone">If set to true, mark this field for profiling. The hardware streams resulting from this field will have a profiler attached to them.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">fletcher_tag_width   </td><td class="markdownTableBodyNone">1 / 2 / 3 / ...   </td><td class="markdownTableBodyNone">1   </td><td class="markdownTableBodyNone">Width of the <code>tag</code> field of commands and unlock streams of RecordBatchReaders/Writers. Can be used to identify commands.   </td></tr>
</table>
<h1>Custom MMIO registers</h1>
<p>You can add custom MMIO registers to your kernel using <code>--reg</code>. More information can be found here.</p>
<h1>Custom external I/O</h1>
<p>Sometimes, your kernel requires other I/O signals than just Arrow data streams in and out, and MMIO registers. There may be some other type of data source or sink in your design, there may be some platform-specific things you want to use, or etcetera.</p>
<p>You can supply Fletchgen with a YAML file describing what signals you want to draw between the kernel and the top-level. An example is shown below, where we want to handshake completion from the platform top-level with a <code>req</code> and <code>ack</code> bit.</p>
<div class="fragment"><div class="line">- record:</div>
<div class="line">  name: platform</div>
<div class="line">  fields:</div>
<div class="line">    - record:</div>
<div class="line">      name: complete</div>
<div class="line">      fields:</div>
<div class="line">        - field:</div>
<div class="line">          name: req</div>
<div class="line">          width: 1</div>
<div class="line">        - field:</div>
<div class="line">          name: ack</div>
<div class="line">          width: 1</div>
<div class="line">          reverse: true</div>
</div><!-- fragment --><p>This will result in the following signals appearing at the top-level:</p>
<div class="fragment"><div class="line"><span class="vhdlchar">ext_platform_complete_req</span> <span class="vhdlchar">:</span> <span class="keywordflow">out</span> <span class="keywordtype">std_logic</span>;</div>
<div class="line"><span class="vhdlchar">ext_platform_complete_ack</span> <span class="vhdlchar">:</span> <span class="keywordflow">in</span>  <span class="keywordtype">std_logic</span></div>
</div><!-- fragment --><ul>
<li>The signals are assumed to be driven by the kernel. To drive them from the top level, use:</li>
</ul>
<div class="fragment"><div class="line">reverse: true</div>
</div><!-- fragment --><ul>
<li>Fields with a width of 1 can be forced to be <code>std_logic_vector</code> instead of <code>std_logic</code> by using:</li>
</ul>
<div class="fragment"><div class="line">vector: true</div>
</div><!-- fragment --><h1>Further reading</h1>
<p>You can generate a simulation top level and provide a Flatbuffer file with a RecordBatch to the simulation environment. You can use this to debug your designs in simulation, independent of an FPGA platform specific simulation environment. An example is shown here.. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
