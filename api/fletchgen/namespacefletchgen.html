<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Fletchgen: fletchgen Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Fletchgen
   </div>
   <div id="projectbrief">The Fletcher Design Generator</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">fletchgen Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Contains all classes and functions related to Fletchgen.  
<a href="namespacefletchgen.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacefletchgen_1_1meta"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefletchgen_1_1meta.html">meta</a></td></tr>
<tr class="memdesc:namespacefletchgen_1_1meta"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fletchgen metadata keys for Cerata objects. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfletchgen_1_1_axi4_lite_spec.html">Axi4LiteSpec</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">AXI4-lite bus specification.  <a href="structfletchgen_1_1_axi4_lite_spec.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfletchgen_1_1_axi4_lite_port.html">Axi4LitePort</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An AXI4-lite port derived from an AXI4-lite specification.  <a href="structfletchgen_1_1_axi4_lite_port.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfletchgen_1_1_bus_dim.html">BusDim</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds bus interface dimensions.  <a href="structfletchgen_1_1_bus_dim.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfletchgen_1_1_bus_dim_params.html">BusDimParams</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds bus parameters based on bus dimensions, that has actual nodes representing the dimensions.  <a href="structfletchgen_1_1_bus_dim_params.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfletchgen_1_1_bus_spec_params.html">BusSpecParams</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds bus parameters and function based on bus dimensions, that has actual nodes representing the dimensions.  <a href="structfletchgen_1_1_bus_spec_params.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfletchgen_1_1_bus_spec.html">BusSpec</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds bus dimensions and function, without instantiating Cerata nodes.  <a href="structfletchgen_1_1_bus_spec.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfletchgen_1_1_bus_port.html">BusPort</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A port derived from bus parameters.  <a href="structfletchgen_1_1_bus_port.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfletchgen_1_1_design.html">Design</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure for all components in a Fletcher design.  <a href="structfletchgen_1_1_design.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfletchgen_1_1_kernel.html">Kernel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structfletchgen_1_1_kernel.html" title="The Kernel component to be implemented by the user.">Kernel</a> component to be implemented by the user.  <a href="structfletchgen_1_1_kernel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfletchgen_1_1_mantle.html">Mantle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A component that wraps a <a class="el" href="structfletchgen_1_1_kernel.html" title="The Kernel component to be implemented by the user.">Kernel</a> and all ArrayReaders/Writers resulting from a Schema set.  <a href="classfletchgen_1_1_mantle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfletchgen_1_1_mmio_reg.html">MmioReg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to represent an MMIO register.  <a href="structfletchgen_1_1_mmio_reg.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfletchgen_1_1_mmio_port.html">MmioPort</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A port on the vhdmmio component. Remembers what register spec it came from.  <a href="structfletchgen_1_1_mmio_port.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfletchgen_1_1_nucleus.html">Nucleus</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">It's like a kernel, but there is a kernel inside.  <a href="structfletchgen_1_1_nucleus.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfletchgen_1_1_options.html">Options</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fletcher program options.  <a href="structfletchgen_1_1_options.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfletchgen_1_1_field_port.html">FieldPort</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A port derived from an Arrow field.  <a href="structfletchgen_1_1_field_port.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfletchgen_1_1_record_batch.html">RecordBatch</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="structfletchgen_1_1_record_batch.html" title="A RecordBatch aggregating ArrayReaders/Writers.">RecordBatch</a> aggregating ArrayReaders/Writers.  <a href="structfletchgen_1_1_record_batch.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfletchgen_1_1_fletcher_schema.html">FletcherSchema</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfletchgen_1_1_schema_set.html">SchemaSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A named set of schemas.  <a href="classfletchgen_1_1_schema_set.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a11e5a137c642ba21be810f5a60b8d77f"><td class="memItemLeft" align="right" valign="top"><a id="a11e5a137c642ba21be810f5a60b8d77f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefletchgen.html#a11e5a137c642ba21be810f5a60b8d77f">RBVector</a> = std::vector&lt; std::shared_ptr&lt; arrow::RecordBatch &gt; &gt;</td></tr>
<tr class="memdesc:a11e5a137c642ba21be810f5a60b8d77f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for vector of RecordBatches. <br /></td></tr>
<tr class="separator:a11e5a137c642ba21be810f5a60b8d77f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f8522273f3602bf48837f1a6930520b"><td class="memItemLeft" align="right" valign="top"><a id="a5f8522273f3602bf48837f1a6930520b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefletchgen.html#a5f8522273f3602bf48837f1a6930520b">NodeProfilerPorts</a> = std::map&lt; Node *, std::pair&lt; std::vector&lt; Instance * &gt;, std::vector&lt; Port * &gt; &gt;&gt;</td></tr>
<tr class="memdesc:a5f8522273f3602bf48837f1a6930520b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A mapping from nodes to profiler instances and ports. <br /></td></tr>
<tr class="separator:a5f8522273f3602bf48837f1a6930520b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bdd714a10405ea5ac07e72860741bad"><td class="memItemLeft" align="right" valign="top"><a id="a8bdd714a10405ea5ac07e72860741bad"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Status</b> = putong::Status&lt; <a class="el" href="namespacefletchgen.html#a202f040e54b3beba93c85c62cd8ff543">Error</a> &gt;</td></tr>
<tr class="separator:a8bdd714a10405ea5ac07e72860741bad"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:aabc1aa5af7c948aeb93dddcb947fbb6a"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefletchgen.html#aabc1aa5af7c948aeb93dddcb947fbb6a">ConfigType</a> { <br />
&#160;&#160;<a class="el" href="namespacefletchgen.html#aabc1aa5af7c948aeb93dddcb947fbb6aad6308321b10e1c1466474b9248802268">ARB</a>
, <a class="el" href="namespacefletchgen.html#aabc1aa5af7c948aeb93dddcb947fbb6aa890f5fe6581170eeff26bec1c1e6a023">NUL</a>
, <a class="el" href="namespacefletchgen.html#aabc1aa5af7c948aeb93dddcb947fbb6aa954b965bc0539f07ab3090129a0d4b2d">PRIM</a>
, <a class="el" href="namespacefletchgen.html#aabc1aa5af7c948aeb93dddcb947fbb6aa298cb25408234de02baf2085803a464a">LIST</a>
, <br />
&#160;&#160;<a class="el" href="namespacefletchgen.html#aabc1aa5af7c948aeb93dddcb947fbb6aaa8a76626a0a9404b2776727cc0d92c5f">LIST_PRIM</a>
, <a class="el" href="namespacefletchgen.html#aabc1aa5af7c948aeb93dddcb947fbb6aab8223be2455e0ea5a0e63e8f018d6fc3">STRUCT</a>
<br />
 }</td></tr>
<tr class="memdesc:aabc1aa5af7c948aeb93dddcb947fbb6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Types for ArrayReader/Writer configuration string.  <a href="namespacefletchgen.html#aabc1aa5af7c948aeb93dddcb947fbb6a">More...</a><br /></td></tr>
<tr class="separator:aabc1aa5af7c948aeb93dddcb947fbb6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae105d4405c76792418550227d7dd9f69"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefletchgen.html#ae105d4405c76792418550227d7dd9f69">BusFunction</a> { <a class="el" href="namespacefletchgen.html#ae105d4405c76792418550227d7dd9f69a3466fab4975481651940ed328aa990e4">READ</a>
, <a class="el" href="namespacefletchgen.html#ae105d4405c76792418550227d7dd9f69ad4b9e47f65b6e79b010582f15785867e">WRITE</a>
 }</td></tr>
<tr class="memdesc:ae105d4405c76792418550227d7dd9f69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines function of a bus interface (read/write).  <a href="namespacefletchgen.html#ae105d4405c76792418550227d7dd9f69">More...</a><br /></td></tr>
<tr class="separator:ae105d4405c76792418550227d7dd9f69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81bb2df9bbc0f4f52fd3dfd0b9c625c4"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefletchgen.html#a81bb2df9bbc0f4f52fd3dfd0b9c625c4">MmioFunction</a> { <br />
&#160;&#160;<a class="el" href="namespacefletchgen.html#a81bb2df9bbc0f4f52fd3dfd0b9c625c4a5b39c8b553c821e7cddc6da64b5bd2ee">DEFAULT</a>
, <a class="el" href="namespacefletchgen.html#a81bb2df9bbc0f4f52fd3dfd0b9c625c4a3dba7f2d2578ffb4bd657af94b1add80">BATCH</a>
, <a class="el" href="namespacefletchgen.html#a81bb2df9bbc0f4f52fd3dfd0b9c625c4a17de626bcae5109bb2f7a66dfc4a8a1d">BUFFER</a>
, <a class="el" href="namespacefletchgen.html#a81bb2df9bbc0f4f52fd3dfd0b9c625c4a35c10219c45ccfb5b07444fd7e17214c">KERNEL</a>
, <br />
&#160;&#160;<a class="el" href="namespacefletchgen.html#a81bb2df9bbc0f4f52fd3dfd0b9c625c4a48359f9afd830d28b1152d071fb09147">PROFILE</a>
<br />
 }</td></tr>
<tr class="memdesc:a81bb2df9bbc0f4f52fd3dfd0b9c625c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register intended use enumeration.  <a href="namespacefletchgen.html#a81bb2df9bbc0f4f52fd3dfd0b9c625c4">More...</a><br /></td></tr>
<tr class="separator:a81bb2df9bbc0f4f52fd3dfd0b9c625c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52970d51825f5b1189d88480cc9fa0d0"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefletchgen.html#a52970d51825f5b1189d88480cc9fa0d0">MmioBehavior</a> { <a class="el" href="namespacefletchgen.html#a52970d51825f5b1189d88480cc9fa0d0ac861cd34025f9002df5912d623326130">CONTROL</a>
, <a class="el" href="namespacefletchgen.html#a52970d51825f5b1189d88480cc9fa0d0a5f241c8c8f985b3c51e05d39cf030f4c">STATUS</a>
, <a class="el" href="namespacefletchgen.html#a52970d51825f5b1189d88480cc9fa0d0ad28ce717364dabaaea18e45cf3c2ada0">STROBE</a>
 }</td></tr>
<tr class="memdesc:a52970d51825f5b1189d88480cc9fa0d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register access behavior enumeration.  <a href="namespacefletchgen.html#a52970d51825f5b1189d88480cc9fa0d0">More...</a><br /></td></tr>
<tr class="separator:a52970d51825f5b1189d88480cc9fa0d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a202f040e54b3beba93c85c62cd8ff543"><td class="memItemLeft" align="right" valign="top"><a id="a202f040e54b3beba93c85c62cd8ff543"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefletchgen.html#a202f040e54b3beba93c85c62cd8ff543">Error</a> { <b>GenericError</b>
, <b>YAMLError</b>
 }</td></tr>
<tr class="memdesc:a202f040e54b3beba93c85c62cd8ff543"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error types. <br /></td></tr>
<tr class="separator:a202f040e54b3beba93c85c62cd8ff543"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ab8153bf3b5faa4ac2cee1814b09681f8"><td class="memItemLeft" align="right" valign="top"><a id="ab8153bf3b5faa4ac2cee1814b09681f8"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefletchgen.html#ab8153bf3b5faa4ac2cee1814b09681f8">GetCtrlBufferCount</a> (const arrow::Field &amp;field)</td></tr>
<tr class="memdesc:ab8153bf3b5faa4ac2cee1814b09681f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of buffers for the control field. <br /></td></tr>
<tr class="separator:ab8153bf3b5faa4ac2cee1814b09681f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91ab9bc8e3c00e5d1c0e423b81719f7c"><td class="memItemLeft" align="right" valign="top"><a id="a91ab9bc8e3c00e5d1c0e423b81719f7c"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefletchgen.html#a91ab9bc8e3c00e5d1c0e423b81719f7c">GetTagWidth</a> (const arrow::Field &amp;field)</td></tr>
<tr class="memdesc:a91ab9bc8e3c00e5d1c0e423b81719f7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the tag width of this field as a literal node. Settable through Arrow metadata. Default: 1. <br /></td></tr>
<tr class="separator:a91ab9bc8e3c00e5d1c0e423b81719f7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23a1d46bd22bc4358bd11f2a1eb88735"><td class="memItemLeft" align="right" valign="top"><a id="a23a1d46bd22bc4358bd11f2a1eb88735"></a>
std::shared_ptr&lt; Type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefletchgen.html#a23a1d46bd22bc4358bd11f2a1eb88735">cmd_type</a> (const std::shared_ptr&lt; Node &gt; &amp;index_width, const std::shared_ptr&lt; Node &gt; &amp;tag_width, const std::optional&lt; std::shared_ptr&lt; Node &gt;&gt; &amp;ctrl_width=std::nullopt)</td></tr>
<tr class="memdesc:a23a1d46bd22bc4358bd11f2a1eb88735"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a Fletcher command stream type. <br /></td></tr>
<tr class="separator:a23a1d46bd22bc4358bd11f2a1eb88735"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59ad085561eb709a81a7cd15000afc28"><td class="memItemLeft" align="right" valign="top"><a id="a59ad085561eb709a81a7cd15000afc28"></a>
std::shared_ptr&lt; Type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefletchgen.html#a59ad085561eb709a81a7cd15000afc28">unlock_type</a> (const std::shared_ptr&lt; Node &gt; &amp;tag_width)</td></tr>
<tr class="memdesc:a59ad085561eb709a81a7cd15000afc28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fletcher unlock stream. <br /></td></tr>
<tr class="separator:a59ad085561eb709a81a7cd15000afc28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe2dd72f54a1dc4f65f93a97dad04adc"><td class="memItemLeft" align="right" valign="top"><a id="afe2dd72f54a1dc4f65f93a97dad04adc"></a>
std::shared_ptr&lt; Type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefletchgen.html#afe2dd72f54a1dc4f65f93a97dad04adc">array_reader_out</a> (uint32_t num_streams=0, uint32_t full_width=0)</td></tr>
<tr class="memdesc:afe2dd72f54a1dc4f65f93a97dad04adc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fletcher read data. <br /></td></tr>
<tr class="separator:afe2dd72f54a1dc4f65f93a97dad04adc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0e8fcd9a6d28bfa4f6b27ca5468f72f"><td class="memItemLeft" align="right" valign="top"><a id="ab0e8fcd9a6d28bfa4f6b27ca5468f72f"></a>
std::shared_ptr&lt; Type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefletchgen.html#ab0e8fcd9a6d28bfa4f6b27ca5468f72f">array_writer_in</a> (uint32_t num_streams=0, uint32_t full_width=0)</td></tr>
<tr class="memdesc:ab0e8fcd9a6d28bfa4f6b27ca5468f72f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fletcher write data. <br /></td></tr>
<tr class="separator:ab0e8fcd9a6d28bfa4f6b27ca5468f72f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d52d55567c9e6093e8371564ef3d260"><td class="memItemLeft" align="right" valign="top"><a id="a4d52d55567c9e6093e8371564ef3d260"></a>
std::shared_ptr&lt; Type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefletchgen.html#a4d52d55567c9e6093e8371564ef3d260">array_reader_out</a> (std::pair&lt; uint32_t, uint32_t &gt; spec)</td></tr>
<tr class="memdesc:a4d52d55567c9e6093e8371564ef3d260"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fletcher read data, where the pair contains {num_streams, full_width}. <br /></td></tr>
<tr class="separator:a4d52d55567c9e6093e8371564ef3d260"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabc984e5193a3ee4ac4f76ec174c281b"><td class="memItemLeft" align="right" valign="top"><a id="aabc984e5193a3ee4ac4f76ec174c281b"></a>
std::shared_ptr&lt; Type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefletchgen.html#aabc984e5193a3ee4ac4f76ec174c281b">array_writer_in</a> (std::pair&lt; uint32_t, uint32_t &gt; spec)</td></tr>
<tr class="memdesc:aabc984e5193a3ee4ac4f76ec174c281b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fletcher write data, where the pair contains {num_streams, full_width}. <br /></td></tr>
<tr class="separator:aabc984e5193a3ee4ac4f76ec174c281b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc67ac4bb69250504d1cfad5aa3372ed"><td class="memItemLeft" align="right" valign="top">Component *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefletchgen.html#abc67ac4bb69250504d1cfad5aa3372ed">array</a> (Mode mode)</td></tr>
<tr class="memdesc:abc67ac4bb69250504d1cfad5aa3372ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a Cerata component model of an Array(Reader/Writer).  <a href="namespacefletchgen.html#abc67ac4bb69250504d1cfad5aa3372ed">More...</a><br /></td></tr>
<tr class="separator:abc67ac4bb69250504d1cfad5aa3372ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aececf976e80d382891312fa633558890"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacefletchgen.html#aabc1aa5af7c948aeb93dddcb947fbb6a">ConfigType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefletchgen.html#aececf976e80d382891312fa633558890">GetConfigType</a> (const arrow::DataType &amp;type)</td></tr>
<tr class="memdesc:aececf976e80d382891312fa633558890"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the configuration string type version of an arrow::DataType.  <a href="namespacefletchgen.html#aececf976e80d382891312fa633558890">More...</a><br /></td></tr>
<tr class="separator:aececf976e80d382891312fa633558890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a429b926ef416102ed336af0765508169"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; Node &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefletchgen.html#a429b926ef416102ed336af0765508169">GetWidthNode</a> (const arrow::DataType &amp;type)</td></tr>
<tr class="memdesc:a429b926ef416102ed336af0765508169"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a node representing the width of a (flat) Arrow DataType.  <a href="namespacefletchgen.html#a429b926ef416102ed336af0765508169">More...</a><br /></td></tr>
<tr class="separator:a429b926ef416102ed336af0765508169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33ab2865b9a4aaafb0f828fbdb596bf1"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefletchgen.html#a33ab2865b9a4aaafb0f828fbdb596bf1">GenerateConfigString</a> (const arrow::Field &amp;field, int level=0)</td></tr>
<tr class="memdesc:a33ab2865b9a4aaafb0f828fbdb596bf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the configuration string for a ArrayReader/Writer.  <a href="namespacefletchgen.html#a33ab2865b9a4aaafb0f828fbdb596bf1">More...</a><br /></td></tr>
<tr class="separator:a33ab2865b9a4aaafb0f828fbdb596bf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2de87b117b7c832a62b4ae22ac08c46d"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; TypeMapper &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefletchgen.html#a2de87b117b7c832a62b4ae22ac08c46d">GetStreamTypeMapper</a> (Type *stream_type, Type *other)</td></tr>
<tr class="memdesc:a2de87b117b7c832a62b4ae22ac08c46d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a type mapper for an Arrow::Field-based stream to an ArrayReader/Writer stream.  <a href="namespacefletchgen.html#a2de87b117b7c832a62b4ae22ac08c46d">More...</a><br /></td></tr>
<tr class="separator:a2de87b117b7c832a62b4ae22ac08c46d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe96283869e30ad3e3863bba4b7c20a8"><td class="memItemLeft" align="right" valign="top"><a id="abe96283869e30ad3e3863bba4b7c20a8"></a>
std::shared_ptr&lt; Type &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ListPrimType</b> (int val_epc, int list_epc, int val_width, int idx_width, const std::string &amp;name)</td></tr>
<tr class="separator:abe96283869e30ad3e3863bba4b7c20a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80d70a438f6cad5ed37f2b35b83e420c"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; Type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefletchgen.html#a80d70a438f6cad5ed37f2b35b83e420c">GetStreamType</a> (const arrow::Field &amp;arrow_field, fletcher::Mode mode, int level=0)</td></tr>
<tr class="memdesc:a80d70a438f6cad5ed37f2b35b83e420c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an Arrow::Field into a stream type.  <a href="namespacefletchgen.html#a80d70a438f6cad5ed37f2b35b83e420c">More...</a><br /></td></tr>
<tr class="separator:a80d70a438f6cad5ed37f2b35b83e420c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4861f35dc6842b83bea911302c0aa402"><td class="memItemLeft" align="right" valign="top">std::pair&lt; uint32_t, uint32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefletchgen.html#a4861f35dc6842b83bea911302c0aa402">GetArrayDataSpec</a> (const arrow::Field &amp;arrow_field)</td></tr>
<tr class="memdesc:a4861f35dc6842b83bea911302c0aa402"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the ArrayR/W number of streams and data width from an Arrow Field.  <a href="namespacefletchgen.html#a4861f35dc6842b83bea911302c0aa402">More...</a><br /></td></tr>
<tr class="separator:a4861f35dc6842b83bea911302c0aa402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4edbe64f28c40b602a93e87690a84349"><td class="memItemLeft" align="right" valign="top">Component *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefletchgen.html#a4edbe64f28c40b602a93e87690a84349">array</a> (fletcher::Mode mode)</td></tr>
<tr class="memdesc:a4edbe64f28c40b602a93e87690a84349"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a Cerata component model of an ArrayReader/Writers.  <a href="namespacefletchgen.html#a4edbe64f28c40b602a93e87690a84349">More...</a><br /></td></tr>
<tr class="separator:a4edbe64f28c40b602a93e87690a84349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f6bc7314f9d9c5688b7f6278a3e07f5"><td class="memItemLeft" align="right" valign="top"><a id="a6f6bc7314f9d9c5688b7f6278a3e07f5"></a>
std::shared_ptr&lt; Type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefletchgen.html#a6f6bc7314f9d9c5688b7f6278a3e07f5">axi4_lite_type</a> (<a class="el" href="structfletchgen_1_1_axi4_lite_spec.html">Axi4LiteSpec</a> spec=<a class="el" href="structfletchgen_1_1_axi4_lite_spec.html">Axi4LiteSpec</a>())</td></tr>
<tr class="memdesc:a6f6bc7314f9d9c5688b7f6278a3e07f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">AXI4-lite port type. <br /></td></tr>
<tr class="separator:a6f6bc7314f9d9c5688b7f6278a3e07f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74f7ad31c1faa08cdaff2d55147e756a"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="structfletchgen_1_1_axi4_lite_port.html">Axi4LitePort</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefletchgen.html#a74f7ad31c1faa08cdaff2d55147e756a">axi4_lite</a> (Port::Dir dir, const std::shared_ptr&lt; ClockDomain &gt; &amp;domain=cerata::default_domain(), <a class="el" href="structfletchgen_1_1_axi4_lite_spec.html">Axi4LiteSpec</a> spec=<a class="el" href="structfletchgen_1_1_axi4_lite_spec.html">Axi4LiteSpec</a>())</td></tr>
<tr class="memdesc:a74f7ad31c1faa08cdaff2d55147e756a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a new AXI4-lite port, returning a shared pointer to it.  <a href="namespacefletchgen.html#a74f7ad31c1faa08cdaff2d55147e756a">More...</a><br /></td></tr>
<tr class="separator:a74f7ad31c1faa08cdaff2d55147e756a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29ad4db0aa96942d0cbc8965bd0183bd"><td class="memItemLeft" align="right" valign="top"><a id="a29ad4db0aa96942d0cbc8965bd0183bd"></a>
std::shared_ptr&lt; ClockDomain &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefletchgen.html#a29ad4db0aa96942d0cbc8965bd0183bd">kernel_cd</a> ()</td></tr>
<tr class="memdesc:a29ad4db0aa96942d0cbc8965bd0183bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fletcher accelerator clock domain. <br /></td></tr>
<tr class="separator:a29ad4db0aa96942d0cbc8965bd0183bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac22a45a63daae5ae216eba3bffe8f4bb"><td class="memItemLeft" align="right" valign="top"><a id="ac22a45a63daae5ae216eba3bffe8f4bb"></a>
std::shared_ptr&lt; ClockDomain &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefletchgen.html#ac22a45a63daae5ae216eba3bffe8f4bb">bus_cd</a> ()</td></tr>
<tr class="memdesc:ac22a45a63daae5ae216eba3bffe8f4bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fletcher bus clock domain. <br /></td></tr>
<tr class="separator:ac22a45a63daae5ae216eba3bffe8f4bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4894046bf280bf9f53e42c244dbae158"><td class="memItemLeft" align="right" valign="top"><a id="a4894046bf280bf9f53e42c244dbae158"></a>
std::shared_ptr&lt; Type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefletchgen.html#a4894046bf280bf9f53e42c244dbae158">cr</a> ()</td></tr>
<tr class="memdesc:a4894046bf280bf9f53e42c244dbae158"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fletcher clock/reset;. <br /></td></tr>
<tr class="separator:a4894046bf280bf9f53e42c244dbae158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c4c5b7d1071a7d4d66c9ca22522a499"><td class="memItemLeft" align="right" valign="top"><a id="a3c4c5b7d1071a7d4d66c9ca22522a499"></a>
std::shared_ptr&lt; Type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefletchgen.html#a3c4c5b7d1071a7d4d66c9ca22522a499">valid</a> (int width=1, bool on_primitive=false)</td></tr>
<tr class="memdesc:a3c4c5b7d1071a7d4d66c9ca22522a499"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fletcher valid. <br /></td></tr>
<tr class="separator:a3c4c5b7d1071a7d4d66c9ca22522a499"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f6c754a07164b36cc2045dc11f3e5b5"><td class="memItemLeft" align="right" valign="top"><a id="a6f6c754a07164b36cc2045dc11f3e5b5"></a>
std::shared_ptr&lt; Type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefletchgen.html#a6f6c754a07164b36cc2045dc11f3e5b5">ready</a> (int width=1, bool on_primitive=false)</td></tr>
<tr class="memdesc:a6f6c754a07164b36cc2045dc11f3e5b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fletcher ready. <br /></td></tr>
<tr class="separator:a6f6c754a07164b36cc2045dc11f3e5b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53160305950fb6c565c66494fa0859a2"><td class="memItemLeft" align="right" valign="top"><a id="a53160305950fb6c565c66494fa0859a2"></a>
std::shared_ptr&lt; Type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefletchgen.html#a53160305950fb6c565c66494fa0859a2">data</a> (int width)</td></tr>
<tr class="memdesc:a53160305950fb6c565c66494fa0859a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fletcher data. <br /></td></tr>
<tr class="separator:a53160305950fb6c565c66494fa0859a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a847921467aa34155af0818c60ffc69ac"><td class="memItemLeft" align="right" valign="top"><a id="a847921467aa34155af0818c60ffc69ac"></a>
std::shared_ptr&lt; Type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefletchgen.html#a847921467aa34155af0818c60ffc69ac">length</a> (int width)</td></tr>
<tr class="memdesc:a847921467aa34155af0818c60ffc69ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fletcher length. <br /></td></tr>
<tr class="separator:a847921467aa34155af0818c60ffc69ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d62a2489b26db454c78d955e5c0796c"><td class="memItemLeft" align="right" valign="top"><a id="a8d62a2489b26db454c78d955e5c0796c"></a>
std::shared_ptr&lt; Type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefletchgen.html#a8d62a2489b26db454c78d955e5c0796c">count</a> (int width)</td></tr>
<tr class="memdesc:a8d62a2489b26db454c78d955e5c0796c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fletcher count. <br /></td></tr>
<tr class="separator:a8d62a2489b26db454c78d955e5c0796c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f0d0445426770678603c66a8bbe283a"><td class="memItemLeft" align="right" valign="top"><a id="a7f0d0445426770678603c66a8bbe283a"></a>
std::shared_ptr&lt; Type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefletchgen.html#a7f0d0445426770678603c66a8bbe283a">dvalid</a> (int width=1, bool on_primitive=false)</td></tr>
<tr class="memdesc:a7f0d0445426770678603c66a8bbe283a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fletcher dvalid. <br /></td></tr>
<tr class="separator:a7f0d0445426770678603c66a8bbe283a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3b72a224a6d9724333cc3752457b378"><td class="memItemLeft" align="right" valign="top"><a id="ac3b72a224a6d9724333cc3752457b378"></a>
std::shared_ptr&lt; Type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefletchgen.html#ac3b72a224a6d9724333cc3752457b378">last</a> (int width=1, bool on_primitive=false)</td></tr>
<tr class="memdesc:ac3b72a224a6d9724333cc3752457b378"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fletcher last. <br /></td></tr>
<tr class="separator:ac3b72a224a6d9724333cc3752457b378"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfc32b488a86ce07980d40216b415b44"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefletchgen.html#abfc32b488a86ce07980d40216b415b44">GetFixedWidthTypeBitWidth</a> (const arrow::DataType &amp;arrow_type)</td></tr>
<tr class="memdesc:abfc32b488a86ce07980d40216b415b44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the bit-width of a fixed-width Arrow type. Throws if it's not a fixed-width type.  <a href="namespacefletchgen.html#abfc32b488a86ce07980d40216b415b44">More...</a><br /></td></tr>
<tr class="separator:abfc32b488a86ce07980d40216b415b44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cdf3e4bb7b4f402e318a4849ce79d9c"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; Type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefletchgen.html#a6cdf3e4bb7b4f402e318a4849ce79d9c">ConvertFixedWidthType</a> (const std::shared_ptr&lt; arrow::DataType &gt; &amp;arrow_type, int epc=1)</td></tr>
<tr class="memdesc:a6cdf3e4bb7b4f402e318a4849ce79d9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a fixed-width arrow::DataType to a fixed-width Fletcher Type.  <a href="namespacefletchgen.html#a6cdf3e4bb7b4f402e318a4849ce79d9c">More...</a><br /></td></tr>
<tr class="separator:a6cdf3e4bb7b4f402e318a4849ce79d9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af710bff927a7c41032f605d162c9f64e"><td class="memItemLeft" align="right" valign="top">std::optional&lt; cerata::Port * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefletchgen.html#af710bff927a7c41032f605d162c9f64e">GetClockResetPort</a> (cerata::Graph *graph, const ClockDomain &amp;domain)</td></tr>
<tr class="memdesc:af710bff927a7c41032f605d162c9f64e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the clock/reset port of a graph for a specific clock domain, if it exists.  <a href="namespacefletchgen.html#af710bff927a7c41032f605d162c9f64e">More...</a><br /></td></tr>
<tr class="separator:af710bff927a7c41032f605d162c9f64e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a0ebb4914f0d9736ef8bf32b1ad043b"><td class="memItemLeft" align="right" valign="top"><a id="a2a0ebb4914f0d9736ef8bf32b1ad043b"></a>
std::shared_ptr&lt; Type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefletchgen.html#a2a0ebb4914f0d9736ef8bf32b1ad043b">bus_read</a> (const std::shared_ptr&lt; Node &gt; &amp;addr_width, const std::shared_ptr&lt; Node &gt; &amp;data_width, const std::shared_ptr&lt; Node &gt; &amp;len_width)</td></tr>
<tr class="memdesc:a2a0ebb4914f0d9736ef8bf32b1ad043b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a Cerata type for a Fletcher bus read interface. <br /></td></tr>
<tr class="separator:a2a0ebb4914f0d9736ef8bf32b1ad043b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a291cc8d90a91ee4ffe0b5b028a49b7ac"><td class="memItemLeft" align="right" valign="top"><a id="a291cc8d90a91ee4ffe0b5b028a49b7ac"></a>
std::shared_ptr&lt; Type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefletchgen.html#a291cc8d90a91ee4ffe0b5b028a49b7ac">bus_write</a> (const std::shared_ptr&lt; Node &gt; &amp;addr_width, const std::shared_ptr&lt; Node &gt; &amp;data_width, const std::shared_ptr&lt; Node &gt; &amp;len_width)</td></tr>
<tr class="memdesc:a291cc8d90a91ee4ffe0b5b028a49b7ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a Cerata type for a Fletcher bus write interface. <br /></td></tr>
<tr class="separator:a291cc8d90a91ee4ffe0b5b028a49b7ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f62bb38651a9829aaa9cf87c2637307"><td class="memItemLeft" align="right" valign="top">Component *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefletchgen.html#a5f62bb38651a9829aaa9cf87c2637307">bus_arbiter</a> (<a class="el" href="namespacefletchgen.html#ae105d4405c76792418550227d7dd9f69">BusFunction</a> function)</td></tr>
<tr class="memdesc:a5f62bb38651a9829aaa9cf87c2637307"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a Cerata model of a BusArbiter.  <a href="namespacefletchgen.html#a5f62bb38651a9829aaa9cf87c2637307">More...</a><br /></td></tr>
<tr class="separator:a5f62bb38651a9829aaa9cf87c2637307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4db57a341becc129e0afe7f1c04a0e47"><td class="memItemLeft" align="right" valign="top"><a id="a4db57a341becc129e0afe7f1c04a0e47"></a>
std::shared_ptr&lt; Component &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefletchgen.html#a4db57a341becc129e0afe7f1c04a0e47">BusReadSerializer</a> ()</td></tr>
<tr class="memdesc:a4db57a341becc129e0afe7f1c04a0e47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a BusReadSerializer component. <br /></td></tr>
<tr class="separator:a4db57a341becc129e0afe7f1c04a0e47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc3f0fdea68add14652b7e6c852456db"><td class="memItemLeft" align="right" valign="top"><a id="adc3f0fdea68add14652b7e6c852456db"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefletchgen.html#adc3f0fdea68add14652b7e6c852456db">operator==</a> (const <a class="el" href="structfletchgen_1_1_bus_spec.html">BusSpec</a> &amp;lhs, const <a class="el" href="structfletchgen_1_1_bus_spec.html">BusSpec</a> &amp;rhs)</td></tr>
<tr class="memdesc:adc3f0fdea68add14652b7e6c852456db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if BusSpecs are equal. <br /></td></tr>
<tr class="separator:adc3f0fdea68add14652b7e6c852456db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69b552aa73c157cc1142bf831d4779d7"><td class="memItemLeft" align="right" valign="top"><a id="a69b552aa73c157cc1142bf831d4779d7"></a>
std::shared_ptr&lt; Type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefletchgen.html#a69b552aa73c157cc1142bf831d4779d7">bus</a> (const <a class="el" href="structfletchgen_1_1_bus_spec_params.html">BusSpecParams</a> &amp;param)</td></tr>
<tr class="memdesc:a69b552aa73c157cc1142bf831d4779d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fletcher bus type with access mode conveyed through spec of params. <br /></td></tr>
<tr class="separator:a69b552aa73c157cc1142bf831d4779d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad30a14baa1575f9de19297b4e1b6b92e"><td class="memItemLeft" align="right" valign="top"><a id="ad30a14baa1575f9de19297b4e1b6b92e"></a>
std::shared_ptr&lt; <a class="el" href="structfletchgen_1_1_bus_port.html">BusPort</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefletchgen.html#ad30a14baa1575f9de19297b4e1b6b92e">bus_port</a> (const std::string &amp;name, Port::Dir dir, const <a class="el" href="structfletchgen_1_1_bus_spec_params.html">BusSpecParams</a> &amp;params)</td></tr>
<tr class="memdesc:ad30a14baa1575f9de19297b4e1b6b92e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a new port and return a shared pointer to it. <br /></td></tr>
<tr class="separator:ad30a14baa1575f9de19297b4e1b6b92e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f7938abacb37f5876ed089fc6ab6e18"><td class="memItemLeft" align="right" valign="top"><a id="a8f7938abacb37f5876ed089fc6ab6e18"></a>
std::shared_ptr&lt; <a class="el" href="structfletchgen_1_1_bus_port.html">BusPort</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefletchgen.html#a8f7938abacb37f5876ed089fc6ab6e18">bus_port</a> (Port::Dir dir, const <a class="el" href="structfletchgen_1_1_bus_spec_params.html">BusSpecParams</a> &amp;params)</td></tr>
<tr class="memdesc:a8f7938abacb37f5876ed089fc6ab6e18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a new port, name it automatically based on the bus parameters, and return a shared pointer to it. <br /></td></tr>
<tr class="separator:a8f7938abacb37f5876ed089fc6ab6e18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa516d83938fbc9dc1a5ffe4d0ca0f2a8"><td class="memItemLeft" align="right" valign="top"><a id="aa516d83938fbc9dc1a5ffe4d0ca0f2a8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefletchgen.html#aa516d83938fbc9dc1a5ffe4d0ca0f2a8">ConnectBusParam</a> (cerata::Graph *dst, const std::string &amp;prefix, const <a class="el" href="structfletchgen_1_1_bus_dim_params.html">BusDimParams</a> &amp;src, cerata::NodeMap *rebinding)</td></tr>
<tr class="memdesc:aa516d83938fbc9dc1a5ffe4d0ca0f2a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find and connect all prefixed bus params on a graph to the supplied source params, and append a rebind map. <br /></td></tr>
<tr class="separator:aa516d83938fbc9dc1a5ffe4d0ca0f2a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98f9c878636be71b619062a55e062e1d"><td class="memItemLeft" align="right" valign="top"><a id="a98f9c878636be71b619062a55e062e1d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefletchgen.html#a98f9c878636be71b619062a55e062e1d">operator==</a> (const <a class="el" href="structfletchgen_1_1_bus_dim.html">BusDim</a> &amp;lhs, const <a class="el" href="structfletchgen_1_1_bus_dim.html">BusDim</a> &amp;rhs)</td></tr>
<tr class="memdesc:a98f9c878636be71b619062a55e062e1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if BusDims are equal. <br /></td></tr>
<tr class="separator:a98f9c878636be71b619062a55e062e1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a289305aee9b4e809ae6597bdf4caeea1"><td class="memItemLeft" align="right" valign="top"><a id="a289305aee9b4e809ae6597bdf4caeea1"></a>
std::shared_ptr&lt; Component &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefletchgen.html#a289305aee9b4e809ae6597bdf4caeea1">BusWriteSerializer</a> ()</td></tr>
<tr class="memdesc:a289305aee9b4e809ae6597bdf4caeea1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a BusWriteSerializer component. <br /></td></tr>
<tr class="separator:a289305aee9b4e809ae6597bdf4caeea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adce9c36d091f8fed4a41812cb5965391"><td class="memItemLeft" align="right" valign="top"><a id="adce9c36d091f8fed4a41812cb5965391"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>external</b> () -&gt; std::optional&lt; std::shared_ptr&lt; cerata::Type &gt;&gt;</td></tr>
<tr class="separator:adce9c36d091f8fed4a41812cb5965391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecaa6f7eb60b2c5e6b7f469f38709d20"><td class="memItemLeft" align="right" valign="top"><a id="aecaa6f7eb60b2c5e6b7f469f38709d20"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefletchgen.html#aecaa6f7eb60b2c5e6b7f469f38709d20">fletchgen</a> (int argc, char **argv)</td></tr>
<tr class="memdesc:aecaa6f7eb60b2c5e6b7f469f38709d20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fletchgen main entry. Used to wrap into PyFletchgen. <br /></td></tr>
<tr class="separator:aecaa6f7eb60b2c5e6b7f469f38709d20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa97849c9d0e69c4b58ea612004fe296b"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="structfletchgen_1_1_kernel.html">Kernel</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefletchgen.html#aa97849c9d0e69c4b58ea612004fe296b">kernel</a> (const std::string &amp;name, const std::vector&lt; std::shared_ptr&lt; <a class="el" href="structfletchgen_1_1_record_batch.html">RecordBatch</a> &gt;&gt; &amp;recordbatches, const std::shared_ptr&lt; Component &gt; &amp;<a class="el" href="namespacefletchgen.html#afe871dfa41237c8e28b2266afe29e27a">mmio</a>)</td></tr>
<tr class="memdesc:aa97849c9d0e69c4b58ea612004fe296b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a kernel component based on <a class="el" href="structfletchgen_1_1_record_batch.html" title="A RecordBatch aggregating ArrayReaders/Writers.">RecordBatch</a> and MMIO components.  <a href="namespacefletchgen.html#aa97849c9d0e69c4b58ea612004fe296b">More...</a><br /></td></tr>
<tr class="separator:aa97849c9d0e69c4b58ea612004fe296b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10c2e86a82a643b31dbda1d7978f9ac0"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classfletchgen_1_1_mantle.html">Mantle</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefletchgen.html#a10c2e86a82a643b31dbda1d7978f9ac0">mantle</a> (const std::string &amp;name, const std::vector&lt; std::shared_ptr&lt; <a class="el" href="structfletchgen_1_1_record_batch.html">RecordBatch</a> &gt;&gt; &amp;recordbatches, const std::shared_ptr&lt; <a class="el" href="structfletchgen_1_1_nucleus.html">Nucleus</a> &gt; &amp;<a class="el" href="namespacefletchgen.html#a1a46ba5ead92bd11ff3e4f4b0bca0cb4">nucleus</a>, <a class="el" href="structfletchgen_1_1_bus_dim.html">BusDim</a> bus_spec, <a class="el" href="structfletchgen_1_1_axi4_lite_spec.html">Axi4LiteSpec</a> axi_spec)</td></tr>
<tr class="memdesc:a10c2e86a82a643b31dbda1d7978f9ac0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="classfletchgen_1_1_mantle.html" title="A component that wraps a Kernel and all ArrayReaders/Writers resulting from a Schema set.">Mantle</a> and return a shared pointer to it.  <a href="namespacefletchgen.html#a10c2e86a82a643b31dbda1d7978f9ac0">More...</a><br /></td></tr>
<tr class="separator:a10c2e86a82a643b31dbda1d7978f9ac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a023c355a58fa66bbc6339a76efd98ce5"><td class="memItemLeft" align="right" valign="top"><a id="a023c355a58fa66bbc6339a76efd98ce5"></a>
std::shared_ptr&lt; <a class="el" href="structfletchgen_1_1_mmio_port.html">MmioPort</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefletchgen.html#a023c355a58fa66bbc6339a76efd98ce5">mmio_port</a> (Port::Dir dir, const <a class="el" href="structfletchgen_1_1_mmio_reg.html">MmioReg</a> &amp;reg, const std::shared_ptr&lt; ClockDomain &gt; &amp;domain=cerata::default_domain())</td></tr>
<tr class="memdesc:a023c355a58fa66bbc6339a76efd98ce5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an mmio port. <br /></td></tr>
<tr class="separator:a023c355a58fa66bbc6339a76efd98ce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe871dfa41237c8e28b2266afe29e27a"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; Component &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefletchgen.html#afe871dfa41237c8e28b2266afe29e27a">mmio</a> (const std::vector&lt; fletcher::RecordBatchDescription &gt; &amp;batches, const std::vector&lt; <a class="el" href="structfletchgen_1_1_mmio_reg.html">MmioReg</a> &gt; &amp;regs, <a class="el" href="structfletchgen_1_1_axi4_lite_spec.html">Axi4LiteSpec</a> axi_spec)</td></tr>
<tr class="memdesc:afe871dfa41237c8e28b2266afe29e27a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate the MMIO component for the nucleus.  <a href="namespacefletchgen.html#afe871dfa41237c8e28b2266afe29e27a">More...</a><br /></td></tr>
<tr class="separator:afe871dfa41237c8e28b2266afe29e27a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af422c172be7671d1b4008e74da197638"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefletchgen.html#af422c172be7671d1b4008e74da197638">GenerateVhdmmioYaml</a> (const std::vector&lt; std::vector&lt; <a class="el" href="structfletchgen_1_1_mmio_reg.html">MmioReg</a> &gt; * &gt; &amp;regs, <a class="el" href="structfletchgen_1_1_axi4_lite_spec.html">Axi4LiteSpec</a> axi_spec, std::optional&lt; size_t * &gt; next_addr=std::nullopt)</td></tr>
<tr class="memdesc:af422c172be7671d1b4008e74da197638"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a YAML string for the vhdmmio tool based on a set of registers.  <a href="namespacefletchgen.html#af422c172be7671d1b4008e74da197638">More...</a><br /></td></tr>
<tr class="separator:af422c172be7671d1b4008e74da197638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2537f73729b311f1a1272cc9a8d9d9c"><td class="memItemLeft" align="right" valign="top"><a id="ab2537f73729b311f1a1272cc9a8d9d9c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefletchgen.html#ab2537f73729b311f1a1272cc9a8d9d9c">ExposeToKernel</a> (<a class="el" href="namespacefletchgen.html#a81bb2df9bbc0f4f52fd3dfd0b9c625c4">MmioFunction</a> fun)</td></tr>
<tr class="memdesc:ab2537f73729b311f1a1272cc9a8d9d9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if an mmio register's function must cause it to be exposed to the user kernel. <br /></td></tr>
<tr class="separator:ab2537f73729b311f1a1272cc9a8d9d9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc41a2c0a91da545e46ff6857cf99fb3"><td class="memItemLeft" align="right" valign="top"><a id="abc41a2c0a91da545e46ff6857cf99fb3"></a>
Component *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefletchgen.html#abc41a2c0a91da545e46ff6857cf99fb3">accm</a> ()</td></tr>
<tr class="memdesc:abc41a2c0a91da545e46ff6857cf99fb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the ArrayCmdCtrlMerger component. <br /></td></tr>
<tr class="separator:abc41a2c0a91da545e46ff6857cf99fb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a46ba5ead92bd11ff3e4f4b0bca0cb4"><td class="memItemLeft" align="right" valign="top"><a id="a1a46ba5ead92bd11ff3e4f4b0bca0cb4"></a>
std::shared_ptr&lt; <a class="el" href="structfletchgen_1_1_nucleus.html">Nucleus</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefletchgen.html#a1a46ba5ead92bd11ff3e4f4b0bca0cb4">nucleus</a> (const std::string &amp;name, const std::vector&lt; std::shared_ptr&lt; <a class="el" href="structfletchgen_1_1_record_batch.html">RecordBatch</a> &gt;&gt; &amp;recordbatches, const std::shared_ptr&lt; <a class="el" href="structfletchgen_1_1_kernel.html">Kernel</a> &gt; &amp;<a class="el" href="namespacefletchgen.html#aa97849c9d0e69c4b58ea612004fe296b">kernel</a>, const std::shared_ptr&lt; Component &gt; &amp;<a class="el" href="namespacefletchgen.html#afe871dfa41237c8e28b2266afe29e27a">mmio</a>, <a class="el" href="structfletchgen_1_1_axi4_lite_spec.html">Axi4LiteSpec</a> axi_spec)</td></tr>
<tr class="memdesc:a1a46ba5ead92bd11ff3e4f4b0bca0cb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make an <a class="el" href="structfletchgen_1_1_nucleus.html" title="It&#39;s like a kernel, but there is a kernel inside.">Nucleus</a> component based on <a class="el" href="structfletchgen_1_1_record_batch.html" title="A RecordBatch aggregating ArrayReaders/Writers.">RecordBatch</a> components. Returns a shared pointer to the new <a class="el" href="structfletchgen_1_1_nucleus.html" title="It&#39;s like a kernel, but there is a kernel inside.">Nucleus</a>. <br /></td></tr>
<tr class="separator:a1a46ba5ead92bd11ff3e4f4b0bca0cb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed3d74701f43f4250b4af57e65971f53"><td class="memItemLeft" align="right" valign="top"><a id="aed3d74701f43f4250b4af57e65971f53"></a>
std::vector&lt; <a class="el" href="structfletchgen_1_1_mmio_reg.html">MmioReg</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefletchgen.html#aed3d74701f43f4250b4af57e65971f53">GetProfilingRegs</a> (const std::vector&lt; std::shared_ptr&lt; <a class="el" href="structfletchgen_1_1_record_batch.html">RecordBatch</a> &gt;&gt; &amp;recordbatches)</td></tr>
<tr class="memdesc:aed3d74701f43f4250b4af57e65971f53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the registers that should be reserved in the mmio component for profiling. <br /></td></tr>
<tr class="separator:aed3d74701f43f4250b4af57e65971f53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab564a40fb9b2c35fd000da35dec49e3a"><td class="memItemLeft" align="right" valign="top"><a id="ab564a40fb9b2c35fd000da35dec49e3a"></a>
std::shared_ptr&lt; cerata::Type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefletchgen.html#ab564a40fb9b2c35fd000da35dec49e3a">stream_probe</a> (const std::shared_ptr&lt; Node &gt; &amp;count_width)</td></tr>
<tr class="memdesc:ab564a40fb9b2c35fd000da35dec49e3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a stream probe type based on a count width for multi-epc streams. <br /></td></tr>
<tr class="separator:ab564a40fb9b2c35fd000da35dec49e3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7e924e2c601b47933be15e604a37b4b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacefletchgen.html#a5f8522273f3602bf48837f1a6930520b">NodeProfilerPorts</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefletchgen.html#ad7e924e2c601b47933be15e604a37b4b">EnableStreamProfiling</a> (cerata::Component *comp, const std::vector&lt; cerata::Signal * &gt; &amp;profile_nodes)</td></tr>
<tr class="memdesc:ad7e924e2c601b47933be15e604a37b4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms a Cerata component graph to include stream profilers for selected nodes.  <a href="namespacefletchgen.html#ad7e924e2c601b47933be15e604a37b4b">More...</a><br /></td></tr>
<tr class="separator:ad7e924e2c601b47933be15e604a37b4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a541a2e63cf1c17072efab9bbcc2ca9f9"><td class="memItemLeft" align="right" valign="top"><a id="a541a2e63cf1c17072efab9bbcc2ca9f9"></a>
std::unique_ptr&lt; cerata::Instance &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefletchgen.html#a541a2e63cf1c17072efab9bbcc2ca9f9">profiler</a> (const std::string &amp;name, cerata::NodeMap *rebinding, const std::shared_ptr&lt; cerata::ClockDomain &gt; &amp;domain=<a class="el" href="namespacefletchgen.html#a29ad4db0aa96942d0cbc8965bd0183bd">kernel_cd</a>())</td></tr>
<tr class="memdesc:a541a2e63cf1c17072efab9bbcc2ca9f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an instance of a StreamProfiler. <br /></td></tr>
<tr class="separator:a541a2e63cf1c17072efab9bbcc2ca9f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1c8f150521796f8d98740f2b60242d0"><td class="memItemLeft" align="right" valign="top"><a id="ac1c8f150521796f8d98740f2b60242d0"></a>
std::shared_ptr&lt; <a class="el" href="structfletchgen_1_1_record_batch.html">RecordBatch</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefletchgen.html#ac1c8f150521796f8d98740f2b60242d0">record_batch</a> (const std::string &amp;name, const std::shared_ptr&lt; <a class="el" href="classfletchgen_1_1_fletcher_schema.html">FletcherSchema</a> &gt; &amp;fletcher_schema, const fletcher::RecordBatchDescription &amp;batch_desc)</td></tr>
<tr class="memdesc:ac1c8f150521796f8d98740f2b60242d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a new <a class="el" href="structfletchgen_1_1_record_batch.html" title="A RecordBatch aggregating ArrayReaders/Writers.">RecordBatch</a>(Reader/Writer) component, based on a Fletcher schema. <br /></td></tr>
<tr class="separator:ac1c8f150521796f8d98740f2b60242d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd184943bc24fe4b4ee8b0631d11ac49"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="structfletchgen_1_1_field_port.html">FieldPort</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefletchgen.html#abd184943bc24fe4b4ee8b0631d11ac49">arrow_port</a> (const std::shared_ptr&lt; <a class="el" href="classfletchgen_1_1_fletcher_schema.html">FletcherSchema</a> &gt; &amp;fletcher_schema, const std::shared_ptr&lt; arrow::Field &gt; &amp;field, bool reverse, const std::shared_ptr&lt; ClockDomain &gt; &amp;domain=default_domain())</td></tr>
<tr class="memdesc:abd184943bc24fe4b4ee8b0631d11ac49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a field-derived port for Arrow data.  <a href="namespacefletchgen.html#abd184943bc24fe4b4ee8b0631d11ac49">More...</a><br /></td></tr>
<tr class="separator:abd184943bc24fe4b4ee8b0631d11ac49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af66492d91f9e0b08106429560f554284"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="structfletchgen_1_1_field_port.html">FieldPort</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefletchgen.html#af66492d91f9e0b08106429560f554284">command_port</a> (const std::shared_ptr&lt; <a class="el" href="classfletchgen_1_1_fletcher_schema.html">FletcherSchema</a> &gt; &amp;schema, const std::shared_ptr&lt; arrow::Field &gt; &amp;field, const std::shared_ptr&lt; Node &gt; &amp;index_width, const std::shared_ptr&lt; Node &gt; &amp;tag_width, std::optional&lt; std::shared_ptr&lt; Node &gt;&gt; addr_width=std::nullopt, const std::shared_ptr&lt; ClockDomain &gt; &amp;domain=default_domain())</td></tr>
<tr class="memdesc:af66492d91f9e0b08106429560f554284"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a field-derived command port.  <a href="namespacefletchgen.html#af66492d91f9e0b08106429560f554284">More...</a><br /></td></tr>
<tr class="separator:af66492d91f9e0b08106429560f554284"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf32a9249a6e66d6b1166eecb77afde9"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="structfletchgen_1_1_field_port.html">FieldPort</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefletchgen.html#abf32a9249a6e66d6b1166eecb77afde9">unlock_port</a> (const std::shared_ptr&lt; <a class="el" href="classfletchgen_1_1_fletcher_schema.html">FletcherSchema</a> &gt; &amp;schema, const std::shared_ptr&lt; arrow::Field &gt; &amp;field, const std::shared_ptr&lt; Node &gt; &amp;tag_width, const std::shared_ptr&lt; ClockDomain &gt; &amp;domain=default_domain())</td></tr>
<tr class="memdesc:abf32a9249a6e66d6b1166eecb77afde9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a field-derived unlock port.  <a href="namespacefletchgen.html#abf32a9249a6e66d6b1166eecb77afde9">More...</a><br /></td></tr>
<tr class="separator:abf32a9249a6e66d6b1166eecb77afde9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41126102d1a6cffdea215caa4b017433"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefletchgen.html#a41126102d1a6cffdea215caa4b017433">write_static_vhdl</a> (const std::string &amp;real_dir, const std::string &amp;emb_dir=&quot;hardware&quot;)</td></tr>
<tr class="memdesc:a41126102d1a6cffdea215caa4b017433"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes Fletcher's static VHDL files to the given directory.  <a href="namespacefletchgen.html#a41126102d1a6cffdea215caa4b017433">More...</a><br /></td></tr>
<tr class="separator:a41126102d1a6cffdea215caa4b017433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a336ac22636b2968462818721e2a514ca"><td class="memItemLeft" align="right" valign="top"><a id="a336ac22636b2968462818721e2a514ca"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefletchgen.html#a336ac22636b2968462818721e2a514ca">GetProgramName</a> (char *argv0)</td></tr>
<tr class="memdesc:a336ac22636b2968462818721e2a514ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the name of this program executable. <br /></td></tr>
<tr class="separator:a336ac22636b2968462818721e2a514ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdd617db4a30cbd3c2c56edbbc6e12d8"><td class="memItemLeft" align="right" valign="top"><a id="afdd617db4a30cbd3c2c56edbbc6e12d8"></a>
cerata::Port::Dir&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefletchgen.html#afdd617db4a30cbd3c2c56edbbc6e12d8">mode2dir</a> (fletcher::Mode mode)</td></tr>
<tr class="memdesc:afdd617db4a30cbd3c2c56edbbc6e12d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a Cerata port direction from a Fletcher access mode. <br /></td></tr>
<tr class="separator:afdd617db4a30cbd3c2c56edbbc6e12d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cf1c6870c595d638e5ef5a4c386387f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefletchgen.html#a0cf1c6870c595d638e5ef5a4c386387f">LogCerata</a> (cerata::LogLevel level, std::string const &amp;message, char const *source_function, char const *source_file, int line_number)</td></tr>
<tr class="memdesc:a0cf1c6870c595d638e5ef5a4c386387f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function for the Cerata logger.  <a href="namespacefletchgen.html#a0cf1c6870c595d638e5ef5a4c386387f">More...</a><br /></td></tr>
<tr class="separator:a0cf1c6870c595d638e5ef5a4c386387f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd894d9c6e35a6ec9e0f1cd447f1bad6"><td class="memItemLeft" align="right" valign="top"><a id="acd894d9c6e35a6ec9e0f1cd447f1bad6"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefletchgen.html#acd894d9c6e35a6ec9e0f1cd447f1bad6">version</a> ()</td></tr>
<tr class="memdesc:acd894d9c6e35a6ec9e0f1cd447f1bad6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return Fletchgen version string. <br /></td></tr>
<tr class="separator:acd894d9c6e35a6ec9e0f1cd447f1bad6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a11a3e18d30a82bc760dd210e4ddf0ff7"><td class="memItemLeft" align="right" valign="top"><a id="a11a3e18d30a82bc760dd210e4ddf0ff7"></a>
constexpr char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefletchgen.html#a11a3e18d30a82bc760dd210e4ddf0ff7">MMIO_DEFAULT</a> [] = &quot;fletchgen_mmio_default&quot;</td></tr>
<tr class="memdesc:a11a3e18d30a82bc760dd210e4ddf0ff7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fletchgen metadata for mmio-controlled buffer address ports. <br /></td></tr>
<tr class="separator:a11a3e18d30a82bc760dd210e4ddf0ff7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02d5ce70d1b5f47c9e720e4ddef7fd09"><td class="memItemLeft" align="right" valign="top"><a id="a02d5ce70d1b5f47c9e720e4ddef7fd09"></a>
constexpr char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefletchgen.html#a02d5ce70d1b5f47c9e720e4ddef7fd09">MMIO_BATCH</a> [] = &quot;fletchgen_mmio_batch&quot;</td></tr>
<tr class="memdesc:a02d5ce70d1b5f47c9e720e4ddef7fd09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fletchgen metadata for mmio-controlled buffer address ports. <br /></td></tr>
<tr class="separator:a02d5ce70d1b5f47c9e720e4ddef7fd09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a980c799e6ee6af7de7110930b02e15c3"><td class="memItemLeft" align="right" valign="top"><a id="a980c799e6ee6af7de7110930b02e15c3"></a>
constexpr char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefletchgen.html#a980c799e6ee6af7de7110930b02e15c3">MMIO_BUFFER</a> [] = &quot;fletchgen_mmio_buffer&quot;</td></tr>
<tr class="memdesc:a980c799e6ee6af7de7110930b02e15c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fletchgen metadata for mmio-controlled buffer address ports. <br /></td></tr>
<tr class="separator:a980c799e6ee6af7de7110930b02e15c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cf4447f9b91f087d2a54e3b09866315"><td class="memItemLeft" align="right" valign="top"><a id="a5cf4447f9b91f087d2a54e3b09866315"></a>
constexpr char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefletchgen.html#a5cf4447f9b91f087d2a54e3b09866315">MMIO_KERNEL</a> [] = &quot;fletchgen_mmio_kernel&quot;</td></tr>
<tr class="memdesc:a5cf4447f9b91f087d2a54e3b09866315"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fletchgen metadata for mmio-controlled kernel ports. <br /></td></tr>
<tr class="separator:a5cf4447f9b91f087d2a54e3b09866315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a1e87daa86a7c8cae80a1363b8909ce"><td class="memItemLeft" align="right" valign="top"><a id="a2a1e87daa86a7c8cae80a1363b8909ce"></a>
constexpr char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefletchgen.html#a2a1e87daa86a7c8cae80a1363b8909ce">MMIO_PROFILE</a> [] = &quot;fletchgen_mmio_profile&quot;</td></tr>
<tr class="memdesc:a2a1e87daa86a7c8cae80a1363b8909ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fletchgen metadata for mmio-controlled profiling ports. <br /></td></tr>
<tr class="separator:a2a1e87daa86a7c8cae80a1363b8909ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10c7c1970a991a0af03263eb25c2c561"><td class="memItemLeft" align="right" valign="top">constexpr char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefletchgen.html#a10c7c1970a991a0af03263eb25c2c561">DEFAULT_NOTICE</a> []</td></tr>
<tr class="memdesc:a10c7c1970a991a0af03263eb25c2c561"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default copyright notice.  <a href="namespacefletchgen.html#a10c7c1970a991a0af03263eb25c2c561">More...</a><br /></td></tr>
<tr class="separator:a10c7c1970a991a0af03263eb25c2c561"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Contains all classes and functions related to Fletchgen. </p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ae105d4405c76792418550227d7dd9f69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae105d4405c76792418550227d7dd9f69">&#9670;&nbsp;</a></span>BusFunction</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacefletchgen.html#ae105d4405c76792418550227d7dd9f69">fletchgen::BusFunction</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defines function of a bus interface (read/write). </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ae105d4405c76792418550227d7dd9f69a3466fab4975481651940ed328aa990e4"></a>READ&#160;</td><td class="fielddoc"><p>Interface reads from memory. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae105d4405c76792418550227d7dd9f69ad4b9e47f65b6e79b010582f15785867e"></a>WRITE&#160;</td><td class="fielddoc"><p>Interface writes to memory. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="bus_8h_source.html#l00042">42</a> of file <a class="el" href="bus_8h_source.html">bus.h</a>.</p>

</div>
</div>
<a id="aabc1aa5af7c948aeb93dddcb947fbb6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabc1aa5af7c948aeb93dddcb947fbb6a">&#9670;&nbsp;</a></span>ConfigType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacefletchgen.html#aabc1aa5af7c948aeb93dddcb947fbb6a">fletchgen::ConfigType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Types for ArrayReader/Writer configuration string. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aabc1aa5af7c948aeb93dddcb947fbb6aad6308321b10e1c1466474b9248802268"></a>ARB&#160;</td><td class="fielddoc"><p>Arbiter level. </p>
</td></tr>
<tr><td class="fieldname"><a id="aabc1aa5af7c948aeb93dddcb947fbb6aa890f5fe6581170eeff26bec1c1e6a023"></a>NUL&#160;</td><td class="fielddoc"><p>Null bitmap. </p>
</td></tr>
<tr><td class="fieldname"><a id="aabc1aa5af7c948aeb93dddcb947fbb6aa954b965bc0539f07ab3090129a0d4b2d"></a>PRIM&#160;</td><td class="fielddoc"><p>Primitive (fixed-width) fields. </p>
</td></tr>
<tr><td class="fieldname"><a id="aabc1aa5af7c948aeb93dddcb947fbb6aa298cb25408234de02baf2085803a464a"></a>LIST&#160;</td><td class="fielddoc"><p>Variable length fields. </p>
</td></tr>
<tr><td class="fieldname"><a id="aabc1aa5af7c948aeb93dddcb947fbb6aaa8a76626a0a9404b2776727cc0d92c5f"></a>LIST_PRIM&#160;</td><td class="fielddoc"><p>List of primitives. Can have EPC &gt; 1. </p>
</td></tr>
<tr><td class="fieldname"><a id="aabc1aa5af7c948aeb93dddcb947fbb6aab8223be2455e0ea5a0e63e8f018d6fc3"></a>STRUCT&#160;</td><td class="fielddoc"><p>Structs, composed of multiple fields. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="array_8h_source.html#l00062">62</a> of file <a class="el" href="array_8h_source.html">array.h</a>.</p>

</div>
</div>
<a id="a52970d51825f5b1189d88480cc9fa0d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52970d51825f5b1189d88480cc9fa0d0">&#9670;&nbsp;</a></span>MmioBehavior</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacefletchgen.html#a52970d51825f5b1189d88480cc9fa0d0">fletchgen::MmioBehavior</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register access behavior enumeration. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a52970d51825f5b1189d88480cc9fa0d0ac861cd34025f9002df5912d623326130"></a>CONTROL&#160;</td><td class="fielddoc"><p>Register contents is controlled by host software. </p>
</td></tr>
<tr><td class="fieldname"><a id="a52970d51825f5b1189d88480cc9fa0d0a5f241c8c8f985b3c51e05d39cf030f4c"></a>STATUS&#160;</td><td class="fielddoc"><p>Register contents is controlled by hardware kernel. </p>
</td></tr>
<tr><td class="fieldname"><a id="a52970d51825f5b1189d88480cc9fa0d0ad28ce717364dabaaea18e45cf3c2ada0"></a>STROBE&#160;</td><td class="fielddoc"><p>Register contents is asserted for one cycle by host software. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="mmio_8h_source.html#l00061">61</a> of file <a class="el" href="mmio_8h_source.html">mmio.h</a>.</p>

</div>
</div>
<a id="a81bb2df9bbc0f4f52fd3dfd0b9c625c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81bb2df9bbc0f4f52fd3dfd0b9c625c4">&#9670;&nbsp;</a></span>MmioFunction</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacefletchgen.html#a81bb2df9bbc0f4f52fd3dfd0b9c625c4">fletchgen::MmioFunction</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register intended use enumeration. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a81bb2df9bbc0f4f52fd3dfd0b9c625c4a5b39c8b553c821e7cddc6da64b5bd2ee"></a>DEFAULT&#160;</td><td class="fielddoc"><p>Default registers. </p>
</td></tr>
<tr><td class="fieldname"><a id="a81bb2df9bbc0f4f52fd3dfd0b9c625c4a3dba7f2d2578ffb4bd657af94b1add80"></a>BATCH&#160;</td><td class="fielddoc"><p>Registers for <a class="el" href="structfletchgen_1_1_record_batch.html" title="A RecordBatch aggregating ArrayReaders/Writers.">RecordBatch</a> metadata. </p>
</td></tr>
<tr><td class="fieldname"><a id="a81bb2df9bbc0f4f52fd3dfd0b9c625c4a17de626bcae5109bb2f7a66dfc4a8a1d"></a>BUFFER&#160;</td><td class="fielddoc"><p>Registers for buffer addresses. </p>
</td></tr>
<tr><td class="fieldname"><a id="a81bb2df9bbc0f4f52fd3dfd0b9c625c4a35c10219c45ccfb5b07444fd7e17214c"></a>KERNEL&#160;</td><td class="fielddoc"><p>Registers for the kernel. </p>
</td></tr>
<tr><td class="fieldname"><a id="a81bb2df9bbc0f4f52fd3dfd0b9c625c4a48359f9afd830d28b1152d071fb09147"></a>PROFILE&#160;</td><td class="fielddoc"><p>Register for the profiler. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="mmio_8h_source.html#l00052">52</a> of file <a class="el" href="mmio_8h_source.html">mmio.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a4edbe64f28c40b602a93e87690a84349"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4edbe64f28c40b602a93e87690a84349">&#9670;&nbsp;</a></span>array() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Component* fletchgen::array </td>
          <td>(</td>
          <td class="paramtype">fletcher::Mode&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a Cerata component model of an ArrayReader/Writers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>Whether the Array(Reader/Writer) instance must READ from memory or WRITE to memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A unique pointer holding the Array(Reader/Writer) instance. </dd></dl>

</div>
</div>
<a id="abc67ac4bb69250504d1cfad5aa3372ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc67ac4bb69250504d1cfad5aa3372ed">&#9670;&nbsp;</a></span>array() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Component* fletchgen::array </td>
          <td>(</td>
          <td class="paramtype">Mode&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a Cerata component model of an Array(Reader/Writer). </p>
<p>This model corresponds to either: <a href="https://github.com/johanpel/fletcher/blob/develop/hardware/arrays/ArrayReader.vhd"><code>hardware/arrays/ArrayReader.vhd</code></a> or <a href="https://github.com/johanpel/fletcher/blob/develop/hardware/arrays/ArrayWriter.vhd"><code>hardware/arrays/ArrayWriter.vhd</code></a> depending on the mode parameter.</p>
<p>Changes to the implementation of this component in the HDL source must be reflected in the implementation of this function.</p>
<p>WARNING: Binding of the input/output data stream width generics is more arcane than what is good for most. As such, most widths are just bound to some integer literals rather than parameters. Any code instantiating this component should rebind the type themselves after figuring out their true width.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>Whether this Array component must Read or Write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The component model. </dd></dl>

<p class="definition">Definition at line <a class="el" href="array_8cc_source.html#l00139">139</a> of file <a class="el" href="array_8cc_source.html">array.cc</a>.</p>

</div>
</div>
<a id="abd184943bc24fe4b4ee8b0631d11ac49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd184943bc24fe4b4ee8b0631d11ac49">&#9670;&nbsp;</a></span>arrow_port()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="structfletchgen_1_1_field_port.html">FieldPort</a> &gt; fletchgen::arrow_port </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classfletchgen_1_1_fletcher_schema.html">FletcherSchema</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>fletcher_schema</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; arrow::Field &gt; &amp;&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reverse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; ClockDomain &gt; &amp;&#160;</td>
          <td class="paramname"><em>domain</em> = <code>default_domain()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a field-derived port for Arrow data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fletcher_schema</td><td>The Fletcher-derived schema. </td></tr>
    <tr><td class="paramname">field</td><td>The Arrow field to derive the port from. </td></tr>
    <tr><td class="paramname">reverse</td><td>Reverse the direction of the port. </td></tr>
    <tr><td class="paramname">domain</td><td>The clock domain of this port. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a new <a class="el" href="structfletchgen_1_1_field_port.html" title="A port derived from an Arrow field.">FieldPort</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="recordbatch_8cc_source.html#l00199">199</a> of file <a class="el" href="recordbatch_8cc_source.html">recordbatch.cc</a>.</p>

</div>
</div>
<a id="a74f7ad31c1faa08cdaff2d55147e756a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74f7ad31c1faa08cdaff2d55147e756a">&#9670;&nbsp;</a></span>axi4_lite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="structfletchgen_1_1_axi4_lite_port.html">Axi4LitePort</a> &gt; fletchgen::axi4_lite </td>
          <td>(</td>
          <td class="paramtype">Port::Dir&#160;</td>
          <td class="paramname"><em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; ClockDomain &gt; &amp;&#160;</td>
          <td class="paramname"><em>domain</em> = <code>cerata::default_domain()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfletchgen_1_1_axi4_lite_spec.html">Axi4LiteSpec</a>&#160;</td>
          <td class="paramname"><em>spec</em> = <code><a class="el" href="structfletchgen_1_1_axi4_lite_spec.html">Axi4LiteSpec</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make a new AXI4-lite port, returning a shared pointer to it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dir</td><td>The direction of the port. </td></tr>
    <tr><td class="paramname">spec</td><td>The specification of the port. </td></tr>
    <tr><td class="paramname">domain</td><td>The clock domain. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to the new port. </dd></dl>

<p class="definition">Definition at line <a class="el" href="axi4__lite_8cc_source.html#l00067">67</a> of file <a class="el" href="axi4__lite_8cc_source.html">axi4_lite.cc</a>.</p>

</div>
</div>
<a id="a5f62bb38651a9829aaa9cf87c2637307"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f62bb38651a9829aaa9cf87c2637307">&#9670;&nbsp;</a></span>bus_arbiter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Component * fletchgen::bus_arbiter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacefletchgen.html#ae105d4405c76792418550227d7dd9f69">BusFunction</a>&#160;</td>
          <td class="paramname"><em>function</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a Cerata model of a BusArbiter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>The function of the bus; either read or write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A Bus(Read/Write)Arbiter Cerata component model.</dd></dl>
<p>This model corresponds to either: <a href="https://github.com/johanpel/fletcher/blob/develop/hardware/interconnect/BusReadArbiterVec.vhd"><code>hardware/interconnect/BusReadArbiterVec.vhd</code></a> or <a href="https://github.com/johanpel/fletcher/blob/develop/hardware/interconnect/BusWriteArbiterVec.vhd"><code>hardware/interconnect/BusWriteArbiterVec.vhd</code></a> depending on the function parameter.</p>
<p>Changes to the implementation of this component in the HDL source must be reflected in the implementation of this function. </p>

<p class="definition">Definition at line <a class="el" href="bus_8cc_source.html#l00082">82</a> of file <a class="el" href="bus_8cc_source.html">bus.cc</a>.</p>

</div>
</div>
<a id="af66492d91f9e0b08106429560f554284"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af66492d91f9e0b08106429560f554284">&#9670;&nbsp;</a></span>command_port()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="structfletchgen_1_1_field_port.html">FieldPort</a> &gt; fletchgen::command_port </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classfletchgen_1_1_fletcher_schema.html">FletcherSchema</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>schema</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; arrow::Field &gt; &amp;&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; Node &gt; &amp;&#160;</td>
          <td class="paramname"><em>index_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; Node &gt; &amp;&#160;</td>
          <td class="paramname"><em>tag_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; std::shared_ptr&lt; Node &gt;&gt;&#160;</td>
          <td class="paramname"><em>addr_width</em> = <code>std::nullopt</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; ClockDomain &gt; &amp;&#160;</td>
          <td class="paramname"><em>domain</em> = <code>default_domain()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a field-derived command port. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">schema</td><td>The Fletcher-derived schema. </td></tr>
    <tr><td class="paramname">field</td><td>The Arrow field to derive the port from. </td></tr>
    <tr><td class="paramname">index_width</td><td>Type generic node for index field width. </td></tr>
    <tr><td class="paramname">tag_width</td><td>Type generic node for tag field width. </td></tr>
    <tr><td class="paramname">addr_width</td><td>Optionally, width of addresses in the ctrl field. If not used, no ctrl field is generated. </td></tr>
    <tr><td class="paramname">domain</td><td>The clock domain. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a new <a class="el" href="structfletchgen_1_1_field_port.html" title="A port derived from an Arrow field.">FieldPort</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="recordbatch_8cc_source.html#l00218">218</a> of file <a class="el" href="recordbatch_8cc_source.html">recordbatch.cc</a>.</p>

</div>
</div>
<a id="a6cdf3e4bb7b4f402e318a4849ce79d9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cdf3e4bb7b4f402e318a4849ce79d9c">&#9670;&nbsp;</a></span>ConvertFixedWidthType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; Type &gt; fletchgen::ConvertFixedWidthType </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; arrow::DataType &gt; &amp;&#160;</td>
          <td class="paramname"><em>arrow_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>epc</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a fixed-width arrow::DataType to a fixed-width Fletcher Type. </p>
<p>Does not take into consideration nesting.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arrow_type</td><td>The arrow::DataType. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The corresponding Type </dd></dl>

<p class="definition">Definition at line <a class="el" href="basic__types_8cc_source.html#l00148">148</a> of file <a class="el" href="basic__types_8cc_source.html">basic_types.cc</a>.</p>

</div>
</div>
<a id="ad7e924e2c601b47933be15e604a37b4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7e924e2c601b47933be15e604a37b4b">&#9670;&nbsp;</a></span>EnableStreamProfiling()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacefletchgen.html#a5f8522273f3602bf48837f1a6930520b">NodeProfilerPorts</a> fletchgen::EnableStreamProfiling </td>
          <td>(</td>
          <td class="paramtype">cerata::Component *&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; cerata::Signal * &gt; &amp;&#160;</td>
          <td class="paramname"><em>profile_nodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transforms a Cerata component graph to include stream profilers for selected nodes. </p>
<p>To select a node for profiling, the node must be of type cerata::Stream and it must have the PROFILE_KEY set to true in its kv-metadata.</p>
<p>Currently doesn't make a deep copy, so it modifies the existing structure irreversibly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comp</td><td>The component to apply the transformation to. </td></tr>
    <tr><td class="paramname">profile_nodes</td><td>The signal nodes that should be profiled. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A mapping from each input node to the instantiated profiler and its relevant result port nodes. </dd></dl>

<p class="definition">Definition at line <a class="el" href="profiler_8cc_source.html#l00155">155</a> of file <a class="el" href="profiler_8cc_source.html">profiler.cc</a>.</p>

</div>
</div>
<a id="a33ab2865b9a4aaafb0f828fbdb596bf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33ab2865b9a4aaafb0f828fbdb596bf1">&#9670;&nbsp;</a></span>GenerateConfigString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string fletchgen::GenerateConfigString </td>
          <td>(</td>
          <td class="paramtype">const arrow::Field &amp;&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the configuration string for a ArrayReader/Writer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field</td><td>The arrow::Field to derive the string from. </td></tr>
    <tr><td class="paramname">level</td><td>Nesting level for recursive calls to this function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The string. </dd></dl>

<p class="definition">Definition at line <a class="el" href="array_8cc_source.html#l00256">256</a> of file <a class="el" href="array_8cc_source.html">array.cc</a>.</p>

</div>
</div>
<a id="af422c172be7671d1b4008e74da197638"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af422c172be7671d1b4008e74da197638">&#9670;&nbsp;</a></span>GenerateVhdmmioYaml()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string fletchgen::GenerateVhdmmioYaml </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; <a class="el" href="structfletchgen_1_1_mmio_reg.html">MmioReg</a> &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>regs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfletchgen_1_1_axi4_lite_spec.html">Axi4LiteSpec</a>&#160;</td>
          <td class="paramname"><em>axi_spec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; size_t * &gt;&#160;</td>
          <td class="paramname"><em>next_addr</em> = <code>std::nullopt</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a YAML string for the vhdmmio tool based on a set of registers. </p>
<p>Any fixed addresses in the MmioReg.address field can only occur at the start of the vector set and must be ordered.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">regs</td><td>A vector of pointers to vectors of registers. Will be modified in case address was not set. </td></tr>
    <tr><td class="paramname">axi_spec</td><td>Specification of the AXI4 lite mmio bus. </td></tr>
    <tr><td class="paramname">next_addr</td><td>Optionally outputs the byte address offset of the next free register address. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="mmio_8cc_source.html#l00099">99</a> of file <a class="el" href="mmio_8cc_source.html">mmio.cc</a>.</p>

</div>
</div>
<a id="a4861f35dc6842b83bea911302c0aa402"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4861f35dc6842b83bea911302c0aa402">&#9670;&nbsp;</a></span>GetArrayDataSpec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; uint32_t, uint32_t &gt; fletchgen::GetArrayDataSpec </td>
          <td>(</td>
          <td class="paramtype">const arrow::Field &amp;&#160;</td>
          <td class="paramname"><em>arrow_field</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the ArrayR/W number of streams and data width from an Arrow Field. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arrow_field</td><td>The field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tuple containing the {no. streams, full data width}. </dd></dl>

<p class="definition">Definition at line <a class="el" href="array_8cc_source.html#l00478">478</a> of file <a class="el" href="array_8cc_source.html">array.cc</a>.</p>

</div>
</div>
<a id="af710bff927a7c41032f605d162c9f64e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af710bff927a7c41032f605d162c9f64e">&#9670;&nbsp;</a></span>GetClockResetPort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; cerata::Port * &gt; fletchgen::GetClockResetPort </td>
          <td>(</td>
          <td class="paramtype">cerata::Graph *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ClockDomain &amp;&#160;</td>
          <td class="paramname"><em>domain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the clock/reset port of a graph for a specific clock domain, if it exists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>The graph to find the port for. </td></tr>
    <tr><td class="paramname">domain</td><td>The domain to find the port for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Optionally, the port node that holds the clock/reset record. </dd></dl>

<p class="definition">Definition at line <a class="el" href="basic__types_8cc_source.html#l00181">181</a> of file <a class="el" href="basic__types_8cc_source.html">basic_types.cc</a>.</p>

</div>
</div>
<a id="aececf976e80d382891312fa633558890"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aececf976e80d382891312fa633558890">&#9670;&nbsp;</a></span>GetConfigType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacefletchgen.html#aabc1aa5af7c948aeb93dddcb947fbb6a">ConfigType</a> fletchgen::GetConfigType </td>
          <td>(</td>
          <td class="paramtype">const arrow::DataType &amp;&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the configuration string type version of an arrow::DataType. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The arrow::DataType. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The equivalent ConfigType. </dd></dl>

<p class="definition">Definition at line <a class="el" href="array_8cc_source.html#l00188">188</a> of file <a class="el" href="array_8cc_source.html">array.cc</a>.</p>

</div>
</div>
<a id="abfc32b488a86ce07980d40216b415b44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfc32b488a86ce07980d40216b415b44">&#9670;&nbsp;</a></span>GetFixedWidthTypeBitWidth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fletchgen::GetFixedWidthTypeBitWidth </td>
          <td>(</td>
          <td class="paramtype">const arrow::DataType &amp;&#160;</td>
          <td class="paramname"><em>arrow_type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the bit-width of a fixed-width Arrow type. Throws if it's not a fixed-width type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arrow_type</td><td>The type to inspect. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The bit width of the fixed type. </dd></dl>

<p class="definition">Definition at line <a class="el" href="basic__types_8cc_source.html#l00140">140</a> of file <a class="el" href="basic__types_8cc_source.html">basic_types.cc</a>.</p>

</div>
</div>
<a id="a80d70a438f6cad5ed37f2b35b83e420c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80d70a438f6cad5ed37f2b35b83e420c">&#9670;&nbsp;</a></span>GetStreamType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; Type &gt; fletchgen::GetStreamType </td>
          <td>(</td>
          <td class="paramtype">const arrow::Field &amp;&#160;</td>
          <td class="paramname"><em>arrow_field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fletcher::Mode&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert an Arrow::Field into a stream type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arrow_field</td><td>The Arrow::Field to convert. </td></tr>
    <tr><td class="paramname">mode</td><td>Whether this stream is used for reading or writing. </td></tr>
    <tr><td class="paramname">level</td><td>Nesting level. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Stream Type. </dd></dl>

<p class="definition">Definition at line <a class="el" href="array_8cc_source.html#l00369">369</a> of file <a class="el" href="array_8cc_source.html">array.cc</a>.</p>

</div>
</div>
<a id="a2de87b117b7c832a62b4ae22ac08c46d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2de87b117b7c832a62b4ae22ac08c46d">&#9670;&nbsp;</a></span>GetStreamTypeMapper()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; TypeMapper &gt; fletchgen::GetStreamTypeMapper </td>
          <td>(</td>
          <td class="paramtype">Type *&#160;</td>
          <td class="paramname"><em>stream_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type *&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a type mapper for an Arrow::Field-based stream to an ArrayReader/Writer stream. </p>
<p>These type mappers can be automatically deduced based on the generic Fletcher types being used. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream_type</td><td>The type typically generated with <a class="el" href="namespacefletchgen.html#a80d70a438f6cad5ed37f2b35b83e420c" title="Convert an Arrow::Field into a stream type.">GetStreamType()</a> </td></tr>
    <tr><td class="paramname">other</td><td>The other type, typically some read_data() or write_data() generated type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A type mapper </dd></dl>

<p class="definition">Definition at line <a class="el" href="array_8cc_source.html#l00323">323</a> of file <a class="el" href="array_8cc_source.html">array.cc</a>.</p>

</div>
</div>
<a id="a429b926ef416102ed336af0765508169"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a429b926ef416102ed336af0765508169">&#9670;&nbsp;</a></span>GetWidthNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; Node &gt; fletchgen::GetWidthNode </td>
          <td>(</td>
          <td class="paramtype">const arrow::DataType &amp;&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a node representing the width of a (flat) Arrow DataType. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The arrow::DataType. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A Literal Node representing the width. </dd></dl>

<p class="definition">Definition at line <a class="el" href="array_8cc_source.html#l00209">209</a> of file <a class="el" href="array_8cc_source.html">array.cc</a>.</p>

</div>
</div>
<a id="aa97849c9d0e69c4b58ea612004fe296b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa97849c9d0e69c4b58ea612004fe296b">&#9670;&nbsp;</a></span>kernel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="structfletchgen_1_1_kernel.html">Kernel</a> &gt; fletchgen::kernel </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; <a class="el" href="structfletchgen_1_1_record_batch.html">RecordBatch</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>recordbatches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; Component &gt; &amp;&#160;</td>
          <td class="paramname"><em>mmio</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make a kernel component based on <a class="el" href="structfletchgen_1_1_record_batch.html" title="A RecordBatch aggregating ArrayReaders/Writers.">RecordBatch</a> and MMIO components. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the kernel. </td></tr>
    <tr><td class="paramname">recordbatches</td><td>The recordbatch components to base the kernel on. </td></tr>
    <tr><td class="paramname">mmio</td><td>The MMIO component to base the kernel on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to the new kernel component. </dd></dl>

<p class="definition">Definition at line <a class="el" href="kernel_8cc_source.html#l00093">93</a> of file <a class="el" href="kernel_8cc_source.html">kernel.cc</a>.</p>

</div>
</div>
<a id="a0cf1c6870c595d638e5ef5a4c386387f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cf1c6870c595d638e5ef5a4c386387f">&#9670;&nbsp;</a></span>LogCerata()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fletchgen::LogCerata </td>
          <td>(</td>
          <td class="paramtype">cerata::LogLevel&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>source_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>source_file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>line_number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback function for the Cerata logger. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td>The logging level. </td></tr>
    <tr><td class="paramname">message</td><td>The message. </td></tr>
    <tr><td class="paramname">source_function</td><td>The source code line. </td></tr>
    <tr><td class="paramname">source_file</td><td>The source code file. </td></tr>
    <tr><td class="paramname">line_number</td><td>The line number. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="utils_8cc_source.html#l00043">43</a> of file <a class="el" href="utils_8cc_source.html">utils.cc</a>.</p>

</div>
</div>
<a id="a10c2e86a82a643b31dbda1d7978f9ac0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10c2e86a82a643b31dbda1d7978f9ac0">&#9670;&nbsp;</a></span>mantle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classfletchgen_1_1_mantle.html">Mantle</a> &gt; fletchgen::mantle </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; <a class="el" href="structfletchgen_1_1_record_batch.html">RecordBatch</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>recordbatches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="structfletchgen_1_1_nucleus.html">Nucleus</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>nucleus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfletchgen_1_1_bus_dim.html">BusDim</a>&#160;</td>
          <td class="paramname"><em>bus_spec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfletchgen_1_1_axi4_lite_spec.html">Axi4LiteSpec</a>&#160;</td>
          <td class="paramname"><em>axi_spec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a <a class="el" href="classfletchgen_1_1_mantle.html" title="A component that wraps a Kernel and all ArrayReaders/Writers resulting from a Schema set.">Mantle</a> and return a shared pointer to it. </p>
<p>Construct the mantle component and return a shared pointer to it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the mantle. </td></tr>
    <tr><td class="paramname">recordbatches</td><td>The <a class="el" href="structfletchgen_1_1_record_batch.html" title="A RecordBatch aggregating ArrayReaders/Writers.">RecordBatch</a> components to instantiate. </td></tr>
    <tr><td class="paramname">nucleus</td><td>The <a class="el" href="structfletchgen_1_1_nucleus.html" title="It&#39;s like a kernel, but there is a kernel inside.">Nucleus</a> to instantiate. </td></tr>
    <tr><td class="paramname">bus_spec</td><td>The specification of the top-level bus. </td></tr>
    <tr><td class="paramname">axi_spec</td><td>The specification of the AXI4-lite MMIO interface. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to the mantle component. </dd></dl>

<p class="definition">Definition at line <a class="el" href="mantle_8cc_source.html#l00189">189</a> of file <a class="el" href="mantle_8cc_source.html">mantle.cc</a>.</p>

</div>
</div>
<a id="afe871dfa41237c8e28b2266afe29e27a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe871dfa41237c8e28b2266afe29e27a">&#9670;&nbsp;</a></span>mmio()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; Component &gt; fletchgen::mmio </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; fletcher::RecordBatchDescription &gt; &amp;&#160;</td>
          <td class="paramname"><em>batches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structfletchgen_1_1_mmio_reg.html">MmioReg</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>regs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfletchgen_1_1_axi4_lite_spec.html">Axi4LiteSpec</a>&#160;</td>
          <td class="paramname"><em>axi_spec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate the MMIO component for the nucleus. </p>
<p>Must generate the component in such a way that GenerateVhdmmioYaml in combination with the vhdmmio tool creates an identical component interface.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">batches</td><td>The RecordBatchDescriptions of the recordbatches in the design. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">regs</td><td>A list of custom 32-bit register names. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axi_spec</td><td>Specification of the AXI4-lite interface </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A component. </dd></dl>

<p class="definition">Definition at line <a class="el" href="mmio_8cc_source.html#l00062">62</a> of file <a class="el" href="mmio_8cc_source.html">mmio.cc</a>.</p>

</div>
</div>
<a id="abf32a9249a6e66d6b1166eecb77afde9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf32a9249a6e66d6b1166eecb77afde9">&#9670;&nbsp;</a></span>unlock_port()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="structfletchgen_1_1_field_port.html">FieldPort</a> &gt; fletchgen::unlock_port </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classfletchgen_1_1_fletcher_schema.html">FletcherSchema</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>schema</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; arrow::Field &gt; &amp;&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; Node &gt; &amp;&#160;</td>
          <td class="paramname"><em>tag_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; ClockDomain &gt; &amp;&#160;</td>
          <td class="paramname"><em>domain</em> = <code>default_domain()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a field-derived unlock port. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">schema</td><td>The Fletcher-derived schema. </td></tr>
    <tr><td class="paramname">field</td><td>The Arrow field to derive the port from. </td></tr>
    <tr><td class="paramname">tag_width</td><td>The width of the tag field. </td></tr>
    <tr><td class="paramname">domain</td><td>The clock domain. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a new <a class="el" href="structfletchgen_1_1_field_port.html" title="A port derived from an Arrow field.">FieldPort</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="recordbatch_8cc_source.html#l00235">235</a> of file <a class="el" href="recordbatch_8cc_source.html">recordbatch.cc</a>.</p>

</div>
</div>
<a id="a41126102d1a6cffdea215caa4b017433"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41126102d1a6cffdea215caa4b017433">&#9670;&nbsp;</a></span>write_static_vhdl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fletchgen::write_static_vhdl </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>real_dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>emb_dir</em> = <code>&quot;hardware&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes Fletcher's static VHDL files to the given directory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">real_dir</td><td>The real directory to write to. </td></tr>
    <tr><td class="paramname">emb_dir</td><td>The embedded filesystem directory to read from, defaulting to the toplevel resource directory ("hardware"). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="static__vhdl_8cc_source.html#l00027">27</a> of file <a class="el" href="static__vhdl_8cc_source.html">static_vhdl.cc</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a10c7c1970a991a0af03263eb25c2c561"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10c7c1970a991a0af03263eb25c2c561">&#9670;&nbsp;</a></span>DEFAULT_NOTICE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr char fletchgen::DEFAULT_NOTICE[]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= <span class="stringliteral">&quot;-- Copyright 2018-2019 Delft University of Technology\n&quot;</span></div>
<div class="line">                                  <span class="stringliteral">&quot;--\n&quot;</span></div>
<div class="line">                                  <span class="stringliteral">&quot;-- Licensed under the Apache License, Version 2.0 (the \&quot;License\&quot;);\n&quot;</span></div>
<div class="line">                                  <span class="stringliteral">&quot;-- you may not use this file except in compliance with the License.\n&quot;</span></div>
<div class="line">                                  <span class="stringliteral">&quot;-- You may obtain a copy of the License at\n&quot;</span></div>
<div class="line">                                  <span class="stringliteral">&quot;--\n&quot;</span></div>
<div class="line">                                  <span class="stringliteral">&quot;--     http://www.apache.org/licenses/LICENSE-2.0\n&quot;</span></div>
<div class="line">                                  <span class="stringliteral">&quot;--\n&quot;</span></div>
<div class="line">                                  <span class="stringliteral">&quot;-- Unless required by applicable law or agreed to in writing, software\n&quot;</span></div>
<div class="line">                                  <span class="stringliteral">&quot;-- distributed under the License is distributed on an \&quot;AS IS\&quot; BASIS,\n&quot;</span></div>
<div class="line">                                  <span class="stringliteral">&quot;-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n&quot;</span></div>
<div class="line">                                  <span class="stringliteral">&quot;-- See the License for the specific language governing permissions and\n&quot;</span></div>
<div class="line">                                  <span class="stringliteral">&quot;-- limitations under the License.\n&quot;</span></div>
<div class="line">                                  <span class="stringliteral">&quot;--\n&quot;</span></div>
<div class="line">                                  <span class="stringliteral">&quot;-- This file was generated by Fletchgen. Modify this file at your own risk.\n&quot;</span></div>
<div class="line">                                  <span class="stringliteral">&quot;\n&quot;</span></div>
</div><!-- fragment -->
<p>Default copyright notice. </p>

<p class="definition">Definition at line <a class="el" href="utils_8h_source.html#l00046">46</a> of file <a class="el" href="utils_8h_source.html">utils.h</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
