-- Copyright 2018 Delft University of Technology
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     http://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

-- This file was automatically generated by FletchGen. Modify this file
-- at your own risk.

library ieee;
use ieee.std_logic_1164.all;
use ieee.std_logic_misc.all;
use ieee.numeric_std.all;

library work;
use work.Arrow.all;

entity test is
  generic(
    NUM_USER_REGS                              : natural;
    TAG_WIDTH                                  : natural;
    BUS_ADDR_WIDTH                             : natural;
    INDEX_WIDTH                                : natural;
    REG_WIDTH                                  : natural
  );
  port(
    Name_out_ready                             : out std_logic;
    Name_out_chars_out_data                    : in std_logic_vector(31 downto 0);
    Name_out_chars_out_count                   : in std_logic_vector(2 downto 0);
    Name_out_chars_out_dvalid                  : in std_logic;
    Name_out_chars_out_last                    : in std_logic;
    Name_out_chars_out_ready                   : out std_logic;
    Name_out_chars_out_valid                   : in std_logic;
    Name_out_length                            : in std_logic_vector(INDEX_WIDTH-1 downto 0);
    Name_out_last                              : in std_logic;
    Name_out_valid                             : in std_logic;
    Name_cmd_valid                             : out std_logic;
    Name_cmd_ready                             : in std_logic;
    Name_cmd_firstIdx                          : out std_logic_vector(INDEX_WIDTH-1 downto 0);
    Name_cmd_lastIdx                           : out std_logic_vector(INDEX_WIDTH-1 downto 0);
    Name_cmd_tag                               : out std_logic_vector(TAG_WIDTH-1 downto 0);
    Name_cmd_Name_values_addr                  : out std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);
    Name_cmd_Name_offsets_addr                 : out std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);
    -------------------------------------------------------------------------
    acc_reset                                  : in std_logic;
    acc_clk                                    : in std_logic;
    -------------------------------------------------------------------------
    ctrl_done                                  : out std_logic;
    ctrl_busy                                  : out std_logic;
    ctrl_idle                                  : out std_logic;
    ctrl_reset                                 : in std_logic;
    ctrl_stop                                  : in std_logic;
    ctrl_start                                 : in std_logic;
    -------------------------------------------------------------------------
    reg_return                                 : out std_logic_vector(2*REG_WIDTH-1 downto 0);
    reg_Name_values_addr                       : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);
    reg_Name_offsets_addr                      : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);
    regs_in                                    : in std_logic_vector(2*REG_WIDTH-1 downto 0);
    regs_out                                   : out std_logic_vector(2*REG_WIDTH-1 downto 0);
    regs_out_en                                : out std_logic_vector(1 downto 0)
  );
end test;

architecture Behavioral of test is
begin
  process is
  begin
    Name_out_ready <= '1';
    Name_out_chars_out_ready <= '1';
    loop
      wait until rising_edge(acc_clk);
      if acc_reset /= '1' then 
        Name_cmd_valid <= '1';
        Name_cmd_firstIdx <= (others => '0');
        Name_cmd_lastIdx <= std_logic_vector(to_unsigned(26, INDEX_WIDTH));
        Name_cmd_Name_offsets_addr <= std_logic_vector(to_unsigned(0, BUS_ADDR_WIDTH));
        Name_cmd_Name_values_addr <= std_logic_vector(to_unsigned(128, BUS_ADDR_WIDTH));
        wait until rising_edge(acc_clk);
        exit;
      end if;
    end loop;
    Name_cmd_valid <= '0';
    wait;
  end process;
  
end architecture;
