// -- (c) Copyright 2010 - 2011 Xilinx, Inc. All rights reserved.
// --
// -- This file contains confidential and proprietary information
// -- of Xilinx, Inc. and is protected under U.S. and 
// -- international copyright and other intellectual property
// -- laws.
// --
// -- DISCLAIMER
// -- This disclaimer is not a license and does not grant any
// -- rights to the materials distributed herewith. Except as
// -- otherwise provided in a valid license issued to you by
// -- Xilinx, and to the maximum extent permitted by applicable
// -- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
// -- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
// -- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
// -- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
// -- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
// -- (2) Xilinx shall not be liable (whether in contract or tort,
// -- including negligence, or under any other theory of
// -- liability) for any loss or damage of any kind or nature
// -- related to, arising under or in connection with these
// -- materials, including for any direct, or any indirect,
// -- special, incidental, or consequential loss or damage
// -- (including loss of data, profits, goodwill, or any type of
// -- loss or damage suffered as a result of any action brought
// -- by a third party) even if such damage or loss was
// -- reasonably foreseeable or Xilinx had been advised of the
// -- possibility of the same.
// --
// -- CRITICAL APPLICATIONS
// -- Xilinx products are not designed or intended to be fail-
// -- safe, or for use in any application requiring fail-safe
// -- performance, such as life-support or safety devices or
// -- systems, Class III medical devices, nuclear facilities,
// -- applications related to the deployment of airbags, or any
// -- other applications that could lead to death, personal
// -- injury, or severe property or environmental damage
// -- (individually and collectively, "Critical
// -- Applications"). Customer assumes the sole risk and
// -- liability of any use of Xilinx products in Critical
// -- Applications, subject only to applicable laws and
// -- regulations governing limitations on product liability.
// --
// -- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
// -- PART OF THIS FILE AT ALL TIMES.
//-----------------------------------------------------------------------------
//
// Description: Address AXI3 Slave Converter
//
//
// Verilog-standard:  Verilog 2001
//--------------------------------------------------------------------------
//
// Structure:
//   a_axi3_conv
//     axic_fifo
//
//--------------------------------------------------------------------------
`timescale 1ps/1ps

(* DowngradeIPIdentifiedWarnings="yes" *) 
module axi_interconnect_v1_7_13_a_axi3_conv #
  (
   parameter C_FAMILY                            = "none",
   parameter integer C_AXI_ID_WIDTH              = 1,
   parameter integer C_AXI_ADDR_WIDTH            = 32,
   parameter integer C_AXI_DATA_WIDTH            = 32,
   parameter integer C_AXI_SUPPORTS_USER_SIGNALS = 0,
   parameter integer C_AXI_AUSER_WIDTH           = 1,
   parameter integer C_AXI_CHANNEL                    = 0,
                       // 0 = AXI AW Channel.
                       // 1 = AXI AR Channel.
   parameter integer C_SUPPORT_SPLITTING              = 1,
                       // Implement transaction splitting logic.
                       // Disabled whan all connected masters are AXI3 and have same or narrower data width.
   parameter integer C_SUPPORT_BURSTS                 = 1,
                       // Disabled when all connected masters are AxiLite,
                       //   allowing logic to be simplified.
   parameter integer C_SINGLE_THREAD                  = 1
                       // 0 = Ignore ID when propagating transactions (assume all responses are in order).
                       // 1 = Enforce single-threading (one ID at a time) when any outstanding or 
                       //     requested transaction requires splitting.
                       //     While no split is ongoing any new non-split transaction will pass immediately regardless
                       //     off ID.
                       //     A split transaction will stall if there are multiple ID (non-split) transactions
                       //     ongoing, once it has been forwarded only transactions with the same ID is allowed
                       //     (split or not) until all ongoing split transactios has been completed.
   )
  (
   // System Signals
   input wire ACLK,
   input wire ARESET,

   // Command Interface (W/R)
   output wire                              cmd_valid,
   output wire                              cmd_split,
   output wire [C_AXI_ID_WIDTH-1:0]         cmd_id,
   output wire [4-1:0]                      cmd_length,
   input  wire                              cmd_ready,
   
   // Command Interface (B)
   output wire                              cmd_b_valid,
   output wire                              cmd_b_split,
   output wire [4-1:0]                      cmd_b_repeat,
   input  wire                              cmd_b_ready,
   
   // Slave Interface Write Address Ports
   input  wire [C_AXI_ID_WIDTH-1:0]     S_AXI_AID,
   input  wire [C_AXI_ADDR_WIDTH-1:0]   S_AXI_AADDR,
   input  wire [8-1:0]                  S_AXI_ALEN,
   input  wire [3-1:0]                  S_AXI_ASIZE,
   input  wire [2-1:0]                  S_AXI_ABURST,
   input  wire [2-1:0]                  S_AXI_ALOCK,
   input  wire [4-1:0]                  S_AXI_ACACHE,
   input  wire [3-1:0]                  S_AXI_APROT,
   input  wire [4-1:0]                  S_AXI_AQOS,
   input  wire [C_AXI_AUSER_WIDTH-1:0]  S_AXI_AUSER,
   input  wire                          S_AXI_AVALID,
   output wire                          S_AXI_AREADY,

   // Master Interface Write Address Port
   output wire [C_AXI_ID_WIDTH-1:0]     M_AXI_AID,
   output wire [C_AXI_ADDR_WIDTH-1:0]   M_AXI_AADDR,
   output wire [8-1:0]                  M_AXI_ALEN,
   output wire [3-1:0]                  M_AXI_ASIZE,
   output wire [2-1:0]                  M_AXI_ABURST,
   output wire [2-1:0]                  M_AXI_ALOCK,
   output wire [4-1:0]                  M_AXI_ACACHE,
   output wire [3-1:0]                  M_AXI_APROT,
   output wire [4-1:0]                  M_AXI_AREGION,  // constant 0
   output wire [4-1:0]                  M_AXI_AQOS,
   output wire [C_AXI_AUSER_WIDTH-1:0]  M_AXI_AUSER,
   output wire                          M_AXI_AVALID,
   input  wire                          M_AXI_AREADY
   );

   
  /////////////////////////////////////////////////////////////////////////////
  // Variables for generating parameter controlled instances.
  /////////////////////////////////////////////////////////////////////////////
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Local params
  /////////////////////////////////////////////////////////////////////////////
  
  // Constants for burst types.
  localparam [2-1:0] C_FIX_BURST         = 2'b00;
  localparam [2-1:0] C_INCR_BURST        = 2'b01;
  localparam [2-1:0] C_WRAP_BURST        = 2'b10;
  
  // Depth for command FIFO.
  localparam integer C_FIFO_DEPTH_LOG    = 5;
  
  // Constants used to generate size mask.
  localparam [C_AXI_ADDR_WIDTH+8-1:0] C_SIZE_MASK = {{C_AXI_ADDR_WIDTH{1'b1}}, 8'b0000_0000};
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Functions
  /////////////////////////////////////////////////////////////////////////////
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Internal signals
  /////////////////////////////////////////////////////////////////////////////
  
  // Access decoding related signals.
  wire                                access_is_incr;
  wire [4-1:0]                        num_transactions;
  wire                                incr_need_to_split;
  reg  [C_AXI_ADDR_WIDTH-1:0]         next_mi_addr;
  reg                                 split_ongoing;
  reg  [4-1:0]                        pushed_commands;
  reg  [16-1:0]                       addr_step;
  reg  [C_AXI_ADDR_WIDTH-1:0]         size_mask;
  
  // Access decoding related signals for internal pipestage.
  reg                                 access_is_incr_q;
  reg                                 incr_need_to_split_q;
  wire                                need_to_split_q;
  reg  [4-1:0]                        num_transactions_q;
  reg  [16-1:0]                       addr_step_q;
  reg  [C_AXI_ADDR_WIDTH-1:0]         size_mask_q;
  
  // Command buffer help signals.
  reg  [C_FIFO_DEPTH_LOG:0]           cmd_depth;
  reg                                 cmd_empty;
  reg  [C_AXI_ID_WIDTH-1:0]           queue_id;
  wire                                id_match;
  wire                                cmd_id_check;
  wire                                s_ready;
  wire                                cmd_full;
  wire                                allow_this_cmd;
  wire                                allow_new_cmd;
  wire                                cmd_push;
  reg                                 cmd_push_block;
  reg  [C_FIFO_DEPTH_LOG:0]           cmd_b_depth;
  reg                                 cmd_b_empty;
  wire                                cmd_b_full;
  wire                                cmd_b_push;
  reg                                 cmd_b_push_block;
  wire                                pushed_new_cmd;
  wire                                last_incr_split;
  wire                                last_split;
  wire                                no_cmd;
  wire                                allow_split_cmd;
  wire                                almost_empty;
  wire                                no_b_cmd;
  wire                                allow_non_split_cmd;
  wire                                almost_b_empty;
  reg                                 multiple_id_non_split;
  reg                                 split_in_progress;
  
  // Internal Command Interface signals (W/R).
  wire                                cmd_split_i;
  wire [C_AXI_ID_WIDTH-1:0]           cmd_id_i;
  reg  [4-1:0]                        cmd_length_i;
  
  // Internal Command Interface signals (B).
  wire                                cmd_b_split_i;
  wire [4-1:0]                        cmd_b_repeat_i;
  
  // Throttling help signals.
  wire                                mi_stalling;
  reg                                 command_ongoing;
   
  // Internal SI-side signals.
  reg  [C_AXI_ID_WIDTH-1:0]           S_AXI_AID_Q;
  reg  [C_AXI_ADDR_WIDTH-1:0]         S_AXI_AADDR_Q;
  reg  [8-1:0]                        S_AXI_ALEN_Q;
  reg  [3-1:0]                        S_AXI_ASIZE_Q;
  reg  [2-1:0]                        S_AXI_ABURST_Q;
  reg  [2-1:0]                        S_AXI_ALOCK_Q;
  reg  [4-1:0]                        S_AXI_ACACHE_Q;
  reg  [3-1:0]                        S_AXI_APROT_Q;
  reg  [4-1:0]                        S_AXI_AQOS_Q;
  reg  [C_AXI_AUSER_WIDTH-1:0]        S_AXI_AUSER_Q;
  reg                                 S_AXI_AREADY_I;
  
  // Internal MI-side signals.
  wire [C_AXI_ID_WIDTH-1:0]           M_AXI_AID_I;
  reg  [C_AXI_ADDR_WIDTH-1:0]         M_AXI_AADDR_I;
  reg  [8-1:0]                        M_AXI_ALEN_I;
  wire [3-1:0]                        M_AXI_ASIZE_I;
  wire [2-1:0]                        M_AXI_ABURST_I;
  reg  [2-1:0]                        M_AXI_ALOCK_I;
  wire [4-1:0]                        M_AXI_ACACHE_I;
  wire [3-1:0]                        M_AXI_APROT_I;
  wire [4-1:0]                        M_AXI_AQOS_I;
  wire [C_AXI_AUSER_WIDTH-1:0]        M_AXI_AUSER_I;
  wire                                M_AXI_AVALID_I;
  wire                                M_AXI_AREADY_I;
  
  reg [1:0] areset_d; // Reset delay register
  always @(posedge ACLK) begin
    areset_d <= {areset_d[0], ARESET};
  end
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Capture SI-Side signals.
  //
  /////////////////////////////////////////////////////////////////////////////
  
  // Register SI-Side signals.
  always @ (posedge ACLK) begin
    if ( ARESET ) begin
      S_AXI_AID_Q     <= {C_AXI_ID_WIDTH{1'b0}};
      S_AXI_AADDR_Q   <= {C_AXI_ADDR_WIDTH{1'b0}};
      S_AXI_ALEN_Q    <= 8'b0;
      S_AXI_ASIZE_Q   <= 3'b0;
      S_AXI_ABURST_Q  <= 2'b0;
      S_AXI_ALOCK_Q   <= 2'b0;
      S_AXI_ACACHE_Q  <= 4'b0;
      S_AXI_APROT_Q   <= 3'b0;
      S_AXI_AQOS_Q    <= 4'b0;
      S_AXI_AUSER_Q   <= {C_AXI_AUSER_WIDTH{1'b0}};
    end else begin
      if ( S_AXI_AREADY_I ) begin
        S_AXI_AID_Q     <= S_AXI_AID;
        S_AXI_AADDR_Q   <= S_AXI_AADDR;
        S_AXI_ALEN_Q    <= S_AXI_ALEN;
        S_AXI_ASIZE_Q   <= S_AXI_ASIZE;
        S_AXI_ABURST_Q  <= S_AXI_ABURST;
        S_AXI_ALOCK_Q   <= S_AXI_ALOCK;
        S_AXI_ACACHE_Q  <= S_AXI_ACACHE;
        S_AXI_APROT_Q   <= S_AXI_APROT;
        S_AXI_AQOS_Q    <= S_AXI_AQOS;
        S_AXI_AUSER_Q   <= S_AXI_AUSER;
      end
    end
  end
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Decode the Incoming Transaction.
  // 
  // Extract transaction type and the number of splits that may be needed.
  // 
  // Calculate the step size so that the address for each part of a split can
  // can be calculated. 
  // 
  /////////////////////////////////////////////////////////////////////////////
  
  // Transaction burst type.
  assign access_is_incr   = ( S_AXI_ABURST == C_INCR_BURST );
  
  // Get number of transactions for split INCR.
  assign num_transactions = S_AXI_ALEN[4 +: 4];
  
  // Generate address bits used for SI-side transaction size.
  always @ *
  begin
    case (S_AXI_ASIZE)
      3'b000: addr_step = 16'h0010;
      3'b001: addr_step = 16'h0020;
      3'b010: addr_step = 16'h0040;
      3'b011: addr_step = 16'h0080;
      3'b100: addr_step = 16'h0100;
      3'b101: addr_step = 16'h0200;
      3'b110: addr_step = 16'h0400;
      3'b111: addr_step = 16'h0800;
    endcase
  end
  
  // Generate address mask bits to remove split transaction unalignment.
  always @ *
  begin
    case (S_AXI_ASIZE)
      3'b000: size_mask = C_SIZE_MASK[8 +: C_AXI_ADDR_WIDTH];
      3'b001: size_mask = C_SIZE_MASK[7 +: C_AXI_ADDR_WIDTH];
      3'b010: size_mask = C_SIZE_MASK[6 +: C_AXI_ADDR_WIDTH];
      3'b011: size_mask = C_SIZE_MASK[5 +: C_AXI_ADDR_WIDTH];
      3'b100: size_mask = C_SIZE_MASK[4 +: C_AXI_ADDR_WIDTH];
      3'b101: size_mask = C_SIZE_MASK[3 +: C_AXI_ADDR_WIDTH];
      3'b110: size_mask = C_SIZE_MASK[2 +: C_AXI_ADDR_WIDTH];
      3'b111: size_mask = C_SIZE_MASK[1 +: C_AXI_ADDR_WIDTH];
    endcase
  end
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Transfer SI-Side signals to internal Pipeline Stage.
  //
  /////////////////////////////////////////////////////////////////////////////
  
  always @ (posedge ACLK) begin
    if ( ARESET ) begin
      access_is_incr_q      <= 1'b0;
      incr_need_to_split_q  <= 1'b0;
      num_transactions_q    <= 4'b0;
      addr_step_q           <= 16'b0;
      size_mask_q           <= {C_AXI_ADDR_WIDTH{1'b0}};
    end else begin
      if ( S_AXI_AREADY_I ) begin
        access_is_incr_q      <= access_is_incr;
        incr_need_to_split_q  <= incr_need_to_split;
        num_transactions_q    <= num_transactions;
        addr_step_q           <= addr_step;
        size_mask_q           <= size_mask;
      end
    end
  end
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Generate Command Information.
  // 
  // Detect if current transation needs to be split, and keep track of all
  // the generated split transactions.
  // 
  // 
  /////////////////////////////////////////////////////////////////////////////
  
  // Detect when INCR must be split.
  assign incr_need_to_split = access_is_incr & ( num_transactions != 0 ) &
                              ( C_SUPPORT_SPLITTING == 1 ) &
                              ( C_SUPPORT_BURSTS == 1 );
  
  // Detect when a command has to be split.
  assign need_to_split_q    = incr_need_to_split_q;
  
  // Handle progress of split transactions.
  always @ (posedge ACLK) begin
    if ( ARESET ) begin
      split_ongoing     <= 1'b0;
    end else begin
      if ( pushed_new_cmd ) begin
        split_ongoing     <= need_to_split_q & ~last_split;
      end
    end
  end
  
  // Keep track of number of transactions generated.
  always @ (posedge ACLK) begin
    if ( ARESET ) begin
      pushed_commands <= 4'b0;
    end else begin
      if ( S_AXI_AREADY_I ) begin
        pushed_commands <= 4'b0;
      end else if ( pushed_new_cmd ) begin
        pushed_commands <= pushed_commands + 4'b1;
      end
    end
  end
  
  // Detect last part of a command, split or not.
  assign last_incr_split    = access_is_incr_q & ( num_transactions_q   == pushed_commands );
  assign last_split         = last_incr_split | ~access_is_incr_q | 
                              ( C_SUPPORT_SPLITTING == 0 ) |
                              ( C_SUPPORT_BURSTS == 0 );
  
  // Calculate base for next address.
  always @ (posedge ACLK) begin
    if ( ARESET ) begin
      next_mi_addr  = {C_AXI_ADDR_WIDTH{1'b0}};
    end else if ( pushed_new_cmd ) begin
      next_mi_addr  = M_AXI_AADDR_I + addr_step_q;
    end
  end
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Translating Transaction.
  // 
  // Set Split transaction information on all part except last for a transaction 
  // that needs splitting.
  // The B Channel will only get one command for a Split transaction and in 
  // the Split bflag will be set in that case.
  // 
  // The AWID is extracted and applied to all commands generated for the current 
  // incomming SI-Side transaction.
  // 
  // The address is increased for each part of a Split transaction, the amount
  // depends on the siSIZE for the transaction.
  // 
  // The length has to be changed for Split transactions. All part except tha 
  // last one will have 0xF, the last one uses the 4 lsb bits from the SI-side
  // transaction as length.
  // 
  // Non-Split has untouched address and length information.
  // 
  // Exclusive access are diasabled for a Split transaction because it is not 
  // possible to guarantee concistency between all the parts.
  // 
  /////////////////////////////////////////////////////////////////////////////
  
  // Assign Split signals.
  assign cmd_split_i        = need_to_split_q & ~last_split;
  assign cmd_b_split_i      = need_to_split_q & ~last_split;
  
  // Copy AW ID to W.
  assign cmd_id_i           = S_AXI_AID_Q;
  
  // Set B Responses to merge.
  assign cmd_b_repeat_i     = num_transactions_q;
  
  // Select new size or remaining size.
  always @ *
  begin
    if ( split_ongoing & access_is_incr_q ) begin
      M_AXI_AADDR_I = next_mi_addr & size_mask_q;
    end else begin
      M_AXI_AADDR_I = S_AXI_AADDR_Q;
    end
  end
  
  // Generate the base length for each transaction.
  always @ *
  begin
    if ( last_split ) begin
      M_AXI_ALEN_I = S_AXI_ALEN_Q[0 +: 4];
      cmd_length_i = S_AXI_ALEN_Q[0 +: 4];
    end else begin
      M_AXI_ALEN_I = 4'hF;
      cmd_length_i = 4'hF;
    end
  end
  
  // Kill Exclusive for Split transactions.
  always @ *
  begin
    if ( need_to_split_q ) begin
      M_AXI_ALOCK_I = {S_AXI_ALOCK_Q[1], 1'b0};
    end else begin
      M_AXI_ALOCK_I = S_AXI_ALOCK_Q;
    end
  end
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Forward the command to the MI-side interface.
  // 
  // It is determined that this is an allowed command/access when there is 
  // room in the command queue (and it passes ID and Split checks as required).
  //
  /////////////////////////////////////////////////////////////////////////////
  
  // Move SI-side transaction to internal pipe stage.
  always @ (posedge ACLK) begin
    if (ARESET) begin
      command_ongoing <= 1'b0;
      S_AXI_AREADY_I <= 1'b0;
    end else begin
      if (areset_d == 2'b10) begin
        S_AXI_AREADY_I <= 1'b1;
      end else begin
        if ( S_AXI_AVALID & S_AXI_AREADY_I ) begin
          command_ongoing <= 1'b1;
          S_AXI_AREADY_I <= 1'b0;
        end else if ( pushed_new_cmd & last_split ) begin
          command_ongoing <= 1'b0;
          S_AXI_AREADY_I <= 1'b1;
        end 
      end
    end
  end
  
  // Generate ready signal.
  assign S_AXI_AREADY   = S_AXI_AREADY_I;
  
  // Only allowed to forward translated command when command queue is ok with it.
  assign M_AXI_AVALID_I = allow_new_cmd & command_ongoing;
  
  // Detect when MI-side is stalling.
  assign mi_stalling    = M_AXI_AVALID_I & ~M_AXI_AREADY_I;
                          
  
  /////////////////////////////////////////////////////////////////////////////
  // Simple transfer of paramters that doesn't need to be adjusted.
  // 
  // ID     - Transaction still recognized with the same ID.
  // CACHE  - No need to change the chache features. Even if the modyfiable
  //          bit is overridden (forcefully) there is no need to let downstream
  //          component beleive it is ok to modify it further.
  // PROT   - Security level of access is not changed when upsizing.
  // REGION - Address region is static 0.
  // QOS    - Quality of Service is static 0.
  // USER   - User bits remains the same.
  // 
  /////////////////////////////////////////////////////////////////////////////
  
  assign M_AXI_AID_I      = S_AXI_AID_Q;
  assign M_AXI_ASIZE_I    = S_AXI_ASIZE_Q;
  assign M_AXI_ABURST_I   = S_AXI_ABURST_Q;
  assign M_AXI_ACACHE_I   = S_AXI_ACACHE_Q;
  assign M_AXI_APROT_I    = S_AXI_APROT_Q;
  assign M_AXI_AQOS_I     = S_AXI_AQOS_Q;
  assign M_AXI_AUSER_I    = ( C_AXI_SUPPORTS_USER_SIGNALS ) ? S_AXI_AUSER_Q : {C_AXI_AUSER_WIDTH{1'b0}};
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Control command queue to W/R channel.
  //
  // Commands can be pushed into the Cmd FIFO even if MI-side is stalling.
  // A flag is set if MI-side is stalling when Command is pushed to the 
  // Cmd FIFO. This will prevent multiple push of the same Command as well as
  // keeping the MI-side Valid signal if the Allow Cmd requirement has been 
  // updated to disable furter Commands (I.e. it is made sure that the SI-side 
  // Command has been forwarded to both Cmd FIFO and MI-side).
  // 
  // It is allowed to continue pushing new commands as long as
  // * There is room in the queue(s)
  // * The ID is the same as previously queued. Since data is not reordered
  //   for the same ID it is always OK to let them proceed.
  //   Or, if no split transaction is ongoing any ID can be allowed.
  //
  /////////////////////////////////////////////////////////////////////////////
  
  // Keep track of current ID in queue.
  always @ (posedge ACLK) begin
    if (ARESET) begin
      queue_id              <= {C_AXI_ID_WIDTH{1'b0}};
      multiple_id_non_split <= 1'b0;
      split_in_progress     <= 1'b0;
    end else begin
      if ( cmd_push ) begin
        // Store ID (it will be matching ID or a "new beginning").
        queue_id              <= S_AXI_AID_Q;
      end
      
      if ( no_cmd & no_b_cmd ) begin
        multiple_id_non_split <= 1'b0;
      end else if ( cmd_push & allow_non_split_cmd & ~id_match ) begin
        multiple_id_non_split <= 1'b1;
      end
      
      if ( no_cmd & no_b_cmd ) begin
        split_in_progress     <= 1'b0;
      end else if ( cmd_push & allow_split_cmd ) begin
        split_in_progress     <= 1'b1;
      end
    end
  end
  
  // Determine if the command FIFOs are empty.
  assign no_cmd               = almost_empty   & cmd_ready   | cmd_empty;
  assign no_b_cmd             = almost_b_empty & cmd_b_ready | cmd_b_empty;
  
  // Check ID to make sure this command is allowed.
  assign id_match             = ( C_SINGLE_THREAD == 0 ) | ( queue_id == S_AXI_AID_Q);
  assign cmd_id_check         = (cmd_empty & cmd_b_empty) | ( id_match & (~cmd_empty | ~cmd_b_empty) );
  
  // Command type affects possibility to push immediately or wait.
  assign allow_split_cmd      = need_to_split_q & cmd_id_check & ~multiple_id_non_split;
  assign allow_non_split_cmd  = ~need_to_split_q & (cmd_id_check | ~split_in_progress);
  assign allow_this_cmd       = allow_split_cmd | allow_non_split_cmd | ( C_SINGLE_THREAD == 0 );
  
  // Check if it is allowed to push more commands.
  assign allow_new_cmd        = (~cmd_full & ~cmd_b_full & allow_this_cmd) | 
                                cmd_push_block;
  
  // Push new command when allowed and MI-side is able to receive the command.
  assign cmd_push             = M_AXI_AVALID_I & ~cmd_push_block;
  assign cmd_b_push           = M_AXI_AVALID_I & ~cmd_b_push_block & (C_AXI_CHANNEL == 0);
  
  // Block furter push until command has been forwarded to MI-side.
  always @ (posedge ACLK) begin
    if (ARESET) begin
      cmd_push_block <= 1'b0;
    end else begin
      if ( pushed_new_cmd ) begin
        cmd_push_block <= 1'b0;
      end else if ( cmd_push & mi_stalling ) begin
        cmd_push_block <= 1'b1;
      end 
    end
  end
  
  // Block furter push until command has been forwarded to MI-side.
  always @ (posedge ACLK) begin
    if (ARESET) begin
      cmd_b_push_block <= 1'b0;
    end else begin
      if ( S_AXI_AREADY_I ) begin
        cmd_b_push_block <= 1'b0;
      end else if ( cmd_b_push ) begin
        cmd_b_push_block <= 1'b1;
      end 
    end
  end
  
  // Acknowledge command when we can push it into queue (and forward it).
  assign pushed_new_cmd = M_AXI_AVALID_I & M_AXI_AREADY_I;
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Command Queue (W/R):
  // 
  // Instantiate a FIFO as the queue and adjust the control signals.
  // 
  // The features from Command FIFO can be reduced depending on configuration:
  // Read Channel only need the split information.
  // Write Channel always require ID information. When bursts are supported 
  // Split and Length information is also used.
  // 
  /////////////////////////////////////////////////////////////////////////////
  
  // Instantiated queue.
  generate
    if ( C_AXI_CHANNEL == 1 && C_SUPPORT_SPLITTING == 1 && C_SUPPORT_BURSTS == 1 ) begin : USE_R_CHANNEL
  axi_interconnect_v1_7_13_axic_fifo #
      (
       .C_FAMILY(C_FAMILY),
       .C_FIFO_DEPTH_LOG(C_FIFO_DEPTH_LOG),
       .C_FIFO_WIDTH(1),
       .C_FIFO_TYPE("lut")
       ) 
       cmd_queue
      (
       .ACLK(ACLK),
       .ARESET(ARESET),
       .S_MESG({cmd_split_i}),
       .S_VALID(cmd_push),
       .S_READY(s_ready),
       .M_MESG({cmd_split}),
       .M_VALID(cmd_valid),
       .M_READY(cmd_ready)
       );
       
       assign cmd_id            = {C_AXI_ID_WIDTH{1'b0}};
       assign cmd_length        = 4'b0;
       
    end else if (C_SUPPORT_BURSTS == 1) begin : USE_BURSTS
  axi_interconnect_v1_7_13_axic_fifo #
      (
       .C_FAMILY(C_FAMILY),
       .C_FIFO_DEPTH_LOG(C_FIFO_DEPTH_LOG),
       .C_FIFO_WIDTH(C_AXI_ID_WIDTH+4),
       .C_FIFO_TYPE("lut")
       ) 
       cmd_queue
      (
       .ACLK(ACLK),
       .ARESET(ARESET),
       .S_MESG({cmd_id_i, cmd_length_i}),
       .S_VALID(cmd_push),
       .S_READY(s_ready),
       .M_MESG({cmd_id, cmd_length}),
       .M_VALID(cmd_valid),
       .M_READY(cmd_ready)
       );
       
       assign cmd_split         = 1'b0;
       
    end else begin : NO_BURSTS
  axi_interconnect_v1_7_13_axic_fifo #
      (
       .C_FAMILY(C_FAMILY),
       .C_FIFO_DEPTH_LOG(C_FIFO_DEPTH_LOG),
       .C_FIFO_WIDTH(C_AXI_ID_WIDTH),
       .C_FIFO_TYPE("lut")
       ) 
       cmd_queue
      (
       .ACLK(ACLK),
       .ARESET(ARESET),
       .S_MESG({cmd_id_i}),
       .S_VALID(cmd_push),
       .S_READY(s_ready),
       .M_MESG({cmd_id}),
       .M_VALID(cmd_valid),
       .M_READY(cmd_ready)
       );
       
       assign cmd_split         = 1'b0;
       assign cmd_length        = 4'b0;
       
    end
  endgenerate

  // Queue is concidered full when not ready.
  assign cmd_full   = ~s_ready;
  
  // Queue is empty when no data at output port.
  always @ (posedge ACLK) begin
    if (ARESET) begin
      cmd_empty <= 1'b1;
      cmd_depth <= {C_FIFO_DEPTH_LOG+1{1'b0}};
    end else begin
      if ( cmd_push & ~cmd_ready ) begin
        // Push only => Increase depth.
        cmd_depth <= cmd_depth + 1'b1;
        cmd_empty <= 1'b0;
      end else if ( ~cmd_push & cmd_ready ) begin
        // Pop only => Decrease depth.
        cmd_depth <= cmd_depth - 1'b1;
        cmd_empty <= almost_empty;
      end
    end
  end
  
  assign almost_empty = ( cmd_depth == 1 );
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Command Queue (B):
  // 
  // Add command queue for B channel only when it is AW channel and both burst
  // and splitting is supported.
  //
  // When turned off the command appears always empty.
  // 
  /////////////////////////////////////////////////////////////////////////////
  
  // Instantiated queue.
  generate
    if ( C_AXI_CHANNEL == 0 && C_SUPPORT_SPLITTING == 1 && C_SUPPORT_BURSTS == 1 ) begin : USE_B_CHANNEL
      
      wire                                cmd_b_valid_i;
      wire                                s_b_ready;
      
  axi_interconnect_v1_7_13_axic_fifo #
      (
       .C_FAMILY(C_FAMILY),
       .C_FIFO_DEPTH_LOG(C_FIFO_DEPTH_LOG),
       .C_FIFO_WIDTH(1+4),
       .C_FIFO_TYPE("lut")
       ) 
       cmd_b_queue
      (
       .ACLK(ACLK),
       .ARESET(ARESET),
       .S_MESG({cmd_b_split_i, cmd_b_repeat_i}),
       .S_VALID(cmd_b_push),
       .S_READY(s_b_ready),
       .M_MESG({cmd_b_split, cmd_b_repeat}),
       .M_VALID(cmd_b_valid_i),
       .M_READY(cmd_b_ready)
       );
    
      // Queue is concidered full when not ready.
      assign cmd_b_full   = ~s_b_ready;
      
      // Queue is empty when no data at output port.
      always @ (posedge ACLK) begin
        if (ARESET) begin
          cmd_b_empty <= 1'b1;
          cmd_b_depth <= {C_FIFO_DEPTH_LOG+1{1'b0}};
        end else begin
          if ( cmd_b_push & ~cmd_b_ready ) begin
            // Push only => Increase depth.
            cmd_b_depth <= cmd_b_depth + 1'b1;
            cmd_b_empty <= 1'b0;
          end else if ( ~cmd_b_push & cmd_b_ready ) begin
            // Pop only => Decrease depth.
            cmd_b_depth <= cmd_b_depth - 1'b1;
            cmd_b_empty <= ( cmd_b_depth == 1 );
          end
        end
      end
  
      assign almost_b_empty = ( cmd_b_depth == 1 );
      
      // Assign external signal.
      assign cmd_b_valid  = cmd_b_valid_i;
      
    end else begin : NO_B_CHANNEL
      
      // Assign external command signals.
      assign cmd_b_valid    = 1'b0;
      assign cmd_b_split    = 1'b0;
      assign cmd_b_repeat   = 4'b0;
   
      // Assign internal command FIFO signals.
      assign cmd_b_full     = 1'b0;
      assign almost_b_empty = 1'b0;
      always @ (posedge ACLK) begin
        if (ARESET) begin
          cmd_b_empty <= 1'b1;
          cmd_b_depth <= {C_FIFO_DEPTH_LOG+1{1'b0}};
        end else begin
          // Constant FF due to ModelSim behavior.
          cmd_b_empty <= 1'b1;
          cmd_b_depth <= {C_FIFO_DEPTH_LOG+1{1'b0}};
        end
      end
      
    end
  endgenerate
  
  
  /////////////////////////////////////////////////////////////////////////////
  // MI-side output handling
  // 
  /////////////////////////////////////////////////////////////////////////////
  assign M_AXI_AID      = M_AXI_AID_I;
  assign M_AXI_AADDR    = M_AXI_AADDR_I;
  assign M_AXI_ALEN     = M_AXI_ALEN_I;
  assign M_AXI_ASIZE    = M_AXI_ASIZE_I;
  assign M_AXI_ABURST   = M_AXI_ABURST_I;
  assign M_AXI_ALOCK    = M_AXI_ALOCK_I;
  assign M_AXI_ACACHE   = M_AXI_ACACHE_I;
  assign M_AXI_APROT    = M_AXI_APROT_I;
  assign M_AXI_AREGION  = 4'b0;
  assign M_AXI_AQOS     = M_AXI_AQOS_I;
  assign M_AXI_AUSER    = M_AXI_AUSER_I;
  assign M_AXI_AVALID   = M_AXI_AVALID_I;
  assign M_AXI_AREADY_I = M_AXI_AREADY;
  
  
endmodule



// -- (c) Copyright 2009 - 2011 Xilinx, Inc. All rights reserved.
// --
// -- This file contains confidential and proprietary information
// -- of Xilinx, Inc. and is protected under U.S. and 
// -- international copyright and other intellectual property
// -- laws.
// --
// -- DISCLAIMER
// -- This disclaimer is not a license and does not grant any
// -- rights to the materials distributed herewith. Except as
// -- otherwise provided in a valid license issued to you by
// -- Xilinx, and to the maximum extent permitted by applicable
// -- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
// -- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
// -- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
// -- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
// -- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
// -- (2) Xilinx shall not be liable (whether in contract or tort,
// -- including negligence, or under any other theory of
// -- liability) for any loss or damage of any kind or nature
// -- related to, arising under or in connection with these
// -- materials, including for any direct, or any indirect,
// -- special, incidental, or consequential loss or damage
// -- (including loss of data, profits, goodwill, or any type of
// -- loss or damage suffered as a result of any action brought
// -- by a third party) even if such damage or loss was
// -- reasonably foreseeable or Xilinx had been advised of the
// -- possibility of the same.
// --
// -- CRITICAL APPLICATIONS
// -- Xilinx products are not designed or intended to be fail-
// -- safe, or for use in any application requiring fail-safe
// -- performance, such as life-support or safety devices or
// -- systems, Class III medical devices, nuclear facilities,
// -- applications related to the deployment of airbags, or any
// -- other applications that could lead to death, personal
// -- injury, or severe property or environmental damage
// -- (individually and collectively, "Critical
// -- Applications"). Customer assumes the sole risk and
// -- liability of any use of Xilinx products in Critical
// -- Applications, subject only to applicable laws and
// -- regulations governing limitations on product liability.
// --
// -- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
// -- PART OF THIS FILE AT ALL TIMES.
//-----------------------------------------------------------------------------
//
// File name: addr_arbiter_sasd.v
//
// Description: 
//   Hybrid priority + round-robin arbiter.
//   Read & write requests combined (read preferred) at each slot
//   Muxes AR and AW channel payload inputs based on arbitration results.
//-----------------------------------------------------------------------------
//
// Structure:
//    addr_arbiter_sasd
//      mux_enc
//-----------------------------------------------------------------------------

`timescale 1ps/1ps
`default_nettype none

(* DowngradeIPIdentifiedWarnings="yes" *) 
module axi_interconnect_v1_7_13_addr_arbiter_sasd #
  (
   parameter integer C_MAX_S = 16,
   parameter         C_FAMILY                         = "none", 
   parameter integer C_NUM_S                = 1, 
   parameter integer C_NUM_S_LOG                = 1, 
   parameter integer C_AMESG_WIDTH                 = 1, 
   parameter         C_GRANT_ENC        = 0,
   parameter [C_MAX_S*32-1:0] C_ARB_PRIORITY             = {C_MAX_S{32'h00000000}}
                       // Arbitration priority among each SI slot. 
                       // Higher values indicate higher priority.
                       // Format: C_NUM_SLAVE_SLOTS{Bit32};
                       // Range: 'h0-'hF.
   )
  (
   // Global Signals
   input  wire                                      ACLK,
   input  wire                                      ARESET,
   // Slave Ports
   input  wire [C_NUM_S*C_AMESG_WIDTH-1:0]  S_AWMESG,
   input  wire [C_NUM_S*C_AMESG_WIDTH-1:0]  S_ARMESG,
   input  wire [C_NUM_S-1:0]                S_AWVALID,
   output wire [C_NUM_S-1:0]                S_AWREADY,
   input  wire [C_NUM_S-1:0]                S_ARVALID,
   output wire [C_NUM_S-1:0]                S_ARREADY,
   // Master Ports
   output wire [C_AMESG_WIDTH-1:0]          M_AMESG,
   output wire [C_NUM_S_LOG-1:0]            M_GRANT_ENC,
   output wire [C_NUM_S-1:0]                M_GRANT_HOT,
   output wire                              M_GRANT_RNW,
   output wire                              M_GRANT_ANY,
   output wire                              M_AWVALID,
   input  wire                              M_AWREADY,
   output wire                              M_ARVALID,
   input  wire                              M_ARREADY
   );
   
  // Generates a mask for all input slots that are priority based
  function [C_NUM_S-1:0] f_prio_mask
    (
      input integer null_arg
    );
    reg   [C_NUM_S-1:0]            mask;
    integer                        i;    
    begin
      mask = 0;    
      for (i=0; i < C_NUM_S; i=i+1) begin
        mask[i] = (C_ARB_PRIORITY[i*32+:32] != 0);
      end 
      f_prio_mask = mask;
    end   
  endfunction
  
  // Convert 16-bit one-hot to 4-bit binary
  function [3:0] f_hot2enc
    (
      input [15:0]  one_hot
    );
    begin
      f_hot2enc[0] = |(one_hot & 16'b1010101010101010);
      f_hot2enc[1] = |(one_hot & 16'b1100110011001100);
      f_hot2enc[2] = |(one_hot & 16'b1111000011110000);
      f_hot2enc[3] = |(one_hot & 16'b1111111100000000);
    end
  endfunction

  localparam [C_NUM_S-1:0] P_PRIO_MASK = f_prio_mask(0);

  reg                     m_valid_i;
  reg [C_NUM_S-1:0]       s_ready_i;
  reg [C_NUM_S-1:0]       s_awvalid_reg;
  reg [C_NUM_S-1:0]       s_arvalid_reg;
  wire [15:0]             s_avalid;
  wire                    m_aready;
  wire [C_NUM_S-1:0]      rnw;
  reg                     grant_rnw;
  reg [C_NUM_S_LOG-1:0]   m_grant_enc_i;
  reg [C_NUM_S-1:0]       m_grant_hot_i; 
  reg [C_NUM_S-1:0]       last_rr_hot;
  reg                     any_grant;
  reg                     any_prio;
  reg [C_NUM_S-1:0]       which_prio_hot;
  reg [C_NUM_S_LOG-1:0]   which_prio_enc;          
  reg [4:0]               current_highest;
  reg [15:0]              next_prio_hot;
  reg [C_NUM_S_LOG-1:0]   next_prio_enc;    
  reg                     found_prio;
  wire [C_NUM_S-1:0]      valid_rr;
  reg [15:0]              next_rr_hot;
  reg [C_NUM_S_LOG-1:0]   next_rr_enc;    
  reg [C_NUM_S*C_NUM_S-1:0] carry_rr;
  reg [C_NUM_S*C_NUM_S-1:0] mask_rr;
  reg                     found_rr;
  wire [C_NUM_S-1:0]      next_hot;
  wire [C_NUM_S_LOG-1:0]  next_enc;    
  integer                 i;
  wire  [C_AMESG_WIDTH-1:0] amesg_mux;
  reg   [C_AMESG_WIDTH-1:0] m_amesg_i;
  wire [C_NUM_S*C_AMESG_WIDTH-1:0] s_amesg;
  genvar                  gen_si;

  always @(posedge ACLK) begin
    if (ARESET) begin
      s_awvalid_reg <= 0;
      s_arvalid_reg <= 0;
    end else if (|s_ready_i) begin
      s_awvalid_reg <= 0;
      s_arvalid_reg <= 0;
    end else begin
      s_arvalid_reg <= S_ARVALID & ~s_awvalid_reg;
      s_awvalid_reg <= S_AWVALID & ~s_arvalid_reg & (~S_ARVALID | s_awvalid_reg);
    end
  end
  
  assign s_avalid = S_AWVALID | S_ARVALID;
  assign M_AWVALID = m_valid_i & ~grant_rnw;
  assign M_ARVALID = m_valid_i & grant_rnw;
  assign S_AWREADY = s_ready_i & {C_NUM_S{~grant_rnw}};
  assign S_ARREADY = s_ready_i & {C_NUM_S{grant_rnw}};
  assign M_GRANT_ENC = C_GRANT_ENC ? m_grant_enc_i : 0;
  assign M_GRANT_HOT = m_grant_hot_i;
  assign M_GRANT_RNW = grant_rnw;
  assign rnw = S_ARVALID & ~s_awvalid_reg;
  assign M_AMESG = m_amesg_i;
  assign m_aready = grant_rnw ? M_ARREADY : M_AWREADY;
  
  generate
    for (gen_si=0; gen_si<C_NUM_S; gen_si=gen_si+1) begin : gen_mesg_mux
      assign s_amesg[C_AMESG_WIDTH*gen_si +: C_AMESG_WIDTH] = rnw[gen_si] ? S_ARMESG[C_AMESG_WIDTH*gen_si +: C_AMESG_WIDTH] : S_AWMESG[C_AMESG_WIDTH*gen_si +: C_AMESG_WIDTH];
    end  // gen_mesg_mux
         
    if (C_NUM_S>1) begin : gen_arbiter
    
      /////////////////////////////////////////////////////////////////////////////
      // Grant a new request when there is none still pending.
      // If no qualified requests found, de-assert M_VALID.
      /////////////////////////////////////////////////////////////////////////////
      
      assign M_GRANT_ANY = any_grant;
      assign next_hot = found_prio ? next_prio_hot : next_rr_hot;
      assign next_enc = found_prio ? next_prio_enc : next_rr_enc;
      
      always @(posedge ACLK) begin
        if (ARESET) begin
          m_valid_i <= 0;
          s_ready_i <= 0;
          m_grant_hot_i <= 0;
          m_grant_enc_i <= 0;
          any_grant <= 1'b0;
          last_rr_hot <= {1'b1, {C_NUM_S-1{1'b0}}};
          grant_rnw <= 1'b0;
        end else begin
          s_ready_i <= 0;
          if (m_valid_i) begin
            // Stall 1 cycle after each master-side completion.
            if (m_aready) begin  // Master-side completion
              m_valid_i <= 1'b0;
              m_grant_hot_i <= 0;
              any_grant <= 1'b0;
            end
          end else if (any_grant) begin
            m_valid_i <= 1'b1;
            s_ready_i <= m_grant_hot_i;  // Assert S_AW/READY for 1 cycle to complete SI address transfer
          end else begin
            if (found_prio | found_rr) begin
              m_grant_hot_i <= next_hot;
              m_grant_enc_i <= next_enc;
              any_grant <= 1'b1;
              grant_rnw <= |(rnw & next_hot);
              if (~found_prio) begin
                last_rr_hot <= next_rr_hot;
              end
            end
          end
        end
      end
    
      /////////////////////////////////////////////////////////////////////////////
      // Fixed Priority arbiter
      // Selects next request to grant from among inputs with PRIO > 0, if any.
      /////////////////////////////////////////////////////////////////////////////
      
      always @ * begin : ALG_PRIO
        integer ip;
        any_prio = 1'b0;
        which_prio_hot = 0;        
        which_prio_enc = 0;    
        current_highest = 0;    
        for (ip=0; ip < C_NUM_S; ip=ip+1) begin
          if (P_PRIO_MASK[ip] & ({1'b0, C_ARB_PRIORITY[ip*32+:4]} > current_highest)) begin
            if (s_avalid[ip]) begin
              current_highest[0+:4] = C_ARB_PRIORITY[ip*32+:4];
              any_prio = 1'b1;
              which_prio_hot = 1'b1 << ip;
              which_prio_enc = ip;
            end
          end   
        end
        found_prio = any_prio;
        next_prio_hot = which_prio_hot;
        next_prio_enc = which_prio_enc;
      end
     
      /////////////////////////////////////////////////////////////////////////////
      // Round-robin arbiter
      // Selects next request to grant from among inputs with PRIO = 0, if any.
      /////////////////////////////////////////////////////////////////////////////
      
      assign valid_rr = ~P_PRIO_MASK & s_avalid;
      
      always @ * begin : ALG_RR
        integer ir, jr, nr;
        next_rr_hot = 0;
        for (ir=0;ir<C_NUM_S;ir=ir+1) begin
          nr = (ir>0) ? (ir-1) : (C_NUM_S-1);
          carry_rr[ir*C_NUM_S] = last_rr_hot[nr];
          mask_rr[ir*C_NUM_S] = ~valid_rr[nr];
          for (jr=1;jr<C_NUM_S;jr=jr+1) begin
            nr = (ir-jr > 0) ? (ir-jr-1) : (C_NUM_S+ir-jr-1);
            carry_rr[ir*C_NUM_S+jr] = carry_rr[ir*C_NUM_S+jr-1] | (last_rr_hot[nr] & mask_rr[ir*C_NUM_S+jr-1]);
            if (jr < C_NUM_S-1) begin
              mask_rr[ir*C_NUM_S+jr] = mask_rr[ir*C_NUM_S+jr-1] & ~valid_rr[nr];
            end
          end   
          next_rr_hot[ir] = valid_rr[ir] & carry_rr[(ir+1)*C_NUM_S-1];
        end
        next_rr_enc = f_hot2enc(next_rr_hot);
        found_rr = |(next_rr_hot);
      end
  
  axi_interconnect_v1_7_13_mux_enc # 
        (
         .C_FAMILY      (C_FAMILY),
         .C_RATIO       (C_NUM_S),
         .C_SEL_WIDTH   (C_NUM_S_LOG),
         .C_DATA_WIDTH  (C_AMESG_WIDTH)
        ) si_amesg_mux_inst 
        (
         .S   (next_enc),
         .A   (s_amesg),
         .O   (amesg_mux),
         .OE  (1'b1)
        ); 
        
      always @(posedge ACLK) begin
        if (~any_grant) begin
          m_amesg_i <= amesg_mux;
        end
      end
    
    end else begin : gen_no_arbiter
      
      assign M_GRANT_ANY = m_grant_hot_i;

      always @ (posedge ACLK) begin
        if (ARESET) begin
          m_valid_i <= 1'b0;
          s_ready_i <= 1'b0;
          m_grant_enc_i <= 0;
          m_grant_hot_i <= 1'b0;
          grant_rnw <= 1'b0;
        end else begin
          s_ready_i <= 1'b0;
          if (m_valid_i) begin
            if (m_aready) begin
              m_valid_i <= 1'b0;
              m_grant_hot_i <= 1'b0;
            end
          end else if (m_grant_hot_i) begin
            m_valid_i <= 1'b1;
            s_ready_i[0] <= 1'b1;  // Assert S_AW/READY for 1 cycle to complete SI address transfer
          end else if (s_avalid[0]) begin
            m_grant_hot_i <= 1'b1;
            grant_rnw <= rnw[0];
          end
        end
      end
      
      always @ (posedge ACLK) begin
        if (~m_grant_hot_i) begin
          m_amesg_i <= s_amesg;
        end
      end
    
    end  // gen_arbiter
  endgenerate
endmodule

`default_nettype wire


// -- (c) Copyright 2009 - 2011 Xilinx, Inc. All rights reserved.
// --
// -- This file contains confidential and proprietary information
// -- of Xilinx, Inc. and is protected under U.S. and 
// -- international copyright and other intellectual property
// -- laws.
// --
// -- DISCLAIMER
// -- This disclaimer is not a license and does not grant any
// -- rights to the materials distributed herewith. Except as
// -- otherwise provided in a valid license issued to you by
// -- Xilinx, and to the maximum extent permitted by applicable
// -- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
// -- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
// -- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
// -- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
// -- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
// -- (2) Xilinx shall not be liable (whether in contract or tort,
// -- including negligence, or under any other theory of
// -- liability) for any loss or damage of any kind or nature
// -- related to, arising under or in connection with these
// -- materials, including for any direct, or any indirect,
// -- special, incidental, or consequential loss or damage
// -- (including loss of data, profits, goodwill, or any type of
// -- loss or damage suffered as a result of any action brought
// -- by a third party) even if such damage or loss was
// -- reasonably foreseeable or Xilinx had been advised of the
// -- possibility of the same.
// --
// -- CRITICAL APPLICATIONS
// -- Xilinx products are not designed or intended to be fail-
// -- safe, or for use in any application requiring fail-safe
// -- performance, such as life-support or safety devices or
// -- systems, Class III medical devices, nuclear facilities,
// -- applications related to the deployment of airbags, or any
// -- other applications that could lead to death, personal
// -- injury, or severe property or environmental damage
// -- (individually and collectively, "Critical
// -- Applications"). Customer assumes the sole risk and
// -- liability of any use of Xilinx products in Critical
// -- Applications, subject only to applicable laws and
// -- regulations governing limitations on product liability.
// --
// -- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
// -- PART OF THIS FILE AT ALL TIMES.
//-----------------------------------------------------------------------------
//
// File name: addr_arbiter.v
//
// Description: 
//   Instantiates generic priority encoder.
//   Each request is qualified if its target has not reached its issuing limit.
//   Muxes mesg and target inputs based on arbitration results.
//-----------------------------------------------------------------------------
//
// Structure:
//    addr_arbiter
//      mux_enc
//-----------------------------------------------------------------------------

`timescale 1ps/1ps
`default_nettype none

(* DowngradeIPIdentifiedWarnings="yes" *) 
module axi_interconnect_v1_7_13_addr_arbiter #
  (
   parameter integer C_MAX_S = 16,
   parameter         C_FAMILY                         = "none", 
   parameter integer C_NUM_S                = 1, 
   parameter integer C_NUM_S_LOG                = 1, 
   parameter integer C_NUM_M               = 1, 
   parameter integer C_MESG_WIDTH                 = 1, 
   parameter [C_MAX_S*32-1:0] C_ARB_PRIORITY             = {C_MAX_S{32'h00000000}}
                       // Arbitration priority among each SI slot. 
                       // Higher values indicate higher priority.
                       // Format: C_NUM_SLAVE_SLOTS{Bit32};
                       // Range: 'h0-'hF.
   )
  (
   // Global Signals
   input  wire                                      ACLK,
   input  wire                                      ARESET,
   // Slave Ports
   input  wire [C_NUM_S*C_MESG_WIDTH-1:0]  S_MESG,
   input  wire [C_NUM_S*C_NUM_M-1:0]                S_TARGET_HOT,
   input  wire [C_NUM_S-1:0]                S_VALID,
   input  wire [C_NUM_S-1:0]                S_VALID_QUAL,
   output wire [C_NUM_S-1:0]                S_READY,
   // Master Ports
   output wire [C_MESG_WIDTH-1:0]                    M_MESG,
   output wire [C_NUM_M-1:0]                           M_TARGET_HOT,
   output wire [C_NUM_S_LOG-1:0]                      M_GRANT_ENC,
   output wire                                        M_VALID,
   input  wire                                        M_READY,
   // Sideband input
   input  wire [C_NUM_M-1:0]                ISSUING_LIMIT
   );
   
  // Generates a mask for all input slots that are priority based
  function [C_NUM_S-1:0] f_prio_mask
    (
      input integer null_arg
    );
    reg   [C_NUM_S-1:0]            mask;
    integer                        i;    
    begin
      mask = 0;    
      for (i=0; i < C_NUM_S; i=i+1) begin
        mask[i] = (C_ARB_PRIORITY[i*32+:32] != 0);
      end 
      f_prio_mask = mask;
    end   
  endfunction
  
  // Convert 16-bit one-hot to 4-bit binary
  function [3:0] f_hot2enc
    (
      input [15:0]  one_hot
    );
    begin
      f_hot2enc[0] = |(one_hot & 16'b1010101010101010);
      f_hot2enc[1] = |(one_hot & 16'b1100110011001100);
      f_hot2enc[2] = |(one_hot & 16'b1111000011110000);
      f_hot2enc[3] = |(one_hot & 16'b1111111100000000);
    end
  endfunction

  // THESE SETTINGS CONTROL WHEN EXTRA HANDSHAKE PIPELINING IS INSERTED BETWEEN ADDRESS DECODER AND ARBITER
  localparam [C_NUM_S-1:0] P_PRIO_MASK = f_prio_mask(0);

  reg                     m_valid_i;
  reg [C_NUM_S-1:0]       s_ready_i;
  reg [C_NUM_S-1:0]       qual_reg;
  reg [C_NUM_S-1:0]       grant_hot; 
  reg [C_NUM_S-1:0]       last_rr_hot;
  reg                     any_grant;
  reg                     any_prio;
  reg                     found_prio;
  reg [C_NUM_S-1:0]       which_prio_hot;
  reg [C_NUM_S-1:0]       next_prio_hot;
  reg [C_NUM_S_LOG-1:0]   which_prio_enc;          
  reg [C_NUM_S_LOG-1:0]   next_prio_enc;    
  reg [4:0]               current_highest;
  wire [C_NUM_S-1:0]      valid_rr;
  reg [15:0]              next_rr_hot;
  reg [C_NUM_S_LOG-1:0]   next_rr_enc;    
  reg [C_NUM_S*C_NUM_S-1:0] carry_rr;
  reg [C_NUM_S*C_NUM_S-1:0] mask_rr;
  reg                     found_rr;
  wire [C_NUM_S-1:0]      next_hot;
  wire [C_NUM_S_LOG-1:0]  next_enc;    
  reg                     prio_stall;
  integer                 i;
  wire [C_NUM_S-1:0]      valid_qual_i;
  reg  [C_NUM_S_LOG-1:0]  m_grant_enc_i;
  reg  [C_NUM_M-1:0]      m_target_hot_i;
  wire [C_NUM_M-1:0]      m_target_hot_mux;
  reg  [C_MESG_WIDTH-1:0] m_mesg_i;
  wire [C_MESG_WIDTH-1:0] m_mesg_mux;
  genvar                  gen_si;

  assign M_VALID = m_valid_i;
  assign S_READY = s_ready_i;
  assign M_GRANT_ENC = m_grant_enc_i;
  assign M_MESG = m_mesg_i;
  assign M_TARGET_HOT = m_target_hot_i;
  
  generate
    if (C_NUM_S>1) begin : gen_arbiter
      
      always @(posedge ACLK) begin
        if (ARESET) begin
          qual_reg <= 0;
        end else begin 
          qual_reg <= valid_qual_i | ~S_VALID; // Don't disqualify when bus not VALID (valid_qual_i would be garbage)
        end
      end
    
      for (gen_si=0; gen_si<C_NUM_S; gen_si=gen_si+1) begin : gen_req_qual
        assign valid_qual_i[gen_si] = S_VALID_QUAL[gen_si] & (|(S_TARGET_HOT[gen_si*C_NUM_M+:C_NUM_M] & ~ISSUING_LIMIT));
      end
    
      /////////////////////////////////////////////////////////////////////////////
      // Grant a new request when there is none still pending.
      // If no qualified requests found, de-assert M_VALID.
      /////////////////////////////////////////////////////////////////////////////
      
      assign next_hot = found_prio ? next_prio_hot : next_rr_hot;
      assign next_enc = found_prio ? next_prio_enc : next_rr_enc;
      
      always @(posedge ACLK) begin
        if (ARESET) begin
          m_valid_i <= 0;
          s_ready_i <= 0;
          grant_hot <= 0;
          any_grant <= 1'b0;
          m_grant_enc_i <= 0;
          last_rr_hot <= {1'b1, {C_NUM_S-1{1'b0}}};
          m_target_hot_i <= 0;
        end else begin
          s_ready_i <= 0;
          if (m_valid_i) begin
            // Stall 1 cycle after each master-side completion.
            if (M_READY) begin  // Master-side completion
              m_valid_i <= 1'b0;
              grant_hot <= 0;
              any_grant <= 1'b0;
            end
          end else if (any_grant) begin
            m_valid_i <= 1'b1;
            s_ready_i <= grant_hot;  // Assert S_AW/READY for 1 cycle to complete SI address transfer (regardless of M_AREADY)
          end else begin
            if ((found_prio | found_rr) & ~prio_stall) begin
              // Waste 1 cycle and re-arbitrate if target of highest prio hit issuing limit in previous cycle (valid_qual_i).
              if (|(next_hot & valid_qual_i)) begin  
                grant_hot <= next_hot;
                m_grant_enc_i <= next_enc;
                any_grant <= 1'b1;
                if (~found_prio) begin
                  last_rr_hot <= next_rr_hot;
                end
                m_target_hot_i <= m_target_hot_mux;
              end
            end
          end
        end
      end
    
      /////////////////////////////////////////////////////////////////////////////
      // Fixed Priority arbiter
      // Selects next request to grant from among inputs with PRIO > 0, if any.
      /////////////////////////////////////////////////////////////////////////////
          
      always @ * begin : ALG_PRIO
        integer ip;
        any_prio = 1'b0;
        prio_stall = 1'b0;
        which_prio_hot = 0;        
        which_prio_enc = 0;    
        current_highest = 0;    
        for (ip=0; ip < C_NUM_S; ip=ip+1) begin
          // Disqualify slot if target hit issuing limit (pass to lower prio slot).
          if (P_PRIO_MASK[ip] & S_VALID[ip] & qual_reg[ip]) begin
            if ({1'b0, C_ARB_PRIORITY[ip*32+:4]} > current_highest) begin
              current_highest[0+:4] = C_ARB_PRIORITY[ip*32+:4];
              // Stall 1 cycle when highest prio is recovering from SI-side handshake.
              // (Do not allow lower-prio slot to win arbitration.)
              if (s_ready_i[ip]) begin
                any_prio = 1'b0;
                prio_stall = 1'b1;
                which_prio_hot = 0;
                which_prio_enc = 0;
              end else begin
                any_prio = 1'b1;
                which_prio_hot = 1'b1 << ip;
                which_prio_enc = ip;
              end
            end
          end   
        end
        found_prio = any_prio;
        next_prio_hot = which_prio_hot;
        next_prio_enc = which_prio_enc;
      end
     
      /////////////////////////////////////////////////////////////////////////////
      // Round-robin arbiter
      // Selects next request to grant from among inputs with PRIO = 0, if any.
      /////////////////////////////////////////////////////////////////////////////
      
      // Disqualify slot if target hit issuing limit 2 or more cycles earlier (pass to next RR slot).
      // Disqualify for 1 cycle a slot that is recovering from SI-side handshake (s_ready_i),
      //   and allow arbitration to pass to any other RR requester.
      assign valid_rr = ~P_PRIO_MASK & S_VALID & ~s_ready_i & qual_reg;
      
      always @ * begin : ALG_RR
        integer ir, jr, nr;
        next_rr_hot = 0;
        for (ir=0;ir<C_NUM_S;ir=ir+1) begin
          nr = (ir>0) ? (ir-1) : (C_NUM_S-1);
          carry_rr[ir*C_NUM_S] = last_rr_hot[nr];
          mask_rr[ir*C_NUM_S] = ~valid_rr[nr];
          for (jr=1;jr<C_NUM_S;jr=jr+1) begin
            nr = (ir-jr > 0) ? (ir-jr-1) : (C_NUM_S+ir-jr-1);
            carry_rr[ir*C_NUM_S+jr] = carry_rr[ir*C_NUM_S+jr-1] | (last_rr_hot[nr] & mask_rr[ir*C_NUM_S+jr-1]);
            if (jr < C_NUM_S-1) begin
              mask_rr[ir*C_NUM_S+jr] = mask_rr[ir*C_NUM_S+jr-1] & ~valid_rr[nr];
            end
          end   
          next_rr_hot[ir] = valid_rr[ir] & carry_rr[(ir+1)*C_NUM_S-1];
        end
        next_rr_enc = f_hot2enc(next_rr_hot);
        found_rr = |(next_rr_hot);
      end
  
  axi_interconnect_v1_7_13_mux_enc # 
        (
         .C_FAMILY      (C_FAMILY),
         .C_RATIO       (C_NUM_S),
         .C_SEL_WIDTH   (C_NUM_S_LOG),
         .C_DATA_WIDTH  (C_MESG_WIDTH)
        ) mux_mesg 
        (
         .S   (m_grant_enc_i),
         .A   (S_MESG),
         .O   (m_mesg_mux),
         .OE  (1'b1)
        ); 
        
  axi_interconnect_v1_7_13_mux_enc # 
        (
         .C_FAMILY      (C_FAMILY),
         .C_RATIO       (C_NUM_S),
         .C_SEL_WIDTH   (C_NUM_S_LOG),
         .C_DATA_WIDTH  (C_NUM_M)
        ) si_amesg_mux_inst 
        (
         .S   (next_enc),
         .A   (S_TARGET_HOT),
         .O   (m_target_hot_mux),
         .OE  (1'b1)
        ); 
        
      always @(posedge ACLK) begin
        if (~m_valid_i) begin
          m_mesg_i <= m_mesg_mux;
        end
      end
    
    end else begin : gen_no_arbiter
      
      assign valid_qual_i = S_VALID_QUAL & |(S_TARGET_HOT & ~ISSUING_LIMIT);
      
      always @ (posedge ACLK) begin
        if (ARESET) begin
          m_valid_i <= 1'b0;
          s_ready_i <= 1'b0;
          m_grant_enc_i <= 0;
        end else begin
          s_ready_i <= 1'b0;
          if (m_valid_i) begin
            if (M_READY) begin
              m_valid_i <= 1'b0;
            end
          end else if (S_VALID[0] & valid_qual_i[0] & ~s_ready_i) begin
            m_valid_i <= 1'b1;
            s_ready_i <= 1'b1;
            m_target_hot_i <= S_TARGET_HOT;
          end
        end
      end
      always @(posedge ACLK) begin
        if (~m_valid_i) begin
          m_mesg_i <= S_MESG;
        end
      end
      
      
    end  // gen_arbiter
  endgenerate
endmodule

`default_nettype wire


// -- (c) Copyright 2010 - 2011 Xilinx, Inc. All rights reserved.
// --
// -- This file contains confidential and proprietary information
// -- of Xilinx, Inc. and is protected under U.S. and 
// -- international copyright and other intellectual property
// -- laws.
// --
// -- DISCLAIMER
// -- This disclaimer is not a license and does not grant any
// -- rights to the materials distributed herewith. Except as
// -- otherwise provided in a valid license issued to you by
// -- Xilinx, and to the maximum extent permitted by applicable
// -- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
// -- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
// -- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
// -- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
// -- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
// -- (2) Xilinx shall not be liable (whether in contract or tort,
// -- including negligence, or under any other theory of
// -- liability) for any loss or damage of any kind or nature
// -- related to, arising under or in connection with these
// -- materials, including for any direct, or any indirect,
// -- special, incidental, or consequential loss or damage
// -- (including loss of data, profits, goodwill, or any type of
// -- loss or damage suffered as a result of any action brought
// -- by a third party) even if such damage or loss was
// -- reasonably foreseeable or Xilinx had been advised of the
// -- possibility of the same.
// --
// -- CRITICAL APPLICATIONS
// -- Xilinx products are not designed or intended to be fail-
// -- safe, or for use in any application requiring fail-safe
// -- performance, such as life-support or safety devices or
// -- systems, Class III medical devices, nuclear facilities,
// -- applications related to the deployment of airbags, or any
// -- other applications that could lead to death, personal
// -- injury, or severe property or environmental damage
// -- (individually and collectively, "Critical
// -- Applications"). Customer assumes the sole risk and
// -- liability of any use of Xilinx products in Critical
// -- Applications, subject only to applicable laws and
// -- regulations governing limitations on product liability.
// --
// -- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
// -- PART OF THIS FILE AT ALL TIMES.
//-----------------------------------------------------------------------------
//
// Description: Addr Decoder
// Each received address is compared to base and high address pairs for each 
//   of a set of decode targets. 
// The matching target's index (if any) is output combinatorially.
// If the decode is successful (matches any target), the MATCH output is asserted.
// For each target, a set of alternative address ranges may be specified.
// The base and high address pairs are formatted as a pair of 2-dimensional arrays,
//   alternative address ranges iterate within each target.
// The alternative range which matches the address is also output as REGION.
//
// Verilog-standard:  Verilog 2001
//--------------------------------------------------------------------------
//
// Structure:
//   addr_decoder
//      comparator_static
//
//--------------------------------------------------------------------------
`timescale 1ps/1ps

(* DowngradeIPIdentifiedWarnings="yes" *) 
module axi_interconnect_v1_7_13_addr_decoder #
  (
   parameter integer C_MAX_M = 16,
   parameter         C_FAMILY          = "none",
   parameter integer C_NUM_TARGETS     = 2,  // Number of decode targets = [1:16]
   parameter integer C_NUM_TARGETS_LOG = 1,  // Log2(C_NUM_TARGETS)
   parameter integer C_NUM_RANGES      = 16, // Number of alternative ranges that
                                             //    can match each target [1:16]
   parameter integer C_ADDR_WIDTH      = 32, // Width of decoder operand and of
                                             //   each base and high address [2:64]
   parameter integer C_TARGET_ENC      = 0,  // Enable encoded target output
   parameter integer C_TARGET_HOT      = 1,  // Enable 1-hot target output
   parameter integer C_REGION_ENC      = 0,   // Enable REGION output
   parameter [C_MAX_M*C_NUM_RANGES*64-1:0] C_BASE_ADDR                 = {C_MAX_M*C_NUM_RANGES{64'hFFFFFFFF_FFFFFFFF}}, 
                       // Base address of each range of each MI slot. 
                       // For unused ranges, set base address to 'hFFFFFFFF.
                       // Format: C_NUM_MASTER_SLOTS{C_NUM_RANGES{Bit64}}.
   parameter [C_MAX_M*C_NUM_RANGES*64-1:0] C_HIGH_ADDR                 = {C_MAX_M*C_NUM_RANGES{64'h00000000_00000000}}, 
                       // High address of each range of each MI slot. 
                       // For unused ranges, set high address to 'h00000000.
                       // Format: C_NUM_MASTER_SLOTS{C_NUM_RANGES{Bit64}}.
   parameter [31:0]    C_TARGET_QUAL                 = 32'hFFFFFFFF,
                       // Indicates whether each target has connectivity.
                       // Format: C_NUM_TARGETS{Bit1}.
   parameter integer   C_RESOLUTION                 = 0,
                       // Number of low-order ADDR bits that can be ignored when decoding.
   parameter integer   C_COMPARATOR_THRESHOLD       = 6
                       // Number of decoded ADDR bits above which will implement comparator_static.
   )
  (
   input  wire [C_ADDR_WIDTH-1:0]      ADDR,        // Decoder input operand
   output wire [C_NUM_TARGETS-1:0]     TARGET_HOT,  // Target matching address (1-hot)
   output wire [C_NUM_TARGETS_LOG-1:0] TARGET_ENC,  // Target matching address (encoded)
   output wire                         MATCH,       // Decode successful
   output wire [3:0]                   REGION      // Range within target matching address (encoded)
   );
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Variables for generating parameter controlled instances.
  genvar target_cnt;
  genvar region_cnt;
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Function to detect addrs is in the addressable range.
  // Only compare 4KB page address (ignore low-order 12 bits)
  function  decode_address;
    input [C_ADDR_WIDTH-1:0] base, high, addr;
    reg   [C_ADDR_WIDTH-C_RESOLUTION-1:0] mask;
    reg   [C_ADDR_WIDTH-C_RESOLUTION-1:0] addr_page;
    reg   [C_ADDR_WIDTH-C_RESOLUTION-1:0] base_page;
    reg   [C_ADDR_WIDTH-C_RESOLUTION-1:0] high_page;
  begin
    addr_page = addr[C_RESOLUTION+:C_ADDR_WIDTH-C_RESOLUTION];
    base_page = base[C_RESOLUTION+:C_ADDR_WIDTH-C_RESOLUTION];
    high_page = high[C_RESOLUTION+:C_ADDR_WIDTH-C_RESOLUTION];
    if (base[C_ADDR_WIDTH-1] & ~high[C_ADDR_WIDTH-1]) begin
      decode_address = 1'b0;
    end else begin
      mask  = base_page ^ high_page;
      if ( (base_page & ~mask) == (addr_page & ~mask) ) begin
        decode_address = 1'b1;
      end else begin
        decode_address = 1'b0;
      end
    end
  end
  endfunction
  
  // Generates a binary coded from onehotone encoded
  function [3:0] f_hot2enc
    (
      input [15:0]  one_hot
    );
    begin
      f_hot2enc[0] = |(one_hot & 16'b1010101010101010);
      f_hot2enc[1] = |(one_hot & 16'b1100110011001100);
      f_hot2enc[2] = |(one_hot & 16'b1111000011110000);
      f_hot2enc[3] = |(one_hot & 16'b1111111100000000);
    end
  endfunction

  /////////////////////////////////////////////////////////////////////////////
  // Internal signals
  wire [C_NUM_TARGETS-1:0]              TARGET_HOT_I;     // Target matching address (1-hot).
  wire [C_NUM_TARGETS*C_NUM_RANGES-1:0] ADDRESS_HIT;      // For address hit (1-hot).
  wire [C_NUM_TARGETS*C_NUM_RANGES-1:0] ADDRESS_HIT_REG;  // For address hit (1-hot).
  wire [C_NUM_RANGES-1:0]               REGION_HOT;       // Reginon matching address (1-hot).
  wire [3:0]                            TARGET_ENC_I;     // Internal version of encoded hit. 
  /////////////////////////////////////////////////////////////////////////////
  // Generate detection per region per target.
  generate
    for (target_cnt = 0; target_cnt < C_NUM_TARGETS; target_cnt = target_cnt + 1) begin : gen_target
      for (region_cnt = 0; region_cnt < C_NUM_RANGES; region_cnt = region_cnt + 1) begin : gen_region
        // Detect if this is an address hit (including used region decoding).
        if ((C_ADDR_WIDTH - C_RESOLUTION) > C_COMPARATOR_THRESHOLD) begin : gen_comparator_static
          if (C_TARGET_QUAL[target_cnt] &&
              ((C_BASE_ADDR[(target_cnt*C_NUM_RANGES+region_cnt)*64 +: C_ADDR_WIDTH] == 0) ||
               (C_HIGH_ADDR[(target_cnt*C_NUM_RANGES+region_cnt)*64 +: C_ADDR_WIDTH] != 0))) begin : gen_addr_range
  axi_interconnect_v1_7_13_comparator_static #
            (
            .C_FAMILY(C_FAMILY),
            .C_VALUE(C_BASE_ADDR[(target_cnt*C_NUM_RANGES+region_cnt)*64+C_RESOLUTION +: C_ADDR_WIDTH-C_RESOLUTION]),
            .C_DATA_WIDTH(C_ADDR_WIDTH-C_RESOLUTION)
            ) addr_decode_comparator
            (
            .CIN(1'b1),
            .A(ADDR[C_RESOLUTION +: C_ADDR_WIDTH-C_RESOLUTION] &
              ~(C_BASE_ADDR[(target_cnt*C_NUM_RANGES+region_cnt)*64+C_RESOLUTION +: C_ADDR_WIDTH-C_RESOLUTION] ^
                C_HIGH_ADDR[(target_cnt*C_NUM_RANGES+region_cnt)*64+C_RESOLUTION +: C_ADDR_WIDTH-C_RESOLUTION])),
            .COUT(ADDRESS_HIT[target_cnt*C_NUM_RANGES + region_cnt])
            );
          end else begin : gen_null_range
            assign ADDRESS_HIT[target_cnt*C_NUM_RANGES + region_cnt] = 1'b0;
          end
        end else begin : gen_no_comparator_static
          assign ADDRESS_HIT[target_cnt*C_NUM_RANGES + region_cnt] = C_TARGET_QUAL[target_cnt] ? 
                                    decode_address(
                                      C_BASE_ADDR[(target_cnt*C_NUM_RANGES+region_cnt)*64 +: C_ADDR_WIDTH],
                                      C_HIGH_ADDR[(target_cnt*C_NUM_RANGES+region_cnt)*64 +: C_ADDR_WIDTH],
                                      ADDR)
                                    : 1'b0;
        end  // gen_comparator_static
        assign ADDRESS_HIT_REG[region_cnt*C_NUM_TARGETS+target_cnt] = ADDRESS_HIT[target_cnt*C_NUM_RANGES + region_cnt];
      end  // gen_region
      
      // All regions are non-overlapping
      // => Or all the region detections for this target to determine if it is a hit.
      assign TARGET_HOT_I[target_cnt]  = | ADDRESS_HIT[target_cnt*C_NUM_RANGES +: C_NUM_RANGES];
    end  // gen_target
    
    for (region_cnt = 0; region_cnt < C_NUM_RANGES; region_cnt = region_cnt + 1) begin : gen_region_or
      assign REGION_HOT[region_cnt] = | ADDRESS_HIT_REG[region_cnt*C_NUM_TARGETS +: C_NUM_TARGETS];
    end  // gen_region_or
  endgenerate
  
  
  /////////////////////////////////////////////////////////////////////////////
  // All regions are non-overlapping
  // => Or all the target hit detections if it is a match.
  assign MATCH = | TARGET_HOT_I;
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Assign conditional onehot target output signal.
  generate
    if (C_TARGET_HOT == 1) begin : USE_TARGET_ONEHOT
      assign TARGET_HOT = MATCH ? TARGET_HOT_I : 1;
    end else begin : NO_TARGET_ONEHOT
      assign TARGET_HOT = {C_NUM_TARGETS{1'b0}};
    end
  endgenerate
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Assign conditional encoded target output signal.
  generate
    if (C_TARGET_ENC == 1) begin : USE_TARGET_ENCODED
      assign TARGET_ENC_I = f_hot2enc(TARGET_HOT_I);
      assign TARGET_ENC   = TARGET_ENC_I[C_NUM_TARGETS_LOG-1:0];
    end else begin : NO_TARGET_ENCODED
      assign TARGET_ENC = {C_NUM_TARGETS_LOG{1'b0}};
    end
  endgenerate
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Assign conditional encoded region output signal.
  generate
    if (C_TARGET_ENC == 1) begin : USE_REGION_ENCODED
      assign REGION = f_hot2enc(REGION_HOT);
    end else begin : NO_REGION_ENCODED
      assign REGION = 4'b0;
    end
  endgenerate
  
  
endmodule


// -- (c) Copyright 2010 - 2011 Xilinx, Inc. All rights reserved.
// --
// -- This file contains confidential and proprietary information
// -- of Xilinx, Inc. and is protected under U.S. and 
// -- international copyright and other intellectual property
// -- laws.
// --
// -- DISCLAIMER
// -- This disclaimer is not a license and does not grant any
// -- rights to the materials distributed herewith. Except as
// -- otherwise provided in a valid license issued to you by
// -- Xilinx, and to the maximum extent permitted by applicable
// -- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
// -- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
// -- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
// -- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
// -- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
// -- (2) Xilinx shall not be liable (whether in contract or tort,
// -- including negligence, or under any other theory of
// -- liability) for any loss or damage of any kind or nature
// -- related to, arising under or in connection with these
// -- materials, including for any direct, or any indirect,
// -- special, incidental, or consequential loss or damage
// -- (including loss of data, profits, goodwill, or any type of
// -- loss or damage suffered as a result of any action brought
// -- by a third party) even if such damage or loss was
// -- reasonably foreseeable or Xilinx had been advised of the
// -- possibility of the same.
// --
// -- CRITICAL APPLICATIONS
// -- Xilinx products are not designed or intended to be fail-
// -- safe, or for use in any application requiring fail-safe
// -- performance, such as life-support or safety devices or
// -- systems, Class III medical devices, nuclear facilities,
// -- applications related to the deployment of airbags, or any
// -- other applications that could lead to death, personal
// -- injury, or severe property or environmental damage
// -- (individually and collectively, "Critical
// -- Applications"). Customer assumes the sole risk and
// -- liability of any use of Xilinx products in Critical
// -- Applications, subject only to applicable laws and
// -- regulations governing limitations on product liability.
// --
// -- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
// -- PART OF THIS FILE AT ALL TIMES.
//-----------------------------------------------------------------------------
//
// Description: Address Down-Sizer
//
//
// Verilog-standard:  Verilog 2001
//--------------------------------------------------------------------------
//
// Structure:
//   a_downsizer
//     axic_fifo
//       fifo_gen
//         fifo_coregen
//
//--------------------------------------------------------------------------
`timescale 1ps/1ps

(* DowngradeIPIdentifiedWarnings="yes" *) 
module axi_interconnect_v1_7_13_a_downsizer #
  (
   parameter         C_FAMILY                         = "none", 
                       // FPGA Family. Current version: virtex6 or spartan6.
   parameter integer C_AXI_ID_WIDTH                   = 4, 
                       // Width of all ID signals on SI and MI side of converter.
                       // Range: >= 1.
   parameter integer C_AXI_ADDR_WIDTH                 = 32, 
                       // Width of all ADDR signals on SI and MI side of converter.
                       // Range: 32.
   parameter         C_S_AXI_DATA_WIDTH               = 32'h00000020,
                       // Width of S_AXI_WDATA and S_AXI_RDATA.
                       // Format: Bit32;
                       // Range: 'h00000040, 'h00000080, 'h00000100.
   parameter         C_M_AXI_DATA_WIDTH               = 32'h00000020, 
                       // Width of M_AXI_WDATA and M_AXI_RDATA. 
                       // Assume always smaller than C_S_AXI_DATA_WIDTH.
                       // Format: Bit32; 
                       // Range: 'h00000020, 'h00000040, 'h00000080.
   parameter integer C_AXI_SUPPORTS_USER_SIGNALS      = 0,
                       // 1 = Propagate all USER signals, 0 = Dont propagate.
   parameter integer C_AXI_AUSER_WIDTH                = 1,
                       // Width of AWUSER signals. 
                       // Range: >= 1.
   parameter integer C_AXI_CHANNEL                    = 0,
                       // 0 = AXI AW Channel.
                       // 1 = AXI AR Channel.
   parameter integer C_SUPPORT_SPLITTING              = 1,
                       // Implement transaction splitting logic.
   parameter integer C_SUPPORT_BURSTS                 = 1,
                       // Disabled when all connected slaves and masters are AxiLite,
                       //   allowing logic to be simplified.
   parameter integer C_SINGLE_THREAD                  = 1,
                       // Allow multiple outstanding transactions only if the IDs are the same.
   parameter integer C_S_AXI_BYTES_LOG                = 3,
                       // Log2 of number of 32bit word on SI-side.
   parameter integer C_M_AXI_BYTES_LOG                = 2,
                       // Log2 of number of 32bit word on MI-side.
   parameter integer C_RATIO_LOG                      = 1
                       // Log2 of Up-Sizing ratio for data.
   )
  (
   // Global Signals
   input  wire                                                    ARESET,
   input  wire                                                    ACLK,

   // Command Interface (W/R)
   output wire                              cmd_valid,
   output wire                              cmd_split,
   output wire                              cmd_mirror,
   output wire                              cmd_fix,
   output wire [C_S_AXI_BYTES_LOG-1:0]      cmd_first_word, 
   output wire [C_S_AXI_BYTES_LOG-1:0]      cmd_offset,
   output wire [C_S_AXI_BYTES_LOG-1:0]      cmd_mask,
   output wire [C_M_AXI_BYTES_LOG:0]        cmd_step,
   output wire [3-1:0]                      cmd_size,
   output wire [8-1:0]                      cmd_length,
   input  wire                              cmd_ready,
   
   // Command Interface (B)
   output wire                              cmd_b_valid,
   output wire                              cmd_b_split,
   output wire [4-1:0]                      cmd_b_repeat,
   input  wire                              cmd_b_ready,
   
   // Slave Interface Write Address Ports
   input  wire [C_AXI_ID_WIDTH-1:0]          S_AXI_AID,
   input  wire [C_AXI_ADDR_WIDTH-1:0]          S_AXI_AADDR,
   input  wire [8-1:0]                         S_AXI_ALEN,
   input  wire [3-1:0]                         S_AXI_ASIZE,
   input  wire [2-1:0]                         S_AXI_ABURST,
   input  wire [2-1:0]                         S_AXI_ALOCK,
   input  wire [4-1:0]                         S_AXI_ACACHE,
   input  wire [3-1:0]                         S_AXI_APROT,
   input  wire [4-1:0]                         S_AXI_AREGION,
   input  wire [4-1:0]                         S_AXI_AQOS,
   input  wire [C_AXI_AUSER_WIDTH-1:0]         S_AXI_AUSER,
   input  wire                                                   S_AXI_AVALID,
   output wire                                                   S_AXI_AREADY,

   // Master Interface Write Address Port
   output wire [C_AXI_ID_WIDTH-1:0]            M_AXI_AID,
   output wire [C_AXI_ADDR_WIDTH-1:0]          M_AXI_AADDR,
   output wire [8-1:0]                         M_AXI_ALEN,
   output wire [3-1:0]                         M_AXI_ASIZE,
   output wire [2-1:0]                         M_AXI_ABURST,
   output wire [2-1:0]                         M_AXI_ALOCK,
   output wire [4-1:0]                         M_AXI_ACACHE,
   output wire [3-1:0]                         M_AXI_APROT,
   output wire [4-1:0]                         M_AXI_AREGION,
   output wire [4-1:0]                         M_AXI_AQOS,
   output wire [C_AXI_AUSER_WIDTH-1:0]         M_AXI_AUSER,
   output wire                                                   M_AXI_AVALID,
   input  wire                                                   M_AXI_AREADY
   );

   
  /////////////////////////////////////////////////////////////////////////////
  // Variables for generating parameter controlled instances.
  /////////////////////////////////////////////////////////////////////////////
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Local params
  /////////////////////////////////////////////////////////////////////////////
  
  // Decode the native transaction size on the SI-side interface.
  localparam [3-1:0] C_S_AXI_NATIVE_SIZE = (C_S_AXI_DATA_WIDTH == 1024) ? 3'b111 :
                                           (C_S_AXI_DATA_WIDTH ==  512) ? 3'b110 :
                                           (C_S_AXI_DATA_WIDTH ==  256) ? 3'b101 :
                                           (C_S_AXI_DATA_WIDTH ==  128) ? 3'b100 :
                                           (C_S_AXI_DATA_WIDTH ==   64) ? 3'b011 :
                                           (C_S_AXI_DATA_WIDTH ==   32) ? 3'b010 :
                                           (C_S_AXI_DATA_WIDTH ==   16) ? 3'b001 :
                                           3'b000;
  
  // Decode the native transaction size on the MI-side interface.
  localparam [3-1:0] C_M_AXI_NATIVE_SIZE = (C_M_AXI_DATA_WIDTH == 1024) ? 3'b111 :
                                           (C_M_AXI_DATA_WIDTH ==  512) ? 3'b110 :
                                           (C_M_AXI_DATA_WIDTH ==  256) ? 3'b101 :
                                           (C_M_AXI_DATA_WIDTH ==  128) ? 3'b100 :
                                           (C_M_AXI_DATA_WIDTH ==   64) ? 3'b011 :
                                           (C_M_AXI_DATA_WIDTH ==   32) ? 3'b010 :
                                           (C_M_AXI_DATA_WIDTH ==   16) ? 3'b001 :
                                           3'b000;
  
  // Help constant to generate mask signals.
  localparam [C_AXI_ADDR_WIDTH+8-1:0]      C_DOUBLE_LEN = {{C_AXI_ADDR_WIDTH{1'b0}}, 8'b1111_1111};
  
  // Constants for burst types.
  localparam [2-1:0] C_FIX_BURST         = 2'b00;
  localparam [2-1:0] C_INCR_BURST        = 2'b01;
  localparam [2-1:0] C_WRAP_BURST        = 2'b10;
  
  // Depth for command FIFO.
  localparam integer C_FIFO_DEPTH_LOG    = 5;
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Functions
  /////////////////////////////////////////////////////////////////////////////
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Internal signals
  /////////////////////////////////////////////////////////////////////////////
  
  // Access decoding related signals.
  wire                                access_is_fix;
  wire                                access_is_incr;
  wire                                access_is_wrap;
  wire [C_AXI_ADDR_WIDTH+16-1:0]      alen_help_vector;
  reg  [C_S_AXI_BYTES_LOG-1:0]        size_mask;
  reg  [C_AXI_ADDR_WIDTH-1:0]         split_addr_mask;
  reg  [C_S_AXI_BYTES_LOG+8-1:0]      full_downsized_len;
  wire [8-1:0]                        downsized_len;
  reg                                 legal_wrap_len;
  reg  [8-1:0]                        fix_len;
  reg  [8-1:0]                        unalignment_addr;
  reg  [C_AXI_ADDR_WIDTH-1:0]         burst_mask;
  wire [C_AXI_ADDR_WIDTH-1:0]         masked_addr;
  wire [C_AXI_ADDR_WIDTH-1:0]         burst_unalignment;
  wire [8-1:0]                        wrap_unaligned_len;
  reg  [8-1:0]                        wrap_rest_len;
  wire [C_S_AXI_BYTES_LOG-1:0]        num_transactions;
  wire                                access_fit_mi_side;
  wire                                si_full_size;
  wire                                fix_need_to_split;
  wire                                incr_need_to_split;
  wire                                wrap_need_to_split;
  wire [C_AXI_ADDR_WIDTH-1:0]         pre_mi_addr;
  reg  [C_AXI_ADDR_WIDTH-1:0]         next_mi_addr;
  reg                                 split_ongoing;
  reg  [4-1:0]                        pushed_commands;
  wire                                need_to_split;
  
  // Access decoding related signals for internal pipestage.
  reg                                 access_is_fix_q;
  reg                                 access_is_incr_q;
  reg                                 access_is_wrap_q;
  reg                                 access_fit_mi_side_q;
  reg                                 legal_wrap_len_q;
  reg                                 si_full_size_q;
  reg                                 fix_need_to_split_q;
  reg                                 incr_need_to_split_q;
  reg                                 wrap_need_to_split_q;
  wire                                need_to_split_q;
  reg  [C_AXI_ADDR_WIDTH-1:0]         split_addr_mask_q;
  reg  [C_S_AXI_BYTES_LOG-1:0]        num_transactions_q;
  reg  [8-1:0]                        wrap_unaligned_len_q;
  reg  [C_S_AXI_BYTES_LOG-1:0]        size_mask_q;
  reg  [8-1:0]                        downsized_len_q;
  reg  [8-1:0]                        fix_len_q;
  reg  [8-1:0]                        unalignment_addr_q;
  reg  [C_AXI_ADDR_WIDTH-1:0]         masked_addr_q;
  
  // Command buffer help signals.
  reg  [C_FIFO_DEPTH_LOG:0]           cmd_depth;
  reg                                 cmd_empty;
  reg  [C_AXI_ID_WIDTH-1:0]           queue_id;
  wire                                id_match;
  wire                                cmd_id_check;
  wire                                cmd_id_check_empty;
  wire                                s_ready;
  wire                                cmd_full;
  wire                                allow_new_cmd;
  wire                                cmd_push;
  reg                                 cmd_push_block;
  reg  [C_FIFO_DEPTH_LOG:0]           cmd_b_depth;
  reg                                 cmd_b_empty_i;
  wire                                cmd_b_empty;
  wire                                cmd_b_full;
  wire                                cmd_b_push;
  reg                                 cmd_b_push_block;
  wire                                pushed_new_cmd;
  wire                                last_fix_split;
  wire                                last_incr_split;
  wire                                last_wrap_split;
  wire                                last_split;
  
  // Internal Command Interface signals (W/R).
  wire                                cmd_valid_i;
  wire                                cmd_fix_i;
  wire                                cmd_split_i;
  wire                                cmd_mirror_i;
  reg  [C_S_AXI_BYTES_LOG-1:0]        cmd_first_word_ii;
  wire [C_S_AXI_BYTES_LOG-1:0]        cmd_first_word_i;
  wire [C_S_AXI_BYTES_LOG-1:0]        cmd_offset_i;
  reg  [C_S_AXI_BYTES_LOG-1:0]        cmd_mask_i;
  reg  [C_S_AXI_BYTES_LOG-1:0]        cmd_mask_q;
  reg  [3-1:0]                        cmd_size_i;
  wire [3-1:0]                        cmd_size_ii;
  reg  [7-1:0]                        cmd_step_i;
  wire [8-1:0]                        cmd_length_i;
  reg  [8-1:0]                        base_len;
  reg  [8-1:0]                        compensation_len;
  
  // Internal Command Interface signals (B).
  wire                                cmd_b_split_i;
  reg  [4-1:0]                        cmd_b_repeat_i;
  
  // Throttling help signals.
  wire                                mi_stalling;
  reg                                 command_ongoing;
   
  // Internal SI-side signals.
  reg  [C_AXI_ID_WIDTH-1:0]           S_AXI_AID_Q;
  reg  [C_AXI_ADDR_WIDTH-1:0]         S_AXI_AADDR_Q;
  reg  [8-1:0]                        S_AXI_ALEN_Q;
  reg  [3-1:0]                        S_AXI_ASIZE_Q;
  reg  [2-1:0]                        S_AXI_ABURST_Q;
  reg  [2-1:0]                        S_AXI_ALOCK_Q;
  reg  [4-1:0]                        S_AXI_ACACHE_Q;
  reg  [3-1:0]                        S_AXI_APROT_Q;
  reg  [4-1:0]                        S_AXI_AREGION_Q;
  reg  [4-1:0]                        S_AXI_AQOS_Q;
  reg  [C_AXI_AUSER_WIDTH-1:0]        S_AXI_AUSER_Q;
  reg                                 S_AXI_AREADY_I;
  
  // Internal MI-side signals.
  wire [C_AXI_ID_WIDTH-1:0]           M_AXI_AID_I;
  reg  [C_AXI_ADDR_WIDTH-1:0]         M_AXI_AADDR_I;
  wire [8-1:0]                        M_AXI_ALEN_I;
  reg  [3-1:0]                        M_AXI_ASIZE_I;
  reg  [2-1:0]                        M_AXI_ABURST_I;
  reg  [2-1:0]                        M_AXI_ALOCK_I;
  wire [4-1:0]                        M_AXI_ACACHE_I;
  wire [3-1:0]                        M_AXI_APROT_I;
  wire [4-1:0]                        M_AXI_AREGION_I;
  wire [4-1:0]                        M_AXI_AQOS_I;
  wire [C_AXI_AUSER_WIDTH-1:0]        M_AXI_AUSER_I;
  wire                                M_AXI_AVALID_I;
  wire                                M_AXI_AREADY_I;
  
  reg [1:0] areset_d; // Reset delay register
  always @(posedge ACLK) begin
    areset_d <= {areset_d[0], ARESET};
  end
  
  /////////////////////////////////////////////////////////////////////////////
  // Capture SI-Side signals.
  //
  /////////////////////////////////////////////////////////////////////////////
  
  // Register SI-Side signals.
  always @ (posedge ACLK) begin
    if ( S_AXI_AREADY_I ) begin
      S_AXI_AID_Q     <= S_AXI_AID;
      S_AXI_AADDR_Q   <= S_AXI_AADDR;
      S_AXI_ALEN_Q    <= S_AXI_ALEN;
      S_AXI_ASIZE_Q   <= S_AXI_ASIZE;
      S_AXI_ABURST_Q  <= S_AXI_ABURST;
      S_AXI_ALOCK_Q   <= S_AXI_ALOCK;
      S_AXI_ACACHE_Q  <= S_AXI_ACACHE;
      S_AXI_APROT_Q   <= S_AXI_APROT;
      S_AXI_AREGION_Q <= S_AXI_AREGION;
      S_AXI_AQOS_Q    <= S_AXI_AQOS;
      S_AXI_AUSER_Q   <= S_AXI_AUSER;
    end
  end
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Transfer SI-Side signals to internal Pipeline Stage.
  //
  /////////////////////////////////////////////////////////////////////////////
  always @ (posedge ACLK) begin
    if ( ARESET ) begin
      access_is_fix_q       <= 1'b0;
      access_is_incr_q      <= 1'b0;
      access_is_wrap_q      <= 1'b0;
      access_fit_mi_side_q  <= 1'b0;
      legal_wrap_len_q      <= 1'b0;
      si_full_size_q        <= 1'b0;
      fix_need_to_split_q   <= 1'b0;
      incr_need_to_split_q  <= 1'b0;
      wrap_need_to_split_q  <= 1'b0;
      split_addr_mask_q     <= {C_AXI_ADDR_WIDTH{1'b0}};
      num_transactions_q    <= {C_S_AXI_BYTES_LOG{1'b0}};
      wrap_unaligned_len_q  <= 8'b0;
      cmd_mask_q            <= {C_S_AXI_BYTES_LOG{1'b0}};
      size_mask_q           <= {C_S_AXI_BYTES_LOG{1'b0}};
      downsized_len_q       <= 8'b0;
      fix_len_q             <= 8'b0;
      unalignment_addr_q    <= 8'b0;
      masked_addr_q         <= {C_AXI_ADDR_WIDTH{1'b0}};
    end else begin
      if ( S_AXI_AREADY_I ) begin
        access_is_fix_q       <= access_is_fix;
        access_is_incr_q      <= access_is_incr;
        access_is_wrap_q      <= access_is_wrap;
        access_fit_mi_side_q  <= access_fit_mi_side;
        legal_wrap_len_q      <= legal_wrap_len;
        si_full_size_q        <= si_full_size;
        fix_need_to_split_q   <= fix_need_to_split;
        incr_need_to_split_q  <= incr_need_to_split;
        wrap_need_to_split_q  <= wrap_need_to_split;
        split_addr_mask_q     <= split_addr_mask;
        num_transactions_q    <= num_transactions;
        wrap_unaligned_len_q  <= wrap_unaligned_len;
        cmd_mask_q            <= cmd_mask_i;
        size_mask_q           <= size_mask;
        downsized_len_q       <= downsized_len;
        fix_len_q             <= fix_len;
        unalignment_addr_q    <= unalignment_addr;
        masked_addr_q         <= masked_addr;
      end
    end
  end
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Decode the Incoming Transaction.
  // 
  // Decode transaction type and various mask and length data.
  // 
  // Generate mask for address bits that are used unused on SI-side to remove
  // sub transaction size unalignment from data multiplex control signals.
  // 
  // Generate mask to keep addressbit between SI-side width and width of 
  // current transaction, i.e. when SI-side > AxSIZE > MI-side. Mask is used 
  // to make sure that split INCR transactions are continued at the correct 
  // offset after split.
  // 
  // Generate mask for subsize WRAP that fit in MI-Side to make sure offset and
  // sub-size wrap position is correct. For example 8-bit in a 32-bit or wider
  // MI-Side.
  // 
  // Calculate MI-Side downsize length. Downsized length is equal to SI-Side
  // length for sub-sized transactions, i.e. AxSIZE <= MI-Side width. The 8 
  // least significant bits are used to determine the length of a transaction 
  // that doesn't need to be split and the length of the last transaction if it 
  // has been split. 
  // The most significant bits are used to determine the number of transactions
  // that has to be generated on the MI-Side.
  // 
  // Evaluate if current SI-Side WRAP length is a legal length on the MI-Side.
  // 
  // Calculate the length of a FIX transaction that needs to be translated into
  // a INCR on the MI-Side. I.e. for transactions with AxSIZE > MI-Side width.
  // 
  // Determine unalignment offset depending on transaction size so that it can 
  // be discarded on the MI-side. I.e. Unused data is removed to save cycles.
  // 
  // Calculate the address bits on the MI-Side that is covered by this burst 
  // transaction. This mask is used to generate WRAP base address and the 
  // length of the second half of a WRAP transaction that has to be split into 
  // two MI-Side INCR transactions.
  // 
  // Decode if the transaction fits on the MI-Side without needing to translate 
  // it. Also decode if the tranaction is of maximum SI-Side width.
  // 
  /////////////////////////////////////////////////////////////////////////////
  
  // Transaction burst type.
  assign access_is_fix   = ( S_AXI_ABURST == C_FIX_BURST );
  assign access_is_incr  = ( S_AXI_ABURST == C_INCR_BURST );
  assign access_is_wrap  = ( S_AXI_ABURST == C_WRAP_BURST );
  
  // Generate address bits used for SI-side transaction size.
  always @ *
  begin
    case (S_AXI_ASIZE)
      3'b000: size_mask = ~C_DOUBLE_LEN[8 +: C_M_AXI_BYTES_LOG];
      3'b001: size_mask = ~C_DOUBLE_LEN[7 +: C_M_AXI_BYTES_LOG];
      3'b010: size_mask = ~C_DOUBLE_LEN[6 +: C_M_AXI_BYTES_LOG];
      3'b011: size_mask = ~C_DOUBLE_LEN[5 +: C_M_AXI_BYTES_LOG];
      3'b100: size_mask = ~C_DOUBLE_LEN[4 +: C_M_AXI_BYTES_LOG];
      3'b101: size_mask = ~C_DOUBLE_LEN[3 +: C_M_AXI_BYTES_LOG];
      3'b110: size_mask = ~C_DOUBLE_LEN[2 +: C_M_AXI_BYTES_LOG];
      3'b111: size_mask = ~C_DOUBLE_LEN[1 +: C_M_AXI_BYTES_LOG];
    endcase
  end
  
  // Generate address mask for split transactions.
  always @ *
  begin
    case (S_AXI_ASIZE)
      3'b000: split_addr_mask = ~C_DOUBLE_LEN[8 +: C_AXI_ADDR_WIDTH];
      3'b001: split_addr_mask = ~C_DOUBLE_LEN[7 +: C_AXI_ADDR_WIDTH];
      3'b010: split_addr_mask = ~C_DOUBLE_LEN[6 +: C_AXI_ADDR_WIDTH];
      3'b011: split_addr_mask = ~C_DOUBLE_LEN[5 +: C_AXI_ADDR_WIDTH];
      3'b100: split_addr_mask = ~C_DOUBLE_LEN[4 +: C_AXI_ADDR_WIDTH];
      3'b101: split_addr_mask = ~C_DOUBLE_LEN[3 +: C_AXI_ADDR_WIDTH];
      3'b110: split_addr_mask = ~C_DOUBLE_LEN[2 +: C_AXI_ADDR_WIDTH];
      3'b111: split_addr_mask = ~C_DOUBLE_LEN[1 +: C_AXI_ADDR_WIDTH];
    endcase
  end
  
  // Help vector to determine the affected addressbits in the SI-side domain.
  // Also help to determine the length of downzized thransaction on the MI-side.
  assign alen_help_vector = {{C_AXI_ADDR_WIDTH-8{1'b0}}, S_AXI_ALEN, 8'hFF};
  
  // Calculate the address bits that are affected when a complete wrap is detected.
  always @ *
  begin
    if ( access_is_wrap & ( C_SUPPORT_BURSTS == 1 ) ) begin
      case (S_AXI_ASIZE)
        3'b000: cmd_mask_i  = alen_help_vector[8-0 +: C_S_AXI_BYTES_LOG];
        3'b001: cmd_mask_i  = alen_help_vector[8-1 +: C_S_AXI_BYTES_LOG];
        3'b010: cmd_mask_i  = alen_help_vector[8-2 +: C_S_AXI_BYTES_LOG];
        3'b011: cmd_mask_i  = alen_help_vector[8-3 +: C_S_AXI_BYTES_LOG];
        3'b100: cmd_mask_i  = alen_help_vector[8-4 +: C_S_AXI_BYTES_LOG];
        3'b101: cmd_mask_i  = alen_help_vector[8-5 +: C_S_AXI_BYTES_LOG];
        3'b110: cmd_mask_i  = alen_help_vector[8-6 +: C_S_AXI_BYTES_LOG];
        3'b111: cmd_mask_i  = alen_help_vector[8-7 +: C_S_AXI_BYTES_LOG];
      endcase
    end else begin
      cmd_mask_i          = {C_S_AXI_BYTES_LOG{1'b1}};
    end
  end

  // Calculate the length of downzized thransaction on the MI-side.
  always @ *
  begin
    if ( access_fit_mi_side & ( C_SUPPORT_BURSTS == 1 ) ) begin
      full_downsized_len = alen_help_vector[8-0 +: C_S_AXI_BYTES_LOG + 8];
    end else begin
      case (S_AXI_ASIZE)
        3'b000: full_downsized_len = alen_help_vector[8+C_M_AXI_BYTES_LOG-0 +: C_S_AXI_BYTES_LOG + 8];  // Illegal setting.
        3'b001: full_downsized_len = alen_help_vector[8+C_M_AXI_BYTES_LOG-1 +: C_S_AXI_BYTES_LOG + 8];  // Illegal setting.
        3'b010: full_downsized_len = alen_help_vector[8+C_M_AXI_BYTES_LOG-2 +: C_S_AXI_BYTES_LOG + 8];  // Illegal setting.
        3'b011: full_downsized_len = alen_help_vector[8+C_M_AXI_BYTES_LOG-3 +: C_S_AXI_BYTES_LOG + 8];
        3'b100: full_downsized_len = alen_help_vector[8+C_M_AXI_BYTES_LOG-4 +: C_S_AXI_BYTES_LOG + 8];
        3'b101: full_downsized_len = alen_help_vector[8+C_M_AXI_BYTES_LOG-5 +: C_S_AXI_BYTES_LOG + 8];
        3'b110: full_downsized_len = alen_help_vector[8+C_M_AXI_BYTES_LOG-6 +: C_S_AXI_BYTES_LOG + 8];
        3'b111: full_downsized_len = alen_help_vector[8+C_M_AXI_BYTES_LOG-7 +: C_S_AXI_BYTES_LOG + 8];
      endcase
    end
  end
  
  // Extract the least significant part (that fit MI-side LEN).
  assign downsized_len = full_downsized_len[8-1:0];
  
  // Calculate if the current setting would fit a WRAP downsizing.
  always @ *
  begin
    if ( access_fit_mi_side & ( C_SUPPORT_BURSTS == 1 ) ) begin
      legal_wrap_len = 1'b1;
    end else begin
      case (S_AXI_ASIZE)
        3'b000: legal_wrap_len = 1'b1;  // Illegal setting.
        3'b001: legal_wrap_len = 1'b1;  // Illegal setting.
        3'b010: legal_wrap_len = 1'b1;  // Illegal setting.
        3'b011: legal_wrap_len = S_AXI_ALEN < ( 16 * (2 ** C_M_AXI_NATIVE_SIZE) / (2 ** 3) );
        3'b100: legal_wrap_len = S_AXI_ALEN < ( 16 * (2 ** C_M_AXI_NATIVE_SIZE) / (2 ** 4) );
        3'b101: legal_wrap_len = S_AXI_ALEN < ( 16 * (2 ** C_M_AXI_NATIVE_SIZE) / (2 ** 5) );
        3'b110: legal_wrap_len = S_AXI_ALEN < ( 16 * (2 ** C_M_AXI_NATIVE_SIZE) / (2 ** 6) );
        3'b111: legal_wrap_len = S_AXI_ALEN < ( 16 * (2 ** C_M_AXI_NATIVE_SIZE) / (2 ** 7) );
      endcase
    end
  end
  
  // Length when converting a large FIX transaction into INCR.
  always @ *
  begin
    case (S_AXI_ASIZE)
      3'b000: fix_len = ( 8'h00 >> C_M_AXI_BYTES_LOG );
      3'b001: fix_len = ( 8'h01 >> C_M_AXI_BYTES_LOG );
      3'b010: fix_len = ( 8'h03 >> C_M_AXI_BYTES_LOG );
      3'b011: fix_len = ( 8'h07 >> C_M_AXI_BYTES_LOG );
      3'b100: fix_len = ( 8'h0F >> C_M_AXI_BYTES_LOG );
      3'b101: fix_len = ( 8'h1F >> C_M_AXI_BYTES_LOG );
      3'b110: fix_len = ( 8'h3F >> C_M_AXI_BYTES_LOG );
      3'b111: fix_len = ( 8'h7F >> C_M_AXI_BYTES_LOG );
    endcase
  end
  
  // Calculate unalignment address.
  always @ *
  begin
    case (S_AXI_ASIZE)
      3'b000: unalignment_addr  = 8'b0;
      3'b001: unalignment_addr  = {7'b0, ( S_AXI_AADDR[0 +: 1] >> C_M_AXI_BYTES_LOG )};
      3'b010: unalignment_addr  = {6'b0, ( S_AXI_AADDR[0 +: 2] >> C_M_AXI_BYTES_LOG )};
      3'b011: unalignment_addr  = {5'b0, ( S_AXI_AADDR[0 +: 3] >> C_M_AXI_BYTES_LOG )};
      3'b100: unalignment_addr  = {4'b0, ( S_AXI_AADDR[0 +: 4] >> C_M_AXI_BYTES_LOG )};
      3'b101: unalignment_addr  = {3'b0, ( S_AXI_AADDR[0 +: 5] >> C_M_AXI_BYTES_LOG )};
      3'b110: unalignment_addr  = {2'b0, ( S_AXI_AADDR[0 +: 6] >> C_M_AXI_BYTES_LOG )};
      3'b111: unalignment_addr  = {1'b0, ( S_AXI_AADDR[0 +: 7] >> C_M_AXI_BYTES_LOG )};
    endcase
  end
  
  // Mask for address bits that are inside burst address.
  always @ *
  begin
    case (S_AXI_ASIZE)
      3'b000: burst_mask  = alen_help_vector[8-0 +: C_AXI_ADDR_WIDTH];
      3'b001: burst_mask  = alen_help_vector[8-1 +: C_AXI_ADDR_WIDTH];
      3'b010: burst_mask  = alen_help_vector[8-2 +: C_AXI_ADDR_WIDTH];
      3'b011: burst_mask  = alen_help_vector[8-3 +: C_AXI_ADDR_WIDTH];
      3'b100: burst_mask  = alen_help_vector[8-4 +: C_AXI_ADDR_WIDTH];
      3'b101: burst_mask  = alen_help_vector[8-5 +: C_AXI_ADDR_WIDTH];
      3'b110: burst_mask  = alen_help_vector[8-6 +: C_AXI_ADDR_WIDTH];
      3'b111: burst_mask  = alen_help_vector[8-7 +: C_AXI_ADDR_WIDTH];
    endcase
  end
  
  // Mask address to get start WRAP boundary.
  assign masked_addr        = ( S_AXI_AADDR & ~burst_mask );
  
  // Calculate the burst WRAP LEN.
  assign burst_unalignment  = ( ( S_AXI_AADDR & burst_mask ) >> C_M_AXI_BYTES_LOG );
  assign wrap_unaligned_len = burst_unalignment[0 +: 8];
  
  // Get number of transactions for downsized data.
  assign num_transactions   = full_downsized_len[8 +: C_S_AXI_BYTES_LOG];

  // Detect if the transaction can fit on MI-side untouched.
  assign access_fit_mi_side = ( S_AXI_ASIZE <= C_M_AXI_NATIVE_SIZE );
  assign si_full_size       = ( S_AXI_ASIZE == C_S_AXI_NATIVE_SIZE );
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Generate Command Information.
  // 
  // From the decode SI-side information determine if the transaction need to 
  // be split:
  // * FIX is always split when the don't fit MI-Side (AxSIZE > MI-Side width).
  // * INCR is split when the calculated downsized length has any of the most
  //   significant bits set.
  // * WRAP is split when it cannot downsized to a legal length, i.e. the 
  //   downsized lenght requires more that 16 data beats. And it doesn't fit the 
  //   natuaral MI_Side width. And it is unaligned.
  //   (An aligneded WRAP can always be translated into a INCR without splitting,
  //    it is the wrap offset that forces the split).
  // 
  // Keep track of when the splitting of a transaction has starts and ends. This 
  // is done by detecting the need for a split and keeping track of the number 
  // of commands issued so far. The command count is reset when last command has 
  // been forwarded (and the SI-side transaction is acknowledged).
  // 
  // Calculate the length of the second part of a split WRAP transaction.
  // 
  // Determine when the last command for a split is about to be generated. This
  // information is used to ackowledge the SI-Side transaction and also prepare
  // for the next transaction. This means that the only command for a 
  // transaction that doesn't nedd to be split is also considered the last (and
  // only) command.
  // 
  // Set that Read data should mirrored when transaction is smaller or equal to
  // MI-Side width.
  // 
  // Extract unalignement information to be able to extract and merge data
  // correctly in the W and R channels. 
  // * First MI-Side data extraction isalways based on the SI-Side start address, 
  //   regardless of transaction type.
  // * WRAP and full size INCR transactions always start following split transactions
  //   at a SI-Side aligned boundary, i.e. 0.
  // * Split INCR that has AxSIZE less than SI-Side width has to adjust the data 
  //   extraction start with previously calculated address mask, i.e. to only use
  //   address bit defined by size difference between AxSIZE and SI-Side width.
  // 
  // Generate data extraction offset for small WRAP transactions.
  // 
  // Prepare address for next part of split transaction.
  // 
  /////////////////////////////////////////////////////////////////////////////
    
  // Detect when FIX must be split (and translate into INCR).
  assign fix_need_to_split  = access_is_fix & ~access_fit_mi_side &
                              ( C_SUPPORT_SPLITTING == 1 ) &
                              ( C_SUPPORT_BURSTS == 1 );
  
  // Detect when INCR must be split.
  assign incr_need_to_split = access_is_incr & ( num_transactions != 0 ) &
                              ( C_SUPPORT_SPLITTING == 1 ) &
                              ( C_SUPPORT_BURSTS == 1 );
  
  // Detect when WRAP must be split (and translate into INCR).
  assign wrap_need_to_split = access_is_wrap &
                              (~access_fit_mi_side & ~legal_wrap_len & ( wrap_unaligned_len != 0 )) &
                              ( C_SUPPORT_SPLITTING == 1 ) &
                              ( C_SUPPORT_BURSTS == 1 );
  
  // Detect when a command has to be split.
  assign need_to_split_q    = ( fix_need_to_split_q | incr_need_to_split_q | wrap_need_to_split_q );
  
  // Handle progress of split transactions.
  always @ (posedge ACLK) begin
    if ( ARESET ) begin
      split_ongoing     <= 1'b0;
    end else begin
      if ( pushed_new_cmd ) begin
        split_ongoing     <= need_to_split_q & ~last_split;
      end
    end
  end
  
  // Keep track of number of transactions generated.
  always @ (posedge ACLK) begin
    if ( ARESET ) begin
      pushed_commands <= 4'b0;
    end else begin
      if ( S_AXI_AREADY_I ) begin
        pushed_commands <= 4'b0;
      end else if ( pushed_new_cmd ) begin
        pushed_commands <= pushed_commands + 4'b1;
      end
    end
  end
  
  // Generate the remaining LEN for split WRAP transaction.
  always @ (posedge ACLK) begin
    if ( ARESET ) begin
      wrap_rest_len <= 8'b0;
    end else begin
      wrap_rest_len <= wrap_unaligned_len_q - 8'b1;
    end
  end
  
  // Detect last part of a command, split or not.
  assign last_fix_split     = access_is_fix_q & ( ~fix_need_to_split_q | 
                                                ( fix_need_to_split_q & ( S_AXI_ALEN_Q[0 +: 4] == pushed_commands ) ) );
  assign last_incr_split    = access_is_incr_q & ( num_transactions_q   == pushed_commands );
  assign last_wrap_split    = access_is_wrap_q & ( ~wrap_need_to_split_q |
                                                 ( wrap_need_to_split_q & split_ongoing) );
  assign last_split         = last_fix_split | last_incr_split | last_wrap_split |
                              ( C_SUPPORT_SPLITTING == 0 ) |
                              ( C_SUPPORT_BURSTS == 0 );
  
  // Only FIX that are small enough is concidered FIX.
  assign cmd_fix_i          = access_is_fix_q & access_fit_mi_side_q;
  
  // Assign Split signals.
  assign cmd_split_i        = need_to_split_q & ~last_split;
  assign cmd_b_split_i      = need_to_split_q & ~last_split;
  
  // Determine if data should be mirrored for Read.
  assign cmd_mirror_i       = ( access_fit_mi_side_q ) |
                              ( C_SUPPORT_BURSTS == 0 );
  
  // Get unalignment address bits (including aligning it inside covered area).
  always @ *
  begin
    if ( split_ongoing & access_is_incr_q & si_full_size_q | split_ongoing & access_is_wrap_q ) begin
      cmd_first_word_ii = {C_S_AXI_BYTES_LOG{1'b0}};
    end else if ( split_ongoing & access_is_incr_q ) begin
      cmd_first_word_ii = S_AXI_AADDR_Q[C_S_AXI_BYTES_LOG-1:0] & split_addr_mask_q[C_S_AXI_BYTES_LOG-1:0];
    end else begin
      cmd_first_word_ii = S_AXI_AADDR_Q[C_S_AXI_BYTES_LOG-1:0];
    end
  end
  assign cmd_first_word_i   = cmd_first_word_ii & cmd_mask_q & size_mask_q;
  
  // Offset is the bits that is outside of the Mask.
  assign cmd_offset_i       = cmd_first_word_ii & ~cmd_mask_q;
  
  // Calculate base for next address.
  assign pre_mi_addr        = ( M_AXI_AADDR_I & split_addr_mask_q & {{C_AXI_ADDR_WIDTH-C_M_AXI_BYTES_LOG{1'b1}}, {C_M_AXI_BYTES_LOG{1'b0}}} );
  always @ (posedge ACLK) begin
    if ( ARESET ) begin
      next_mi_addr  = {C_AXI_ADDR_WIDTH{1'b0}};
    end else if ( pushed_new_cmd ) begin
      next_mi_addr  = pre_mi_addr + ( 9'h100 << C_M_AXI_BYTES_LOG );
    end
  end
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Translating Transaction.
  // 
  // Setup the number of MI-Side parts for the current transaction:
  // * FIX transactions that needs to be spit will have # of parts set by the
  //   length of the SI-Side transaction. 
  // * FIX with no need to split has 1 part (1:1).
  // * WRAP will be 1 part unless the length and unalignment requires a split, in
  //   which case the # of parts will be 2.
  // * INCR transactions will have the # of parts defined by the most significant
  //   bits of the true downsized length calculation.
  // 
  // Addreess has to be calculated for each part of a transaction on MI-Side:
  // * AxADDR is always used for the first part (and all types of transactions).
  // * WRAP has aligned wrap boundary as start address for second part.
  // * Split INCR transaction will increase address with maximum sized that can
  //   be covered by a MI-Side burst, i.e. 256 * 2^miBytes.
  // * FIX always use AxADDR for all parts, if split.
  // 
  // The length of a transaction part is calculated by a base length that is
  // depending on the type of transaction. This is the adjusted by unalignment
  // that this or previous parts have had.
  // 
  // Transactions that fit tha native MI-side will pass without altering 
  // AxSIZE and AxBURST. A transaction that is translated will always have the 
  // full MI-Side data width, i.e. AxSIZE is adjusted.
  // FIX and WRAP transactions that cannot fit on MI side will change type to
  // INCR and be split accordingly.
  // 
  /////////////////////////////////////////////////////////////////////////////
  
  // Generate the number of splits, to be able to coalesce responses in B & R channels.
  always @ *
  begin
    if ( fix_need_to_split_q ) begin
      cmd_b_repeat_i = S_AXI_ALEN_Q[0 +: 4];
    end else if ( incr_need_to_split_q ) begin
      cmd_b_repeat_i = num_transactions_q;
    end else if ( wrap_need_to_split_q ) begin
      cmd_b_repeat_i = 4'b1;
    end else begin
      cmd_b_repeat_i = 4'b0;
    end
  end
  
  // Select new size or remaining size.
  always @ *
  begin
    if ( split_ongoing & access_is_incr_q ) begin
      M_AXI_AADDR_I = next_mi_addr;
    end else if ( split_ongoing & access_is_wrap_q ) begin
      M_AXI_AADDR_I = masked_addr_q;
    end else begin
      M_AXI_AADDR_I = S_AXI_AADDR_Q;
    end
  end
  
  // Generate the base length for each transaction.
  always @ *
  begin
    if ( access_fit_mi_side_q ) begin
      base_len = S_AXI_ALEN_Q;
      
    end else if ( ( access_is_wrap_q & legal_wrap_len_q ) | ( access_is_incr_q & ~incr_need_to_split_q ) |
                  ( access_is_wrap_q & ~split_ongoing ) | ( access_is_incr_q & incr_need_to_split_q & last_split ) ) begin
      base_len = downsized_len_q;
      
    end else if ( fix_need_to_split_q ) begin
      base_len = fix_len_q;
      
    end else if ( access_is_wrap_q & split_ongoing ) begin
      base_len = wrap_rest_len;
      
    end else begin
      base_len = 8'hFF; 
      
    end
  end
  
  // Generate the compensation value for the transaction.
  always @ *
  begin
    if ( wrap_need_to_split_q & ~split_ongoing ) begin
      compensation_len = wrap_unaligned_len_q;
      
    end else if ( ( incr_need_to_split_q & ~split_ongoing ) | 
                  ( access_is_incr_q & ~incr_need_to_split_q & ~access_fit_mi_side_q ) |
                  ( fix_need_to_split_q ) ) begin
      compensation_len = unalignment_addr_q;
      
    end else begin
      compensation_len = 8'b0;
      
    end
  end
  
  // Generate the actual length.
  assign cmd_length_i = base_len - compensation_len; 
  assign M_AXI_ALEN_I = cmd_length_i;
  
  // Select directly forwarded or modified transaction.
  always @ *
  begin
    if ( ~access_fit_mi_side_q ) begin
      // SI to MI-side transaction translation.
      M_AXI_ASIZE_I  = C_M_AXI_NATIVE_SIZE;
      if ( access_is_fix_q | access_is_wrap_q & ~legal_wrap_len_q ) begin
        M_AXI_ABURST_I = C_INCR_BURST;
      end else begin
        M_AXI_ABURST_I = S_AXI_ABURST_Q;
      end
      
      // Command settings.
      cmd_size_i     = C_M_AXI_NATIVE_SIZE;
    end else begin
      // SI to MI-side transaction forwarding.
      M_AXI_ASIZE_I  = S_AXI_ASIZE_Q;
      M_AXI_ABURST_I = S_AXI_ABURST_Q;
      
      // Command settings.
      cmd_size_i     = S_AXI_ASIZE_Q;
    end
  end
  
  // Kill Exclusive for Split transactions.
  always @ *
  begin
    if ( need_to_split_q ) begin
      M_AXI_ALOCK_I = {S_AXI_ALOCK_Q[1], 1'b0};
    end else begin
      M_AXI_ALOCK_I = S_AXI_ALOCK_Q;
    end
  end
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Forward the command to the MI-side interface.
  // 
  //
  /////////////////////////////////////////////////////////////////////////////
  
  // Generate ready signal.
  // Move SI-side transaction to internal pipe stage.
  always @ (posedge ACLK) begin
    if (ARESET) begin
      command_ongoing <= 1'b0;
      S_AXI_AREADY_I <= 1'b0;
    end else begin
      if (areset_d == 2'b10) begin
        S_AXI_AREADY_I <= 1'b1;
      end else begin
        if ( S_AXI_AVALID & S_AXI_AREADY_I ) begin
          command_ongoing <= 1'b1;
          S_AXI_AREADY_I <= 1'b0;
        end else if ( pushed_new_cmd & last_split ) begin
          command_ongoing <= 1'b0;
          S_AXI_AREADY_I <= 1'b1;
        end 
      end
    end
  end
  
  assign S_AXI_AREADY   = S_AXI_AREADY_I;
  
  // Only allowed to forward translated command when command queue is ok with it.
  assign M_AXI_AVALID_I = allow_new_cmd & command_ongoing;
  
  // Detect when MI-side is stalling.
  assign mi_stalling    = M_AXI_AVALID_I & ~M_AXI_AREADY_I;
                          
  
  /////////////////////////////////////////////////////////////////////////////
  // Simple transfer of paramters that doesn't need to be adjusted.
  // 
  // ID     - Transaction still recognized with the same ID.
  // CACHE  - No need to change the chache features. Even if the modyfiable
  //          bit is overridden (forcefully) there is no need to let downstream
  //          component beleive it is ok to modify it further.
  // PROT   - Security level of access is not changed when upsizing.
  // REGION - Address region stays the same.
  // QOS    - Quality of Service remains the same.
  // USER   - User bits remains the same.
  // 
  /////////////////////////////////////////////////////////////////////////////
  
  // Assign MI-Side.
  assign M_AXI_AID_I      = S_AXI_AID_Q;
  assign M_AXI_ACACHE_I   = S_AXI_ACACHE_Q;
  assign M_AXI_APROT_I    = S_AXI_APROT_Q;
  assign M_AXI_AREGION_I  = S_AXI_AREGION_Q;
  assign M_AXI_AQOS_I     = S_AXI_AQOS_Q;
  assign M_AXI_AUSER_I    = ( C_AXI_SUPPORTS_USER_SIGNALS ) ? S_AXI_AUSER_Q : {C_AXI_AUSER_WIDTH{1'b0}};
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Control command queue to W/R channel.
  //
  // It is allowed to continue pushing new commands as long as
  // * There is room in the queue(s).
  // * The ID is the same as previously queued. Since data is not reordered
  //   for the same ID it is ok to let them proceed.
  //   (It is only required to control ID for the AW/AR channels)
  //
  /////////////////////////////////////////////////////////////////////////////
  
  // Keep track of current ID in queue.
  always @ (posedge ACLK) begin
    if (ARESET) begin
      queue_id <= {C_AXI_ID_WIDTH{1'b0}};
    end else begin
      if ( cmd_push ) begin
        // Store ID (it will be matching ID or a "new beginning").
        queue_id <= S_AXI_AID_Q;
      end
    end
  end
  
  // Check ID to make sure this command is allowed.
  assign id_match       = ( C_SINGLE_THREAD == 0 ) | ( queue_id == S_AXI_AID_Q);
  assign cmd_id_check_empty = (C_AXI_CHANNEL == 0) ? cmd_b_empty : cmd_empty;
  assign cmd_id_check   = cmd_id_check_empty | ( id_match & ~cmd_id_check_empty );
  
  // Check if it is allowed to push more commands (ID is allowed and there is room in the queue).
  assign allow_new_cmd  = (~cmd_full & ~cmd_b_full & cmd_id_check) | cmd_push_block;
  
  // Push new command when allowed and MI-side is able to receive the command.
  assign cmd_push       = M_AXI_AVALID_I & ~cmd_push_block;
  assign cmd_b_push     = M_AXI_AVALID_I & ~cmd_b_push_block & (C_AXI_CHANNEL == 0);
  
  // Block furter push until command has been forwarded to MI-side.
  always @ (posedge ACLK) begin
    if (ARESET) begin
      cmd_push_block <= 1'b0;
    end else begin
      if ( pushed_new_cmd ) begin
        cmd_push_block <= 1'b0;
      end else if ( cmd_push & mi_stalling ) begin
        cmd_push_block <= 1'b1;
      end 
    end
  end
  
  // Block furter push until command has been forwarded to MI-side.
  always @ (posedge ACLK) begin
    if (ARESET) begin
      cmd_b_push_block <= 1'b0;
    end else begin
      if ( S_AXI_AREADY_I ) begin
        cmd_b_push_block <= 1'b0;
      end else if ( cmd_b_push ) begin
        cmd_b_push_block <= 1'b1;
      end 
    end
  end
  
  // Acknowledge command when we can push it into queue (and forward it).
  assign pushed_new_cmd = M_AXI_AVALID_I & M_AXI_AREADY_I;
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Command Queue (W/R):
  // 
  // Instantiate a FIFO as the queue and adjust the control signals.
  //
  // Decode size to step before passing it along.
  //
  // When there is no need for bursts the command FIFO can be greatly reduced 
  // becase the following is always true:
  // * split = 0 (only single words)
  // * mirror = 1 (always mirror read data)
  // * length = 0
  // * nothing can be packed (i.e. no WRAP at all)
  //   * never any sub-size wraping => static offset (0) and mask (1)
  // 
  /////////////////////////////////////////////////////////////////////////////
  
  // Instantiated queue.
  generate
    if (C_SUPPORT_BURSTS == 1) begin : USE_BURSTS
  axi_interconnect_v1_7_13_axic_fifo #
      (
       .C_FAMILY(C_FAMILY),
       .C_FIFO_DEPTH_LOG(C_FIFO_DEPTH_LOG),
       .C_FIFO_WIDTH(1+1+1+C_S_AXI_BYTES_LOG+C_S_AXI_BYTES_LOG+C_S_AXI_BYTES_LOG+3+8+3),
       .C_FIFO_TYPE("lut")
       ) 
       cmd_queue
      (
       .ACLK(ACLK),
       .ARESET(ARESET),
       .S_MESG({cmd_fix_i, cmd_split_i, cmd_mirror_i, cmd_first_word_i, 
                cmd_offset_i, cmd_mask_q, cmd_size_i, cmd_length_i, S_AXI_ASIZE_Q}),
       .S_VALID(cmd_push),
       .S_READY(s_ready),
       .M_MESG({cmd_fix, cmd_split, cmd_mirror, cmd_first_word,  
                cmd_offset, cmd_mask, cmd_size_ii, cmd_length, cmd_size}),
       .M_VALID(cmd_valid_i),
       .M_READY(cmd_ready)
       );
    end else begin : NO_BURSTS
      
      wire [C_S_AXI_BYTES_LOG-1:0]        cmd_first_word_out;
  
  axi_interconnect_v1_7_13_axic_fifo #
      (
       .C_FAMILY(C_FAMILY),
       .C_FIFO_DEPTH_LOG(C_FIFO_DEPTH_LOG),
       .C_FIFO_WIDTH(1+C_S_AXI_BYTES_LOG+3),
       .C_FIFO_TYPE("lut")
       ) 
       cmd_queue
      (
       .ACLK(ACLK),
       .ARESET(ARESET),
       .S_MESG({cmd_fix_i, cmd_first_word_i, cmd_size_i}),
       .S_VALID(cmd_push),
       .S_READY(s_ready),
       .M_MESG({cmd_fix, cmd_first_word_out, cmd_size_ii}),
       .M_VALID(cmd_valid_i),
       .M_READY(cmd_ready)
       );
       
       assign cmd_split         = 1'b0;
       assign cmd_mirror        = 1'b1;
       assign cmd_first_word    = cmd_first_word_out;
       assign cmd_offset        = {C_S_AXI_BYTES_LOG{1'b0}};
       assign cmd_mask          = {C_S_AXI_BYTES_LOG{1'b1}};
       assign cmd_size          = C_S_AXI_NATIVE_SIZE;        // Doen't matter, unused in target.
       assign cmd_length        = 8'b0;
    end
  endgenerate

  // Queue is concidered full when not ready.
  assign cmd_full   = ~s_ready;
  
  // Queue is empty when no data at output port.
  always @ (posedge ACLK) begin
    if (ARESET) begin
      cmd_empty <= 1'b1;
      cmd_depth <= {C_FIFO_DEPTH_LOG+1{1'b0}};
    end else begin
      if ( cmd_push & ~cmd_ready ) begin
        // Push only => Increase depth.
        cmd_depth <= cmd_depth + 1'b1;
        cmd_empty <= 1'b0;
      end else if ( ~cmd_push & cmd_ready ) begin
        // Pop only => Decrease depth.
        cmd_depth <= cmd_depth - 1'b1;
        cmd_empty <= ( cmd_depth == 1 );
      end
    end
  end
  
  // Assign external signal.
  assign cmd_valid  = cmd_valid_i;
  
  // Translate SI-side size to step for upsizer function.
  always @ *
  begin
    case (cmd_size_ii)
      3'b000: cmd_step_i = 7'b0000001;
      3'b001: cmd_step_i = 7'b0000010;
      3'b010: cmd_step_i = 7'b0000100;
      3'b011: cmd_step_i = 7'b0001000;
      3'b100: cmd_step_i = 7'b0010000;
      3'b101: cmd_step_i = 7'b0100000;
      3'b110: cmd_step_i = 7'b1000000;
      3'b111: cmd_step_i = 7'b0000000; // Illegal setting.
    endcase
  end
  
  // Get only the applicable bits in step.
  assign cmd_step = cmd_step_i[C_M_AXI_BYTES_LOG:0];
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Command Queue (B):
  // 
  // Add command queue for B channel only when it is AW channel and both burst
  // and splitting is supported.
  //
  // When turned off the command appears always empty.
  // 
  /////////////////////////////////////////////////////////////////////////////
  
  // Instantiated queue.
  generate
    if ( C_AXI_CHANNEL == 0 && C_SUPPORT_SPLITTING == 1 && C_SUPPORT_BURSTS == 1 ) begin : USE_B_CHANNEL
      
      wire                                cmd_b_valid_i;
      wire                                s_b_ready;
      
  axi_interconnect_v1_7_13_axic_fifo #
      (
       .C_FAMILY(C_FAMILY),
       .C_FIFO_DEPTH_LOG(C_FIFO_DEPTH_LOG),
       .C_FIFO_WIDTH(1+4),
       .C_FIFO_TYPE("lut")
       ) 
       cmd_b_queue
      (
       .ACLK(ACLK),
       .ARESET(ARESET),
       .S_MESG({cmd_b_split_i, cmd_b_repeat_i}),
       .S_VALID(cmd_b_push),
       .S_READY(s_b_ready),
       .M_MESG({cmd_b_split, cmd_b_repeat}),
       .M_VALID(cmd_b_valid_i),
       .M_READY(cmd_b_ready)
       );
    
      // Queue is concidered full when not ready.
      assign cmd_b_full   = ~s_b_ready;
      
      // Queue is empty when no data at output port.
      always @ (posedge ACLK) begin
        if (ARESET) begin
          cmd_b_empty_i <= 1'b1;
          cmd_b_depth <= {C_FIFO_DEPTH_LOG+1{1'b0}};
        end else begin
          if ( cmd_b_push & ~cmd_b_ready ) begin
            // Push only => Increase depth.
            cmd_b_depth <= cmd_b_depth + 1'b1;
            cmd_b_empty_i <= 1'b0;
          end else if ( ~cmd_b_push & cmd_b_ready ) begin
            // Pop only => Decrease depth.
            cmd_b_depth <= cmd_b_depth - 1'b1;
            cmd_b_empty_i <= ( cmd_b_depth == 1 );
          end
        end
      end
      
      // Assign external signal.
      assign cmd_b_valid  = cmd_b_valid_i;
      assign cmd_b_empty = cmd_b_empty_i;
      
    end else begin : NO_B_CHANNEL
      
      // Assign external command signals.
      assign cmd_b_valid    = 1'b0;
      assign cmd_b_split    = 1'b0;
      assign cmd_b_repeat   = 4'b0;
   
      // Assign internal command FIFO signals.
      assign cmd_b_full     = 1'b0;
      assign cmd_b_empty    = 1'b1;
      
    end
  endgenerate
  
  
  /////////////////////////////////////////////////////////////////////////////
  // MI-side output handling
  // 
  /////////////////////////////////////////////////////////////////////////////
// TODO: registered?  
  assign M_AXI_AID      = M_AXI_AID_I;
  assign M_AXI_AADDR    = M_AXI_AADDR_I;
  assign M_AXI_ALEN     = M_AXI_ALEN_I;
  assign M_AXI_ASIZE    = M_AXI_ASIZE_I;
  assign M_AXI_ABURST   = M_AXI_ABURST_I;
  assign M_AXI_ALOCK    = M_AXI_ALOCK_I;
  assign M_AXI_ACACHE   = M_AXI_ACACHE_I;
  assign M_AXI_APROT    = M_AXI_APROT_I;
  assign M_AXI_AREGION  = M_AXI_AREGION_I;
  assign M_AXI_AQOS     = M_AXI_AQOS_I;
  assign M_AXI_AUSER    = M_AXI_AUSER_I;
  assign M_AXI_AVALID   = M_AXI_AVALID_I;
  assign M_AXI_AREADY_I = M_AXI_AREADY;
  
  
endmodule



// -- (c) Copyright 2010 - 2011 Xilinx, Inc. All rights reserved.
// --
// -- This file contains confidential and proprietary information
// -- of Xilinx, Inc. and is protected under U.S. and 
// -- international copyright and other intellectual property
// -- laws.
// --
// -- DISCLAIMER
// -- This disclaimer is not a license and does not grant any
// -- rights to the materials distributed herewith. Except as
// -- otherwise provided in a valid license issued to you by
// -- Xilinx, and to the maximum extent permitted by applicable
// -- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
// -- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
// -- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
// -- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
// -- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
// -- (2) Xilinx shall not be liable (whether in contract or tort,
// -- including negligence, or under any other theory of
// -- liability) for any loss or damage of any kind or nature
// -- related to, arising under or in connection with these
// -- materials, including for any direct, or any indirect,
// -- special, incidental, or consequential loss or damage
// -- (including loss of data, profits, goodwill, or any type of
// -- loss or damage suffered as a result of any action brought
// -- by a third party) even if such damage or loss was
// -- reasonably foreseeable or Xilinx had been advised of the
// -- possibility of the same.
// --
// -- CRITICAL APPLICATIONS
// -- Xilinx products are not designed or intended to be fail-
// -- safe, or for use in any application requiring fail-safe
// -- performance, such as life-support or safety devices or
// -- systems, Class III medical devices, nuclear facilities,
// -- applications related to the deployment of airbags, or any
// -- other applications that could lead to death, personal
// -- injury, or severe property or environmental damage
// -- (individually and collectively, "Critical
// -- Applications"). Customer assumes the sole risk and
// -- liability of any use of Xilinx products in Critical
// -- Applications, subject only to applicable laws and
// -- regulations governing limitations on product liability.
// --
// -- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
// -- PART OF THIS FILE AT ALL TIMES.
//-----------------------------------------------------------------------------
//
// Round-Robin Arbiter for R and B channel responses
// Verilog-standard:  Verilog 2001
//--------------------------------------------------------------------------
//
// Structure:
//    arbiter_resp
//--------------------------------------------------------------------------
`timescale 1ps/1ps

(* DowngradeIPIdentifiedWarnings="yes" *) 
module axi_interconnect_v1_7_13_arbiter_resp #
  (
   parameter         C_FAMILY       = "none",
   parameter integer C_NUM_S        = 4,      // Number of requesting Slave ports = [2:16]
   parameter integer C_NUM_S_LOG    = 2,      // Log2(C_NUM_S)
   parameter integer C_GRANT_ENC    = 0,      // Enable encoded grant output
   parameter integer C_GRANT_HOT    = 1       // Enable 1-hot grant output
   )
  (
   // Global Inputs
   input  wire                     ACLK,
   input  wire                     ARESET,
   // Slave  Ports
   input  wire [C_NUM_S-1:0]       S_VALID,      // Request from each slave
   output wire [C_NUM_S-1:0]       S_READY,      // Grant response to each slave
   // Master Ports
   output wire [C_NUM_S_LOG-1:0]   M_GRANT_ENC,  // Granted slave index (encoded)
   output wire [C_NUM_S-1:0]       M_GRANT_HOT,  // Granted slave index (1-hot)
   output wire                     M_VALID,      // Grant event
   input  wire                     M_READY
   );

  // Generates a binary coded from onehotone encoded
  function [4:0] f_hot2enc
    (
      input [16:0]  one_hot
    );
    begin
      f_hot2enc[0] = |(one_hot & 17'b01010101010101010);
      f_hot2enc[1] = |(one_hot & 17'b01100110011001100);
      f_hot2enc[2] = |(one_hot & 17'b01111000011110000);
      f_hot2enc[3] = |(one_hot & 17'b01111111100000000);
      f_hot2enc[4] = |(one_hot & 17'b10000000000000000);
    end
  endfunction

  (* use_clock_enable = "yes" *)
  reg [C_NUM_S-1:0]      chosen;
  
  wire [C_NUM_S-1:0]     grant_hot; 
  wire                   master_selected; 
  wire                   active_master;
  wire                   need_arbitration;
  wire                   m_valid_i;
  wire [C_NUM_S-1:0]     s_ready_i;
  wire                   access_done;
  reg [C_NUM_S-1:0]      last_rr_hot;
  wire [C_NUM_S-1:0]     valid_rr;
  reg [C_NUM_S-1:0]      next_rr_hot;
  reg [C_NUM_S*C_NUM_S-1:0] carry_rr;
  reg [C_NUM_S*C_NUM_S-1:0] mask_rr;
  integer                 i;
  integer                 j;
  integer                 n;
  
  /////////////////////////////////////////////////////////////////////////////
  //   
  // Implementation of the arbiter outputs independant of arbitration
  //
  /////////////////////////////////////////////////////////////////////////////
  
  // Mask the current requests with the chosen master
  assign grant_hot        = chosen & S_VALID;

  // See if we have a selected master
  assign master_selected  = |grant_hot[0+:C_NUM_S];

  // See if we have current requests
  assign active_master    = |S_VALID;

  // Access is completed
  assign access_done = m_valid_i & M_READY;
  
  // Need to handle if we drive S_ready combinatorial and without an IDLE state

  // Drive S_READY on the master who has been chosen when we get a M_READY
  assign s_ready_i = {C_NUM_S{M_READY}} & grant_hot[0+:C_NUM_S];

  // Drive M_VALID if we have a selected master
  assign m_valid_i = master_selected;
                
  // If we have request and not a selected master, we need to arbitrate a new chosen 
  assign need_arbitration = (active_master & ~master_selected) | access_done;

  // need internal signals of the output signals
  assign M_VALID = m_valid_i;
  assign S_READY = s_ready_i;

  /////////////////////////////////////////////////////////////////////////////
  // Assign conditional onehot target output signal.
  assign M_GRANT_HOT = (C_GRANT_HOT == 1) ? grant_hot[0+:C_NUM_S] : {C_NUM_S{1'b0}};
  /////////////////////////////////////////////////////////////////////////////
  // Assign conditional encoded target output signal.
  assign M_GRANT_ENC = (C_GRANT_ENC == 1) ? f_hot2enc(grant_hot) : {C_NUM_S_LOG{1'b0}};
  
  /////////////////////////////////////////////////////////////////////////////
  // Select a new chosen when we need to arbitrate
  // If we don't have a new chosen, keep the old one since it's a good chance
  // that it will do another request
  always @(posedge ACLK)
    begin
      if (ARESET) begin
        chosen <= {C_NUM_S{1'b0}};
        last_rr_hot <= {1'b1, {C_NUM_S-1{1'b0}}};
      end else if (need_arbitration) begin
        chosen <= next_rr_hot;   
        if (|next_rr_hot) last_rr_hot <= next_rr_hot;
      end
    end

  assign valid_rr =  S_VALID;

  /////////////////////////////////////////////////////////////////////////////
  // Round-robin arbiter
  // Selects next request to grant from among inputs with PRIO = 0, if any.
  /////////////////////////////////////////////////////////////////////////////
  
  always @ * begin
    next_rr_hot = 0;
    for (i=0;i<C_NUM_S;i=i+1) begin
      n = (i>0) ? (i-1) : (C_NUM_S-1);
      carry_rr[i*C_NUM_S] = last_rr_hot[n];
      mask_rr[i*C_NUM_S] = ~valid_rr[n];
      for (j=1;j<C_NUM_S;j=j+1) begin
        n = (i-j > 0) ? (i-j-1) : (C_NUM_S+i-j-1);
        carry_rr[i*C_NUM_S+j] = carry_rr[i*C_NUM_S+j-1] | (last_rr_hot[n] & mask_rr[i*C_NUM_S+j-1]);
        if (j < C_NUM_S-1) begin
          mask_rr[i*C_NUM_S+j] = mask_rr[i*C_NUM_S+j-1] & ~valid_rr[n];
        end
      end   
      next_rr_hot[i] = valid_rr[i] & carry_rr[(i+1)*C_NUM_S-1];
    end
  end
  
endmodule


// -- (c) Copyright 2010 - 2011 Xilinx, Inc. All rights reserved.
// --
// -- This file contains confidential and proprietary information
// -- of Xilinx, Inc. and is protected under U.S. and 
// -- international copyright and other intellectual property
// -- laws.
// --
// -- DISCLAIMER
// -- This disclaimer is not a license and does not grant any
// -- rights to the materials distributed herewith. Except as
// -- otherwise provided in a valid license issued to you by
// -- Xilinx, and to the maximum extent permitted by applicable
// -- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
// -- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
// -- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
// -- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
// -- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
// -- (2) Xilinx shall not be liable (whether in contract or tort,
// -- including negligence, or under any other theory of
// -- liability) for any loss or damage of any kind or nature
// -- related to, arising under or in connection with these
// -- materials, including for any direct, or any indirect,
// -- special, incidental, or consequential loss or damage
// -- (including loss of data, profits, goodwill, or any type of
// -- loss or damage suffered as a result of any action brought
// -- by a third party) even if such damage or loss was
// -- reasonably foreseeable or Xilinx had been advised of the
// -- possibility of the same.
// --
// -- CRITICAL APPLICATIONS
// -- Xilinx products are not designed or intended to be fail-
// -- safe, or for use in any application requiring fail-safe
// -- performance, such as life-support or safety devices or
// -- systems, Class III medical devices, nuclear facilities,
// -- applications related to the deployment of airbags, or any
// -- other applications that could lead to death, personal
// -- injury, or severe property or environmental damage
// -- (individually and collectively, "Critical
// -- Applications"). Customer assumes the sole risk and
// -- liability of any use of Xilinx products in Critical
// -- Applications, subject only to applicable laws and
// -- regulations governing limitations on product liability.
// --
// -- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
// -- PART OF THIS FILE AT ALL TIMES.
//-----------------------------------------------------------------------------
//
// Description: Address Up-Sizer
//
//
// Verilog-standard:  Verilog 2001
//--------------------------------------------------------------------------
//
// Structure:
//   a_upsizer
//     generic_baseblocks/*
//
//--------------------------------------------------------------------------
`timescale 1ps/1ps


(* DowngradeIPIdentifiedWarnings="yes" *) 
module axi_interconnect_v1_7_13_a_upsizer #
  (
   parameter         C_FAMILY                         = "rtl", 
                       // FPGA Family. Current version: virtex6 or spartan6.
   parameter integer C_AXI_ID_WIDTH                 = 4, 
                       // Width of all ID signals on SI and MI side of converter.
                       // Range: >= 1.
   parameter integer C_AXI_ADDR_WIDTH                 = 32, 
                       // Width of all ADDR signals on SI and MI side of converter.
                       // Range: 32.
   parameter         C_S_AXI_DATA_WIDTH               = 32'h00000020, 
                       // Width of S_AXI_WDATA and S_AXI_RDATA.
                       // Format: Bit32; 
                       // Range: 'h00000020, 'h00000040, 'h00000080, 'h00000100.
   parameter         C_M_AXI_DATA_WIDTH               = 32'h00000040, 
                       // Width of M_AXI_WDATA and M_AXI_RDATA.
                       // Assume greater than or equal to C_S_AXI_DATA_WIDTH.
                       // Format: Bit32;
                       // Range: 'h00000020, 'h00000040, 'h00000080, 'h00000100.
   parameter integer C_M_AXI_REGISTER                 = 0,
                       // Clock output data.
                       // Range: 0, 1
   parameter integer C_AXI_SUPPORTS_USER_SIGNALS      = 0,
                       // 1 = Propagate all USER signals, 0 = Dont propagate.
   parameter integer C_AXI_AUSER_WIDTH                = 1,
                       // Width of AWUSER/ARUSER signals. 
                       // Range: >= 1.
   parameter integer C_AXI_CHANNEL                      = 0,
                       // 0 = AXI AW Channel.
                       // 1 = AXI AR Channel.
   parameter integer C_PACKING_LEVEL                    = 1,
                       // 0 = Never pack (expander only); packing logic is omitted.
                       // 1 = Pack only when CACHE[1] (Modifiable) is high.
                       // 2 = Always pack, regardless of sub-size transaction or Modifiable bit.
                       //     (Required when used as helper-core by mem-con.)
   parameter integer C_SUPPORT_BURSTS                 = 1,
                       // Disabled when all connected masters and slaves are AxiLite,
                       //   allowing logic to be simplified.
   parameter integer C_SINGLE_THREAD                  = 1,
                       // 0 = Ignore ID when propagating transactions (assume all responses are in order).
                       // 1 = Allow multiple outstanding transactions only if the IDs are the same
                       //   to prevent response reordering.
                       //   (If ID mismatches, stall until outstanding transaction counter = 0.)
   parameter integer C_S_AXI_BYTES_LOG                = 3,
                       // Log2 of number of 32bit word on SI-side.
   parameter integer C_M_AXI_BYTES_LOG                = 3
                       // Log2 of number of 32bit word on MI-side.
   )
  (
   // Global Signals
   input  wire                                                    ARESET,
   input  wire                                                    ACLK,

   // Command Interface
   output wire                              cmd_valid,
   output wire                              cmd_fix,
   output wire                              cmd_modified,
   output wire                              cmd_complete_wrap,
   output wire                              cmd_packed_wrap,
   output wire [C_M_AXI_BYTES_LOG-1:0]      cmd_first_word, 
   output wire [C_M_AXI_BYTES_LOG-1:0]      cmd_next_word, 
   output wire [C_M_AXI_BYTES_LOG-1:0]      cmd_last_word,
   output wire [C_M_AXI_BYTES_LOG-1:0]      cmd_offset,
   output wire [C_M_AXI_BYTES_LOG-1:0]      cmd_mask,
   output wire [C_S_AXI_BYTES_LOG:0]        cmd_step,
   output wire [8-1:0]                      cmd_length,
   input  wire                              cmd_ready,
   
   // Slave Interface Write Address Ports
   input  wire [C_AXI_ID_WIDTH-1:0]          S_AXI_AID,
   input  wire [C_AXI_ADDR_WIDTH-1:0]          S_AXI_AADDR,
   input  wire [8-1:0]                         S_AXI_ALEN,
   input  wire [3-1:0]                         S_AXI_ASIZE,
   input  wire [2-1:0]                         S_AXI_ABURST,
   input  wire [2-1:0]                         S_AXI_ALOCK,
   input  wire [4-1:0]                         S_AXI_ACACHE,
   input  wire [3-1:0]                         S_AXI_APROT,
   input  wire [4-1:0]                         S_AXI_AREGION,
   input  wire [4-1:0]                         S_AXI_AQOS,
   input  wire [C_AXI_AUSER_WIDTH-1:0]         S_AXI_AUSER,
   input  wire                                                   S_AXI_AVALID,
   output wire                                                   S_AXI_AREADY,

   // Master Interface Write Address Port
   output wire [C_AXI_ID_WIDTH-1:0]          M_AXI_AID,
   output wire [C_AXI_ADDR_WIDTH-1:0]          M_AXI_AADDR,
   output wire [8-1:0]                         M_AXI_ALEN,
   output wire [3-1:0]                         M_AXI_ASIZE,
   output wire [2-1:0]                         M_AXI_ABURST,
   output wire [2-1:0]                         M_AXI_ALOCK,
   output wire [4-1:0]                         M_AXI_ACACHE,
   output wire [3-1:0]                         M_AXI_APROT,
   output wire [4-1:0]                         M_AXI_AREGION,
   output wire [4-1:0]                         M_AXI_AQOS,
   output wire [C_AXI_AUSER_WIDTH-1:0]         M_AXI_AUSER,
   output wire                                                   M_AXI_AVALID,
   input  wire                                                   M_AXI_AREADY
   );
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Local params
  /////////////////////////////////////////////////////////////////////////////
  
  // Decode the native transaction size on the SI-side interface.
  localparam [3-1:0] C_S_AXI_NATIVE_SIZE = (C_S_AXI_DATA_WIDTH == 1024) ? 3'b111 :
                                           (C_S_AXI_DATA_WIDTH ==  512) ? 3'b110 :
                                           (C_S_AXI_DATA_WIDTH ==  256) ? 3'b101 :
                                           (C_S_AXI_DATA_WIDTH ==  128) ? 3'b100 :
                                           (C_S_AXI_DATA_WIDTH ==   64) ? 3'b011 :
                                           (C_S_AXI_DATA_WIDTH ==   32) ? 3'b010 :
                                           (C_S_AXI_DATA_WIDTH ==   16) ? 3'b001 :
                                           3'b000;
  
  // Decode the native transaction size on the MI-side interface.
  localparam [3-1:0] C_M_AXI_NATIVE_SIZE = (C_M_AXI_DATA_WIDTH == 1024) ? 3'b111 :
                                           (C_M_AXI_DATA_WIDTH ==  512) ? 3'b110 :
                                           (C_M_AXI_DATA_WIDTH ==  256) ? 3'b101 :
                                           (C_M_AXI_DATA_WIDTH ==  128) ? 3'b100 :
                                           (C_M_AXI_DATA_WIDTH ==   64) ? 3'b011 :
                                           (C_M_AXI_DATA_WIDTH ==   32) ? 3'b010 :
                                           (C_M_AXI_DATA_WIDTH ==   16) ? 3'b001 :
                                           3'b000;
  
  // Constants used to generate maximum length on SI-side for complete wrap.
  localparam [24-1:0] C_DOUBLE_LEN       = 24'b0000_0000_0000_0000_1111_1111;
  
  // Constants for burst types.
  localparam [2-1:0] C_FIX_BURST         = 2'b00;
  localparam [2-1:0] C_INCR_BURST        = 2'b01;
  localparam [2-1:0] C_WRAP_BURST        = 2'b10;
  
  // Constants for packing levels.
  localparam integer C_NEVER_PACK        = 0;
  localparam integer C_DEFAULT_PACK      = 1;
  localparam integer C_ALWAYS_PACK       = 2;
  
  // Depth for command FIFO.
  localparam integer C_FIFO_DEPTH_LOG    = 5;
  
  // Maximum address bit coverage by WRAP.
  localparam integer C_BURST_BYTES_LOG   = 4 + C_S_AXI_BYTES_LOG;
  
  // Calculate unused address bits.
  localparam integer C_SI_UNUSED_LOG     = C_AXI_ADDR_WIDTH-C_S_AXI_BYTES_LOG;
  localparam integer C_MI_UNUSED_LOG     = C_AXI_ADDR_WIDTH-C_M_AXI_BYTES_LOG;
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Variables for generating parameter controlled instances.
  /////////////////////////////////////////////////////////////////////////////
  
  genvar bit_cnt;
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Functions
  /////////////////////////////////////////////////////////////////////////////
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Internal signals
  /////////////////////////////////////////////////////////////////////////////
  
  // Access decoding related signals.
  wire                                access_is_fix;
  wire                                access_is_incr;
  wire                                access_is_wrap;
  wire                                access_is_modifiable;
  wire                                access_is_unaligned;
  reg  [8-1:0]                        si_maximum_length;
  wire [16-1:0]                       mi_word_intra_len_complete;
  wire [20-1:0]                       mask_help_vector;
  reg  [C_M_AXI_BYTES_LOG-1:0]        mi_word_intra_len;
  reg  [8-1:0]                        upsized_length;
  wire                                sub_sized_wrap;
  reg  [C_M_AXI_BYTES_LOG-1:0]        size_mask;
  reg  [C_BURST_BYTES_LOG-1:0]        burst_mask;
  
  // Translation related signals.
  wire                                access_need_extra_word;
  wire [8-1:0]                        adjusted_length;
  wire [C_BURST_BYTES_LOG-1:0]        wrap_addr_aligned;
  
  // Command buffer help signals.
  wire                                cmd_empty;
  reg  [C_AXI_ID_WIDTH-1:0]           queue_id;
  wire                                id_match;
  wire                                cmd_id_check;
  wire                                s_ready;
  wire                                cmd_full;
  wire                                allow_new_cmd;
  wire                                cmd_push;
  reg                                 cmd_push_block;
  
  // Internal Command Interface signals.
  wire                                cmd_valid_i;
  wire                                cmd_fix_i;
  wire                                cmd_modified_i;
  wire                                cmd_complete_wrap_i;
  wire                                cmd_packed_wrap_i;
  wire [C_M_AXI_BYTES_LOG-1:0]        cmd_first_word_ii;
  wire [C_M_AXI_BYTES_LOG-1:0]        cmd_first_word_i;
  wire [C_M_AXI_BYTES_LOG-1:0]        cmd_next_word_ii;
  wire [C_M_AXI_BYTES_LOG-1:0]        cmd_next_word_i;
  wire [C_M_AXI_BYTES_LOG:0]          cmd_last_word_ii;
  wire [C_M_AXI_BYTES_LOG-1:0]        cmd_last_word_i;
  wire [C_M_AXI_BYTES_LOG-1:0]        cmd_offset_i;
  reg  [C_M_AXI_BYTES_LOG-1:0]        cmd_mask_i;
  wire [3-1:0]                        cmd_size_i;
  wire [3-1:0]                        cmd_size;
  reg  [8-1:0]                        cmd_step_ii;
  wire [C_S_AXI_BYTES_LOG:0]          cmd_step_i;
  reg  [8-1:0]                        cmd_length_i;
  
  // Internal SI-side signals.
  wire                                S_AXI_AREADY_I;
   
  // Internal MI-side signals.
  wire [C_AXI_ID_WIDTH-1:0]           M_AXI_AID_I;
  reg  [C_AXI_ADDR_WIDTH-1:0]         M_AXI_AADDR_I;
  reg  [8-1:0]                        M_AXI_ALEN_I;
  reg  [3-1:0]                        M_AXI_ASIZE_I;
  reg  [2-1:0]                        M_AXI_ABURST_I;
  wire [2-1:0]                        M_AXI_ALOCK_I;
  wire [4-1:0]                        M_AXI_ACACHE_I;
  wire [3-1:0]                        M_AXI_APROT_I;
  wire [4-1:0]                        M_AXI_AREGION_I;
  wire [4-1:0]                        M_AXI_AQOS_I;
  wire [C_AXI_AUSER_WIDTH-1:0]        M_AXI_AUSER_I;
  wire                                M_AXI_AVALID_I;
  wire                                M_AXI_AREADY_I;
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Decode the incoming transaction:
  //
  // Determine the burst type sucha as FIX, INCR and WRAP. Only WRAP and INCR 
  // transactions can be upsized to the MI-side data width.
  // Detect if the transaction is modifiable and if it is of native size. Only
  // native sized transaction are upsized when allowed, unless forced by 
  // parameter. FIX can never be upsized (packed) regardless if force is 
  // turned on. However the FIX data will be steered to the correct 
  // byte lane(s) and the transaction will be native on MI-side when 
  // applicable.
  //
  // Calculate the MI-side length for the SI-side transaction.
  // 
  // Decode the affected address bits in the MI-side. Used to determine last 
  // word for a burst and if necassarily adjust the length of the upsized 
  // transaction. Length adjustment only occurs when the trasaction is longer 
  // than can fit in MI-side and there is an unalignment for the first word
  // (and the last word crosses MI-word boundary and wraps).
  // 
  // The maximum allowed SI-side length is calculated to be able to determine 
  // if a WRAP transaction can fit inside a single MI-side data word.
  // 
  // Determine address bits mask for the SI-side transaction size, i.e. address
  // bits that shall be removed for unalignment when managing data in W and 
  // R channels. For example: the two least significant bits are not used 
  // for data packing in a 32-bit SI-side transaction (address 1-3 will appear
  // as 0 for the W and R channels, but the untouched address is still forwarded 
  // to the MI-side).
  // 
  // Determine the Mask bits for the address bits that are affected by a
  // sub-sized WRAP transaction (up to and including complete WRAP). The Mask 
  // is used to generate the correct data mapping for a sub-sized and
  // complete WRAP, i.e. having a local wrap in a partial MI-side word.
  // 
  // Detect any SI-side address unalignment when used on the MI-side.
  // 
  /////////////////////////////////////////////////////////////////////////////
  
  // Transaction burst type.
  assign access_is_fix          = ( S_AXI_ABURST == C_FIX_BURST );
  assign access_is_incr         = ( S_AXI_ABURST == C_INCR_BURST );
  assign access_is_wrap         = ( S_AXI_ABURST == C_WRAP_BURST );
  assign cmd_fix_i              = access_is_fix;
  
  // Get if it is allowed to modify transaction.
  assign access_is_modifiable   = S_AXI_ACACHE[1];
  
  // Get SI-side maximum length to fit MI-side.
  always @ *
  begin
    case (S_AXI_ASIZE)
      3'b000: si_maximum_length = C_S_AXI_NATIVE_SIZE >= 3'b000 ? C_DOUBLE_LEN[ 8-C_M_AXI_BYTES_LOG +: 8] : 8'b0;
      3'b001: si_maximum_length = C_S_AXI_NATIVE_SIZE >= 3'b001 ? C_DOUBLE_LEN[ 9-C_M_AXI_BYTES_LOG +: 8] : 8'b0;
      3'b010: si_maximum_length = C_S_AXI_NATIVE_SIZE >= 3'b010 ? C_DOUBLE_LEN[10-C_M_AXI_BYTES_LOG +: 8] : 8'b0;
      3'b011: si_maximum_length = C_S_AXI_NATIVE_SIZE >= 3'b011 ? C_DOUBLE_LEN[11-C_M_AXI_BYTES_LOG +: 8] : 8'b0;
      3'b100: si_maximum_length = C_S_AXI_NATIVE_SIZE >= 3'b100 ? C_DOUBLE_LEN[12-C_M_AXI_BYTES_LOG +: 8] : 8'b0;
      3'b101: si_maximum_length = C_S_AXI_NATIVE_SIZE >= 3'b101 ? C_DOUBLE_LEN[13-C_M_AXI_BYTES_LOG +: 8] : 8'b0;
      3'b110: si_maximum_length = C_S_AXI_NATIVE_SIZE >= 3'b110 ? C_DOUBLE_LEN[14-C_M_AXI_BYTES_LOG +: 8] : 8'b0;
      3'b111: si_maximum_length = C_S_AXI_NATIVE_SIZE >= 3'b111 ? C_DOUBLE_LEN[15-C_M_AXI_BYTES_LOG +: 8] : 8'b0;
    endcase
  end
  
  // Help vector to determine the length of thransaction in the MI-side domain.
  assign mi_word_intra_len_complete = {S_AXI_ALEN, 8'b0};
  
  // Get intra MI-side word length bits (in bytes).
  always @ *
  begin
    if ( C_SUPPORT_BURSTS == 1 ) begin
      if ( ~cmd_fix_i ) begin
        case (S_AXI_ASIZE)
          3'b000: mi_word_intra_len = C_S_AXI_NATIVE_SIZE >= 3'b000 ? 
                                      mi_word_intra_len_complete[8-0 +: C_M_AXI_BYTES_LOG] : {C_M_AXI_BYTES_LOG{1'b0}};
          3'b001: mi_word_intra_len = C_S_AXI_NATIVE_SIZE >= 3'b001 ? 
                                      mi_word_intra_len_complete[8-1 +: C_M_AXI_BYTES_LOG] : {C_M_AXI_BYTES_LOG{1'b0}};
          3'b010: mi_word_intra_len = C_S_AXI_NATIVE_SIZE >= 3'b010 ? 
                                      mi_word_intra_len_complete[8-2 +: C_M_AXI_BYTES_LOG] : {C_M_AXI_BYTES_LOG{1'b0}};
          3'b011: mi_word_intra_len = C_S_AXI_NATIVE_SIZE >= 3'b011 ? 
                                      mi_word_intra_len_complete[8-3 +: C_M_AXI_BYTES_LOG] : {C_M_AXI_BYTES_LOG{1'b0}};
          3'b100: mi_word_intra_len = C_S_AXI_NATIVE_SIZE >= 3'b100 ? 
                                      mi_word_intra_len_complete[8-4 +: C_M_AXI_BYTES_LOG] : {C_M_AXI_BYTES_LOG{1'b0}};
          3'b101: mi_word_intra_len = C_S_AXI_NATIVE_SIZE >= 3'b101 ? 
                                      mi_word_intra_len_complete[8-5 +: C_M_AXI_BYTES_LOG] : {C_M_AXI_BYTES_LOG{1'b0}};
          3'b110: mi_word_intra_len = C_S_AXI_NATIVE_SIZE >= 3'b110 ? 
                                      mi_word_intra_len_complete[8-6 +: C_M_AXI_BYTES_LOG] : {C_M_AXI_BYTES_LOG{1'b0}};
          3'b111: mi_word_intra_len = C_S_AXI_NATIVE_SIZE >= 3'b111 ? 
                                      mi_word_intra_len_complete[8-7 +: C_M_AXI_BYTES_LOG] : {C_M_AXI_BYTES_LOG{1'b0}};  // Illegal setting.
        endcase
      end else begin
        mi_word_intra_len = {C_M_AXI_BYTES_LOG{1'b0}};
      end
    end else begin
      mi_word_intra_len = {C_M_AXI_BYTES_LOG{1'b0}};
    end
  end
  
  // Get MI-side length after upsizing.
  always @ *
  begin
    if ( C_SUPPORT_BURSTS == 1 ) begin
      if ( cmd_fix_i | ~cmd_modified_i ) begin
        // Fix has to maintain length even if forced packing.
        upsized_length = S_AXI_ALEN;
      end else begin
        case (S_AXI_ASIZE)
          3'b000: upsized_length = C_S_AXI_NATIVE_SIZE >= 3'b000 ? 
                                   (S_AXI_ALEN >> C_M_AXI_BYTES_LOG-0) : 8'b0;
          3'b001: upsized_length = C_S_AXI_NATIVE_SIZE >= 3'b001 ? 
                                   (S_AXI_ALEN >> C_M_AXI_BYTES_LOG-1) : 8'b0;
          3'b010: upsized_length = C_S_AXI_NATIVE_SIZE >= 3'b010 ? 
                                   (S_AXI_ALEN >> C_M_AXI_BYTES_LOG-2) : 8'b0;
          3'b011: upsized_length = C_S_AXI_NATIVE_SIZE >= 3'b011 ? 
                                   (S_AXI_ALEN >> C_M_AXI_BYTES_LOG-3) : 8'b0;
          3'b100: upsized_length = C_S_AXI_NATIVE_SIZE >= 3'b100 ? 
                                   (S_AXI_ALEN >> C_M_AXI_BYTES_LOG-4) : 8'b0;
          3'b101: upsized_length = C_S_AXI_NATIVE_SIZE >= 3'b101 ? 
                                   (S_AXI_ALEN >> C_M_AXI_BYTES_LOG-5) : 8'b0;
          3'b110: upsized_length = C_S_AXI_NATIVE_SIZE >= 3'b110 ? 
                                   (S_AXI_ALEN >> C_M_AXI_BYTES_LOG-6) : 8'b0;
          3'b111: upsized_length = C_S_AXI_NATIVE_SIZE >= 3'b111 ? 
                                   (S_AXI_ALEN                       ) : 8'b0;  // Illegal setting.
        endcase
      end
    end else begin
      upsized_length = 8'b0;
    end
  end
  
  // Generate address bits used for SI-side transaction size.
  always @ *
  begin
    case (S_AXI_ASIZE)
      3'b000: size_mask = ~C_DOUBLE_LEN[8 +: C_S_AXI_BYTES_LOG];
      3'b001: size_mask = ~C_DOUBLE_LEN[7 +: C_S_AXI_BYTES_LOG];
      3'b010: size_mask = ~C_DOUBLE_LEN[6 +: C_S_AXI_BYTES_LOG];
      3'b011: size_mask = ~C_DOUBLE_LEN[5 +: C_S_AXI_BYTES_LOG];
      3'b100: size_mask = ~C_DOUBLE_LEN[4 +: C_S_AXI_BYTES_LOG];
      3'b101: size_mask = ~C_DOUBLE_LEN[3 +: C_S_AXI_BYTES_LOG];
      3'b110: size_mask = ~C_DOUBLE_LEN[2 +: C_S_AXI_BYTES_LOG];
      3'b111: size_mask = ~C_DOUBLE_LEN[1 +: C_S_AXI_BYTES_LOG];  // Illegal setting.
    endcase
  end
  
  // Help vector to determine the length of thransaction in the MI-side domain.
  assign mask_help_vector = {4'b0, S_AXI_ALEN, 8'b1};
  
  // Calculate the address bits that are affected when a complete wrap is detected.
  always @ *
  begin
    if ( sub_sized_wrap & ( C_SUPPORT_BURSTS == 1 ) ) begin
      case (S_AXI_ASIZE)
        3'b000: cmd_mask_i = C_S_AXI_NATIVE_SIZE >= 3'b000 ? 
                             mask_help_vector[8-0 +: C_M_AXI_BYTES_LOG] : {C_M_AXI_BYTES_LOG{1'b0}};
        3'b001: cmd_mask_i = C_S_AXI_NATIVE_SIZE >= 3'b000 ? 
                             mask_help_vector[8-1 +: C_M_AXI_BYTES_LOG] : {C_M_AXI_BYTES_LOG{1'b0}};
        3'b010: cmd_mask_i = C_S_AXI_NATIVE_SIZE >= 3'b000 ? 
                             mask_help_vector[8-2 +: C_M_AXI_BYTES_LOG] : {C_M_AXI_BYTES_LOG{1'b0}};
        3'b011: cmd_mask_i = C_S_AXI_NATIVE_SIZE >= 3'b000 ? 
                             mask_help_vector[8-3 +: C_M_AXI_BYTES_LOG] : {C_M_AXI_BYTES_LOG{1'b0}};
        3'b100: cmd_mask_i = C_S_AXI_NATIVE_SIZE >= 3'b000 ? 
                             mask_help_vector[8-4 +: C_M_AXI_BYTES_LOG] : {C_M_AXI_BYTES_LOG{1'b0}};
        3'b101: cmd_mask_i = C_S_AXI_NATIVE_SIZE >= 3'b000 ? 
                             mask_help_vector[8-5 +: C_M_AXI_BYTES_LOG] : {C_M_AXI_BYTES_LOG{1'b0}};
        3'b110: cmd_mask_i = C_S_AXI_NATIVE_SIZE >= 3'b000 ? 
                             mask_help_vector[8-6 +: C_M_AXI_BYTES_LOG] : {C_M_AXI_BYTES_LOG{1'b0}};
        3'b111: cmd_mask_i = C_S_AXI_NATIVE_SIZE >= 3'b000 ? 
                             mask_help_vector[8-7 +: C_M_AXI_BYTES_LOG] : {C_M_AXI_BYTES_LOG{1'b0}};  // Illegal setting.
      endcase
    end else begin
      cmd_mask_i = {C_M_AXI_BYTES_LOG{1'b1}};
    end
  end

  // Calculate the address bits that are affected when a complete wrap is detected.
  always @ *
  begin
    case (S_AXI_ASIZE)
      3'b000: burst_mask = C_S_AXI_NATIVE_SIZE >= 3'b000 ? 
                           mask_help_vector[8-0 +: C_BURST_BYTES_LOG] : {C_BURST_BYTES_LOG{1'b0}};
      3'b001: burst_mask = C_S_AXI_NATIVE_SIZE >= 3'b000 ? 
                           mask_help_vector[8-1 +: C_BURST_BYTES_LOG] : {C_BURST_BYTES_LOG{1'b0}};
      3'b010: burst_mask = C_S_AXI_NATIVE_SIZE >= 3'b000 ? 
                           mask_help_vector[8-2 +: C_BURST_BYTES_LOG] : {C_BURST_BYTES_LOG{1'b0}};
      3'b011: burst_mask = C_S_AXI_NATIVE_SIZE >= 3'b000 ? 
                           mask_help_vector[8-3 +: C_BURST_BYTES_LOG] : {C_BURST_BYTES_LOG{1'b0}};
      3'b100: burst_mask = C_S_AXI_NATIVE_SIZE >= 3'b000 ? 
                           mask_help_vector[8-4 +: C_BURST_BYTES_LOG] : {C_BURST_BYTES_LOG{1'b0}};
      3'b101: burst_mask = C_S_AXI_NATIVE_SIZE >= 3'b000 ? 
                           mask_help_vector[8-5 +: C_BURST_BYTES_LOG] : {C_BURST_BYTES_LOG{1'b0}};
      3'b110: burst_mask = C_S_AXI_NATIVE_SIZE >= 3'b000 ? 
                           mask_help_vector[8-6 +: C_BURST_BYTES_LOG] : {C_BURST_BYTES_LOG{1'b0}};
      3'b111: burst_mask = C_S_AXI_NATIVE_SIZE >= 3'b000 ? 
                           mask_help_vector[8-7 +: C_BURST_BYTES_LOG] : {C_BURST_BYTES_LOG{1'b0}};  // Illegal setting.
    endcase
  end

  // Propagate the SI-side size of the transaction.
  assign cmd_size_i = S_AXI_ASIZE;
  
  // Detect if there is any unalignment in regards to the MI-side.
  assign access_is_unaligned = ( S_AXI_AADDR[0 +: C_M_AXI_BYTES_LOG] != {C_M_AXI_BYTES_LOG{1'b0}} );
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Evaluate if transaction is to be translated:
  // * Forcefully translate when C_PACKING_LEVEL is set to C_ALWAYS_PACK. 
  // * When SI-side transaction size is native, it is allowed and default 
  //   packing is set. (Expander mode never packs).
  //
  /////////////////////////////////////////////////////////////////////////////
  
  // Modify transaction forcefully or when transaction allows it
  assign cmd_modified_i = ~access_is_fix &
                          ( ( C_PACKING_LEVEL == C_ALWAYS_PACK  ) | 
                            ( access_is_modifiable & ( S_AXI_ALEN != 8'b0 ) & ( C_PACKING_LEVEL == C_DEFAULT_PACK ) ) );
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Translate SI-side access to MI-side:
  //
  // Detemine if this is a complete WRAP. Conditions are that it must fit 
  // inside a single MI-side data word, it must be a WRAP access and that
  // bursts are allowed. Without burst there can never be a WRAP access.
  //
  // Determine if this ia a packed WRAP, i.e. a WRAP that is to large to 
  // be a complete wrap and it is unaligned SI-side address relative to 
  // the native MI-side data width.
  //
  // The address for the First SI-side data word is adjusted to when there 
  // is a complete WRAP, otherwise it only the least significant bits of the 
  // SI-side address.
  // For complete WRAP access the Offset is generated as the most significant 
  // bits that are left by the Mask.
  // Last address is calculated with the adjusted First word address.
  //
  // The Adjusted MI-side burst length is calculated as the Upsized length
  // plus one when the SI-side data must wrap on the MI-side (unless it is
  // a complete or packed WRAP).
  // 
  // Depending on the conditions some of the forwarded MI-side tranaction 
  // and Command Queue parameters has to be adjusted:
  // * For unmodified transaction the parameter are left un affected.
  //   (M_AXI_AADDR, M_AXI_ASIZE, M_AXI_ABURST, M_AXI_ALEN and cmd_length 
  //    are untouched)
  // * For complete WRAP transactions the burst type is changed to INCR
  //   and the address is adjusted to the sub-size affected by the transaction
  //   (the sub-size can be 2 bytes up to a full MI-side data word).
  //   The size is set to the native MI-side transaction size. And the length
  //   is set to the calculated upsized length.
  // * For all other modified transations the address and burst type remains 
  //   the same. The length is adjusted to the previosly described length
  //   and size is set to native MI-side transaction size.
  //
  /////////////////////////////////////////////////////////////////////////////
  
  // Detemine if this is a sub-sized transaction.
  assign sub_sized_wrap         = access_is_wrap & ( S_AXI_ALEN <= si_maximum_length ) & 
                                  ( C_SUPPORT_BURSTS == 1);
  
  // See if entite burst can fit inside one MI-side word.
  assign cmd_complete_wrap_i    = cmd_modified_i & sub_sized_wrap;
  
  // Detect if this is a packed WRAP (multiple MI-side words).
  assign cmd_packed_wrap_i      = cmd_modified_i & access_is_wrap & ( S_AXI_ALEN > si_maximum_length ) & 
                                  access_is_unaligned & ( C_SUPPORT_BURSTS == 1);
  
  // Get unalignment address bits (including aligning it inside covered area).
  assign cmd_first_word_ii      = S_AXI_AADDR[C_M_AXI_BYTES_LOG-1:0];
  assign cmd_first_word_i       = cmd_first_word_ii & cmd_mask_i & size_mask;
  
  // Generate next word address.
  assign cmd_next_word_ii       = cmd_first_word_ii + cmd_step_ii[C_M_AXI_BYTES_LOG-1:0];
  assign cmd_next_word_i        = cmd_next_word_ii & cmd_mask_i & size_mask;
  
  // Offset is the bits that is outside of the Mask.
  assign cmd_offset_i           = cmd_first_word_ii & ~cmd_mask_i;
  
  // Select RTL or Optimized implementation.
  generate
    if ( C_FAMILY == "rtl" ) begin : USE_RTL_ADJUSTED_LEN
      // Calculate Last word on MI-side.
      assign cmd_last_word_ii       = cmd_first_word_i + mi_word_intra_len;
      assign cmd_last_word_i        = cmd_last_word_ii[C_M_AXI_BYTES_LOG-1:0] & cmd_mask_i & size_mask;
      
      // Detect if extra word on MI-side is needed.
      assign access_need_extra_word = cmd_last_word_ii[C_M_AXI_BYTES_LOG] & 
                                      access_is_incr & cmd_modified_i;
      
      // Calculate true length of modified transaction.
      assign adjusted_length        = upsized_length + access_need_extra_word;
          
    end else begin : USE_FPGA_ADJUSTED_LEN
      
      wire [C_M_AXI_BYTES_LOG:0]          last_word_local_carry;
      wire [C_M_AXI_BYTES_LOG-1:0]        last_word_sel;
      wire [C_M_AXI_BYTES_LOG:0]          last_word_for_mask_local_carry;
      wire [C_M_AXI_BYTES_LOG-1:0]        last_word_for_mask_dummy_carry1;
      wire [C_M_AXI_BYTES_LOG-1:0]        last_word_for_mask_dummy_carry2;
      wire [C_M_AXI_BYTES_LOG-1:0]        last_word_for_mask_dummy_carry3;
      wire [C_M_AXI_BYTES_LOG-1:0]        last_word_for_mask_sel;
      wire [C_M_AXI_BYTES_LOG-1:0]        last_word_for_mask;
      wire [C_M_AXI_BYTES_LOG-1:0]        last_word_mask;
      wire                                sel_access_need_extra_word;
      wire [8:0]                          adjusted_length_local_carry;
      wire [8-1:0]                        adjusted_length_sel;
    
      
      assign last_word_local_carry[0] = 1'b0;
      assign last_word_for_mask_local_carry[0] = 1'b0;
      
      for (bit_cnt = 0; bit_cnt < C_M_AXI_BYTES_LOG ; bit_cnt = bit_cnt + 1) begin : LUT_LAST_MASK
        
        assign last_word_for_mask_sel[bit_cnt]  = cmd_first_word_ii[bit_cnt] ^ mi_word_intra_len[bit_cnt];
        assign last_word_mask[bit_cnt]          = cmd_mask_i[bit_cnt] & size_mask[bit_cnt];
        
        MUXCY and_inst1 
        (
         .O (last_word_for_mask_dummy_carry1[bit_cnt]), 
         .CI (last_word_for_mask_local_carry[bit_cnt]), 
         .DI (mi_word_intra_len[bit_cnt]), 
         .S (last_word_for_mask_sel[bit_cnt])
        ); 
        
        MUXCY and_inst2 
        (
         .O (last_word_for_mask_dummy_carry2[bit_cnt]), 
         .CI (last_word_for_mask_dummy_carry1[bit_cnt]), 
         .DI (1'b0), 
         .S (1'b1)
        ); 
        
        MUXCY and_inst3 
        (
         .O (last_word_for_mask_dummy_carry3[bit_cnt]), 
         .CI (last_word_for_mask_dummy_carry2[bit_cnt]), 
         .DI (1'b0), 
         .S (1'b1)
        ); 
        
        MUXCY and_inst4 
        (
         .O (last_word_for_mask_local_carry[bit_cnt+1]), 
         .CI (last_word_for_mask_dummy_carry3[bit_cnt]), 
         .DI (1'b0), 
         .S (1'b1)
        ); 
        
        XORCY xorcy_inst 
        (
         .O(last_word_for_mask[bit_cnt]),
         .CI(last_word_for_mask_local_carry[bit_cnt]),
         .LI(last_word_for_mask_sel[bit_cnt])
        );
        
  axi_interconnect_v1_7_13_carry_latch_and #
          (
           .C_FAMILY(C_FAMILY)
           ) last_mask_inst
          (
           .CIN(last_word_for_mask[bit_cnt]),
           .I(last_word_mask[bit_cnt]),
           .O(cmd_last_word_i[bit_cnt])
           );
           
      end // end for bit_cnt
      
      for (bit_cnt = 0; bit_cnt < C_M_AXI_BYTES_LOG ; bit_cnt = bit_cnt + 1) begin : LUT_LAST
        
        assign last_word_sel[bit_cnt] = cmd_first_word_ii[bit_cnt] ^ mi_word_intra_len[bit_cnt];
        
        MUXCY and_inst 
        (
         .O (last_word_local_carry[bit_cnt+1]), 
         .CI (last_word_local_carry[bit_cnt]), 
         .DI (mi_word_intra_len[bit_cnt]), 
         .S (last_word_sel[bit_cnt])
        ); 
        
        XORCY xorcy_inst 
        (
         .O(cmd_last_word_ii[bit_cnt]),
         .CI(last_word_local_carry[bit_cnt]),
         .LI(last_word_sel[bit_cnt])
        );
        
      end // end for bit_cnt
      
      assign sel_access_need_extra_word = access_is_incr & cmd_modified_i;
      
  axi_interconnect_v1_7_13_carry_and #
        (
         .C_FAMILY(C_FAMILY)
         ) access_need_extra_word_inst
        (
         .CIN(last_word_local_carry[C_M_AXI_BYTES_LOG]),
         .S(sel_access_need_extra_word),
         .COUT(adjusted_length_local_carry[0])
         );
         
      for (bit_cnt = 0; bit_cnt < 8 ; bit_cnt = bit_cnt + 1) begin : LUT_ADJUST
        
        assign adjusted_length_sel[bit_cnt] = ( upsized_length[bit_cnt] &  cmd_modified_i) |
                                              ( S_AXI_ALEN[bit_cnt]     & ~cmd_modified_i);
        
        MUXCY and_inst 
        (
         .O (adjusted_length_local_carry[bit_cnt+1]), 
         .CI (adjusted_length_local_carry[bit_cnt]), 
         .DI (1'b0), 
         .S (adjusted_length_sel[bit_cnt])
        ); 
        
        XORCY xorcy_inst 
        (
         .O(adjusted_length[bit_cnt]),
         .CI(adjusted_length_local_carry[bit_cnt]),
         .LI(adjusted_length_sel[bit_cnt])
        );
        
      end // end for bit_cnt
      
    end
  endgenerate
  
  // Generate adjusted wrap address.
  assign wrap_addr_aligned      = ( C_AXI_CHANNEL != 0 ) ? 
                                  ( S_AXI_AADDR[0 +: C_BURST_BYTES_LOG] ) :
                                  ( S_AXI_AADDR[0 +: C_BURST_BYTES_LOG] + ( 2 ** C_M_AXI_BYTES_LOG ) );
  
  // Select directly forwarded or modified transaction.
  always @ *
  begin
    if ( cmd_modified_i ) begin
      // SI to MI-side transaction translation.
      if ( cmd_complete_wrap_i ) begin
        // Complete wrap is turned into incr
        M_AXI_AADDR_I  = S_AXI_AADDR & {{C_MI_UNUSED_LOG{1'b1}}, ~cmd_mask_i};
        M_AXI_ABURST_I = C_INCR_BURST;
        
      end else begin
        // Retain the currenent 
        if ( cmd_packed_wrap_i ) begin
            M_AXI_AADDR_I  = {S_AXI_AADDR[C_BURST_BYTES_LOG +: C_AXI_ADDR_WIDTH-C_BURST_BYTES_LOG], 
                              (S_AXI_AADDR[0 +: C_BURST_BYTES_LOG] & ~burst_mask) | (wrap_addr_aligned & burst_mask) } & 
                             {{C_MI_UNUSED_LOG{1'b1}}, ~cmd_mask_i};
        end else begin
          M_AXI_AADDR_I  = S_AXI_AADDR;
        end
        M_AXI_ABURST_I = S_AXI_ABURST;
        
      end
      
      M_AXI_ASIZE_I  = C_M_AXI_NATIVE_SIZE;
    end else begin
      // SI to MI-side transaction forwarding.
      M_AXI_AADDR_I  = S_AXI_AADDR;
      M_AXI_ASIZE_I  = S_AXI_ASIZE;
      M_AXI_ABURST_I = S_AXI_ABURST;
    end
    
    M_AXI_ALEN_I   = adjusted_length;
    cmd_length_i   = adjusted_length;
  end
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Forward the command to the MI-side interface.
  //
  // It is determined that this is an allowed command/access when there is 
  // room in the command queue (and it passes any ID checks as required).
  //
  /////////////////////////////////////////////////////////////////////////////
  
  // Select RTL or Optimized implementation.
  generate
    if ( C_FAMILY == "rtl" || ( C_SINGLE_THREAD == 0 ) ) begin : USE_RTL_AVALID
      // Only allowed to forward translated command when command queue is ok with it.
      assign M_AXI_AVALID_I = allow_new_cmd & S_AXI_AVALID;
      
    end else begin : USE_FPGA_AVALID
      
      wire sel_s_axi_avalid;
      
      assign sel_s_axi_avalid = S_AXI_AVALID & ~ARESET;
      
  axi_interconnect_v1_7_13_carry_and #
        (
         .C_FAMILY(C_FAMILY)
         ) avalid_inst
        (
         .CIN(allow_new_cmd),
         .S(sel_s_axi_avalid),
         .COUT(M_AXI_AVALID_I)
         );
      
    end
  endgenerate
                          
  
  /////////////////////////////////////////////////////////////////////////////
  // Simple transfer of paramters that doesn't need to be adjusted.
  //
  // ID     - Transaction still recognized with the same ID.
  // LOCK   - No need to change exclusive or barrier transactions.
  // CACHE  - No need to change the chache features. Even if the modyfiable
  //          bit is overridden (forcefully) there is no need to let downstream
  //          component beleive it is ok to modify it further.
  // PROT   - Security level of access is not changed when upsizing.
  // REGION - Address region stays the same.
  // QOS    - Quality of Service remains the same.
  // USER   - User bits remains the same.
  // 
  /////////////////////////////////////////////////////////////////////////////
  
  assign M_AXI_AID_I      = S_AXI_AID;
  assign M_AXI_ALOCK_I    = S_AXI_ALOCK;
  assign M_AXI_ACACHE_I   = S_AXI_ACACHE;
  assign M_AXI_APROT_I    = S_AXI_APROT;
  assign M_AXI_AREGION_I  = S_AXI_AREGION;
  assign M_AXI_AQOS_I     = S_AXI_AQOS;
  assign M_AXI_AUSER_I    = ( C_AXI_SUPPORTS_USER_SIGNALS ) ? S_AXI_AUSER : {C_AXI_AUSER_WIDTH{1'b0}};
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Command queue to W/R channel.
  // 
  // Commands can be pushed into the Cmd FIFO even if MI-side is stalling.
  // A flag is set if MI-side is stalling when Command is pushed to the 
  // Cmd FIFO. This will prevent multiple push of the same Command as well as
  // keeping the MI-side Valid signal if the Allow Cmd requirement has been 
  // updated to disable furter Commands (I.e. it is made sure that the SI-side 
  // Command has been forwarded to both Cmd FIFO and MI-side).
  // 
  // It is allowed to continue pushing new commands as long as
  // * There is room in the queue
  // * The ID is the same as previously queued. Since data is not reordered
  //   for the same ID it is ok to let them proceed.
  //
  /////////////////////////////////////////////////////////////////////////////
  
  // Keep track of current ID in queue.
  always @ (posedge ACLK) begin
    if (ARESET) begin
      queue_id <= {C_AXI_ID_WIDTH{1'b0}};
    end else begin
      if ( cmd_push ) begin
        // Store ID (it will be matching ID or a "new beginning").
        queue_id <= S_AXI_AID;
      end
    end
  end
  
  // Select RTL or Optimized implementation.
  generate
    if ( C_FAMILY == "rtl" || ( C_SINGLE_THREAD == 0 ) ) begin : USE_RTL_ID_MATCH
      // Check ID to make sure this command is allowed.
      assign id_match       = ( C_SINGLE_THREAD == 0 ) | ( queue_id == S_AXI_AID);
      assign cmd_id_check   = cmd_empty | ( id_match & ~cmd_empty );
      
      // Check if it is allowed to push more commands (ID is allowed and there is room in the queue).
      assign allow_new_cmd  = (~cmd_full & cmd_id_check) | cmd_push_block;
      
      // Push new command when allowed and MI-side is able to receive the command.
      assign cmd_push       = M_AXI_AVALID_I & ~cmd_push_block;
      
    end else begin : USE_FPGA_ID_MATCH
      
      wire cmd_id_check_i;
      wire allow_new_cmd_i;
      wire sel_cmd_id_check;
      wire sel_cmd_push;
      
  axi_interconnect_v1_7_13_comparator #
        (
         .C_FAMILY(C_FAMILY),
         .C_DATA_WIDTH(C_AXI_ID_WIDTH)
         ) id_match_inst
        (
         .CIN(1'b1),
         .A(queue_id),
         .B(S_AXI_AID),
         .COUT(id_match)
         );
         
      assign sel_cmd_id_check = ~cmd_empty;
      
  axi_interconnect_v1_7_13_carry_and #
        (
         .C_FAMILY(C_FAMILY)
         ) cmd_id_check_inst_1
        (
         .CIN(id_match),
         .S(sel_cmd_id_check),
         .COUT(cmd_id_check_i)
         );

  axi_interconnect_v1_7_13_carry_or #
        (
         .C_FAMILY(C_FAMILY)
         ) cmd_id_check_inst_2
        (
         .CIN(cmd_id_check_i),
         .S(cmd_empty),
         .COUT(cmd_id_check)
         );
         
  axi_interconnect_v1_7_13_carry_and #
        (
         .C_FAMILY(C_FAMILY)
         ) allow_new_cmd_inst_1
        (
         .CIN(cmd_id_check),
         .S(s_ready),
         .COUT(allow_new_cmd_i)
         );

  axi_interconnect_v1_7_13_carry_or #
        (
         .C_FAMILY(C_FAMILY)
         ) allow_new_cmd_inst_2
        (
         .CIN(allow_new_cmd_i),
         .S(cmd_push_block),
         .COUT(allow_new_cmd)
         );
         
      assign sel_cmd_push = ~cmd_push_block;
      
  axi_interconnect_v1_7_13_carry_and #
        (
         .C_FAMILY(C_FAMILY)
         ) cmd_push_inst
        (
         .CIN(M_AXI_AVALID_I),
         .S(sel_cmd_push),
         .COUT(cmd_push)
         );

    end
  endgenerate
  
  // Block furter push until command has been forwarded to MI-side.
  always @ (posedge ACLK) begin
    if (ARESET) begin
      cmd_push_block <= 1'b0;
    end else begin
      cmd_push_block <= M_AXI_AVALID_I & ~M_AXI_AREADY_I;
    end
  end
  
  // Acknowledge command when we can push it into queue (and forward it).
  assign S_AXI_AREADY_I = M_AXI_AREADY_I & allow_new_cmd & ~ARESET;
  assign S_AXI_AREADY   = S_AXI_AREADY_I;
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Command Queue:
  // 
  // Instantiate a FIFO as the queue and adjust the control signals.
  //
  // Decode size to step before passing it along.
  //
  // When there is no need for bursts the command FIFO can be greatly reduced 
  // becase the following is always true:
  // * first = last
  // * length = 0
  // * nothing can be packed (i.e. no WRAP at all)
  //   * never any sub-size wraping => static offset (0) and mask (1)
  // 
  /////////////////////////////////////////////////////////////////////////////
  
  // Translate SI-side size to step for upsizer function.
  always @ *
  begin
    case (cmd_size_i)
      3'b000: cmd_step_ii = 8'b00000001;
      3'b001: cmd_step_ii = 8'b00000010;
      3'b010: cmd_step_ii = 8'b00000100;
      3'b011: cmd_step_ii = 8'b00001000;
      3'b100: cmd_step_ii = 8'b00010000;
      3'b101: cmd_step_ii = 8'b00100000;
      3'b110: cmd_step_ii = 8'b01000000;
      3'b111: cmd_step_ii = 8'b10000000; // Illegal setting.
    endcase
  end
  
  // Get only the applicable bits in step.
  assign cmd_step_i = cmd_step_ii[C_S_AXI_BYTES_LOG:0];
  
  // Instantiated queue.
  generate
    if (C_SUPPORT_BURSTS == 1) begin : USE_BURSTS
  axi_interconnect_v1_7_13_command_fifo #
      (
       .C_FAMILY                    (C_FAMILY),
       .C_ENABLE_S_VALID_CARRY      (1),
       .C_ENABLE_REGISTERED_OUTPUT  (1),
       .C_FIFO_DEPTH_LOG            (C_FIFO_DEPTH_LOG),
       .C_FIFO_WIDTH                (1+1+1+1+C_M_AXI_BYTES_LOG+C_M_AXI_BYTES_LOG+
                                     C_M_AXI_BYTES_LOG+C_M_AXI_BYTES_LOG+C_M_AXI_BYTES_LOG+C_S_AXI_BYTES_LOG+1+8)
       ) 
       cmd_queue
      (
       .ACLK    (ACLK),
       .ARESET  (ARESET),
       .EMPTY   (cmd_empty),
       .S_MESG  ({cmd_fix_i, cmd_modified_i, cmd_complete_wrap_i, cmd_packed_wrap_i, cmd_first_word_i, cmd_next_word_i, 
                  cmd_last_word_i, cmd_offset_i, cmd_mask_i, cmd_step_i, cmd_length_i}),
       .S_VALID (cmd_push),
       .S_READY (s_ready),
       .M_MESG  ({cmd_fix, cmd_modified, cmd_complete_wrap, cmd_packed_wrap, cmd_first_word, cmd_next_word, 
                  cmd_last_word, cmd_offset, cmd_mask, cmd_step, cmd_length}),
       .M_VALID (cmd_valid_i),
       .M_READY (cmd_ready)
       );
    end else begin : NO_BURSTS
    
      wire [C_M_AXI_BYTES_LOG-1:0]        cmd_first_word_out;
  
  axi_interconnect_v1_7_13_command_fifo #
      (
       .C_FAMILY                    (C_FAMILY),
       .C_ENABLE_S_VALID_CARRY      (1),
       .C_ENABLE_REGISTERED_OUTPUT  (1),
       .C_FIFO_DEPTH_LOG            (C_FIFO_DEPTH_LOG),
       .C_FIFO_WIDTH                (1+C_M_AXI_BYTES_LOG+C_S_AXI_BYTES_LOG+1)
       ) 
       cmd_queue
      (
       .ACLK    (ACLK),
       .ARESET  (ARESET),
       .EMPTY   (cmd_empty),
       .S_MESG  ({cmd_fix_i, cmd_first_word_i, cmd_step_i}),
       .S_VALID (cmd_push),
       .S_READY (s_ready),
       .M_MESG  ({cmd_fix, cmd_first_word_out, cmd_step}),
       .M_VALID (cmd_valid_i),
       .M_READY (cmd_ready)
       );
       
       assign cmd_modified      = ( C_PACKING_LEVEL == C_ALWAYS_PACK ) ? 1'b1 : 1'b0;
       assign cmd_complete_wrap = 1'b0;
       assign cmd_packed_wrap   = 1'b0;
       assign cmd_first_word    = cmd_first_word_out;
       assign cmd_next_word     = cmd_first_word_out;
       assign cmd_last_word     = cmd_first_word_out;
       assign cmd_offset        = {C_M_AXI_BYTES_LOG{1'b0}};
       assign cmd_mask          = {C_M_AXI_BYTES_LOG{1'b1}};
       assign cmd_length        = 8'b0;
    end
  endgenerate

  // Queue is concidered full when not ready.
  assign cmd_full = ~s_ready;
  
  // Assign external signal.
  assign cmd_valid = cmd_valid_i;
  
  
  /////////////////////////////////////////////////////////////////////////////
  // MI-side output handling
  /////////////////////////////////////////////////////////////////////////////
  
  generate
    if ( C_M_AXI_REGISTER ) begin : USE_REGISTER
    
      reg  [C_AXI_ID_WIDTH-1:0]           M_AXI_AID_q;
      reg  [C_AXI_ADDR_WIDTH-1:0]         M_AXI_AADDR_q;
      reg  [8-1:0]                        M_AXI_ALEN_q;
      reg  [3-1:0]                        M_AXI_ASIZE_q;
      reg  [2-1:0]                        M_AXI_ABURST_q;
      reg  [2-1:0]                        M_AXI_ALOCK_q;
      reg  [4-1:0]                        M_AXI_ACACHE_q;
      reg  [3-1:0]                        M_AXI_APROT_q;
      reg  [4-1:0]                        M_AXI_AREGION_q;
      reg  [4-1:0]                        M_AXI_AQOS_q;
      reg  [C_AXI_AUSER_WIDTH-1:0]        M_AXI_AUSER_q;
      reg                                 M_AXI_AVALID_q;
    
      // Register MI-side Data.
      always @ (posedge ACLK) begin
        if (ARESET) begin
          M_AXI_AVALID_q    <= 1'b0;
        end else if ( M_AXI_AREADY_I ) begin
          M_AXI_AVALID_q    <= M_AXI_AVALID_I;
        end

        if ( M_AXI_AREADY_I ) begin
          M_AXI_AID_q       <= M_AXI_AID_I;
          M_AXI_AADDR_q     <= M_AXI_AADDR_I;
          M_AXI_ALEN_q      <= M_AXI_ALEN_I;
          M_AXI_ASIZE_q     <= M_AXI_ASIZE_I;
          M_AXI_ABURST_q    <= M_AXI_ABURST_I;
          M_AXI_ALOCK_q     <= M_AXI_ALOCK_I;
          M_AXI_ACACHE_q    <= M_AXI_ACACHE_I;
          M_AXI_APROT_q     <= M_AXI_APROT_I;
          M_AXI_AREGION_q   <= M_AXI_AREGION_I;
          M_AXI_AQOS_q      <= M_AXI_AQOS_I;
          M_AXI_AUSER_q     <= M_AXI_AUSER_I;
        end
      end
      
      assign M_AXI_AID        = M_AXI_AID_q;
      assign M_AXI_AADDR      = M_AXI_AADDR_q;
      assign M_AXI_ALEN       = M_AXI_ALEN_q;
      assign M_AXI_ASIZE      = M_AXI_ASIZE_q;
      assign M_AXI_ABURST     = M_AXI_ABURST_q;
      assign M_AXI_ALOCK      = M_AXI_ALOCK_q;
      assign M_AXI_ACACHE     = M_AXI_ACACHE_q;
      assign M_AXI_APROT      = M_AXI_APROT_q;
      assign M_AXI_AREGION    = M_AXI_AREGION_q;
      assign M_AXI_AQOS       = M_AXI_AQOS_q;
      assign M_AXI_AUSER      = M_AXI_AUSER_q;
      assign M_AXI_AVALID     = M_AXI_AVALID_q;
      assign M_AXI_AREADY_I = ( M_AXI_AVALID_q & M_AXI_AREADY) | ~M_AXI_AVALID_q;
      
    end else begin : NO_REGISTER
    
      // Combinatorial MI-side Data.
      assign M_AXI_AID      = M_AXI_AID_I;
      assign M_AXI_AADDR    = M_AXI_AADDR_I;
      assign M_AXI_ALEN     = M_AXI_ALEN_I;
      assign M_AXI_ASIZE    = M_AXI_ASIZE_I;
      assign M_AXI_ABURST   = M_AXI_ABURST_I;
      assign M_AXI_ALOCK    = M_AXI_ALOCK_I;
      assign M_AXI_ACACHE   = M_AXI_ACACHE_I;
      assign M_AXI_APROT    = M_AXI_APROT_I;
      assign M_AXI_AREGION  = M_AXI_AREGION_I;
      assign M_AXI_AQOS     = M_AXI_AQOS_I;
      assign M_AXI_AUSER    = M_AXI_AUSER_I;
      assign M_AXI_AVALID   = M_AXI_AVALID_I;
      assign M_AXI_AREADY_I = M_AXI_AREADY;
                          
    end
  endgenerate
  
  
endmodule



// -- (c) Copyright 2010 - 2011 Xilinx, Inc. All rights reserved.
// --
// -- This file contains confidential and proprietary information
// -- of Xilinx, Inc. and is protected under U.S. and 
// -- international copyright and other intellectual property
// -- laws.
// --
// -- DISCLAIMER
// -- This disclaimer is not a license and does not grant any
// -- rights to the materials distributed herewith. Except as
// -- otherwise provided in a valid license issued to you by
// -- Xilinx, and to the maximum extent permitted by applicable
// -- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
// -- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
// -- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
// -- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
// -- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
// -- (2) Xilinx shall not be liable (whether in contract or tort,
// -- including negligence, or under any other theory of
// -- liability) for any loss or damage of any kind or nature
// -- related to, arising under or in connection with these
// -- materials, including for any direct, or any indirect,
// -- special, incidental, or consequential loss or damage
// -- (including loss of data, profits, goodwill, or any type of
// -- loss or damage suffered as a result of any action brought
// -- by a third party) even if such damage or loss was
// -- reasonably foreseeable or Xilinx had been advised of the
// -- possibility of the same.
// --
// -- CRITICAL APPLICATIONS
// -- Xilinx products are not designed or intended to be fail-
// -- safe, or for use in any application requiring fail-safe
// -- performance, such as life-support or safety devices or
// -- systems, Class III medical devices, nuclear facilities,
// -- applications related to the deployment of airbags, or any
// -- other applications that could lead to death, personal
// -- injury, or severe property or environmental damage
// -- (individually and collectively, "Critical
// -- Applications"). Customer assumes the sole risk and
// -- liability of any use of Xilinx products in Critical
// -- Applications, subject only to applicable laws and
// -- regulations governing limitations on product liability.
// --
// -- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
// -- PART OF THIS FILE AT ALL TIMES.
//-----------------------------------------------------------------------------
//
// Description: AXI3 Slave Converter
// This module instantiates Address, Write Data and Read Data AXI3 Converter 
// modules, each one taking care of the channel specific tasks.
// The Address AXI3 converter can handle both AR and AW channels.
// The Write Respons Channel is reused from the Down-Sizer.
//
// Verilog-standard:  Verilog 2001
//--------------------------------------------------------------------------
//
// Structure:
//    axi3_conv
//      a_axi3_conv
//        axic_fifo
//      w_axi3_conv
//      b_downsizer
//      r_axi3_conv
//
//--------------------------------------------------------------------------
`timescale 1ps/1ps

(* DowngradeIPIdentifiedWarnings="yes" *) 
module axi_interconnect_v1_7_13_axi3_conv #
  (
   parameter C_FAMILY                            = "none",
   parameter integer C_AXI_ID_WIDTH              = 1,
   parameter integer C_AXI_ADDR_WIDTH            = 32,
   parameter integer C_AXI_DATA_WIDTH            = 32,
   parameter integer C_AXI_SUPPORTS_USER_SIGNALS = 0,
   parameter integer C_AXI_AWUSER_WIDTH          = 1,
   parameter integer C_AXI_ARUSER_WIDTH          = 1,
   parameter integer C_AXI_WUSER_WIDTH           = 1,
   parameter integer C_AXI_RUSER_WIDTH           = 1,
   parameter integer C_AXI_BUSER_WIDTH           = 1,
   parameter integer C_AXI_SUPPORTS_WRITE             = 1,
   parameter integer C_AXI_SUPPORTS_READ              = 1,
   parameter integer C_SUPPORT_SPLITTING              = 1,
                       // Implement transaction splitting logic.
                       // Disabled whan all connected masters are AXI3 and have same or narrower data width.
   parameter integer C_SUPPORT_BURSTS                 = 1,
                       // Disabled when all connected masters are AxiLite,
                       //   allowing logic to be simplified.
   parameter integer C_SINGLE_THREAD                  = 1
                       // 0 = Ignore ID when propagating transactions (assume all responses are in order).
                       // 1 = Enforce single-threading (one ID at a time) when any outstanding or 
                       //     requested transaction requires splitting.
                       //     While no split is ongoing any new non-split transaction will pass immediately regardless
                       //     off ID.
                       //     A split transaction will stall if there are multiple ID (non-split) transactions
                       //     ongoing, once it has been forwarded only transactions with the same ID is allowed
                       //     (split or not) until all ongoing split transactios has been completed.
   )
  (
   // System Signals
   input wire ACLK,
   input wire ARESETN,

   // Slave Interface Write Address Ports
   input  wire [C_AXI_ID_WIDTH-1:0]     S_AXI_AWID,
   input  wire [C_AXI_ADDR_WIDTH-1:0]   S_AXI_AWADDR,
   input  wire [8-1:0]                  S_AXI_AWLEN,
   input  wire [3-1:0]                  S_AXI_AWSIZE,
   input  wire [2-1:0]                  S_AXI_AWBURST,
   input  wire [2-1:0]                  S_AXI_AWLOCK,
   input  wire [4-1:0]                  S_AXI_AWCACHE,
   input  wire [3-1:0]                  S_AXI_AWPROT,
   input  wire [4-1:0]                  S_AXI_AWQOS,
   input  wire [C_AXI_AWUSER_WIDTH-1:0] S_AXI_AWUSER,
   input  wire                          S_AXI_AWVALID,
   output wire                          S_AXI_AWREADY,

   // Slave Interface Write Data Ports
   input  wire [C_AXI_DATA_WIDTH-1:0]   S_AXI_WDATA,
   input  wire [C_AXI_DATA_WIDTH/8-1:0] S_AXI_WSTRB,
   input  wire                          S_AXI_WLAST,
   input  wire [C_AXI_WUSER_WIDTH-1:0]  S_AXI_WUSER,
   input  wire                          S_AXI_WVALID,
   output wire                          S_AXI_WREADY,

   // Slave Interface Write Response Ports
   output wire [C_AXI_ID_WIDTH-1:0]    S_AXI_BID,
   output wire [2-1:0]                 S_AXI_BRESP,
   output wire [C_AXI_BUSER_WIDTH-1:0] S_AXI_BUSER,
   output wire                         S_AXI_BVALID,
   input  wire                         S_AXI_BREADY,

   // Slave Interface Read Address Ports
   input  wire [C_AXI_ID_WIDTH-1:0]     S_AXI_ARID,
   input  wire [C_AXI_ADDR_WIDTH-1:0]   S_AXI_ARADDR,
   input  wire [8-1:0]                  S_AXI_ARLEN,
   input  wire [3-1:0]                  S_AXI_ARSIZE,
   input  wire [2-1:0]                  S_AXI_ARBURST,
   input  wire [2-1:0]                  S_AXI_ARLOCK,
   input  wire [4-1:0]                  S_AXI_ARCACHE,
   input  wire [3-1:0]                  S_AXI_ARPROT,
   input  wire [4-1:0]                  S_AXI_ARQOS,
   input  wire [C_AXI_ARUSER_WIDTH-1:0] S_AXI_ARUSER,
   input  wire                          S_AXI_ARVALID,
   output wire                          S_AXI_ARREADY,

   // Slave Interface Read Data Ports
   output wire [C_AXI_ID_WIDTH-1:0]    S_AXI_RID,
   output wire [C_AXI_DATA_WIDTH-1:0]  S_AXI_RDATA,
   output wire [2-1:0]                 S_AXI_RRESP,
   output wire                         S_AXI_RLAST,
   output wire [C_AXI_RUSER_WIDTH-1:0] S_AXI_RUSER,
   output wire                         S_AXI_RVALID,
   input  wire                         S_AXI_RREADY,
   
   // Master Interface Write Address Port
   output wire [C_AXI_ID_WIDTH-1:0]     M_AXI_AWID,
   output wire [C_AXI_ADDR_WIDTH-1:0]   M_AXI_AWADDR,
   output wire [8-1:0]                  M_AXI_AWLEN,
   output wire [3-1:0]                  M_AXI_AWSIZE,
   output wire [2-1:0]                  M_AXI_AWBURST,
   output wire [2-1:0]                  M_AXI_AWLOCK,
   output wire [4-1:0]                  M_AXI_AWCACHE,
   output wire [3-1:0]                  M_AXI_AWPROT,
   output wire [4-1:0]                  M_AXI_AWREGION,  // constant 0
   output wire [4-1:0]                  M_AXI_AWQOS,
   output wire [C_AXI_AWUSER_WIDTH-1:0] M_AXI_AWUSER,
   output wire                          M_AXI_AWVALID,
   input  wire                          M_AXI_AWREADY,
   
   // Master Interface Write Data Ports
   output wire [C_AXI_ID_WIDTH-1:0]     M_AXI_WID,
   output wire [C_AXI_DATA_WIDTH-1:0]   M_AXI_WDATA,
   output wire [C_AXI_DATA_WIDTH/8-1:0] M_AXI_WSTRB,
   output wire                          M_AXI_WLAST,
   output wire [C_AXI_WUSER_WIDTH-1:0]  M_AXI_WUSER,
   output wire                          M_AXI_WVALID,
   input  wire                          M_AXI_WREADY,
   
   // Master Interface Write Response Ports
   input  wire [C_AXI_ID_WIDTH-1:0]    M_AXI_BID,
   input  wire [2-1:0]                 M_AXI_BRESP,
   input  wire [C_AXI_BUSER_WIDTH-1:0] M_AXI_BUSER,
   input  wire                         M_AXI_BVALID,
   output wire                         M_AXI_BREADY,
   
   // Master Interface Read Address Port
   output wire [C_AXI_ID_WIDTH-1:0]     M_AXI_ARID,
   output wire [C_AXI_ADDR_WIDTH-1:0]   M_AXI_ARADDR,
   output wire [8-1:0]                  M_AXI_ARLEN,
   output wire [3-1:0]                  M_AXI_ARSIZE,
   output wire [2-1:0]                  M_AXI_ARBURST,
   output wire [2-1:0]                  M_AXI_ARLOCK,
   output wire [4-1:0]                  M_AXI_ARCACHE,
   output wire [3-1:0]                  M_AXI_ARPROT,
   output wire [4-1:0]                  M_AXI_ARREGION,  // constant 0
   output wire [4-1:0]                  M_AXI_ARQOS,
   output wire [C_AXI_ARUSER_WIDTH-1:0] M_AXI_ARUSER,
   output wire                          M_AXI_ARVALID,
   input  wire                          M_AXI_ARREADY,
   
   // Master Interface Read Data Ports
   input  wire [C_AXI_ID_WIDTH-1:0]    M_AXI_RID,
   input  wire [C_AXI_DATA_WIDTH-1:0]  M_AXI_RDATA,
   input  wire [2-1:0]                 M_AXI_RRESP,
   input  wire                         M_AXI_RLAST,
   input  wire [C_AXI_RUSER_WIDTH-1:0] M_AXI_RUSER,
   input  wire                         M_AXI_RVALID,
   output wire                         M_AXI_RREADY
   );

   
  /////////////////////////////////////////////////////////////////////////////
  // Functions
  /////////////////////////////////////////////////////////////////////////////
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Local params
  /////////////////////////////////////////////////////////////////////////////
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Variables for generating parameter controlled instances.
  /////////////////////////////////////////////////////////////////////////////
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Internal signals
  /////////////////////////////////////////////////////////////////////////////
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Handle Write Channels (AW/W/B)
  /////////////////////////////////////////////////////////////////////////////
  generate
    if (C_AXI_SUPPORTS_WRITE == 1) begin : USE_WRITE
    
      // Write Channel Signals for Commands Queue Interface.
      wire                              wr_cmd_valid;
      wire [C_AXI_ID_WIDTH-1:0]         wr_cmd_id;
      wire [4-1:0]                      wr_cmd_length;
      wire                              wr_cmd_ready;
      
      wire                              wr_cmd_b_valid;
      wire                              wr_cmd_b_split;
      wire [4-1:0]                      wr_cmd_b_repeat;
      wire                              wr_cmd_b_ready;
      
      // Write Address Channel.
  axi_interconnect_v1_7_13_a_axi3_conv #
      (
       .C_FAMILY                    (C_FAMILY),
       .C_AXI_ID_WIDTH              (C_AXI_ID_WIDTH),
       .C_AXI_ADDR_WIDTH            (C_AXI_ADDR_WIDTH),
       .C_AXI_DATA_WIDTH            (C_AXI_DATA_WIDTH),
       .C_AXI_SUPPORTS_USER_SIGNALS (C_AXI_SUPPORTS_USER_SIGNALS),
       .C_AXI_AUSER_WIDTH           (C_AXI_AWUSER_WIDTH),
       .C_AXI_CHANNEL               (0),
       .C_SUPPORT_SPLITTING         (C_SUPPORT_SPLITTING),
       .C_SUPPORT_BURSTS            (C_SUPPORT_BURSTS),
       .C_SINGLE_THREAD             (C_SINGLE_THREAD)
        ) write_addr_inst
       (
        // Global Signals
        .ARESET                     (~ARESETN),
        .ACLK                       (ACLK),
    
        // Command Interface (W)
        .cmd_valid                  (wr_cmd_valid),
        .cmd_split                  (),
        .cmd_id                     (wr_cmd_id),
        .cmd_length                 (wr_cmd_length),
        .cmd_ready                  (wr_cmd_ready),
       
        // Command Interface (B)
        .cmd_b_valid                (wr_cmd_b_valid),
        .cmd_b_split                (wr_cmd_b_split),
        .cmd_b_repeat               (wr_cmd_b_repeat),
        .cmd_b_ready                (wr_cmd_b_ready),
       
        // Slave Interface Write Address Ports
        .S_AXI_AID                  (S_AXI_AWID),
        .S_AXI_AADDR                (S_AXI_AWADDR),
        .S_AXI_ALEN                 (S_AXI_AWLEN),
        .S_AXI_ASIZE                (S_AXI_AWSIZE),
        .S_AXI_ABURST               (S_AXI_AWBURST),
        .S_AXI_ALOCK                (S_AXI_AWLOCK),
        .S_AXI_ACACHE               (S_AXI_AWCACHE),
        .S_AXI_APROT                (S_AXI_AWPROT),
        .S_AXI_AQOS                 (S_AXI_AWQOS),
        .S_AXI_AUSER                (S_AXI_AWUSER),
        .S_AXI_AVALID               (S_AXI_AWVALID),
        .S_AXI_AREADY               (S_AXI_AWREADY),
        
        // Master Interface Write Address Port
        .M_AXI_AID                  (M_AXI_AWID),
        .M_AXI_AADDR                (M_AXI_AWADDR),
        .M_AXI_ALEN                 (M_AXI_AWLEN),
        .M_AXI_ASIZE                (M_AXI_AWSIZE),
        .M_AXI_ABURST               (M_AXI_AWBURST),
        .M_AXI_ALOCK                (M_AXI_AWLOCK),
        .M_AXI_ACACHE               (M_AXI_AWCACHE),
        .M_AXI_APROT                (M_AXI_AWPROT),
        .M_AXI_AREGION              (M_AXI_AWREGION),
        .M_AXI_AQOS                 (M_AXI_AWQOS),
        .M_AXI_AUSER                (M_AXI_AWUSER),
        .M_AXI_AVALID               (M_AXI_AWVALID),
        .M_AXI_AREADY               (M_AXI_AWREADY)
       );
       
      // Write Data Channel.
  axi_interconnect_v1_7_13_w_axi3_conv #
      (
       .C_FAMILY                    (C_FAMILY),
       .C_AXI_ID_WIDTH              (C_AXI_ID_WIDTH),
       .C_AXI_DATA_WIDTH            (C_AXI_DATA_WIDTH),
       .C_AXI_SUPPORTS_USER_SIGNALS (C_AXI_SUPPORTS_USER_SIGNALS),
       .C_AXI_WUSER_WIDTH           (C_AXI_WUSER_WIDTH),
       .C_SUPPORT_SPLITTING         (C_SUPPORT_SPLITTING),
       .C_SUPPORT_BURSTS            (C_SUPPORT_BURSTS)
        ) write_data_inst
       (
        // Global Signals
        .ARESET                     (~ARESETN),
        .ACLK                       (ACLK),
    
        // Command Interface
        .cmd_valid                  (wr_cmd_valid),
        .cmd_id                     (wr_cmd_id),
        .cmd_length                 (wr_cmd_length),
        .cmd_ready                  (wr_cmd_ready),
       
        // Slave Interface Write Data Ports
        .S_AXI_WDATA                (S_AXI_WDATA),
        .S_AXI_WSTRB                (S_AXI_WSTRB),
        .S_AXI_WLAST                (S_AXI_WLAST),
        .S_AXI_WUSER                (S_AXI_WUSER),
        .S_AXI_WVALID               (S_AXI_WVALID),
        .S_AXI_WREADY               (S_AXI_WREADY),
        
        // Master Interface Write Data Ports
        .M_AXI_WID                  (M_AXI_WID),
        .M_AXI_WDATA                (M_AXI_WDATA),
        .M_AXI_WSTRB                (M_AXI_WSTRB),
        .M_AXI_WLAST                (M_AXI_WLAST),
        .M_AXI_WUSER                (M_AXI_WUSER),
        .M_AXI_WVALID               (M_AXI_WVALID),
        .M_AXI_WREADY               (M_AXI_WREADY)
       );
      
      if ( C_SUPPORT_SPLITTING == 1 && C_SUPPORT_BURSTS == 1 ) begin : USE_SPLIT
      
        // Write Data Response Channel.
  axi_interconnect_v1_7_13_b_downsizer #
        (
         .C_FAMILY                    (C_FAMILY),
         .C_AXI_ID_WIDTH              (C_AXI_ID_WIDTH),
         .C_AXI_SUPPORTS_USER_SIGNALS (C_AXI_SUPPORTS_USER_SIGNALS),
         .C_AXI_BUSER_WIDTH           (C_AXI_BUSER_WIDTH)
          ) write_resp_inst
         (
          // Global Signals
          .ARESET                     (~ARESETN),
          .ACLK                       (ACLK),
      
          // Command Interface
          .cmd_valid                  (wr_cmd_b_valid),
          .cmd_split                  (wr_cmd_b_split),
          .cmd_repeat                 (wr_cmd_b_repeat),
          .cmd_ready                  (wr_cmd_b_ready),
          
          // Slave Interface Write Response Ports
          .S_AXI_BID                  (S_AXI_BID),
          .S_AXI_BRESP                (S_AXI_BRESP),
          .S_AXI_BUSER                (S_AXI_BUSER),
          .S_AXI_BVALID               (S_AXI_BVALID),
          .S_AXI_BREADY               (S_AXI_BREADY),
          
          // Master Interface Write Response Ports
          .M_AXI_BID                  (M_AXI_BID),
          .M_AXI_BRESP                (M_AXI_BRESP),
          .M_AXI_BUSER                (M_AXI_BUSER),
          .M_AXI_BVALID               (M_AXI_BVALID),
          .M_AXI_BREADY               (M_AXI_BREADY)
         );
        
      end else begin : NO_SPLIT
      
        // MI -> SI Interface Write Response Ports
        assign S_AXI_BID      = M_AXI_BID;
        assign S_AXI_BRESP    = M_AXI_BRESP;
        assign S_AXI_BUSER    = M_AXI_BUSER;
        assign S_AXI_BVALID   = M_AXI_BVALID;
        assign M_AXI_BREADY   = S_AXI_BREADY;
        
      end
      
    end else begin : NO_WRITE
    
      // Slave Interface Write Address Ports
      assign S_AXI_AWREADY = 1'b0;
      // Slave Interface Write Data Ports
      assign S_AXI_WREADY  = 1'b0;
      // Slave Interface Write Response Ports
      assign S_AXI_BID     = {C_AXI_ID_WIDTH{1'b0}};
      assign S_AXI_BRESP   = 2'b0;
      assign S_AXI_BUSER   = {C_AXI_BUSER_WIDTH{1'b0}};
      assign S_AXI_BVALID  = 1'b0;
      
      // Master Interface Write Address Port
      assign M_AXI_AWID    = {C_AXI_ID_WIDTH{1'b0}};
      assign M_AXI_AWADDR  = {C_AXI_ADDR_WIDTH{1'b0}};
      assign M_AXI_AWLEN   = 8'b0;
      assign M_AXI_AWSIZE  = 3'b0;
      assign M_AXI_AWBURST = 2'b0;
      assign M_AXI_AWLOCK  = 2'b0;
      assign M_AXI_AWCACHE = 4'b0;
      assign M_AXI_AWPROT  = 3'b0;
      assign M_AXI_AWQOS   = 4'b0;
      assign M_AXI_AWUSER  = {C_AXI_AWUSER_WIDTH{1'b0}};
      assign M_AXI_AWVALID = 1'b0;
      // Master Interface Write Data Ports
      assign M_AXI_WDATA   = {C_AXI_DATA_WIDTH{1'b0}};
      assign M_AXI_WSTRB   = {C_AXI_DATA_WIDTH/8{1'b0}};
      assign M_AXI_WLAST   = 1'b0;
      assign M_AXI_WUSER   = {C_AXI_WUSER_WIDTH{1'b0}};
      assign M_AXI_WVALID  = 1'b0;
      // Master Interface Write Response Ports
      assign M_AXI_BREADY  = 1'b0;
      
    end
  endgenerate
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Handle Read Channels (AR/R)
  /////////////////////////////////////////////////////////////////////////////
  generate
    if (C_AXI_SUPPORTS_READ == 1) begin : USE_READ
    
      // Write Response channel.
      if ( C_SUPPORT_SPLITTING == 1 && C_SUPPORT_BURSTS == 1 ) begin : USE_SPLIT
      
        // Read Channel Signals for Commands Queue Interface.
        wire                              rd_cmd_valid;
        wire                              rd_cmd_split;
        wire                              rd_cmd_ready;
        
        // Write Address Channel.
  axi_interconnect_v1_7_13_a_axi3_conv #
        (
         .C_FAMILY                    (C_FAMILY),
         .C_AXI_ID_WIDTH              (C_AXI_ID_WIDTH),
         .C_AXI_ADDR_WIDTH            (C_AXI_ADDR_WIDTH),
         .C_AXI_DATA_WIDTH            (C_AXI_DATA_WIDTH),
         .C_AXI_SUPPORTS_USER_SIGNALS (C_AXI_SUPPORTS_USER_SIGNALS),
         .C_AXI_AUSER_WIDTH           (C_AXI_ARUSER_WIDTH),
         .C_AXI_CHANNEL               (1),
         .C_SUPPORT_SPLITTING         (C_SUPPORT_SPLITTING),
         .C_SUPPORT_BURSTS            (C_SUPPORT_BURSTS),
         .C_SINGLE_THREAD             (C_SINGLE_THREAD)
          ) read_addr_inst
         (
          // Global Signals
          .ARESET                     (~ARESETN),
          .ACLK                       (ACLK),
      
          // Command Interface (R)
          .cmd_valid                  (rd_cmd_valid),
          .cmd_split                  (rd_cmd_split),
          .cmd_id                     (),
          .cmd_length                 (),
          .cmd_ready                  (rd_cmd_ready),
         
          // Command Interface (B)
          .cmd_b_valid                (),
          .cmd_b_split                (),
          .cmd_b_repeat               (),
          .cmd_b_ready                (1'b0),
         
          // Slave Interface Write Address Ports
          .S_AXI_AID                  (S_AXI_ARID),
          .S_AXI_AADDR                (S_AXI_ARADDR),
          .S_AXI_ALEN                 (S_AXI_ARLEN),
          .S_AXI_ASIZE                (S_AXI_ARSIZE),
          .S_AXI_ABURST               (S_AXI_ARBURST),
          .S_AXI_ALOCK                (S_AXI_ARLOCK),
          .S_AXI_ACACHE               (S_AXI_ARCACHE),
          .S_AXI_APROT                (S_AXI_ARPROT),
          .S_AXI_AQOS                 (S_AXI_ARQOS),
          .S_AXI_AUSER                (S_AXI_ARUSER),
          .S_AXI_AVALID               (S_AXI_ARVALID),
          .S_AXI_AREADY               (S_AXI_ARREADY),
          
          // Master Interface Write Address Port
          .M_AXI_AID                  (M_AXI_ARID),
          .M_AXI_AADDR                (M_AXI_ARADDR),
          .M_AXI_ALEN                 (M_AXI_ARLEN),
          .M_AXI_ASIZE                (M_AXI_ARSIZE),
          .M_AXI_ABURST               (M_AXI_ARBURST),
          .M_AXI_ALOCK                (M_AXI_ARLOCK),
          .M_AXI_ACACHE               (M_AXI_ARCACHE),
          .M_AXI_APROT                (M_AXI_ARPROT),
          .M_AXI_AREGION              (M_AXI_ARREGION),
          .M_AXI_AQOS                 (M_AXI_ARQOS),
          .M_AXI_AUSER                (M_AXI_ARUSER),
          .M_AXI_AVALID               (M_AXI_ARVALID),
          .M_AXI_AREADY               (M_AXI_ARREADY)
         );
         
        // Read Data Channel.
  axi_interconnect_v1_7_13_r_axi3_conv #
        (
         .C_FAMILY                    (C_FAMILY),
         .C_AXI_ID_WIDTH              (C_AXI_ID_WIDTH),
         .C_AXI_DATA_WIDTH            (C_AXI_DATA_WIDTH),
         .C_AXI_SUPPORTS_USER_SIGNALS (C_AXI_SUPPORTS_USER_SIGNALS),
         .C_AXI_RUSER_WIDTH           (C_AXI_RUSER_WIDTH),
         .C_SUPPORT_SPLITTING         (C_SUPPORT_SPLITTING),
         .C_SUPPORT_BURSTS            (C_SUPPORT_BURSTS)
          ) read_data_inst
         (
          // Global Signals
          .ARESET                     (~ARESETN),
          .ACLK                       (ACLK),
      
          // Command Interface
          .cmd_valid                  (rd_cmd_valid),
          .cmd_split                  (rd_cmd_split),
          .cmd_ready                  (rd_cmd_ready),
         
          // Slave Interface Read Data Ports
          .S_AXI_RID                  (S_AXI_RID),
          .S_AXI_RDATA                (S_AXI_RDATA),
          .S_AXI_RRESP                (S_AXI_RRESP),
          .S_AXI_RLAST                (S_AXI_RLAST),
          .S_AXI_RUSER                (S_AXI_RUSER),
          .S_AXI_RVALID               (S_AXI_RVALID),
          .S_AXI_RREADY               (S_AXI_RREADY),
          
          // Master Interface Read Data Ports
          .M_AXI_RID                  (M_AXI_RID),
          .M_AXI_RDATA                (M_AXI_RDATA),
          .M_AXI_RRESP                (M_AXI_RRESP),
          .M_AXI_RLAST                (M_AXI_RLAST),
          .M_AXI_RUSER                (M_AXI_RUSER),
          .M_AXI_RVALID               (M_AXI_RVALID),
          .M_AXI_RREADY               (M_AXI_RREADY)
         );
       
      end else begin : NO_SPLIT
      
        // SI -> MI Interface Write Address Port
        assign M_AXI_ARID     = S_AXI_ARID;
        assign M_AXI_ARADDR   = S_AXI_ARADDR;
        assign M_AXI_ARLEN    = S_AXI_ARLEN;
        assign M_AXI_ARSIZE   = S_AXI_ARSIZE;
        assign M_AXI_ARBURST  = S_AXI_ARBURST;
        assign M_AXI_ARLOCK   = S_AXI_ARLOCK;
        assign M_AXI_ARCACHE  = S_AXI_ARCACHE;
        assign M_AXI_ARPROT   = S_AXI_ARPROT;
        assign M_AXI_ARREGION = 4'b0;
        assign M_AXI_ARQOS    = 4'b0;
        assign M_AXI_ARUSER   = S_AXI_ARUSER;
        assign M_AXI_ARVALID  = S_AXI_ARVALID;
        assign S_AXI_ARREADY  = M_AXI_ARREADY;
        
        // MI -> SI Interface Read Data Ports
        assign S_AXI_RID      = M_AXI_RID;
        assign S_AXI_RDATA    = M_AXI_RDATA;
        assign S_AXI_RRESP    = M_AXI_RRESP;
        assign S_AXI_RLAST    = M_AXI_RLAST;
        assign S_AXI_RUSER    = M_AXI_RUSER;
        assign S_AXI_RVALID   = M_AXI_RVALID;
        assign M_AXI_RREADY   = S_AXI_RREADY;
        
      end
      
    end else begin : NO_READ
    
      // Slave Interface Read Address Ports
      assign S_AXI_ARREADY = 1'b0;
      // Slave Interface Read Data Ports
      assign S_AXI_RID     = {C_AXI_ID_WIDTH{1'b0}};
      assign S_AXI_RDATA   = {C_AXI_DATA_WIDTH{1'b0}};
      assign S_AXI_RRESP   = 2'b0;
      assign S_AXI_RLAST   = 1'b0;
      assign S_AXI_RUSER   = {C_AXI_RUSER_WIDTH{1'b0}};
      assign S_AXI_RVALID  = 1'b0;
      
      // Master Interface Read Address Port
      assign M_AXI_ARID    = {C_AXI_ID_WIDTH{1'b0}};
      assign M_AXI_ARADDR  = {C_AXI_ADDR_WIDTH{1'b0}};
      assign M_AXI_ARLEN   = 8'b0;
      assign M_AXI_ARSIZE  = 3'b0;
      assign M_AXI_ARBURST = 2'b0;
      assign M_AXI_ARLOCK  = 2'b0;
      assign M_AXI_ARCACHE = 4'b0;
      assign M_AXI_ARPROT  = 3'b0;
      assign M_AXI_ARQOS   = 4'b0;
      assign M_AXI_ARUSER  = {C_AXI_ARUSER_WIDTH{1'b0}};
      assign M_AXI_ARVALID = 1'b0;
      // Master Interface Read Data Ports
      assign M_AXI_RREADY  = 1'b0;
      
    end
  endgenerate
  
  
endmodule


// -- (c) Copyright 2010 - 2011 Xilinx, Inc. All rights reserved.
// --
// -- This file contains confidential and proprietary information
// -- of Xilinx, Inc. and is protected under U.S. and 
// -- international copyright and other intellectual property
// -- laws.
// --
// -- DISCLAIMER
// -- This disclaimer is not a license and does not grant any
// -- rights to the materials distributed herewith. Except as
// -- otherwise provided in a valid license issued to you by
// -- Xilinx, and to the maximum extent permitted by applicable
// -- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
// -- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
// -- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
// -- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
// -- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
// -- (2) Xilinx shall not be liable (whether in contract or tort,
// -- including negligence, or under any other theory of
// -- liability) for any loss or damage of any kind or nature
// -- related to, arising under or in connection with these
// -- materials, including for any direct, or any indirect,
// -- special, incidental, or consequential loss or damage
// -- (including loss of data, profits, goodwill, or any type of
// -- loss or damage suffered as a result of any action brought
// -- by a third party) even if such damage or loss was
// -- reasonably foreseeable or Xilinx had been advised of the
// -- possibility of the same.
// --
// -- CRITICAL APPLICATIONS
// -- Xilinx products are not designed or intended to be fail-
// -- safe, or for use in any application requiring fail-safe
// -- performance, such as life-support or safety devices or
// -- systems, Class III medical devices, nuclear facilities,
// -- applications related to the deployment of airbags, or any
// -- other applications that could lead to death, personal
// -- injury, or severe property or environmental damage
// -- (individually and collectively, "Critical
// -- Applications"). Customer assumes the sole risk and
// -- liability of any use of Xilinx products in Critical
// -- Applications, subject only to applicable laws and
// -- regulations governing limitations on product liability.
// --
// -- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
// -- PART OF THIS FILE AT ALL TIMES.
//-----------------------------------------------------------------------------
//
// Generic single-channel AXI FIFO
// Synchronous FIFO is implemented using either LUTs (SRL) or BRAM.
// Transfers received on the AXI slave port are pushed onto the FIFO.
// FIFO output, when available, is presented on the AXI master port and
//   popped when the master port responds (M_READY).
//
// Verilog-standard:  Verilog 2001
//--------------------------------------------------------------------------
// Structure:
//   axic_fifo
//     fifo_gen
//--------------------------------------------------------------------------
`timescale 1ps/1ps


(* DowngradeIPIdentifiedWarnings="yes" *) 
module axi_interconnect_v1_7_13_axic_fifo #
  (
   parameter         C_FAMILY          = "virtex6",
   parameter integer C_FIFO_DEPTH_LOG  = 5,      // FIFO depth = 2**C_FIFO_DEPTH_LOG
                                                 // Range = [5:9] when TYPE="lut",
                                                 // Range = [5:12] when TYPE="bram",
   parameter integer C_FIFO_WIDTH      = 64,     // Width of payload [1:512]
   parameter         C_FIFO_TYPE       = "lut"   // "lut" = LUT (SRL) based,
                                                 // "bram" = BRAM based
   )
  (
   // Global inputs
   input  wire                        ACLK,    // Clock
   input  wire                        ARESET,  // Reset
   // Slave  Port
   input  wire [C_FIFO_WIDTH-1:0]     S_MESG,  // Payload (may be any set of channel signals)
   input  wire                        S_VALID, // FIFO push
   output wire                        S_READY, // FIFO not full
   // Master  Port
   output wire [C_FIFO_WIDTH-1:0]     M_MESG,  // Payload
   output wire                        M_VALID, // FIFO not empty
   input  wire                        M_READY  // FIFO pop
   );

  axi_interconnect_v1_7_13_fifo_gen #(
     .C_FAMILY(C_FAMILY),
     .C_COMMON_CLOCK(1),
     .C_FIFO_DEPTH_LOG(C_FIFO_DEPTH_LOG),
     .C_FIFO_WIDTH(C_FIFO_WIDTH),
     .C_FIFO_TYPE(C_FIFO_TYPE))
   inst (
     .clk(ACLK),
     .rst(ARESET),
     .wr_clk(1'b0),
     .wr_en(S_VALID),
     .wr_ready(S_READY),
     .wr_data(S_MESG),
     .rd_clk(1'b0),
     .rd_en(M_READY),
     .rd_valid(M_VALID),
     .rd_data(M_MESG));

endmodule


// -- (c) Copyright 2010 - 2013 Xilinx, Inc. All rights reserved.
// --
// -- This file contains confidential and proprietary information
// -- of Xilinx, Inc. and is protected under U.S. and 
// -- international copyright and other intellectual property
// -- laws.
// --
// -- DISCLAIMER
// -- This disclaimer is not a license and does not grant any
// -- rights to the materials distributed herewith. Except as
// -- otherwise provided in a valid license issued to you by
// -- Xilinx, and to the maximum extent permitted by applicable
// -- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
// -- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
// -- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
// -- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
// -- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
// -- (2) Xilinx shall not be liable (whether in contract or tort,
// -- including negligence, or under any other theory of
// -- liability) for any loss or damage of any kind or nature
// -- related to, arising under or in connection with these
// -- materials, including for any direct, or any indirect,
// -- special, incidental, or consequential loss or damage
// -- (including loss of data, profits, goodwill, or any type of
// -- loss or damage suffered as a result of any action brought
// -- by a third party) even if such damage or loss was
// -- reasonably foreseeable or Xilinx had been advised of the
// -- possibility of the same.
// --
// -- CRITICAL APPLICATIONS
// -- Xilinx products are not designed or intended to be fail-
// -- safe, or for use in any application requiring fail-safe
// -- performance, such as life-support or safety devices or
// -- systems, Class III medical devices, nuclear facilities,
// -- applications related to the deployment of airbags, or any
// -- other applications that could lead to death, personal
// -- injury, or severe property or environmental damage
// -- (individually and collectively, "Critical
// -- Applications"). Customer assumes the sole risk and
// -- liability of any use of Xilinx products in Critical
// -- Applications, subject only to applicable laws and
// -- regulations governing limitations on product liability.
// --
// -- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
// -- PART OF THIS FILE AT ALL TIMES.
//-----------------------------------------------------------------------------
//
// Clock converter module
//   Asynchronous clock converter when asynchronous M:N conversion
//   Bypass when synchronous and ratio between S and M clock is 1:1
//   Synchronous clock converter (S:M or M:S must be integer ratio)  
//
// Verilog-standard:  Verilog 2001
//--------------------------------------------------------------------------
//
// Structure:
//   axi_clock_conv
//     fifo_generator
//     axic_sync_clock_converter
//       axic_sample_cycle_ratio
//
// PROTECTED NAMES:
//   Instance names "asyncfifo_*" are pattern-matched in core-level UCF.
//   Signal names "*_resync" are pattern-matched in core-level UCF.
//
//--------------------------------------------------------------------------

`timescale 1ps/1ps

(* DowngradeIPIdentifiedWarnings="yes" *) 
module axi_interconnect_v1_7_13_axi_clock_converter #
  (parameter         C_FAMILY = "rtl",                      // FPGA Family. Current version: virtex6 or spartan6.
   parameter integer C_AXI_ID_WIDTH = 5,                    // Width of all ID signals on SI and MI side.
                                                            // Range: >= 1.
   parameter integer C_AXI_ADDR_WIDTH = 32,                 // Width of S_AXI_AWADDR, S_AXI_ARADDR, M_AXI_AWADDR and 
                                                            // M_AXI_ARADDR.
                                                            // Range: 32.
   parameter integer C_AXI_DATA_WIDTH = 32,       // Width of WDATA and RDATA (either side).
                                                            // Format: Bit32; 
                                                            // Range: 'h00000020, 'h00000040, 'h00000080, 'h00000100.
   parameter         C_S_AXI_ACLK_RATIO = 1,     // Clock frequency ratio of SI w.r.t. MI.
   parameter         C_M_AXI_ACLK_RATIO = 1,     // (Slowest of all clock inputs should have ratio=1.)
                                                            // S:M or M:S must be integer ratio.
                                                            // Format: Bit32; Range: >='h00000001.
   parameter integer C_AXI_IS_ACLK_ASYNC = 1,            // Indicates whether S and M clocks are asynchronous.
                                                            // FUTURE FEATURE
                                                            // Format: Bit1. Range = 1'b0.
   parameter integer C_AXI_PROTOCOL = 0,         // Protocol of this SI/MI slot.
   parameter integer C_AXI_SUPPORTS_USER_SIGNALS  = 0,      // 1 = Propagate all USER signals, 0 = Do not propagate.
   parameter integer C_AXI_AWUSER_WIDTH = 1,                // Width of AWUSER signals. 
                                                            // Range: >= 1.
   parameter integer C_AXI_ARUSER_WIDTH = 1,                // Width of ARUSER signals. 
                                                            // Range: >= 1.
   parameter integer C_AXI_WUSER_WIDTH = 1,                 // Width of WUSER signals. 
                                                            // Range: >= 1.
   parameter integer C_AXI_RUSER_WIDTH = 1,                 // Width of RUSER signals. 
                                                            // Range: >= 1.
   parameter integer C_AXI_BUSER_WIDTH = 1,                 // Width of BUSER signals. 
                                                            // Range: >= 1.
   parameter integer C_AXI_SUPPORTS_WRITE = 1,              // Implement AXI write channels
   parameter integer C_AXI_SUPPORTS_READ = 1,               // Implement AXI read channels
   parameter integer C_SYNCHRONIZER_STAGE = 3
  )

  (
   // Global Signals
   input  wire                            INTERCONNECT_ACLK,
   input  wire                            INTERCONNECT_ARESETN,
   input  wire                            LOCAL_ARESETN,
   output wire                            INTERCONNECT_RESET_OUT_N,
   output wire                            S_AXI_RESET_OUT_N,
   output wire                            M_AXI_RESET_OUT_N,

   // Slave Interface System Signals
   (* KEEP = "TRUE" *) input  wire        S_AXI_ACLK,

   // Slave Interface Write Address Ports
   input  wire [C_AXI_ID_WIDTH-1:0]       S_AXI_AWID,
   input  wire [C_AXI_ADDR_WIDTH-1:0]     S_AXI_AWADDR,
   input  wire [8-1:0]                    S_AXI_AWLEN,
   input  wire [3-1:0]                    S_AXI_AWSIZE,
   input  wire [2-1:0]                    S_AXI_AWBURST,
   input  wire [2-1:0]                    S_AXI_AWLOCK,
   input  wire [4-1:0]                    S_AXI_AWCACHE,
   input  wire [3-1:0]                    S_AXI_AWPROT,
   input  wire [4-1:0]                    S_AXI_AWREGION,
   input  wire [4-1:0]                    S_AXI_AWQOS,
   input  wire [C_AXI_AWUSER_WIDTH-1:0]   S_AXI_AWUSER,
   input  wire                            S_AXI_AWVALID,
   output wire                            S_AXI_AWREADY,

   // Slave Interface Write Data Ports
   input  wire [C_AXI_DATA_WIDTH-1:0]     S_AXI_WDATA,
   input  wire [C_AXI_DATA_WIDTH/8-1:0]   S_AXI_WSTRB,
   input  wire                            S_AXI_WLAST,
   input  wire [C_AXI_WUSER_WIDTH-1:0]    S_AXI_WUSER,
   input  wire                            S_AXI_WVALID,
   output wire                            S_AXI_WREADY,

   // Slave Interface Write Response Ports
   output wire [C_AXI_ID_WIDTH-1:0]       S_AXI_BID,
   output wire [2-1:0]                    S_AXI_BRESP,
   output wire [C_AXI_BUSER_WIDTH-1:0]    S_AXI_BUSER,
   output wire                            S_AXI_BVALID,
   input  wire                            S_AXI_BREADY,

   // Slave Interface Read Address Ports
   input  wire [C_AXI_ID_WIDTH-1:0]       S_AXI_ARID,
   input  wire [C_AXI_ADDR_WIDTH-1:0]     S_AXI_ARADDR,
   input  wire [8-1:0]                    S_AXI_ARLEN,
   input  wire [3-1:0]                    S_AXI_ARSIZE,
   input  wire [2-1:0]                    S_AXI_ARBURST,
   input  wire [2-1:0]                    S_AXI_ARLOCK,
   input  wire [4-1:0]                    S_AXI_ARCACHE,
   input  wire [3-1:0]                    S_AXI_ARPROT,
   input  wire [4-1:0]                    S_AXI_ARREGION,
   input  wire [4-1:0]                    S_AXI_ARQOS,
   input  wire [C_AXI_ARUSER_WIDTH-1:0]   S_AXI_ARUSER,
   input  wire                            S_AXI_ARVALID,
   output wire                            S_AXI_ARREADY,

   // Slave Interface Read Data Ports
   output wire [C_AXI_ID_WIDTH-1:0]       S_AXI_RID,
   output wire [C_AXI_DATA_WIDTH-1:0]     S_AXI_RDATA,
   output wire [2-1:0]                    S_AXI_RRESP,
   output wire                            S_AXI_RLAST,
   output wire [C_AXI_RUSER_WIDTH-1:0]    S_AXI_RUSER,
   output wire                            S_AXI_RVALID,
   input  wire                            S_AXI_RREADY,
   
   // Master Interface System Signals
   (* KEEP = "TRUE" *) input  wire        M_AXI_ACLK,

   // Master Interface Write Address Port
   output wire [C_AXI_ID_WIDTH-1:0]       M_AXI_AWID,
   output wire [C_AXI_ADDR_WIDTH-1:0]     M_AXI_AWADDR,
   output wire [8-1:0]                    M_AXI_AWLEN,
   output wire [3-1:0]                    M_AXI_AWSIZE,
   output wire [2-1:0]                    M_AXI_AWBURST,
   output wire [2-1:0]                    M_AXI_AWLOCK,
   output wire [4-1:0]                    M_AXI_AWCACHE,
   output wire [3-1:0]                    M_AXI_AWPROT,
   output wire [4-1:0]                    M_AXI_AWREGION,
   output wire [4-1:0]                    M_AXI_AWQOS,
   output wire [C_AXI_AWUSER_WIDTH-1:0]   M_AXI_AWUSER,
   output wire                            M_AXI_AWVALID,  
   input  wire                            M_AXI_AWREADY,

   // Master Interface Write Data Ports
   output wire [C_AXI_DATA_WIDTH-1:0]     M_AXI_WDATA,
   output wire [C_AXI_DATA_WIDTH/8-1:0]   M_AXI_WSTRB,
   output wire                            M_AXI_WLAST,
   output wire [C_AXI_WUSER_WIDTH-1:0]    M_AXI_WUSER,
   output wire                            M_AXI_WVALID,
   input  wire                            M_AXI_WREADY,

   // Master Interface Write Response Ports
   input  wire [C_AXI_ID_WIDTH-1:0]       M_AXI_BID,
   input  wire [2-1:0]                    M_AXI_BRESP,
   input  wire [C_AXI_BUSER_WIDTH-1:0]    M_AXI_BUSER,
   input  wire                            M_AXI_BVALID,
   output wire                            M_AXI_BREADY,

   // Master Interface Read Address Port
   output wire [C_AXI_ID_WIDTH-1:0]       M_AXI_ARID,
   output wire [C_AXI_ADDR_WIDTH-1:0]     M_AXI_ARADDR,
   output wire [8-1:0]                    M_AXI_ARLEN,
   output wire [3-1:0]                    M_AXI_ARSIZE,
   output wire [2-1:0]                    M_AXI_ARBURST,
   output wire [2-1:0]                    M_AXI_ARLOCK,
   output wire [4-1:0]                    M_AXI_ARCACHE,
   output wire [3-1:0]                    M_AXI_ARPROT,
   output wire [4-1:0]                    M_AXI_ARREGION,
   output wire [4-1:0]                    M_AXI_ARQOS,
   output wire [C_AXI_ARUSER_WIDTH-1:0]   M_AXI_ARUSER,
   output wire                            M_AXI_ARVALID,
   input  wire                            M_AXI_ARREADY,

   // Master Interface Read Data Ports
   input  wire [C_AXI_ID_WIDTH-1:0]       M_AXI_RID,
   input  wire [C_AXI_DATA_WIDTH-1:0]     M_AXI_RDATA,
   input  wire [2-1:0]                    M_AXI_RRESP,
   input  wire                            M_AXI_RLAST,
   input  wire [C_AXI_RUSER_WIDTH-1:0]    M_AXI_RUSER,
   input  wire                            M_AXI_RVALID,
   output wire                            M_AXI_RREADY);

  function integer f_ceil_log2
    (
     input integer x
     );
    integer acc;
    begin
      acc=0;
      while ((2**acc) < x)
        acc = acc + 1;
      f_ceil_log2 = acc;
    end
  endfunction

  localparam P_AXILITE = 32'h00000002;
  localparam integer P_LIGHT_WT = 0;
  localparam integer P_FULLY_REG = 1;
  localparam integer P_LUTRAM_ASYNC = 12;
  localparam P_PRIM_FIFO_TYPE = "512x72" ;
  
  // Sample cycle ratio
  localparam  P_SI_LT_MI = (C_S_AXI_ACLK_RATIO < C_M_AXI_ACLK_RATIO);
  localparam integer P_ROUNDING_OFFSET = P_SI_LT_MI ? (C_S_AXI_ACLK_RATIO/2) : (C_M_AXI_ACLK_RATIO/2);
  localparam integer P_ACLK_RATIO = P_SI_LT_MI ? ((C_M_AXI_ACLK_RATIO + P_ROUNDING_OFFSET) / C_S_AXI_ACLK_RATIO) : ((C_S_AXI_ACLK_RATIO + P_ROUNDING_OFFSET) / C_M_AXI_ACLK_RATIO);
  localparam integer P_LOAD_CNT = (P_ACLK_RATIO > 2) ? (P_ACLK_RATIO - 3) : 0;
  localparam integer P_ACLK_RATIO_LOG = f_ceil_log2(P_ACLK_RATIO);
  
  wire fast_aclk;
  wire slow_aclk;
  wire fast_areset;
  wire slow_areset;
  wire sample_cycle;
  wire sample_cycle_early;
  
  // Write Address Port bit positions
  localparam integer C_AWUSER_RIGHT   = 0;
  localparam integer C_AWUSER_LEN     = C_AXI_SUPPORTS_USER_SIGNALS*C_AXI_AWUSER_WIDTH;
  localparam integer C_AWQOS_RIGHT    = C_AWUSER_RIGHT + C_AWUSER_LEN;
  localparam integer C_AWQOS_LEN      = 4;
  localparam integer C_AWREGION_RIGHT = C_AWQOS_RIGHT + C_AWQOS_LEN;
  localparam integer C_AWREGION_LEN   = 4;
  localparam integer C_AWPROT_RIGHT   = C_AWREGION_RIGHT + C_AWREGION_LEN;
  localparam integer C_AWPROT_LEN     = 3;
  localparam integer C_AWCACHE_RIGHT  = C_AWPROT_RIGHT + C_AWPROT_LEN;
  localparam integer C_AWCACHE_LEN    = 4;
  localparam integer C_AWLOCK_RIGHT   = C_AWCACHE_RIGHT + C_AWCACHE_LEN;
  localparam integer C_AWLOCK_LEN     = 2;
  localparam integer C_AWBURST_RIGHT  = C_AWLOCK_RIGHT + C_AWLOCK_LEN;
  localparam integer C_AWBURST_LEN    = 2;
  localparam integer C_AWSIZE_RIGHT   = C_AWBURST_RIGHT + C_AWBURST_LEN;
  localparam integer C_AWSIZE_LEN     = 3;
  localparam integer C_AWLEN_RIGHT    = C_AWSIZE_RIGHT + C_AWSIZE_LEN;
  localparam integer C_AWLEN_LEN      = 8;
  localparam integer C_AWADDR_RIGHT   = C_AWLEN_RIGHT + C_AWLEN_LEN;
  localparam integer C_AWADDR_LEN     = C_AXI_ADDR_WIDTH;
  localparam integer C_AWID_RIGHT     = C_AWADDR_RIGHT + C_AWADDR_LEN;
  localparam integer C_AWID_LEN       = C_AXI_ID_WIDTH;
  localparam integer C_AW_SIZE        = C_AWID_RIGHT + C_AWID_LEN;

  // Write Address Port FIFO data read and write
  wire [C_AW_SIZE-1:0] s_aw_data ;
  wire [C_AW_SIZE-1:0] m_aw_data ;
  wire M_AXI_AWLOCK_I;

  // Write Data Port bit positions
  localparam integer C_WUSER_RIGHT   = 0;
  localparam integer C_WUSER_LEN     = C_AXI_SUPPORTS_USER_SIGNALS*C_AXI_WUSER_WIDTH;
  localparam integer C_WLAST_RIGHT   = C_WUSER_RIGHT + C_WUSER_LEN;
  localparam integer C_WLAST_LEN     = 1;
  localparam integer C_WSTRB_RIGHT   = C_WLAST_RIGHT + C_WLAST_LEN;
  localparam integer C_WSTRB_LEN     = C_AXI_DATA_WIDTH/8;
  localparam integer C_WDATA_RIGHT   = C_WSTRB_RIGHT + C_WSTRB_LEN;
  localparam integer C_WDATA_LEN     = C_AXI_DATA_WIDTH;
  localparam integer C_W_SIZE        = C_WDATA_RIGHT + C_WDATA_LEN;
  localparam integer C_W_FIFOGEN_SIZE = C_W_SIZE + C_AXI_ID_WIDTH;

  // Write Data Port FIFO data read and write
  wire [C_W_SIZE-1:0] s_w_data;
  wire [C_W_SIZE-1:0] m_w_data;

  // Write Response Port bit positions
  localparam integer C_BUSER_RIGHT   = 0;
  localparam integer C_BUSER_LEN     = C_AXI_SUPPORTS_USER_SIGNALS*C_AXI_BUSER_WIDTH;
  localparam integer C_BRESP_RIGHT   = C_BUSER_RIGHT + C_BUSER_LEN;
  localparam integer C_BRESP_LEN     = 2;
  localparam integer C_BID_RIGHT     = C_BRESP_RIGHT + C_BRESP_LEN;
  localparam integer C_BID_LEN       = C_AXI_ID_WIDTH;
  localparam integer C_B_SIZE        = C_BID_RIGHT + C_BID_LEN;

  // Write Response Port FIFO data read and write
  wire [C_B_SIZE-1:0] s_b_data;
  wire [C_B_SIZE-1:0] m_b_data;

  // Read Address Port bit positions
  localparam integer C_ARUSER_RIGHT   = 0;
  localparam integer C_ARUSER_LEN     = C_AXI_SUPPORTS_USER_SIGNALS*C_AXI_ARUSER_WIDTH;
  localparam integer C_ARQOS_RIGHT    = C_ARUSER_RIGHT + C_ARUSER_LEN;
  localparam integer C_ARQOS_LEN      = 4;
  localparam integer C_ARREGION_RIGHT = C_ARQOS_RIGHT + C_ARQOS_LEN;
  localparam integer C_ARREGION_LEN   = 4;
  localparam integer C_ARPROT_RIGHT   = C_ARREGION_RIGHT + C_ARREGION_LEN;
  localparam integer C_ARPROT_LEN     = 3;
  localparam integer C_ARCACHE_RIGHT  = C_ARPROT_RIGHT + C_ARPROT_LEN;
  localparam integer C_ARCACHE_LEN    = 4;
  localparam integer C_ARLOCK_RIGHT   = C_ARCACHE_RIGHT + C_ARCACHE_LEN;
  localparam integer C_ARLOCK_LEN     = 2;
  localparam integer C_ARBURST_RIGHT  = C_ARLOCK_RIGHT + C_ARLOCK_LEN;
  localparam integer C_ARBURST_LEN    = 2;
  localparam integer C_ARSIZE_RIGHT   = C_ARBURST_RIGHT + C_ARBURST_LEN;
  localparam integer C_ARSIZE_LEN     = 3;
  localparam integer C_ARLEN_RIGHT    = C_ARSIZE_RIGHT + C_ARSIZE_LEN;
  localparam integer C_ARLEN_LEN      = 8;
  localparam integer C_ARADDR_RIGHT   = C_ARLEN_RIGHT + C_ARLEN_LEN;
  localparam integer C_ARADDR_LEN     = C_AXI_ADDR_WIDTH;
  localparam integer C_ARID_RIGHT     = C_ARADDR_RIGHT + C_ARADDR_LEN;
  localparam integer C_ARID_LEN       = C_AXI_ID_WIDTH;
  localparam integer C_AR_SIZE        = C_ARID_RIGHT + C_ARID_LEN;

  // Read Address Port FIFO data read and write
  wire [C_AR_SIZE-1:0] s_ar_data;
  wire [C_AR_SIZE-1:0] m_ar_data;
  wire M_AXI_ARLOCK_I;

  // Read Data Ports bit positions
  localparam integer C_RUSER_RIGHT   = 0;
  localparam integer C_RUSER_LEN     = C_AXI_SUPPORTS_USER_SIGNALS*C_AXI_RUSER_WIDTH;
  localparam integer C_RLAST_RIGHT   = C_RUSER_RIGHT + C_RUSER_LEN;
  localparam integer C_RLAST_LEN     = 1;
  localparam integer C_RRESP_RIGHT   = C_RLAST_RIGHT + C_RLAST_LEN;
  localparam integer C_RRESP_LEN     = 2;
  localparam integer C_RDATA_RIGHT   = C_RRESP_RIGHT + C_RRESP_LEN;
  localparam integer C_RDATA_LEN     = C_AXI_DATA_WIDTH;
  localparam integer C_RID_RIGHT     = C_RDATA_RIGHT + C_RDATA_LEN;
  localparam integer C_RID_LEN       = C_AXI_ID_WIDTH;
  localparam integer C_R_SIZE        = C_RID_RIGHT + C_RID_LEN;

  // Read Data Ports FIFO data read and write
  wire [C_R_SIZE-1:0] s_r_data;
  wire [C_R_SIZE-1:0] m_r_data;

  // Reset resynchronization signals
  wire interconnect_areset_i;
  (* async_reg="yes", shreg_extract="no", iob="false", equivalent_register_removal = "no" *) reg [3:0] m_axi_aresetn_resync;
  (* async_reg="yes", shreg_extract="no", iob="false", equivalent_register_removal = "no" *) reg [3:0] s_axi_aresetn_resync;
  (* async_reg="yes", shreg_extract="no", iob="false", equivalent_register_removal = "no" *) reg [3:0] interconnect_aresetn_resync;
  (* async_reg="yes", shreg_extract="no" *) reg  [2:0] interconnect_aresetn_pipe;
  (* async_reg="yes", shreg_extract="no" *) reg  [2:0] m_axi_aresetn_pipe;
  (* async_reg="yes", shreg_extract="no" *) reg  [2:0] s_axi_aresetn_pipe;
  (* async_reg="yes", KEEP = "TRUE", shreg_extract="no", iob="false", equivalent_register_removal = "no" *) reg m_async_conv_reset /* synthesis syn_keep = 1 */;
  (* async_reg="yes", KEEP = "TRUE", shreg_extract="no", iob="false", equivalent_register_removal = "no" *) reg s_async_conv_reset /* synthesis syn_keep = 1 */;
  
  wire async_conv_reset_n;
  wire s_axi_reset_out_i; 
  wire m_axi_reset_out_i; 
  reg  s_axi_reset_out_n_i; 
  reg  m_axi_reset_out_n_i; 

  ////////////////////////////////////////////////////////////////////////////////
  // AXI Reset Signal Resynchronization
  ////////////////////////////////////////////////////////////////////////////////
  
  assign interconnect_areset_i = ~INTERCONNECT_ARESETN;
  
  assign INTERCONNECT_RESET_OUT_N = interconnect_aresetn_pipe[2];
  always @(posedge INTERCONNECT_ACLK or posedge interconnect_areset_i) begin
    if (interconnect_areset_i) begin
      interconnect_aresetn_resync <= 4'b0000;
    end else begin
      interconnect_aresetn_resync <= {interconnect_aresetn_resync[2:0], 1'b1};
    end
  end
  always @(posedge INTERCONNECT_ACLK) begin
    if (~interconnect_aresetn_resync[3]) begin
      interconnect_aresetn_pipe <= 3'b000;
    end else begin
      interconnect_aresetn_pipe <= {interconnect_aresetn_pipe[1:0], 1'b1};
    end
  end
  
  assign async_conv_reset_n = ~(m_async_conv_reset | s_async_conv_reset);
  always @(posedge S_AXI_ACLK) begin
    s_async_conv_reset <= s_axi_reset_out_i;
  end
  always @(posedge M_AXI_ACLK) begin
    m_async_conv_reset <= m_axi_reset_out_i;
  end
  
  
  generate
    if ((C_AXI_IS_ACLK_ASYNC == 1'b1) ||
        (P_ACLK_RATIO > 1)) begin : gen_aresetn_sync
      
      assign M_AXI_RESET_OUT_N = m_axi_aresetn_pipe[2];
      assign m_axi_reset_out_i = ~m_axi_aresetn_pipe[2];
      always @(posedge M_AXI_ACLK or posedge interconnect_areset_i) begin
        if (interconnect_areset_i) begin
          m_axi_aresetn_resync <= 4'b0000;
        end else begin
          m_axi_aresetn_resync <= {m_axi_aresetn_resync[2:0], 1'b1};
        end
      end
      always @(posedge M_AXI_ACLK) begin
        if (~m_axi_aresetn_resync[3]) begin
          m_axi_aresetn_pipe <= 3'b000;
        end else begin
          m_axi_aresetn_pipe <= {m_axi_aresetn_pipe[1:0], 1'b1};
        end
      end
      
      assign S_AXI_RESET_OUT_N = s_axi_aresetn_pipe[2];
      assign s_axi_reset_out_i = ~s_axi_aresetn_pipe[2];
      always @(posedge S_AXI_ACLK or posedge interconnect_areset_i) begin
        if (interconnect_areset_i) begin
          s_axi_aresetn_resync <= 4'b0000;
        end else begin
          s_axi_aresetn_resync <= {s_axi_aresetn_resync[2:0], 1'b1};
        end
      end
      always @(posedge S_AXI_ACLK) begin
        if (~s_axi_aresetn_resync[3]) begin
          s_axi_aresetn_pipe <= 3'b000;
        end else begin
          s_axi_aresetn_pipe <= {s_axi_aresetn_pipe[1:0], 1'b1};
        end
      end
      
    end else begin : gen_no_aresetn_sync
      always @(posedge M_AXI_ACLK) begin
        m_axi_reset_out_n_i <= LOCAL_ARESETN;
      end
      always @(posedge S_AXI_ACLK) begin
        s_axi_reset_out_n_i <= LOCAL_ARESETN;
      end
      assign M_AXI_RESET_OUT_N = m_axi_reset_out_n_i;
      assign S_AXI_RESET_OUT_N = s_axi_reset_out_n_i;
      assign m_axi_reset_out_i = 1'b0;
      assign s_axi_reset_out_i = 1'b0;
    end  
    
  if (C_AXI_IS_ACLK_ASYNC && (C_AXI_SUPPORTS_READ == 0)) begin : gen_async_writeonly
      assign M_AXI_AWLOCK   = {1'b0,M_AXI_AWLOCK_I};
      
      // Read Address Port
      assign M_AXI_ARID     = 0;
      assign M_AXI_ARADDR   = 0;
      assign M_AXI_ARLEN    = 0;
      assign M_AXI_ARSIZE   = 0;
      assign M_AXI_ARBURST  = 0;
      assign M_AXI_ARLOCK   = 0;
      assign M_AXI_ARCACHE  = 0;
      assign M_AXI_ARPROT   = 0;
      assign M_AXI_ARREGION = 0;
      assign M_AXI_ARQOS    = 0;
      assign M_AXI_ARUSER   = 0;
      assign M_AXI_ARVALID  = 1'b0;
      assign S_AXI_ARREADY  = 1'b0;

      // Read Data Port
      assign S_AXI_RID      = 0;
      assign S_AXI_RDATA    = 0;
      assign S_AXI_RRESP    = 0;
      assign S_AXI_RLAST    = 0;
      assign S_AXI_RUSER    = 0;
      assign S_AXI_RVALID   = 1'b0;
      assign M_AXI_RREADY   = 1'b0;
      
  fifo_generator_v13_1_4 #(
          .C_ADD_NGC_CONSTRAINT(0),
          .C_APPLICATION_TYPE_AXIS(0),
          .C_APPLICATION_TYPE_RACH(0),
          .C_APPLICATION_TYPE_RDCH(0),
          .C_APPLICATION_TYPE_WACH(0),
          .C_APPLICATION_TYPE_WDCH(0),
          .C_APPLICATION_TYPE_WRCH(0),
          .C_AXI_ADDR_WIDTH(C_AXI_ADDR_WIDTH),
          .C_AXI_ARUSER_WIDTH(C_AXI_ARUSER_WIDTH),
          .C_AXI_AWUSER_WIDTH(C_AXI_AWUSER_WIDTH),
          .C_AXI_BUSER_WIDTH(C_AXI_BUSER_WIDTH),
          .C_AXI_DATA_WIDTH(C_AXI_DATA_WIDTH),
          .C_AXI_ID_WIDTH(C_AXI_ID_WIDTH),
          .C_AXI_LEN_WIDTH(8),
          .C_AXI_LOCK_WIDTH(1),
          .C_AXI_RUSER_WIDTH(C_AXI_RUSER_WIDTH),
          .C_AXI_TYPE(1),
          .C_AXI_WUSER_WIDTH(C_AXI_WUSER_WIDTH),
          .C_AXIS_TDATA_WIDTH(64),
          .C_AXIS_TDEST_WIDTH(4),
          .C_AXIS_TID_WIDTH(4),
          .C_AXIS_TKEEP_WIDTH(4),
          .C_AXIS_TSTRB_WIDTH(4),
          .C_AXIS_TUSER_WIDTH(4),
          .C_AXIS_TYPE(0),
          .C_COMMON_CLOCK(0),
          .C_COUNT_TYPE(0),
          .C_DATA_COUNT_WIDTH(10),
          .C_DEFAULT_VALUE("BlankString"),
          .C_DIN_WIDTH(18),
          .C_DIN_WIDTH_AXIS(1),
          .C_DIN_WIDTH_RACH(C_AR_SIZE),
          .C_DIN_WIDTH_RDCH(C_R_SIZE),
          .C_DIN_WIDTH_WACH(C_AW_SIZE),
          .C_DIN_WIDTH_WDCH(C_W_SIZE),
          .C_DIN_WIDTH_WRCH(C_B_SIZE),
          .C_DOUT_RST_VAL("0"),
          .C_DOUT_WIDTH(18),
          .C_ENABLE_RLOCS(0),
          .C_ENABLE_RST_SYNC(1),
          .C_ERROR_INJECTION_TYPE(0),
          .C_ERROR_INJECTION_TYPE_AXIS(0),
          .C_ERROR_INJECTION_TYPE_RACH(0),
          .C_ERROR_INJECTION_TYPE_RDCH(0),
          .C_ERROR_INJECTION_TYPE_WACH(0),
          .C_ERROR_INJECTION_TYPE_WDCH(0),
          .C_ERROR_INJECTION_TYPE_WRCH(0),
          .C_FAMILY(C_FAMILY),
          .C_FULL_FLAGS_RST_VAL(1),
          .C_HAS_ALMOST_EMPTY(0),
          .C_HAS_ALMOST_FULL(0),
          .C_HAS_AXI_RD_CHANNEL(C_AXI_SUPPORTS_READ),
          .C_HAS_AXI_WR_CHANNEL(C_AXI_SUPPORTS_WRITE),
          .C_HAS_AXI_ID(1),
          .C_HAS_AXI_ARUSER(C_AXI_SUPPORTS_USER_SIGNALS),
          .C_HAS_AXI_AWUSER(C_AXI_SUPPORTS_USER_SIGNALS),
          .C_HAS_AXI_BUSER(C_AXI_SUPPORTS_USER_SIGNALS),
          .C_HAS_AXI_RUSER(C_AXI_SUPPORTS_USER_SIGNALS),
          .C_HAS_AXI_WUSER(C_AXI_SUPPORTS_USER_SIGNALS),
          .C_HAS_AXIS_TDATA(0),
          .C_HAS_AXIS_TDEST(0),
          .C_HAS_AXIS_TID(0),
          .C_HAS_AXIS_TKEEP(0),
          .C_HAS_AXIS_TLAST(0),
          .C_HAS_AXIS_TREADY(1),
          .C_HAS_AXIS_TSTRB(0),
          .C_HAS_AXIS_TUSER(0),
          .C_HAS_BACKUP(0),
          .C_HAS_DATA_COUNT(0),
          .C_HAS_DATA_COUNTS_AXIS(0),
          .C_HAS_DATA_COUNTS_RACH(0),
          .C_HAS_DATA_COUNTS_RDCH(0),
          .C_HAS_DATA_COUNTS_WACH(0),
          .C_HAS_DATA_COUNTS_WDCH(0),
          .C_HAS_DATA_COUNTS_WRCH(0),
          .C_HAS_INT_CLK(0),
          .C_HAS_MASTER_CE(0),
          .C_HAS_MEMINIT_FILE(0),
          .C_HAS_OVERFLOW(0),
          .C_HAS_PROG_FLAGS_AXIS(0),
          .C_HAS_PROG_FLAGS_RACH(0),
          .C_HAS_PROG_FLAGS_RDCH(0),
          .C_HAS_PROG_FLAGS_WACH(0),
          .C_HAS_PROG_FLAGS_WDCH(0),
          .C_HAS_PROG_FLAGS_WRCH(0),
          .C_HAS_RD_DATA_COUNT(0),
          .C_HAS_RD_RST(0),
          .C_HAS_RST(1),
          .C_HAS_SLAVE_CE(0),
          .C_HAS_SRST(0),
          .C_HAS_UNDERFLOW(0),
          .C_HAS_VALID(0),
          .C_HAS_WR_ACK(0),
          .C_HAS_WR_DATA_COUNT(0),
          .C_HAS_WR_RST(0),
          .C_IMPLEMENTATION_TYPE(0),
          .C_IMPLEMENTATION_TYPE_AXIS(P_LUTRAM_ASYNC),
          .C_IMPLEMENTATION_TYPE_RACH(P_LUTRAM_ASYNC),
          .C_IMPLEMENTATION_TYPE_RDCH(P_LUTRAM_ASYNC),
          .C_IMPLEMENTATION_TYPE_WACH(P_LUTRAM_ASYNC),
          .C_IMPLEMENTATION_TYPE_WDCH(P_LUTRAM_ASYNC),
          .C_IMPLEMENTATION_TYPE_WRCH(P_LUTRAM_ASYNC),
          .C_INIT_WR_PNTR_VAL(0),
          .C_INTERFACE_TYPE(2),
          .C_MEMORY_TYPE(1),
          .C_MIF_FILE_NAME("BlankString"),
          .C_MSGON_VAL(1),
          .C_OPTIMIZATION_MODE(0),
          .C_OVERFLOW_LOW(0),
          .C_PRELOAD_LATENCY(1),
          .C_PRELOAD_REGS(0),
          .C_PRIM_FIFO_TYPE("4kx4"),
          .C_PROG_EMPTY_THRESH_ASSERT_VAL(2),
          .C_PROG_EMPTY_THRESH_ASSERT_VAL_AXIS(1021),
          .C_PROG_EMPTY_THRESH_ASSERT_VAL_RACH(29),
          .C_PROG_EMPTY_THRESH_ASSERT_VAL_RDCH(29),
          .C_PROG_EMPTY_THRESH_ASSERT_VAL_WACH(29),
          .C_PROG_EMPTY_THRESH_ASSERT_VAL_WDCH(29),
          .C_PROG_EMPTY_THRESH_ASSERT_VAL_WRCH(29),
          .C_PROG_EMPTY_THRESH_NEGATE_VAL(3),
          .C_PROG_EMPTY_TYPE(0),
          .C_PROG_EMPTY_TYPE_AXIS(5),
          .C_PROG_EMPTY_TYPE_RACH(5),
          .C_PROG_EMPTY_TYPE_RDCH(5),
          .C_PROG_EMPTY_TYPE_WACH(5),
          .C_PROG_EMPTY_TYPE_WDCH(5),
          .C_PROG_EMPTY_TYPE_WRCH(5),
          .C_PROG_FULL_THRESH_ASSERT_VAL(1022),
          .C_PROG_FULL_THRESH_ASSERT_VAL_AXIS(1023),
          .C_PROG_FULL_THRESH_ASSERT_VAL_RACH(31),
          .C_PROG_FULL_THRESH_ASSERT_VAL_RDCH(31),
          .C_PROG_FULL_THRESH_ASSERT_VAL_WACH(31),
          .C_PROG_FULL_THRESH_ASSERT_VAL_WDCH(31),
          .C_PROG_FULL_THRESH_ASSERT_VAL_WRCH(31),
          .C_PROG_FULL_THRESH_NEGATE_VAL(1021),
          .C_PROG_FULL_TYPE(0),
          .C_PROG_FULL_TYPE_AXIS(5),
          .C_PROG_FULL_TYPE_RACH(5),
          .C_PROG_FULL_TYPE_RDCH(5),
          .C_PROG_FULL_TYPE_WACH(5),
          .C_PROG_FULL_TYPE_WDCH(5),
          .C_PROG_FULL_TYPE_WRCH(5),
          .C_RACH_TYPE(C_AXI_SUPPORTS_READ ? 0 : 2),
          .C_RD_DATA_COUNT_WIDTH(10),
          .C_RD_DEPTH(1024),
          .C_RD_FREQ(1),
          .C_RD_PNTR_WIDTH(10),
          .C_RDCH_TYPE(C_AXI_SUPPORTS_READ ? 0 : 2),
          .C_REG_SLICE_MODE_AXIS(0),
          .C_REG_SLICE_MODE_RACH(0),
          .C_REG_SLICE_MODE_RDCH(0),
          .C_REG_SLICE_MODE_WACH(0),
          .C_REG_SLICE_MODE_WDCH(0),
          .C_REG_SLICE_MODE_WRCH(0),
          .C_SYNCHRONIZER_STAGE(C_SYNCHRONIZER_STAGE),
          .C_UNDERFLOW_LOW(0),
          .C_USE_COMMON_OVERFLOW(0),
          .C_USE_COMMON_UNDERFLOW(0),
          .C_USE_DEFAULT_SETTINGS(0),
          .C_USE_DOUT_RST(1),
          .C_USE_ECC(0),
          .C_USE_ECC_AXIS(0),
          .C_USE_ECC_RACH(0),
          .C_USE_ECC_RDCH(0),
          .C_USE_ECC_WACH(0),
          .C_USE_ECC_WDCH(0),
          .C_USE_ECC_WRCH(0),
          .C_USE_EMBEDDED_REG(0),
          .C_USE_FIFO16_FLAGS(0),
          .C_USE_FWFT_DATA_COUNT(0),
          .C_VALID_LOW(0),
          .C_WACH_TYPE(C_AXI_SUPPORTS_WRITE ? 0 : 2),
          .C_WDCH_TYPE(C_AXI_SUPPORTS_WRITE ? 0 : 2),
          .C_WR_ACK_LOW(0),
          .C_WR_DATA_COUNT_WIDTH(10),
          .C_WR_DEPTH(1024),
          .C_WR_DEPTH_AXIS(32),
          .C_WR_DEPTH_RACH(32),
          .C_WR_DEPTH_RDCH(32),
          .C_WR_DEPTH_WACH(32),
          .C_WR_DEPTH_WDCH(32),
          .C_WR_DEPTH_WRCH(32),
          .C_WR_FREQ(1),
          .C_WR_PNTR_WIDTH(10),
          .C_WR_PNTR_WIDTH_AXIS(5),
          .C_WR_PNTR_WIDTH_RACH(5),
          .C_WR_PNTR_WIDTH_RDCH(5),
          .C_WR_PNTR_WIDTH_WACH(5),
          .C_WR_PNTR_WIDTH_WDCH(5),
          .C_WR_PNTR_WIDTH_WRCH(5),
          .C_WR_RESPONSE_LATENCY(1),
          .C_WRCH_TYPE(C_AXI_SUPPORTS_WRITE ? 0 : 2)
        )
        asyncfifo_wo (
          .s_aclk         (S_AXI_ACLK),
          .m_aclk         (M_AXI_ACLK),
          .s_aresetn      (async_conv_reset_n),
          .s_axi_awid     (S_AXI_AWID),
          .s_axi_awaddr   (S_AXI_AWADDR),
          .s_axi_awlen    (S_AXI_AWLEN),
          .s_axi_awsize   (S_AXI_AWSIZE),
          .s_axi_awburst  (S_AXI_AWBURST),
          .s_axi_awlock   (S_AXI_AWLOCK[0]),
          .s_axi_awcache  (S_AXI_AWCACHE),
          .s_axi_awprot   (S_AXI_AWPROT),
          .s_axi_awqos    (S_AXI_AWQOS),
          .s_axi_awregion (S_AXI_AWREGION),
          .s_axi_awuser   (S_AXI_AWUSER),
          .s_axi_awvalid  (S_AXI_AWVALID),
          .s_axi_awready  (S_AXI_AWREADY),
          .s_axi_wid      ({C_AXI_ID_WIDTH{1'b0}}),
          .s_axi_wdata    (S_AXI_WDATA),
          .s_axi_wstrb    (S_AXI_WSTRB),
          .s_axi_wlast    (S_AXI_WLAST),
          .s_axi_wuser    (S_AXI_WUSER),
          .s_axi_wvalid   (S_AXI_WVALID),
          .s_axi_wready   (S_AXI_WREADY),
          .s_axi_bid      (S_AXI_BID),
          .s_axi_bresp    (S_AXI_BRESP),
          .s_axi_buser    (S_AXI_BUSER),
          .s_axi_bvalid   (S_AXI_BVALID),
          .s_axi_bready   (S_AXI_BREADY),
          .m_axi_awid     (M_AXI_AWID),
          .m_axi_awaddr   (M_AXI_AWADDR),
          .m_axi_awlen    (M_AXI_AWLEN),
          .m_axi_awsize   (M_AXI_AWSIZE),
          .m_axi_awburst  (M_AXI_AWBURST),
          .m_axi_awlock   (M_AXI_AWLOCK_I),
          .m_axi_awcache  (M_AXI_AWCACHE),
          .m_axi_awprot   (M_AXI_AWPROT),
          .m_axi_awqos    (M_AXI_AWQOS),
          .m_axi_awregion (M_AXI_AWREGION),
          .m_axi_awuser   (M_AXI_AWUSER),
          .m_axi_awvalid  (M_AXI_AWVALID),
          .m_axi_awready  (M_AXI_AWREADY),
          .m_axi_wid      (),
          .m_axi_wdata    (M_AXI_WDATA),
          .m_axi_wstrb    (M_AXI_WSTRB),
          .m_axi_wlast    (M_AXI_WLAST),
          .m_axi_wuser    (M_AXI_WUSER),
          .m_axi_wvalid   (M_AXI_WVALID),
          .m_axi_wready   (M_AXI_WREADY),
          .m_axi_bid      (M_AXI_BID),
          .m_axi_bresp    (M_AXI_BRESP),
          .m_axi_buser    (M_AXI_BUSER),
          .m_axi_bvalid   (M_AXI_BVALID),
          .m_axi_bready   (M_AXI_BREADY),
          .s_axi_arid     (S_AXI_ARID),
          .s_axi_araddr   (S_AXI_ARADDR),
          .s_axi_arlen    (S_AXI_ARLEN),
          .s_axi_arsize   (S_AXI_ARSIZE),
          .s_axi_arburst  (S_AXI_ARBURST),
          .s_axi_arlock   (S_AXI_ARLOCK[0]),
          .s_axi_arcache  (S_AXI_ARCACHE),
          .s_axi_arprot   (S_AXI_ARPROT),
          .s_axi_arqos    (S_AXI_ARQOS),
          .s_axi_arregion (S_AXI_ARREGION),
          .s_axi_aruser   (S_AXI_ARUSER),
          .s_axi_arvalid  (S_AXI_ARVALID),
          .s_axi_arready  (),
          .s_axi_rid      (),
          .s_axi_rdata    (),
          .s_axi_rresp    (),
          .s_axi_rlast    (),
          .s_axi_ruser    (),
          .s_axi_rvalid   (),
          .s_axi_rready   (S_AXI_RREADY),
          .m_axi_arid     (),
          .m_axi_araddr   (),
          .m_axi_arlen    (),
          .m_axi_arsize   (),
          .m_axi_arburst  (),
          .m_axi_arlock   (),
          .m_axi_arcache  (),
          .m_axi_arprot   (),
          .m_axi_arqos    (),
          .m_axi_arregion (),
          .m_axi_aruser   (),
          .m_axi_arvalid  (),
          .m_axi_arready  (M_AXI_ARREADY),
          .m_axi_rid      (M_AXI_RID),
          .m_axi_rdata    (M_AXI_RDATA),
          .m_axi_rresp    (M_AXI_RRESP),
          .m_axi_rlast    (M_AXI_RLAST),
          .m_axi_ruser    (M_AXI_RUSER),
          .m_axi_rvalid   (M_AXI_RVALID),
          .m_axi_rready   (),
          .m_aclk_en      (1'b1),
          .s_aclk_en      (1'b1),
          .almost_empty(),
          .almost_full(),
          .axis_data_count(),
          .axis_dbiterr(),
          .axis_injectdbiterr(1'b0),
          .axis_injectsbiterr(1'b0),
          .axis_overflow(),
          .axis_prog_empty(),
          .axis_prog_empty_thresh(5'b0),
          .axis_prog_full(),
          .axis_prog_full_thresh(5'b0),
          .axis_rd_data_count(),
          .axis_sbiterr(),
          .axis_underflow(),
          .axis_wr_data_count(),
          .axi_ar_data_count(),
          .axi_ar_dbiterr(),
          .axi_ar_injectdbiterr(1'b0),
          .axi_ar_injectsbiterr(1'b0),
          .axi_ar_overflow(),
          .axi_ar_prog_empty(),
          .axi_ar_prog_empty_thresh(5'b0),
          .axi_ar_prog_full(),
          .axi_ar_prog_full_thresh(5'b0),
          .axi_ar_rd_data_count(),
          .axi_ar_sbiterr(),
          .axi_ar_underflow(),
          .axi_ar_wr_data_count(),
          .axi_aw_data_count(),
          .axi_aw_dbiterr(),
          .axi_aw_injectdbiterr(1'b0),
          .axi_aw_injectsbiterr(1'b0),
          .axi_aw_overflow(),
          .axi_aw_prog_empty(),
          .axi_aw_prog_empty_thresh(5'b0),
          .axi_aw_prog_full(),
          .axi_aw_prog_full_thresh(5'b0),
          .axi_aw_rd_data_count(),
          .axi_aw_sbiterr(),
          .axi_aw_underflow(),
          .axi_aw_wr_data_count(),
          .axi_b_data_count(),
          .axi_b_dbiterr(),
          .axi_b_injectdbiterr(1'b0),
          .axi_b_injectsbiterr(1'b0),
          .axi_b_overflow(),
          .axi_b_prog_empty(),
          .axi_b_prog_empty_thresh(5'b0),
          .axi_b_prog_full(),
          .axi_b_prog_full_thresh(5'b0),
          .axi_b_rd_data_count(),
          .axi_b_sbiterr(),
          .axi_b_underflow(),
          .axi_b_wr_data_count(),
          .axi_r_data_count(),
          .axi_r_dbiterr(),
          .axi_r_injectdbiterr(1'b0),
          .axi_r_injectsbiterr(1'b0),
          .axi_r_overflow(),
          .axi_r_prog_empty(),
          .axi_r_prog_empty_thresh(5'h00),
          .axi_r_prog_full(),
          .axi_r_prog_full_thresh(5'h00),
          .axi_r_rd_data_count(),
          .axi_r_sbiterr(),
          .axi_r_underflow(),
          .axi_r_wr_data_count(),
          .axi_w_data_count(),
          .axi_w_dbiterr(),
          .axi_w_injectdbiterr(1'b0),
          .axi_w_injectsbiterr(1'b0),
          .axi_w_overflow(),
          .axi_w_prog_empty(),
          .axi_w_prog_empty_thresh(5'h00),
          .axi_w_prog_full(),
          .axi_w_prog_full_thresh(5'h00),
          .axi_w_rd_data_count(),
          .axi_w_sbiterr(),
          .axi_w_underflow(),
          .axi_w_wr_data_count(),
          .backup(1'b0),
          .backup_marker(1'b0),
          .clk(1'b0),
          .data_count(),
          .dbiterr(),
          .din(18'b0),
          .dout(),
          .empty(),
          .full(),
          .injectdbiterr(1'b0),
          .injectsbiterr(1'b0),
          .int_clk(1'b0),
          .m_axis_tdata(),
          .m_axis_tdest(),
          .m_axis_tid(),
          .m_axis_tkeep(),
          .m_axis_tlast(),
          .m_axis_tready(1'b0),
          .m_axis_tstrb(),
          .m_axis_tuser(),
          .m_axis_tvalid(),
          .overflow(),
          .prog_empty(),
          .prog_empty_thresh(10'b0),
          .prog_empty_thresh_assert(10'b0),
          .prog_empty_thresh_negate(10'b0),
          .prog_full(),
          .prog_full_thresh(10'b0),
          .prog_full_thresh_assert(10'b0),
          .prog_full_thresh_negate(10'b0),
          .rd_clk(1'b0),
          .rd_data_count(),
          .rd_en(1'b0),
          .rd_rst(1'b0),
          .rst(1'b0),
          .sbiterr(),
          .srst(1'b0),
          .s_axis_tdata(64'b0),
          .s_axis_tdest(4'b0),
          .s_axis_tid(4'b0),
          .s_axis_tkeep(4'b0),
          .s_axis_tlast(1'b0),
          .s_axis_tready(),
          .s_axis_tstrb(4'b0),
          .s_axis_tuser(4'b0),
          .s_axis_tvalid(1'b0),
          .underflow(),
          .valid(),
          .wr_ack(),
          .wr_clk(1'b0),
          .wr_data_count(),
          .wr_en(1'b0),
          .wr_rst(1'b0),
          .sleep(1'b0),
          .rd_rst_busy(),
          .wr_rst_busy()
      );
    end else if (C_AXI_IS_ACLK_ASYNC && (C_AXI_SUPPORTS_WRITE == 0)) begin : gen_async_readonly
      assign M_AXI_ARLOCK   = {1'b0,M_AXI_ARLOCK_I};

      // Write address port
      assign M_AXI_AWID     = 0;
      assign M_AXI_AWADDR   = 0;
      assign M_AXI_AWLEN    = 0;
      assign M_AXI_AWSIZE   = 0;
      assign M_AXI_AWBURST  = 0;
      assign M_AXI_AWLOCK   = 0;
      assign M_AXI_AWCACHE  = 0;
      assign M_AXI_AWPROT   = 0;
      assign M_AXI_AWREGION = 0;
      assign M_AXI_AWQOS    = 0;
      assign M_AXI_AWUSER   = 0;
      assign M_AXI_AWVALID  = 1'b0;
      assign S_AXI_AWREADY  = 1'b0;

      // Write Data Port
      assign M_AXI_WDATA    = 0;
      assign M_AXI_WSTRB    = 0;
      assign M_AXI_WLAST    = 0;
      assign M_AXI_WUSER    = 0;
      assign M_AXI_WVALID   = 1'b0;
      assign S_AXI_WREADY   = 1'b0;

      // Write Response Port
      assign S_AXI_BID      = 0;
      assign S_AXI_BRESP    = 0;
      assign S_AXI_BUSER    = 0;
      assign S_AXI_BVALID   = 1'b0;
      assign M_AXI_BREADY   = 1'b0;

        fifo_generator_v13_1_4 #(
          .C_ADD_NGC_CONSTRAINT(0),
          .C_APPLICATION_TYPE_AXIS(0),
          .C_APPLICATION_TYPE_RACH(0),
          .C_APPLICATION_TYPE_RDCH(0),
          .C_APPLICATION_TYPE_WACH(0),
          .C_APPLICATION_TYPE_WDCH(0),
          .C_APPLICATION_TYPE_WRCH(0),
          .C_AXI_ADDR_WIDTH(C_AXI_ADDR_WIDTH),
          .C_AXI_ARUSER_WIDTH(C_AXI_ARUSER_WIDTH),
          .C_AXI_AWUSER_WIDTH(C_AXI_AWUSER_WIDTH),
          .C_AXI_BUSER_WIDTH(C_AXI_BUSER_WIDTH),
          .C_AXI_DATA_WIDTH(C_AXI_DATA_WIDTH),
          .C_AXI_ID_WIDTH(C_AXI_ID_WIDTH),
          .C_AXI_LEN_WIDTH(8),
          .C_AXI_LOCK_WIDTH(1),
          .C_AXI_RUSER_WIDTH(C_AXI_RUSER_WIDTH),
          .C_AXI_TYPE(1),
          .C_AXI_WUSER_WIDTH(C_AXI_WUSER_WIDTH),
          .C_AXIS_TDATA_WIDTH(64),
          .C_AXIS_TDEST_WIDTH(4),
          .C_AXIS_TID_WIDTH(4),
          .C_AXIS_TKEEP_WIDTH(4),
          .C_AXIS_TSTRB_WIDTH(4),
          .C_AXIS_TUSER_WIDTH(4),
          .C_AXIS_TYPE(0),
          .C_COMMON_CLOCK(0),
          .C_COUNT_TYPE(0),
          .C_DATA_COUNT_WIDTH(10),
          .C_DEFAULT_VALUE("BlankString"),
          .C_DIN_WIDTH(18),
          .C_DIN_WIDTH_AXIS(1),
          .C_DIN_WIDTH_RACH(C_AR_SIZE),
          .C_DIN_WIDTH_RDCH(C_R_SIZE),
          .C_DIN_WIDTH_WACH(C_AW_SIZE),
          .C_DIN_WIDTH_WDCH(C_W_SIZE),
          .C_DIN_WIDTH_WRCH(C_B_SIZE),
          .C_DOUT_RST_VAL("0"),
          .C_DOUT_WIDTH(18),
          .C_ENABLE_RLOCS(0),
          .C_ENABLE_RST_SYNC(1),
          .C_ERROR_INJECTION_TYPE(0),
          .C_ERROR_INJECTION_TYPE_AXIS(0),
          .C_ERROR_INJECTION_TYPE_RACH(0),
          .C_ERROR_INJECTION_TYPE_RDCH(0),
          .C_ERROR_INJECTION_TYPE_WACH(0),
          .C_ERROR_INJECTION_TYPE_WDCH(0),
          .C_ERROR_INJECTION_TYPE_WRCH(0),
          .C_FAMILY(C_FAMILY),
          .C_FULL_FLAGS_RST_VAL(1),
          .C_HAS_ALMOST_EMPTY(0),
          .C_HAS_ALMOST_FULL(0),
          .C_HAS_AXI_RD_CHANNEL(C_AXI_SUPPORTS_READ),
          .C_HAS_AXI_WR_CHANNEL(C_AXI_SUPPORTS_WRITE),
          .C_HAS_AXI_ID(1),
          .C_HAS_AXI_ARUSER(C_AXI_SUPPORTS_USER_SIGNALS),
          .C_HAS_AXI_AWUSER(C_AXI_SUPPORTS_USER_SIGNALS),
          .C_HAS_AXI_BUSER(C_AXI_SUPPORTS_USER_SIGNALS),
          .C_HAS_AXI_RUSER(C_AXI_SUPPORTS_USER_SIGNALS),
          .C_HAS_AXI_WUSER(C_AXI_SUPPORTS_USER_SIGNALS),
          .C_HAS_AXIS_TDATA(0),
          .C_HAS_AXIS_TDEST(0),
          .C_HAS_AXIS_TID(0),
          .C_HAS_AXIS_TKEEP(0),
          .C_HAS_AXIS_TLAST(0),
          .C_HAS_AXIS_TREADY(1),
          .C_HAS_AXIS_TSTRB(0),
          .C_HAS_AXIS_TUSER(0),
          .C_HAS_BACKUP(0),
          .C_HAS_DATA_COUNT(0),
          .C_HAS_DATA_COUNTS_AXIS(0),
          .C_HAS_DATA_COUNTS_RACH(0),
          .C_HAS_DATA_COUNTS_RDCH(0),
          .C_HAS_DATA_COUNTS_WACH(0),
          .C_HAS_DATA_COUNTS_WDCH(0),
          .C_HAS_DATA_COUNTS_WRCH(0),
          .C_HAS_INT_CLK(0),
          .C_HAS_MASTER_CE(0),
          .C_HAS_MEMINIT_FILE(0),
          .C_HAS_OVERFLOW(0),
          .C_HAS_PROG_FLAGS_AXIS(0),
          .C_HAS_PROG_FLAGS_RACH(0),
          .C_HAS_PROG_FLAGS_RDCH(0),
          .C_HAS_PROG_FLAGS_WACH(0),
          .C_HAS_PROG_FLAGS_WDCH(0),
          .C_HAS_PROG_FLAGS_WRCH(0),
          .C_HAS_RD_DATA_COUNT(0),
          .C_HAS_RD_RST(0),
          .C_HAS_RST(1),
          .C_HAS_SLAVE_CE(0),
          .C_HAS_SRST(0),
          .C_HAS_UNDERFLOW(0),
          .C_HAS_VALID(0),
          .C_HAS_WR_ACK(0),
          .C_HAS_WR_DATA_COUNT(0),
          .C_HAS_WR_RST(0),
          .C_IMPLEMENTATION_TYPE(0),
          .C_IMPLEMENTATION_TYPE_AXIS(P_LUTRAM_ASYNC),
          .C_IMPLEMENTATION_TYPE_RACH(P_LUTRAM_ASYNC),
          .C_IMPLEMENTATION_TYPE_RDCH(P_LUTRAM_ASYNC),
          .C_IMPLEMENTATION_TYPE_WACH(P_LUTRAM_ASYNC),
          .C_IMPLEMENTATION_TYPE_WDCH(P_LUTRAM_ASYNC),
          .C_IMPLEMENTATION_TYPE_WRCH(P_LUTRAM_ASYNC),
          .C_INIT_WR_PNTR_VAL(0),
          .C_INTERFACE_TYPE(2),
          .C_MEMORY_TYPE(1),
          .C_MIF_FILE_NAME("BlankString"),
          .C_MSGON_VAL(1),
          .C_OPTIMIZATION_MODE(0),
          .C_OVERFLOW_LOW(0),
          .C_PRELOAD_LATENCY(1),
          .C_PRELOAD_REGS(0),
          .C_PRIM_FIFO_TYPE("4kx4"),
          .C_PROG_EMPTY_THRESH_ASSERT_VAL(2),
          .C_PROG_EMPTY_THRESH_ASSERT_VAL_AXIS(1021),
          .C_PROG_EMPTY_THRESH_ASSERT_VAL_RACH(29),
          .C_PROG_EMPTY_THRESH_ASSERT_VAL_RDCH(29),
          .C_PROG_EMPTY_THRESH_ASSERT_VAL_WACH(29),
          .C_PROG_EMPTY_THRESH_ASSERT_VAL_WDCH(29),
          .C_PROG_EMPTY_THRESH_ASSERT_VAL_WRCH(29),
          .C_PROG_EMPTY_THRESH_NEGATE_VAL(3),
          .C_PROG_EMPTY_TYPE(0),
          .C_PROG_EMPTY_TYPE_AXIS(5),
          .C_PROG_EMPTY_TYPE_RACH(5),
          .C_PROG_EMPTY_TYPE_RDCH(5),
          .C_PROG_EMPTY_TYPE_WACH(5),
          .C_PROG_EMPTY_TYPE_WDCH(5),
          .C_PROG_EMPTY_TYPE_WRCH(5),
          .C_PROG_FULL_THRESH_ASSERT_VAL(1022),
          .C_PROG_FULL_THRESH_ASSERT_VAL_AXIS(1023),
          .C_PROG_FULL_THRESH_ASSERT_VAL_RACH(31),
          .C_PROG_FULL_THRESH_ASSERT_VAL_RDCH(31),
          .C_PROG_FULL_THRESH_ASSERT_VAL_WACH(31),
          .C_PROG_FULL_THRESH_ASSERT_VAL_WDCH(31),
          .C_PROG_FULL_THRESH_ASSERT_VAL_WRCH(31),
          .C_PROG_FULL_THRESH_NEGATE_VAL(1021),
          .C_PROG_FULL_TYPE(0),
          .C_PROG_FULL_TYPE_AXIS(5),
          .C_PROG_FULL_TYPE_RACH(5),
          .C_PROG_FULL_TYPE_RDCH(5),
          .C_PROG_FULL_TYPE_WACH(5),
          .C_PROG_FULL_TYPE_WDCH(5),
          .C_PROG_FULL_TYPE_WRCH(5),
          .C_RACH_TYPE(C_AXI_SUPPORTS_READ ? 0 : 2),
          .C_RD_DATA_COUNT_WIDTH(10),
          .C_RD_DEPTH(1024),
          .C_RD_FREQ(1),
          .C_RD_PNTR_WIDTH(10),
          .C_RDCH_TYPE(C_AXI_SUPPORTS_READ ? 0 : 2),
          .C_REG_SLICE_MODE_AXIS(0),
          .C_REG_SLICE_MODE_RACH(0),
          .C_REG_SLICE_MODE_RDCH(0),
          .C_REG_SLICE_MODE_WACH(0),
          .C_REG_SLICE_MODE_WDCH(0),
          .C_REG_SLICE_MODE_WRCH(0),
          .C_SYNCHRONIZER_STAGE(C_SYNCHRONIZER_STAGE),
          .C_UNDERFLOW_LOW(0),
          .C_USE_COMMON_OVERFLOW(0),
          .C_USE_COMMON_UNDERFLOW(0),
          .C_USE_DEFAULT_SETTINGS(0),
          .C_USE_DOUT_RST(1),
          .C_USE_ECC(0),
          .C_USE_ECC_AXIS(0),
          .C_USE_ECC_RACH(0),
          .C_USE_ECC_RDCH(0),
          .C_USE_ECC_WACH(0),
          .C_USE_ECC_WDCH(0),
          .C_USE_ECC_WRCH(0),
          .C_USE_EMBEDDED_REG(0),
          .C_USE_FIFO16_FLAGS(0),
          .C_USE_FWFT_DATA_COUNT(0),
          .C_VALID_LOW(0),
          .C_WACH_TYPE(C_AXI_SUPPORTS_WRITE ? 0 : 2),
          .C_WDCH_TYPE(C_AXI_SUPPORTS_WRITE ? 0 : 2),
          .C_WR_ACK_LOW(0),
          .C_WR_DATA_COUNT_WIDTH(10),
          .C_WR_DEPTH(1024),
          .C_WR_DEPTH_AXIS(32),
          .C_WR_DEPTH_RACH(32),
          .C_WR_DEPTH_RDCH(32),
          .C_WR_DEPTH_WACH(32),
          .C_WR_DEPTH_WDCH(32),
          .C_WR_DEPTH_WRCH(32),
          .C_WR_FREQ(1),
          .C_WR_PNTR_WIDTH(10),
          .C_WR_PNTR_WIDTH_AXIS(5),
          .C_WR_PNTR_WIDTH_RACH(5),
          .C_WR_PNTR_WIDTH_RDCH(5),
          .C_WR_PNTR_WIDTH_WACH(5),
          .C_WR_PNTR_WIDTH_WDCH(5),
          .C_WR_PNTR_WIDTH_WRCH(5),
          .C_WR_RESPONSE_LATENCY(1),
          .C_WRCH_TYPE(C_AXI_SUPPORTS_WRITE ? 0 : 2)
        )
        asyncfifo_ro (
          .s_aclk         (S_AXI_ACLK),
          .m_aclk         (M_AXI_ACLK),
          .s_aresetn      (async_conv_reset_n),
          .s_axi_awid     (S_AXI_AWID),
          .s_axi_awaddr   (S_AXI_AWADDR),
          .s_axi_awlen    (S_AXI_AWLEN),
          .s_axi_awsize   (S_AXI_AWSIZE),
          .s_axi_awburst  (S_AXI_AWBURST),
          .s_axi_awlock   (S_AXI_AWLOCK[0]),
          .s_axi_awcache  (S_AXI_AWCACHE),
          .s_axi_awprot   (S_AXI_AWPROT),
          .s_axi_awqos    (S_AXI_AWQOS),
          .s_axi_awregion (S_AXI_AWREGION),
          .s_axi_awuser   (S_AXI_AWUSER),
          .s_axi_awvalid  (S_AXI_AWVALID),
          .s_axi_awready  (),
          .s_axi_wid      ({C_AXI_ID_WIDTH{1'b0}}),
          .s_axi_wdata    (S_AXI_WDATA),
          .s_axi_wstrb    (S_AXI_WSTRB),
          .s_axi_wlast    (S_AXI_WLAST),
          .s_axi_wuser    (S_AXI_WUSER),
          .s_axi_wvalid   (S_AXI_WVALID),
          .s_axi_wready   (),
          .s_axi_bid      (),
          .s_axi_bresp    (),
          .s_axi_buser    (),
          .s_axi_bvalid   (),
          .s_axi_bready   (S_AXI_BREADY),
          .m_axi_awid     (),
          .m_axi_awaddr   (),
          .m_axi_awlen    (),
          .m_axi_awsize   (),
          .m_axi_awburst  (),
          .m_axi_awlock   (),
          .m_axi_awcache  (),
          .m_axi_awprot   (),
          .m_axi_awqos    (),
          .m_axi_awregion (),
          .m_axi_awuser   (),
          .m_axi_awvalid  (),
          .m_axi_awready  (M_AXI_AWREADY),
          .m_axi_wid      (),
          .m_axi_wdata    (),
          .m_axi_wstrb    (),
          .m_axi_wlast    (),
          .m_axi_wuser    (),
          .m_axi_wvalid   (),
          .m_axi_wready   (M_AXI_WREADY),
          .m_axi_bid      (M_AXI_BID),
          .m_axi_bresp    (M_AXI_BRESP),
          .m_axi_buser    (M_AXI_BUSER),
          .m_axi_bvalid   (M_AXI_BVALID),
          .m_axi_bready   (),
          .s_axi_arid     (S_AXI_ARID),
          .s_axi_araddr   (S_AXI_ARADDR),
          .s_axi_arlen    (S_AXI_ARLEN),
          .s_axi_arsize   (S_AXI_ARSIZE),
          .s_axi_arburst  (S_AXI_ARBURST),
          .s_axi_arlock   (S_AXI_ARLOCK[0]),
          .s_axi_arcache  (S_AXI_ARCACHE),
          .s_axi_arprot   (S_AXI_ARPROT),
          .s_axi_arqos    (S_AXI_ARQOS),
          .s_axi_arregion (S_AXI_ARREGION),
          .s_axi_aruser   (S_AXI_ARUSER),
          .s_axi_arvalid  (S_AXI_ARVALID),
          .s_axi_arready  (S_AXI_ARREADY),
          .s_axi_rid      (S_AXI_RID),
          .s_axi_rdata    (S_AXI_RDATA),
          .s_axi_rresp    (S_AXI_RRESP),
          .s_axi_rlast    (S_AXI_RLAST),
          .s_axi_ruser    (S_AXI_RUSER),
          .s_axi_rvalid   (S_AXI_RVALID),
          .s_axi_rready   (S_AXI_RREADY),
          .m_axi_arid     (M_AXI_ARID),
          .m_axi_araddr   (M_AXI_ARADDR),
          .m_axi_arlen    (M_AXI_ARLEN),
          .m_axi_arsize   (M_AXI_ARSIZE),
          .m_axi_arburst  (M_AXI_ARBURST),
          .m_axi_arlock   (M_AXI_ARLOCK_I),
          .m_axi_arcache  (M_AXI_ARCACHE),
          .m_axi_arprot   (M_AXI_ARPROT),
          .m_axi_arqos    (M_AXI_ARQOS),
          .m_axi_arregion (M_AXI_ARREGION),
          .m_axi_aruser   (M_AXI_ARUSER),
          .m_axi_arvalid  (M_AXI_ARVALID),
          .m_axi_arready  (M_AXI_ARREADY),
          .m_axi_rid      (M_AXI_RID),
          .m_axi_rdata    (M_AXI_RDATA),
          .m_axi_rresp    (M_AXI_RRESP),
          .m_axi_rlast    (M_AXI_RLAST),
          .m_axi_ruser    (M_AXI_RUSER),
          .m_axi_rvalid   (M_AXI_RVALID),
          .m_axi_rready   (M_AXI_RREADY),
          .m_aclk_en      (1'b1),
          .s_aclk_en      (1'b1),
          .almost_empty(),
          .almost_full(),
          .axis_data_count(),
          .axis_dbiterr(),
          .axis_injectdbiterr(1'b0),
          .axis_injectsbiterr(1'b0),
          .axis_overflow(),
          .axis_prog_empty(),
          .axis_prog_empty_thresh(5'b0),
          .axis_prog_full(),
          .axis_prog_full_thresh(5'b0),
          .axis_rd_data_count(),
          .axis_sbiterr(),
          .axis_underflow(),
          .axis_wr_data_count(),
          .axi_ar_data_count(),
          .axi_ar_dbiterr(),
          .axi_ar_injectdbiterr(1'b0),
          .axi_ar_injectsbiterr(1'b0),
          .axi_ar_overflow(),
          .axi_ar_prog_empty(),
          .axi_ar_prog_empty_thresh(5'b0),
          .axi_ar_prog_full(),
          .axi_ar_prog_full_thresh(5'b0),
          .axi_ar_rd_data_count(),
          .axi_ar_sbiterr(),
          .axi_ar_underflow(),
          .axi_ar_wr_data_count(),
          .axi_aw_data_count(),
          .axi_aw_dbiterr(),
          .axi_aw_injectdbiterr(1'b0),
          .axi_aw_injectsbiterr(1'b0),
          .axi_aw_overflow(),
          .axi_aw_prog_empty(),
          .axi_aw_prog_empty_thresh(5'b0),
          .axi_aw_prog_full(),
          .axi_aw_prog_full_thresh(5'b0),
          .axi_aw_rd_data_count(),
          .axi_aw_sbiterr(),
          .axi_aw_underflow(),
          .axi_aw_wr_data_count(),
          .axi_b_data_count(),
          .axi_b_dbiterr(),
          .axi_b_injectdbiterr(1'b0),
          .axi_b_injectsbiterr(1'b0),
          .axi_b_overflow(),
          .axi_b_prog_empty(),
          .axi_b_prog_empty_thresh(5'b0),
          .axi_b_prog_full(),
          .axi_b_prog_full_thresh(5'b0),
          .axi_b_rd_data_count(),
          .axi_b_sbiterr(),
          .axi_b_underflow(),
          .axi_b_wr_data_count(),
          .axi_r_data_count(),
          .axi_r_dbiterr(),
          .axi_r_injectdbiterr(1'b0),
          .axi_r_injectsbiterr(1'b0),
          .axi_r_overflow(),
          .axi_r_prog_empty(),
          .axi_r_prog_empty_thresh(5'h00),
          .axi_r_prog_full(),
          .axi_r_prog_full_thresh(5'h00),
          .axi_r_rd_data_count(),
          .axi_r_sbiterr(),
          .axi_r_underflow(),
          .axi_r_wr_data_count(),
          .axi_w_data_count(),
          .axi_w_dbiterr(),
          .axi_w_injectdbiterr(1'b0),
          .axi_w_injectsbiterr(1'b0),
          .axi_w_overflow(),
          .axi_w_prog_empty(),
          .axi_w_prog_empty_thresh(5'h00),
          .axi_w_prog_full(),
          .axi_w_prog_full_thresh(5'h00),
          .axi_w_rd_data_count(),
          .axi_w_sbiterr(),
          .axi_w_underflow(),
          .axi_w_wr_data_count(),
          .backup(1'b0),
          .backup_marker(1'b0),
          .clk(1'b0),
          .data_count(),
          .dbiterr(),
          .din(18'b0),
          .dout(),
          .empty(),
          .full(),
          .injectdbiterr(1'b0),
          .injectsbiterr(1'b0),
          .int_clk(1'b0),
          .m_axis_tdata(),
          .m_axis_tdest(),
          .m_axis_tid(),
          .m_axis_tkeep(),
          .m_axis_tlast(),
          .m_axis_tready(1'b0),
          .m_axis_tstrb(),
          .m_axis_tuser(),
          .m_axis_tvalid(),
          .overflow(),
          .prog_empty(),
          .prog_empty_thresh(10'b0),
          .prog_empty_thresh_assert(10'b0),
          .prog_empty_thresh_negate(10'b0),
          .prog_full(),
          .prog_full_thresh(10'b0),
          .prog_full_thresh_assert(10'b0),
          .prog_full_thresh_negate(10'b0),
          .rd_clk(1'b0),
          .rd_data_count(),
          .rd_en(1'b0),
          .rd_rst(1'b0),
          .rst(1'b0),
          .sbiterr(),
          .srst(1'b0),
          .s_axis_tdata(64'b0),
          .s_axis_tdest(4'b0),
          .s_axis_tid(4'b0),
          .s_axis_tkeep(4'b0),
          .s_axis_tlast(1'b0),
          .s_axis_tready(),
          .s_axis_tstrb(4'b0),
          .s_axis_tuser(4'b0),
          .s_axis_tvalid(1'b0),
          .underflow(),
          .valid(),
          .wr_ack(),
          .wr_clk(1'b0),
          .wr_data_count(),
          .wr_en(1'b0),
          .wr_rst(1'b0),
          .sleep(1'b0),
          .rd_rst_busy(),
          .wr_rst_busy()
      );
    end else if (C_AXI_IS_ACLK_ASYNC) begin : gen_async_readwrite
      
      assign M_AXI_AWLOCK   = {1'b0,M_AXI_AWLOCK_I};
      assign M_AXI_ARLOCK   = {1'b0,M_AXI_ARLOCK_I};

      fifo_generator_v13_1_4 #(
          .C_ADD_NGC_CONSTRAINT(0),
          .C_APPLICATION_TYPE_AXIS(0),
          .C_APPLICATION_TYPE_RACH(0),
          .C_APPLICATION_TYPE_RDCH(0),
          .C_APPLICATION_TYPE_WACH(0),
          .C_APPLICATION_TYPE_WDCH(0),
          .C_APPLICATION_TYPE_WRCH(0),
          .C_AXI_ADDR_WIDTH(C_AXI_ADDR_WIDTH),
          .C_AXI_ARUSER_WIDTH(C_AXI_ARUSER_WIDTH),
          .C_AXI_AWUSER_WIDTH(C_AXI_AWUSER_WIDTH),
          .C_AXI_BUSER_WIDTH(C_AXI_BUSER_WIDTH),
          .C_AXI_DATA_WIDTH(C_AXI_DATA_WIDTH),
          .C_AXI_ID_WIDTH(C_AXI_ID_WIDTH),
          .C_AXI_LEN_WIDTH(8),
          .C_AXI_LOCK_WIDTH(1),
          .C_AXI_RUSER_WIDTH(C_AXI_RUSER_WIDTH),
          .C_AXI_TYPE(1),
          .C_AXI_WUSER_WIDTH(C_AXI_WUSER_WIDTH),
          .C_AXIS_TDATA_WIDTH(64),
          .C_AXIS_TDEST_WIDTH(4),
          .C_AXIS_TID_WIDTH(4),
          .C_AXIS_TKEEP_WIDTH(4),
          .C_AXIS_TSTRB_WIDTH(4),
          .C_AXIS_TUSER_WIDTH(4),
          .C_AXIS_TYPE(0),
          .C_COMMON_CLOCK(0),
          .C_COUNT_TYPE(0),
          .C_DATA_COUNT_WIDTH(10),
          .C_DEFAULT_VALUE("BlankString"),
          .C_DIN_WIDTH(18),
          .C_DIN_WIDTH_AXIS(1),
          .C_DIN_WIDTH_RACH(C_AR_SIZE),
          .C_DIN_WIDTH_RDCH(C_R_SIZE),
          .C_DIN_WIDTH_WACH(C_AW_SIZE),
          .C_DIN_WIDTH_WDCH(C_W_SIZE),
          .C_DIN_WIDTH_WRCH(C_B_SIZE),
          .C_DOUT_RST_VAL("0"),
          .C_DOUT_WIDTH(18),
          .C_ENABLE_RLOCS(0),
          .C_ENABLE_RST_SYNC(1),
          .C_ERROR_INJECTION_TYPE(0),
          .C_ERROR_INJECTION_TYPE_AXIS(0),
          .C_ERROR_INJECTION_TYPE_RACH(0),
          .C_ERROR_INJECTION_TYPE_RDCH(0),
          .C_ERROR_INJECTION_TYPE_WACH(0),
          .C_ERROR_INJECTION_TYPE_WDCH(0),
          .C_ERROR_INJECTION_TYPE_WRCH(0),
          .C_FAMILY(C_FAMILY),
          .C_FULL_FLAGS_RST_VAL(1),
          .C_HAS_ALMOST_EMPTY(0),
          .C_HAS_ALMOST_FULL(0),
          .C_HAS_AXI_RD_CHANNEL(C_AXI_SUPPORTS_READ),
          .C_HAS_AXI_WR_CHANNEL(C_AXI_SUPPORTS_WRITE),
          .C_HAS_AXI_ID(1),
          .C_HAS_AXI_ARUSER(C_AXI_SUPPORTS_USER_SIGNALS),
          .C_HAS_AXI_AWUSER(C_AXI_SUPPORTS_USER_SIGNALS),
          .C_HAS_AXI_BUSER(C_AXI_SUPPORTS_USER_SIGNALS),
          .C_HAS_AXI_RUSER(C_AXI_SUPPORTS_USER_SIGNALS),
          .C_HAS_AXI_WUSER(C_AXI_SUPPORTS_USER_SIGNALS),
          .C_HAS_AXIS_TDATA(0),
          .C_HAS_AXIS_TDEST(0),
          .C_HAS_AXIS_TID(0),
          .C_HAS_AXIS_TKEEP(0),
          .C_HAS_AXIS_TLAST(0),
          .C_HAS_AXIS_TREADY(1),
          .C_HAS_AXIS_TSTRB(0),
          .C_HAS_AXIS_TUSER(0),
          .C_HAS_BACKUP(0),
          .C_HAS_DATA_COUNT(0),
          .C_HAS_DATA_COUNTS_AXIS(0),
          .C_HAS_DATA_COUNTS_RACH(0),
          .C_HAS_DATA_COUNTS_RDCH(0),
          .C_HAS_DATA_COUNTS_WACH(0),
          .C_HAS_DATA_COUNTS_WDCH(0),
          .C_HAS_DATA_COUNTS_WRCH(0),
          .C_HAS_INT_CLK(0),
          .C_HAS_MASTER_CE(0),
          .C_HAS_MEMINIT_FILE(0),
          .C_HAS_OVERFLOW(0),
          .C_HAS_PROG_FLAGS_AXIS(0),
          .C_HAS_PROG_FLAGS_RACH(0),
          .C_HAS_PROG_FLAGS_RDCH(0),
          .C_HAS_PROG_FLAGS_WACH(0),
          .C_HAS_PROG_FLAGS_WDCH(0),
          .C_HAS_PROG_FLAGS_WRCH(0),
          .C_HAS_RD_DATA_COUNT(0),
          .C_HAS_RD_RST(0),
          .C_HAS_RST(1),
          .C_HAS_SLAVE_CE(0),
          .C_HAS_SRST(0),
          .C_HAS_UNDERFLOW(0),
          .C_HAS_VALID(0),
          .C_HAS_WR_ACK(0),
          .C_HAS_WR_DATA_COUNT(0),
          .C_HAS_WR_RST(0),
          .C_IMPLEMENTATION_TYPE(0),
          .C_IMPLEMENTATION_TYPE_AXIS(P_LUTRAM_ASYNC),
          .C_IMPLEMENTATION_TYPE_RACH(P_LUTRAM_ASYNC),
          .C_IMPLEMENTATION_TYPE_RDCH(P_LUTRAM_ASYNC),
          .C_IMPLEMENTATION_TYPE_WACH(P_LUTRAM_ASYNC),
          .C_IMPLEMENTATION_TYPE_WDCH(P_LUTRAM_ASYNC),
          .C_IMPLEMENTATION_TYPE_WRCH(P_LUTRAM_ASYNC),
          .C_INIT_WR_PNTR_VAL(0),
          .C_INTERFACE_TYPE(2),
          .C_MEMORY_TYPE(1),
          .C_MIF_FILE_NAME("BlankString"),
          .C_MSGON_VAL(1),
          .C_OPTIMIZATION_MODE(0),
          .C_OVERFLOW_LOW(0),
          .C_PRELOAD_LATENCY(1),
          .C_PRELOAD_REGS(0),
          .C_PRIM_FIFO_TYPE("4kx4"),
          .C_PROG_EMPTY_THRESH_ASSERT_VAL(2),
          .C_PROG_EMPTY_THRESH_ASSERT_VAL_AXIS(1021),
          .C_PROG_EMPTY_THRESH_ASSERT_VAL_RACH(29),
          .C_PROG_EMPTY_THRESH_ASSERT_VAL_RDCH(29),
          .C_PROG_EMPTY_THRESH_ASSERT_VAL_WACH(29),
          .C_PROG_EMPTY_THRESH_ASSERT_VAL_WDCH(29),
          .C_PROG_EMPTY_THRESH_ASSERT_VAL_WRCH(29),
          .C_PROG_EMPTY_THRESH_NEGATE_VAL(3),
          .C_PROG_EMPTY_TYPE(0),
          .C_PROG_EMPTY_TYPE_AXIS(5),
          .C_PROG_EMPTY_TYPE_RACH(5),
          .C_PROG_EMPTY_TYPE_RDCH(5),
          .C_PROG_EMPTY_TYPE_WACH(5),
          .C_PROG_EMPTY_TYPE_WDCH(5),
          .C_PROG_EMPTY_TYPE_WRCH(5),
          .C_PROG_FULL_THRESH_ASSERT_VAL(1022),
          .C_PROG_FULL_THRESH_ASSERT_VAL_AXIS(1023),
          .C_PROG_FULL_THRESH_ASSERT_VAL_RACH(31),
          .C_PROG_FULL_THRESH_ASSERT_VAL_RDCH(31),
          .C_PROG_FULL_THRESH_ASSERT_VAL_WACH(31),
          .C_PROG_FULL_THRESH_ASSERT_VAL_WDCH(31),
          .C_PROG_FULL_THRESH_ASSERT_VAL_WRCH(31),
          .C_PROG_FULL_THRESH_NEGATE_VAL(1021),
          .C_PROG_FULL_TYPE(0),
          .C_PROG_FULL_TYPE_AXIS(5),
          .C_PROG_FULL_TYPE_RACH(5),
          .C_PROG_FULL_TYPE_RDCH(5),
          .C_PROG_FULL_TYPE_WACH(5),
          .C_PROG_FULL_TYPE_WDCH(5),
          .C_PROG_FULL_TYPE_WRCH(5),
          .C_RACH_TYPE(C_AXI_SUPPORTS_READ ? 0 : 2),
          .C_RD_DATA_COUNT_WIDTH(10),
          .C_RD_DEPTH(1024),
          .C_RD_FREQ(1),
          .C_RD_PNTR_WIDTH(10),
          .C_RDCH_TYPE(C_AXI_SUPPORTS_READ ? 0 : 2),
          .C_REG_SLICE_MODE_AXIS(0),
          .C_REG_SLICE_MODE_RACH(0),
          .C_REG_SLICE_MODE_RDCH(0),
          .C_REG_SLICE_MODE_WACH(0),
          .C_REG_SLICE_MODE_WDCH(0),
          .C_REG_SLICE_MODE_WRCH(0),
          .C_SYNCHRONIZER_STAGE(C_SYNCHRONIZER_STAGE),
          .C_UNDERFLOW_LOW(0),
          .C_USE_COMMON_OVERFLOW(0),
          .C_USE_COMMON_UNDERFLOW(0),
          .C_USE_DEFAULT_SETTINGS(0),
          .C_USE_DOUT_RST(1),
          .C_USE_ECC(0),
          .C_USE_ECC_AXIS(0),
          .C_USE_ECC_RACH(0),
          .C_USE_ECC_RDCH(0),
          .C_USE_ECC_WACH(0),
          .C_USE_ECC_WDCH(0),
          .C_USE_ECC_WRCH(0),
          .C_USE_EMBEDDED_REG(0),
          .C_USE_FIFO16_FLAGS(0),
          .C_USE_FWFT_DATA_COUNT(0),
          .C_VALID_LOW(0),
          .C_WACH_TYPE(C_AXI_SUPPORTS_WRITE ? 0 : 2),
          .C_WDCH_TYPE(C_AXI_SUPPORTS_WRITE ? 0 : 2),
          .C_WR_ACK_LOW(0),
          .C_WR_DATA_COUNT_WIDTH(10),
          .C_WR_DEPTH(1024),
          .C_WR_DEPTH_AXIS(32),
          .C_WR_DEPTH_RACH(32),
          .C_WR_DEPTH_RDCH(32),
          .C_WR_DEPTH_WACH(32),
          .C_WR_DEPTH_WDCH(32),
          .C_WR_DEPTH_WRCH(32),
          .C_WR_FREQ(1),
          .C_WR_PNTR_WIDTH(10),
          .C_WR_PNTR_WIDTH_AXIS(5),
          .C_WR_PNTR_WIDTH_RACH(5),
          .C_WR_PNTR_WIDTH_RDCH(5),
          .C_WR_PNTR_WIDTH_WACH(5),
          .C_WR_PNTR_WIDTH_WDCH(5),
          .C_WR_PNTR_WIDTH_WRCH(5),
          .C_WR_RESPONSE_LATENCY(1),
          .C_WRCH_TYPE(C_AXI_SUPPORTS_WRITE ? 0 : 2)
        )
        asyncfifo_rw (
          .s_aclk         (S_AXI_ACLK),
          .m_aclk         (M_AXI_ACLK),
          .s_aresetn      (async_conv_reset_n),
          .s_axi_awid     (S_AXI_AWID),
          .s_axi_awaddr   (S_AXI_AWADDR),
          .s_axi_awlen    (S_AXI_AWLEN),
          .s_axi_awsize   (S_AXI_AWSIZE),
          .s_axi_awburst  (S_AXI_AWBURST),
          .s_axi_awlock   (S_AXI_AWLOCK[0]),
          .s_axi_awcache  (S_AXI_AWCACHE),
          .s_axi_awprot   (S_AXI_AWPROT),
          .s_axi_awqos    (S_AXI_AWQOS),
          .s_axi_awregion (S_AXI_AWREGION),
          .s_axi_awuser   (S_AXI_AWUSER),
          .s_axi_awvalid  (S_AXI_AWVALID),
          .s_axi_awready  (S_AXI_AWREADY),
          .s_axi_wid      ({C_AXI_ID_WIDTH{1'b0}}),
          .s_axi_wdata    (S_AXI_WDATA),
          .s_axi_wstrb    (S_AXI_WSTRB),
          .s_axi_wlast    (S_AXI_WLAST),
          .s_axi_wuser    (S_AXI_WUSER),
          .s_axi_wvalid   (S_AXI_WVALID),
          .s_axi_wready   (S_AXI_WREADY),
          .s_axi_bid      (S_AXI_BID),
          .s_axi_bresp    (S_AXI_BRESP),
          .s_axi_buser    (S_AXI_BUSER),
          .s_axi_bvalid   (S_AXI_BVALID),
          .s_axi_bready   (S_AXI_BREADY),
          .m_axi_awid     (M_AXI_AWID),
          .m_axi_awaddr   (M_AXI_AWADDR),
          .m_axi_awlen    (M_AXI_AWLEN),
          .m_axi_awsize   (M_AXI_AWSIZE),
          .m_axi_awburst  (M_AXI_AWBURST),
          .m_axi_awlock   (M_AXI_AWLOCK_I),
          .m_axi_awcache  (M_AXI_AWCACHE),
          .m_axi_awprot   (M_AXI_AWPROT),
          .m_axi_awqos    (M_AXI_AWQOS),
          .m_axi_awregion (M_AXI_AWREGION),
          .m_axi_awuser   (M_AXI_AWUSER),
          .m_axi_awvalid  (M_AXI_AWVALID),
          .m_axi_awready  (M_AXI_AWREADY),
          .m_axi_wid      (),
          .m_axi_wdata    (M_AXI_WDATA),
          .m_axi_wstrb    (M_AXI_WSTRB),
          .m_axi_wlast    (M_AXI_WLAST),
          .m_axi_wuser    (M_AXI_WUSER),
          .m_axi_wvalid   (M_AXI_WVALID),
          .m_axi_wready   (M_AXI_WREADY),
          .m_axi_bid      (M_AXI_BID),
          .m_axi_bresp    (M_AXI_BRESP),
          .m_axi_buser    (M_AXI_BUSER),
          .m_axi_bvalid   (M_AXI_BVALID),
          .m_axi_bready   (M_AXI_BREADY),
          .s_axi_arid     (S_AXI_ARID),
          .s_axi_araddr   (S_AXI_ARADDR),
          .s_axi_arlen    (S_AXI_ARLEN),
          .s_axi_arsize   (S_AXI_ARSIZE),
          .s_axi_arburst  (S_AXI_ARBURST),
          .s_axi_arlock   (S_AXI_ARLOCK[0]),
          .s_axi_arcache  (S_AXI_ARCACHE),
          .s_axi_arprot   (S_AXI_ARPROT),
          .s_axi_arqos    (S_AXI_ARQOS),
          .s_axi_arregion (S_AXI_ARREGION),
          .s_axi_aruser   (S_AXI_ARUSER),
          .s_axi_arvalid  (S_AXI_ARVALID),
          .s_axi_arready  (S_AXI_ARREADY),
          .s_axi_rid      (S_AXI_RID),
          .s_axi_rdata    (S_AXI_RDATA),
          .s_axi_rresp    (S_AXI_RRESP),
          .s_axi_rlast    (S_AXI_RLAST),
          .s_axi_ruser    (S_AXI_RUSER),
          .s_axi_rvalid   (S_AXI_RVALID),
          .s_axi_rready   (S_AXI_RREADY),
          .m_axi_arid     (M_AXI_ARID),
          .m_axi_araddr   (M_AXI_ARADDR),
          .m_axi_arlen    (M_AXI_ARLEN),
          .m_axi_arsize   (M_AXI_ARSIZE),
          .m_axi_arburst  (M_AXI_ARBURST),
          .m_axi_arlock   (M_AXI_ARLOCK_I),
          .m_axi_arcache  (M_AXI_ARCACHE),
          .m_axi_arprot   (M_AXI_ARPROT),
          .m_axi_arqos    (M_AXI_ARQOS),
          .m_axi_arregion (M_AXI_ARREGION),
          .m_axi_aruser   (M_AXI_ARUSER),
          .m_axi_arvalid  (M_AXI_ARVALID),
          .m_axi_arready  (M_AXI_ARREADY),
          .m_axi_rid      (M_AXI_RID),
          .m_axi_rdata    (M_AXI_RDATA),
          .m_axi_rresp    (M_AXI_RRESP),
          .m_axi_rlast    (M_AXI_RLAST),
          .m_axi_ruser    (M_AXI_RUSER),
          .m_axi_rvalid   (M_AXI_RVALID),
          .m_axi_rready   (M_AXI_RREADY),
          .m_aclk_en      (1'b1),
          .s_aclk_en      (1'b1),
          .almost_empty(),
          .almost_full(),
          .axis_data_count(),
          .axis_dbiterr(),
          .axis_injectdbiterr(1'b0),
          .axis_injectsbiterr(1'b0),
          .axis_overflow(),
          .axis_prog_empty(),
          .axis_prog_empty_thresh(5'b0),
          .axis_prog_full(),
          .axis_prog_full_thresh(5'b0),
          .axis_rd_data_count(),
          .axis_sbiterr(),
          .axis_underflow(),
          .axis_wr_data_count(),
          .axi_ar_data_count(),
          .axi_ar_dbiterr(),
          .axi_ar_injectdbiterr(1'b0),
          .axi_ar_injectsbiterr(1'b0),
          .axi_ar_overflow(),
          .axi_ar_prog_empty(),
          .axi_ar_prog_empty_thresh(5'b0),
          .axi_ar_prog_full(),
          .axi_ar_prog_full_thresh(5'b0),
          .axi_ar_rd_data_count(),
          .axi_ar_sbiterr(),
          .axi_ar_underflow(),
          .axi_ar_wr_data_count(),
          .axi_aw_data_count(),
          .axi_aw_dbiterr(),
          .axi_aw_injectdbiterr(1'b0),
          .axi_aw_injectsbiterr(1'b0),
          .axi_aw_overflow(),
          .axi_aw_prog_empty(),
          .axi_aw_prog_empty_thresh(5'b0),
          .axi_aw_prog_full(),
          .axi_aw_prog_full_thresh(5'b0),
          .axi_aw_rd_data_count(),
          .axi_aw_sbiterr(),
          .axi_aw_underflow(),
          .axi_aw_wr_data_count(),
          .axi_b_data_count(),
          .axi_b_dbiterr(),
          .axi_b_injectdbiterr(1'b0),
          .axi_b_injectsbiterr(1'b0),
          .axi_b_overflow(),
          .axi_b_prog_empty(),
          .axi_b_prog_empty_thresh(5'b0),
          .axi_b_prog_full(),
          .axi_b_prog_full_thresh(5'b0),
          .axi_b_rd_data_count(),
          .axi_b_sbiterr(),
          .axi_b_underflow(),
          .axi_b_wr_data_count(),
          .axi_r_data_count(),
          .axi_r_dbiterr(),
          .axi_r_injectdbiterr(1'b0),
          .axi_r_injectsbiterr(1'b0),
          .axi_r_overflow(),
          .axi_r_prog_empty(),
          .axi_r_prog_empty_thresh(5'h00),
          .axi_r_prog_full(),
          .axi_r_prog_full_thresh(5'h00),
          .axi_r_rd_data_count(),
          .axi_r_sbiterr(),
          .axi_r_underflow(),
          .axi_r_wr_data_count(),
          .axi_w_data_count(),
          .axi_w_dbiterr(),
          .axi_w_injectdbiterr(1'b0),
          .axi_w_injectsbiterr(1'b0),
          .axi_w_overflow(),
          .axi_w_prog_empty(),
          .axi_w_prog_empty_thresh(5'h00),
          .axi_w_prog_full(),
          .axi_w_prog_full_thresh(5'h00),
          .axi_w_rd_data_count(),
          .axi_w_sbiterr(),
          .axi_w_underflow(),
          .axi_w_wr_data_count(),
          .backup(1'b0),
          .backup_marker(1'b0),
          .clk(1'b0),
          .data_count(),
          .dbiterr(),
          .din(18'b0),
          .dout(),
          .empty(),
          .full(),
          .injectdbiterr(1'b0),
          .injectsbiterr(1'b0),
          .int_clk(1'b0),
          .m_axis_tdata(),
          .m_axis_tdest(),
          .m_axis_tid(),
          .m_axis_tkeep(),
          .m_axis_tlast(),
          .m_axis_tready(1'b0),
          .m_axis_tstrb(),
          .m_axis_tuser(),
          .m_axis_tvalid(),
          .overflow(),
          .prog_empty(),
          .prog_empty_thresh(10'b0),
          .prog_empty_thresh_assert(10'b0),
          .prog_empty_thresh_negate(10'b0),
          .prog_full(),
          .prog_full_thresh(10'b0),
          .prog_full_thresh_assert(10'b0),
          .prog_full_thresh_negate(10'b0),
          .rd_clk(1'b0),
          .rd_data_count(),
          .rd_en(1'b0),
          .rd_rst(1'b0),
          .rst(1'b0),
          .sbiterr(),
          .srst(1'b0),
          .s_axis_tdata(64'b0),
          .s_axis_tdest(4'b0),
          .s_axis_tid(4'b0),
          .s_axis_tkeep(4'b0),
          .s_axis_tlast(1'b0),
          .s_axis_tready(),
          .s_axis_tstrb(4'b0),
          .s_axis_tuser(4'b0),
          .s_axis_tvalid(1'b0),
          .underflow(),
          .valid(),
          .wr_ack(),
          .wr_clk(1'b0),
          .wr_data_count(),
          .wr_en(1'b0),
          .wr_rst(1'b0),
          .sleep(1'b0),
          .rd_rst_busy(),
          .wr_rst_busy()
      );
  end else if (P_ACLK_RATIO > 1) begin : gen_sync_conv
    assign {fast_aclk, slow_aclk} = P_SI_LT_MI ? {M_AXI_ACLK, S_AXI_ACLK} : {S_AXI_ACLK, M_AXI_ACLK};
    assign {fast_areset, slow_areset} = P_SI_LT_MI ? {m_axi_reset_out_i, s_axi_reset_out_i} : {s_axi_reset_out_i, m_axi_reset_out_i};

    // Sample cycle used to determine when to assert a signal on a fast clock
    // to be flopped onto a slow clock.
    axi_interconnect_v1_7_13_axic_sample_cycle_ratio #(
      .C_RATIO ( P_ACLK_RATIO )
    ) 
    axic_sample_cycle_inst (
      .SLOW_ACLK          ( slow_aclk               ) ,
      .FAST_ACLK          ( fast_aclk               ) ,
      .SAMPLE_CYCLE_EARLY ( sample_cycle_early ) ,
      .SAMPLE_CYCLE       ( sample_cycle       ) 
    );

  ////////////////////////////////////////////////////////////////////////////////
  // AXI write channels
  ////////////////////////////////////////////////////////////////////////////////
    if (C_AXI_SUPPORTS_WRITE) begin : gen_conv_write_ch

      // Write Address Port
      if (C_AXI_SUPPORTS_USER_SIGNALS == 1) begin : gen_aw_user
        assign s_aw_data    = {S_AXI_AWID, S_AXI_AWADDR, S_AXI_AWLEN, S_AXI_AWSIZE, 
                               S_AXI_AWBURST, S_AXI_AWLOCK, S_AXI_AWCACHE, S_AXI_AWPROT, 
                               S_AXI_AWREGION, S_AXI_AWQOS, S_AXI_AWUSER};
        assign M_AXI_AWUSER = m_aw_data[C_AWUSER_RIGHT+:C_AWUSER_LEN];
      end
      else begin : gen_aw_no_user
        assign s_aw_data    = {S_AXI_AWID, S_AXI_AWADDR, S_AXI_AWLEN, S_AXI_AWSIZE, 
                               S_AXI_AWBURST, S_AXI_AWLOCK, S_AXI_AWCACHE, S_AXI_AWPROT, 
                               S_AXI_AWREGION, S_AXI_AWQOS};
        assign M_AXI_AWUSER = {C_AXI_AWUSER_WIDTH{1'b0}};
      end

      assign M_AXI_AWID     = m_aw_data[C_AWID_RIGHT+:C_AWID_LEN];
      assign M_AXI_AWADDR   = m_aw_data[C_AWADDR_RIGHT+:C_AWADDR_LEN];
      assign M_AXI_AWLEN    = m_aw_data[C_AWLEN_RIGHT+:C_AWLEN_LEN];
      assign M_AXI_AWSIZE   = m_aw_data[C_AWSIZE_RIGHT+:C_AWSIZE_LEN];
      assign M_AXI_AWBURST  = m_aw_data[C_AWBURST_RIGHT+:C_AWBURST_LEN];
      assign M_AXI_AWLOCK   = m_aw_data[C_AWLOCK_RIGHT+:C_AWLOCK_LEN];
      assign M_AXI_AWCACHE  = m_aw_data[C_AWCACHE_RIGHT+:C_AWCACHE_LEN];
      assign M_AXI_AWPROT   = m_aw_data[C_AWPROT_RIGHT+:C_AWPROT_LEN];
      assign M_AXI_AWREGION = m_aw_data[C_AWREGION_RIGHT+:C_AWREGION_LEN];
      assign M_AXI_AWQOS    = m_aw_data[C_AWQOS_RIGHT+:C_AWQOS_LEN];

      axi_interconnect_v1_7_13_axic_sync_clock_converter #( 
        .C_FAMILY         ( C_FAMILY ) ,
        .C_PAYLOAD_WIDTH ( C_AW_SIZE ) ,
        .C_S_ACLK_RATIO   ( P_SI_LT_MI ? 1 : P_ACLK_RATIO ) ,
        .C_M_ACLK_RATIO   ( P_SI_LT_MI ? P_ACLK_RATIO : 1 ) ,
        .C_MODE(P_LIGHT_WT)
      )
      aw_sync_clock_converter (
        .SAMPLE_CYCLE (sample_cycle),
        .SAMPLE_CYCLE_EARLY (sample_cycle_early),
        .S_ACLK     ( S_AXI_ACLK     ) ,
        .S_ARESET   ( s_axi_reset_out_i ) ,
        .S_PAYLOAD ( s_aw_data ) ,
        .S_VALID   ( S_AXI_AWVALID   ) ,
        .S_READY   ( S_AXI_AWREADY   ) ,
        .M_ACLK     ( M_AXI_ACLK     ) ,
        .M_ARESET   ( m_axi_reset_out_i ) ,
        .M_PAYLOAD ( m_aw_data ) ,
        .M_VALID   ( M_AXI_AWVALID   ) ,
        .M_READY   ( M_AXI_AWREADY   ) 
      );
    
      // Write Data Port
      if (C_AXI_SUPPORTS_USER_SIGNALS == 1) begin : gen_w_user
        assign s_w_data     = {S_AXI_WDATA, S_AXI_WSTRB, S_AXI_WLAST, S_AXI_WUSER};
        assign M_AXI_WUSER = m_w_data[C_WUSER_RIGHT+:C_WUSER_LEN];
      end
      else begin : gen_w_no_user
        assign s_w_data     = {S_AXI_WDATA, S_AXI_WSTRB, S_AXI_WLAST};
        assign M_AXI_WUSER  = {C_AXI_WUSER_WIDTH{1'b0}};
      end

      assign M_AXI_WDATA    = m_w_data[C_WDATA_RIGHT+:C_WDATA_LEN];
      assign M_AXI_WSTRB    = m_w_data[C_WSTRB_RIGHT+:C_WSTRB_LEN];
      assign M_AXI_WLAST    = m_w_data[C_WLAST_RIGHT+:C_WLAST_LEN];

      axi_interconnect_v1_7_13_axic_sync_clock_converter #( 
        .C_FAMILY         ( C_FAMILY ) ,
        .C_PAYLOAD_WIDTH ( C_W_SIZE ) ,
        .C_S_ACLK_RATIO   ( P_SI_LT_MI ? 1 : P_ACLK_RATIO ) ,
        .C_M_ACLK_RATIO   ( P_SI_LT_MI ? P_ACLK_RATIO : 1 ) ,
        .C_MODE((C_AXI_PROTOCOL == P_AXILITE) ? P_LIGHT_WT : P_FULLY_REG)
      )
      w_sync_clock_converter (
        .SAMPLE_CYCLE (sample_cycle),
        .SAMPLE_CYCLE_EARLY (sample_cycle_early),
        .S_ACLK     ( S_AXI_ACLK     ) ,
        .S_ARESET   ( s_axi_reset_out_i ) ,
        .S_PAYLOAD ( s_w_data ) ,
        .S_VALID   ( S_AXI_WVALID   ) ,
        .S_READY   ( S_AXI_WREADY   ) ,
        .M_ACLK     ( M_AXI_ACLK     ) ,
        .M_ARESET   ( m_axi_reset_out_i ) ,
        .M_PAYLOAD ( m_w_data ) ,
        .M_VALID   ( M_AXI_WVALID   ) ,
        .M_READY   ( M_AXI_WREADY   ) 
      );
    
      // Write Response Port
      if (C_AXI_SUPPORTS_USER_SIGNALS == 1) begin : gen_b_user
        assign m_b_data     = {M_AXI_BID, M_AXI_BRESP, M_AXI_BUSER};
        assign S_AXI_BUSER  = s_b_data[C_BUSER_RIGHT+:C_BUSER_LEN];
      end
      else begin : gen_b_no_user
        assign m_b_data     = {M_AXI_BID, M_AXI_BRESP};
        assign S_AXI_BUSER  = {C_AXI_BUSER_WIDTH{1'b0}};
      end

      assign S_AXI_BID      = s_b_data[C_BID_RIGHT+:C_BID_LEN];
      assign S_AXI_BRESP    = s_b_data[C_BRESP_RIGHT+:C_BRESP_LEN];

      axi_interconnect_v1_7_13_axic_sync_clock_converter #( 
        .C_FAMILY         ( C_FAMILY ) ,
        .C_PAYLOAD_WIDTH ( C_B_SIZE ) ,
        .C_M_ACLK_RATIO   ( P_SI_LT_MI ? 1 : P_ACLK_RATIO ) ,
        .C_S_ACLK_RATIO   ( P_SI_LT_MI ? P_ACLK_RATIO : 1 ) ,
        .C_MODE(P_LIGHT_WT)
      )
      b_sync_clock_converter (
        .SAMPLE_CYCLE (sample_cycle),
        .SAMPLE_CYCLE_EARLY (sample_cycle_early),
        .S_ACLK     ( M_AXI_ACLK     ) ,
        .S_ARESET   ( m_axi_reset_out_i ) ,
        .S_PAYLOAD ( m_b_data ) ,
        .S_VALID   ( M_AXI_BVALID   ) ,
        .S_READY   ( M_AXI_BREADY   ) ,
        .M_ACLK     ( S_AXI_ACLK     ) ,
        .M_ARESET   ( s_axi_reset_out_i ) ,
        .M_PAYLOAD ( s_b_data ) ,
        .M_VALID   ( S_AXI_BVALID   ) ,
        .M_READY   ( S_AXI_BREADY   ) 
      );
    
    end else begin : gen_tieoff_write_ch

      // Write address port
      assign M_AXI_AWID     = 0;
      assign M_AXI_AWADDR   = 0;
      assign M_AXI_AWLEN    = 0;
      assign M_AXI_AWSIZE   = 0;
      assign M_AXI_AWBURST  = 0;
      assign M_AXI_AWLOCK   = 0;
      assign M_AXI_AWCACHE  = 0;
      assign M_AXI_AWPROT   = 0;
      assign M_AXI_AWREGION = 0;
      assign M_AXI_AWQOS    = 0;
      assign M_AXI_AWUSER   = 0;
      assign M_AXI_AWVALID  = 1'b0;
      assign S_AXI_AWREADY  = 1'b0;

      // Write Data Port
      assign M_AXI_WDATA    = 0;
      assign M_AXI_WSTRB    = 0;
      assign M_AXI_WLAST    = 0;
      assign M_AXI_WUSER    = 0;
      assign M_AXI_WVALID   = 1'b0;
      assign S_AXI_WREADY   = 1'b0;

      // Write Response Port
      assign S_AXI_BID      = 0;
      assign S_AXI_BRESP    = 0;
      assign S_AXI_BUSER    = 0;
      assign S_AXI_BVALID   = 1'b0;
      assign M_AXI_BREADY   = 1'b0;
    end

    ////////////////////////////////////////////////////////////////////////////////
    // AXI read channels
    ////////////////////////////////////////////////////////////////////////////////

    if (C_AXI_SUPPORTS_READ) begin : gen_conv_read_ch

      // Read Address Port
      if (C_AXI_SUPPORTS_USER_SIGNALS == 1) begin : gen_ar_user
        assign s_ar_data    = {S_AXI_ARID, S_AXI_ARADDR, S_AXI_ARLEN, S_AXI_ARSIZE, 
                               S_AXI_ARBURST, S_AXI_ARLOCK, S_AXI_ARCACHE, S_AXI_ARPROT, 
                               S_AXI_ARREGION, S_AXI_ARQOS, S_AXI_ARUSER};
        assign M_AXI_ARUSER = m_ar_data[C_ARUSER_RIGHT+:C_ARUSER_LEN];
      end
      else begin : gen_ar_no_user
        assign s_ar_data    = {S_AXI_ARID, S_AXI_ARADDR, S_AXI_ARLEN, S_AXI_ARSIZE, 
                               S_AXI_ARBURST, S_AXI_ARLOCK, S_AXI_ARCACHE, S_AXI_ARPROT, 
                               S_AXI_ARREGION, S_AXI_ARQOS};
        
        assign M_AXI_ARUSER = {C_AXI_ARUSER_WIDTH{1'b0}};
      end

      assign M_AXI_ARID     = m_ar_data[C_ARID_RIGHT+:C_ARID_LEN];
      assign M_AXI_ARADDR   = m_ar_data[C_ARADDR_RIGHT+:C_ARADDR_LEN];
      assign M_AXI_ARLEN    = m_ar_data[C_ARLEN_RIGHT+:C_ARLEN_LEN];
      assign M_AXI_ARSIZE   = m_ar_data[C_ARSIZE_RIGHT+:C_ARSIZE_LEN];
      assign M_AXI_ARBURST  = m_ar_data[C_ARBURST_RIGHT+:C_ARBURST_LEN];
      assign M_AXI_ARLOCK   = m_ar_data[C_ARLOCK_RIGHT+:C_ARLOCK_LEN];
      assign M_AXI_ARCACHE  = m_ar_data[C_ARCACHE_RIGHT+:C_ARCACHE_LEN];
      assign M_AXI_ARPROT   = m_ar_data[C_ARPROT_RIGHT+:C_ARPROT_LEN];
      assign M_AXI_ARREGION = m_ar_data[C_ARREGION_RIGHT+:C_ARREGION_LEN];
      assign M_AXI_ARQOS    = m_ar_data[C_ARQOS_RIGHT+:C_ARQOS_LEN];

      axi_interconnect_v1_7_13_axic_sync_clock_converter #( 
        .C_FAMILY         ( C_FAMILY ) ,
        .C_PAYLOAD_WIDTH ( C_AR_SIZE ) ,
        .C_S_ACLK_RATIO   ( P_SI_LT_MI ? 1 : P_ACLK_RATIO ) ,
        .C_M_ACLK_RATIO   ( P_SI_LT_MI ? P_ACLK_RATIO : 1 ) ,
        .C_MODE(P_LIGHT_WT)
      )
      ar_sync_clock_converter (
        .SAMPLE_CYCLE (sample_cycle),
        .SAMPLE_CYCLE_EARLY (sample_cycle_early),
        .S_ACLK     ( S_AXI_ACLK     ) ,
        .S_ARESET   ( s_axi_reset_out_i ) ,
        .S_PAYLOAD ( s_ar_data ) ,
        .S_VALID   ( S_AXI_ARVALID   ) ,
        .S_READY   ( S_AXI_ARREADY   ) ,
        .M_ACLK     ( M_AXI_ACLK     ) ,
        .M_ARESET   ( m_axi_reset_out_i ) ,
        .M_PAYLOAD ( m_ar_data ) ,
        .M_VALID   ( M_AXI_ARVALID   ) ,
        .M_READY   ( M_AXI_ARREADY   ) 
      );
    
      // Read Data Port
      if (C_AXI_SUPPORTS_USER_SIGNALS == 1) begin : gen_r_user
        assign m_r_data     = {M_AXI_RID, M_AXI_RDATA, M_AXI_RRESP, M_AXI_RLAST, M_AXI_RUSER};
        assign S_AXI_RUSER  = s_r_data[C_RUSER_RIGHT+:C_RUSER_LEN];
      end
      else begin : gen_r_no_user
        assign m_r_data     = {M_AXI_RID, M_AXI_RDATA, M_AXI_RRESP, M_AXI_RLAST};
        assign S_AXI_RUSER  = {C_AXI_RUSER_WIDTH{1'b0}};
      end

      assign S_AXI_RID      = s_r_data[C_RID_RIGHT+:C_RID_LEN];
      assign S_AXI_RDATA    = s_r_data[C_RDATA_RIGHT+:C_RDATA_LEN];
      assign S_AXI_RRESP    = s_r_data[C_RRESP_RIGHT+:C_RRESP_LEN];
      assign S_AXI_RLAST    = s_r_data[C_RLAST_RIGHT+:C_RLAST_LEN];

      axi_interconnect_v1_7_13_axic_sync_clock_converter #( 
        .C_FAMILY         ( C_FAMILY ) ,
        .C_PAYLOAD_WIDTH ( C_R_SIZE ) ,
        .C_M_ACLK_RATIO   ( P_SI_LT_MI ? 1 : P_ACLK_RATIO ) ,
        .C_S_ACLK_RATIO   ( P_SI_LT_MI ? P_ACLK_RATIO : 1 ) ,
        .C_MODE((C_AXI_PROTOCOL == P_AXILITE) ? P_LIGHT_WT : P_FULLY_REG)
      )
      r_sync_clock_converter (
        .SAMPLE_CYCLE (sample_cycle),
        .SAMPLE_CYCLE_EARLY (sample_cycle_early),
        .S_ACLK     ( M_AXI_ACLK     ) ,
        .S_ARESET   ( m_axi_reset_out_i ) ,
        .S_PAYLOAD ( m_r_data ) ,
        .S_VALID   ( M_AXI_RVALID   ) ,
        .S_READY   ( M_AXI_RREADY   ) ,
        .M_ACLK     ( S_AXI_ACLK     ) ,
        .M_ARESET   ( s_axi_reset_out_i ) ,
        .M_PAYLOAD ( s_r_data ) ,
        .M_VALID   ( S_AXI_RVALID   ) ,
        .M_READY   ( S_AXI_RREADY   ) 
      );
    
    end else begin : gen_tieoff_read_ch

      // Read Address Port
      assign M_AXI_ARID     = 0;
      assign M_AXI_ARADDR   = 0;
      assign M_AXI_ARLEN    = 0;
      assign M_AXI_ARSIZE   = 0;
      assign M_AXI_ARBURST  = 0;
      assign M_AXI_ARLOCK   = 0;
      assign M_AXI_ARCACHE  = 0;
      assign M_AXI_ARPROT   = 0;
      assign M_AXI_ARREGION = 0;
      assign M_AXI_ARQOS    = 0;
      assign M_AXI_ARUSER   = 0;
      assign M_AXI_ARVALID  = 1'b0;
      assign S_AXI_ARREADY  = 1'b0;

      // Read Data Port
      assign S_AXI_RID      = 0;
      assign S_AXI_RDATA    = 0;
      assign S_AXI_RRESP    = 0;
      assign S_AXI_RLAST    = 0;
      assign S_AXI_RUSER    = 0;
      assign S_AXI_RVALID   = 1'b0;
      assign M_AXI_RREADY   = 1'b0;
    end
  end else begin : gen_bypass
    // No clock conversion, i.e. 1:1 

      // Write address port
      assign M_AXI_AWID     = S_AXI_AWID;
      assign M_AXI_AWADDR   = S_AXI_AWADDR;
      assign M_AXI_AWLEN    = S_AXI_AWLEN;
      assign M_AXI_AWSIZE   = S_AXI_AWSIZE;
      assign M_AXI_AWBURST  = S_AXI_AWBURST;
      assign M_AXI_AWLOCK   = S_AXI_AWLOCK;
      assign M_AXI_AWCACHE  = S_AXI_AWCACHE;
      assign M_AXI_AWPROT   = S_AXI_AWPROT;
      assign M_AXI_AWREGION = S_AXI_AWREGION;
      assign M_AXI_AWQOS    = S_AXI_AWQOS;
      assign M_AXI_AWUSER   = S_AXI_AWUSER;
      assign M_AXI_AWVALID  = S_AXI_AWVALID & (C_AXI_SUPPORTS_WRITE != 0);
      assign S_AXI_AWREADY  = M_AXI_AWREADY & (C_AXI_SUPPORTS_WRITE != 0);

      // Write Data Port
      assign M_AXI_WDATA    = S_AXI_WDATA;
      assign M_AXI_WSTRB    = S_AXI_WSTRB;
      assign M_AXI_WLAST    = S_AXI_WLAST;
      assign M_AXI_WUSER    = S_AXI_WUSER;
      assign M_AXI_WVALID   = S_AXI_WVALID & (C_AXI_SUPPORTS_WRITE != 0);
      assign S_AXI_WREADY   = M_AXI_WREADY & (C_AXI_SUPPORTS_WRITE != 0);

      // Write Response Port
      assign S_AXI_BID      = M_AXI_BID;
      assign S_AXI_BRESP    = M_AXI_BRESP;
      assign S_AXI_BUSER    = M_AXI_BUSER;
      assign S_AXI_BVALID   = M_AXI_BVALID & (C_AXI_SUPPORTS_WRITE != 0);
      assign M_AXI_BREADY   = S_AXI_BREADY & (C_AXI_SUPPORTS_WRITE != 0);

      // Read Address Port
      assign M_AXI_ARID     = S_AXI_ARID;
      assign M_AXI_ARADDR   = S_AXI_ARADDR;
      assign M_AXI_ARLEN    = S_AXI_ARLEN;
      assign M_AXI_ARSIZE   = S_AXI_ARSIZE;
      assign M_AXI_ARBURST  = S_AXI_ARBURST;
      assign M_AXI_ARLOCK   = S_AXI_ARLOCK;
      assign M_AXI_ARCACHE  = S_AXI_ARCACHE;
      assign M_AXI_ARPROT   = S_AXI_ARPROT;
      assign M_AXI_ARREGION = S_AXI_ARREGION;
      assign M_AXI_ARQOS    = S_AXI_ARQOS;
      assign M_AXI_ARUSER   = S_AXI_ARUSER;
      assign M_AXI_ARVALID  = S_AXI_ARVALID & (C_AXI_SUPPORTS_READ != 0);
      assign S_AXI_ARREADY  = M_AXI_ARREADY & (C_AXI_SUPPORTS_READ != 0);

      // Read Data Port
      assign S_AXI_RID      = M_AXI_RID;
      assign S_AXI_RDATA    = M_AXI_RDATA;
      assign S_AXI_RRESP    = M_AXI_RRESP;
      assign S_AXI_RLAST    = M_AXI_RLAST;
      assign S_AXI_RUSER    = M_AXI_RUSER;
      assign S_AXI_RVALID   = M_AXI_RVALID & (C_AXI_SUPPORTS_READ != 0);
      assign M_AXI_RREADY   = S_AXI_RREADY & (C_AXI_SUPPORTS_READ != 0);
  end

  endgenerate

endmodule



// -- (c) Copyright 2010 - 2011 Xilinx, Inc. All rights reserved.
// --
// -- This file contains confidential and proprietary information
// -- of Xilinx, Inc. and is protected under U.S. and 
// -- international copyright and other intellectual property
// -- laws.
// --
// -- DISCLAIMER
// -- This disclaimer is not a license and does not grant any
// -- rights to the materials distributed herewith. Except as
// -- otherwise provided in a valid license issued to you by
// -- Xilinx, and to the maximum extent permitted by applicable
// -- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
// -- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
// -- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
// -- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
// -- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
// -- (2) Xilinx shall not be liable (whether in contract or tort,
// -- including negligence, or under any other theory of
// -- liability) for any loss or damage of any kind or nature
// -- related to, arising under or in connection with these
// -- materials, including for any direct, or any indirect,
// -- special, incidental, or consequential loss or damage
// -- (including loss of data, profits, goodwill, or any type of
// -- loss or damage suffered as a result of any action brought
// -- by a third party) even if such damage or loss was
// -- reasonably foreseeable or Xilinx had been advised of the
// -- possibility of the same.
// --
// -- CRITICAL APPLICATIONS
// -- Xilinx products are not designed or intended to be fail-
// -- safe, or for use in any application requiring fail-safe
// -- performance, such as life-support or safety devices or
// -- systems, Class III medical devices, nuclear facilities,
// -- applications related to the deployment of airbags, or any
// -- other applications that could lead to death, personal
// -- injury, or severe property or environmental damage
// -- (individually and collectively, "Critical
// -- Applications"). Customer assumes the sole risk and
// -- liability of any use of Xilinx products in Critical
// -- Applications, subject only to applicable laws and
// -- regulations governing limitations on product liability.
// --
// -- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
// -- PART OF THIS FILE AT ALL TIMES.
//-----------------------------------------------------------------------------
//
// Register Slice
//   Generic single-channel AXI pipeline register on forward and/or reverse signal path
//
// Verilog-standard:  Verilog 2001
//--------------------------------------------------------------------------
//
// Structure:
//   axic_register_slice
//
//--------------------------------------------------------------------------

`timescale 1ps/1ps

(* DowngradeIPIdentifiedWarnings="yes" *) 
module axi_interconnect_v1_7_13_axic_register_slice #
  (
   parameter C_FAMILY     = "virtex6",
   parameter integer C_DATA_WIDTH = 32,
   parameter [31:0] C_REG_CONFIG = 32'h00000000
   // C_REG_CONFIG:
   //   0 => BYPASS    = The channel is just wired through the module.
   //   1 => FWD_REV   = Both FWD and REV (fully-registered)
   //   2 => FWD       = The master VALID and payload signals are registrated. 
   //   3 => REV       = The slave ready signal is registrated
   //   4 => RESERVED (all outputs driven to 0).
   //   5 => RESERVED (all outputs driven to 0).
   //   6 => INPUTS    = Slave and Master side inputs are registrated.
   //   7 => LIGHT_WT  = 1-stage pipeline register with bubble cycle, both FWD and REV pipelining
   )
  (
   // System Signals
   input wire ACLK,
   input wire ARESET,

   // Slave side
   input  wire [C_DATA_WIDTH-1:0] S_PAYLOAD_DATA,
   input  wire S_VALID,
   output wire S_READY,

   // Master side
   output  wire [C_DATA_WIDTH-1:0] M_PAYLOAD_DATA,
   output wire M_VALID,
   input  wire M_READY
   );

  (* use_clock_enable = "yes" *)

  generate
  ////////////////////////////////////////////////////////////////////
  //
  // C_REG_CONFIG = 0
  // Bypass mode
  //
  ////////////////////////////////////////////////////////////////////
    if (C_REG_CONFIG == 32'h00000000)
    begin
      assign M_PAYLOAD_DATA = S_PAYLOAD_DATA;
      assign M_VALID        = S_VALID;
      assign S_READY        = M_READY;      
    end
  ////////////////////////////////////////////////////////////////////
  //
  // C_REG_CONFIG = 1 (or 8)
  // Both FWD and REV mode
  //
  ////////////////////////////////////////////////////////////////////
    else if ((C_REG_CONFIG == 32'h00000001) || (C_REG_CONFIG == 32'h00000008))
    begin
      reg [1:0] state;
      localparam [1:0] 
        ZERO = 2'b10,
        ONE  = 2'b11,
        TWO  = 2'b01;
      
      reg [C_DATA_WIDTH-1:0] storage_data1;
      reg [C_DATA_WIDTH-1:0] storage_data2;
      reg                    load_s1;
      wire                   load_s2;
      wire                   load_s1_from_s2;
      reg                    s_ready_i; //local signal of output
      wire                   m_valid_i; //local signal of output

      // assign local signal to its output signal
      assign S_READY = s_ready_i;
      assign M_VALID = m_valid_i;

      reg [1:0] areset_d; // Reset delay register
      always @(posedge ACLK) begin
        areset_d <= {areset_d[0], ARESET};
      end
      
      // Load storage1 with either slave side data or from storage2
      always @(posedge ACLK) 
      begin
        if (load_s1)
          if (load_s1_from_s2)
            storage_data1 <= storage_data2;
          else
            storage_data1 <= S_PAYLOAD_DATA;        
      end

      // Load storage2 with slave side data
      always @(posedge ACLK) 
      begin
        if (load_s2)
          storage_data2 <= S_PAYLOAD_DATA;
      end

      assign M_PAYLOAD_DATA = storage_data1;

      // Always load s2 on a valid transaction even if it's unnecessary
      assign load_s2 = S_VALID & s_ready_i;

      // Loading s1
      always @ *
      begin
        if ( ((state == ZERO) && (S_VALID == 1)) || // Load when empty on slave transaction
             // Load when ONE if we both have read and write at the same time
             ((state == ONE) && (S_VALID == 1) && (M_READY == 1)) ||
             // Load when TWO and we have a transaction on Master side
             ((state == TWO) && (M_READY == 1)))
          load_s1 = 1'b1;
        else
          load_s1 = 1'b0;
      end // always @ *

      assign load_s1_from_s2 = (state == TWO);
                       
      // State Machine for handling output signals
      always @(posedge ACLK) begin
        if (ARESET) begin
          s_ready_i <= 1'b0;
          state <= ZERO;
        end else if (areset_d == 2'b10) begin
          s_ready_i <= 1'b1;
        end else if (areset_d == 2'b00) begin
          case (state)
            // No transaction stored locally
            ZERO: if (S_VALID) state <= ONE; // Got one so move to ONE

            // One transaction stored locally
            ONE: begin
              if (M_READY & ~S_VALID) state <= ZERO; // Read out one so move to ZERO
              if (~M_READY & S_VALID) begin
                state <= TWO;  // Got another one so move to TWO
                s_ready_i <= 1'b0;
              end
            end

            // TWO transaction stored locally
            TWO: if (M_READY) begin
              state <= ONE; // Read out one so move to ONE
              s_ready_i <= 1'b1;
            end
          endcase // case (state)
        end
      end // always @ (posedge ACLK)
      
      assign m_valid_i = state[0];

    end // if (C_REG_CONFIG == 1)
    
  ////////////////////////////////////////////////////////////////////
  //
  // C_REG_CONFIG = 2
  // Only FWD mode
  //
  ////////////////////////////////////////////////////////////////////
    else if (C_REG_CONFIG == 32'h00000002)
    begin
      reg [C_DATA_WIDTH-1:0] storage_data;
      wire                   s_ready_i; //local signal of output
      reg                    m_valid_i; //local signal of output

      // assign local signal to its output signal
      assign S_READY = s_ready_i;
      assign M_VALID = m_valid_i;

      (* equivalent_register_removal = "no" *) reg [1:0] areset_d; // Reset delay register
      always @(posedge ACLK) begin
        areset_d <= {areset_d[0], ARESET};
      end
      
      // Save payload data whenever we have a transaction on the slave side
      always @(posedge ACLK) 
      begin
        if (S_VALID & s_ready_i)
          storage_data <= S_PAYLOAD_DATA;
      end

      assign M_PAYLOAD_DATA = storage_data;
      
      // M_Valid set to high when we have a completed transfer on slave side
      // Is removed on a M_READY except if we have a new transfer on the slave side
      always @(posedge ACLK) 
      begin
        if (areset_d) 
          m_valid_i <= 1'b0;
        else
          if (S_VALID) // Always set m_valid_i when slave side is valid
            m_valid_i <= 1'b1;
          else
            if (M_READY) // Clear (or keep) when no slave side is valid but master side is ready
              m_valid_i <= 1'b0;
      end // always @ (posedge ACLK)
      
      // Slave Ready is either when Master side drives M_Ready or we have space in our storage data
      assign s_ready_i = (M_READY | ~m_valid_i) & ~|areset_d;

    end // if (C_REG_CONFIG == 2)
  ////////////////////////////////////////////////////////////////////
  //
  // C_REG_CONFIG = 3
  // Only REV mode
  //
  ////////////////////////////////////////////////////////////////////
    else if (C_REG_CONFIG == 32'h00000003)
    begin
      reg [C_DATA_WIDTH-1:0] storage_data;
      reg                    s_ready_i; //local signal of output
      reg                    has_valid_storage_i;
      reg                    has_valid_storage;

      (* equivalent_register_removal = "no" *) reg areset_d; // Reset delay register
      always @(posedge ACLK) begin
        areset_d <= ARESET;
      end
      
      // Save payload data whenever we have a transaction on the slave side
      always @(posedge ACLK) 
      begin
        if (S_VALID & s_ready_i)
          storage_data <= S_PAYLOAD_DATA;
      end

      assign M_PAYLOAD_DATA = has_valid_storage?storage_data:S_PAYLOAD_DATA;

      // Need to determine when we need to save a payload
      // Need a combinatorial signals since it will also effect S_READY
      always @ *
      begin
        // Set the value if we have a slave transaction but master side is not ready
        if (S_VALID & s_ready_i & ~M_READY)
          has_valid_storage_i = 1'b1;
        
        // Clear the value if it's set and Master side completes the transaction but we don't have a new slave side 
        // transaction 
        else if ( (has_valid_storage == 1) && (M_READY == 1) && ( (S_VALID == 0) || (s_ready_i == 0)))
          has_valid_storage_i = 1'b0;
        else
          has_valid_storage_i = has_valid_storage;
      end // always @ *

      always @(posedge ACLK) 
      begin
        if (ARESET) 
          has_valid_storage <= 1'b0;
        else
          has_valid_storage <= has_valid_storage_i;
      end

      // S_READY is either clocked M_READY or that we have room in local storage
      always @(posedge ACLK) 
      begin
        if (ARESET) 
          s_ready_i <= 1'b0;
        else
          s_ready_i <= M_READY | ~has_valid_storage_i;
      end

      // assign local signal to its output signal
      assign S_READY = s_ready_i;

      // M_READY is either combinatorial S_READY or that we have valid data in local storage
      assign M_VALID = (S_VALID | has_valid_storage) & ~areset_d;
      
    end // if (C_REG_CONFIG == 3)
    
  ////////////////////////////////////////////////////////////////////
  //
  // C_REG_CONFIG = 4 or 5 is NO LONGER SUPPORTED
  //
  ////////////////////////////////////////////////////////////////////
    else if ((C_REG_CONFIG == 32'h00000004) || (C_REG_CONFIG == 32'h00000005))
    begin
// synthesis translate_off
      initial begin  
        $display ("ERROR: For axi_register_slice, C_REG_CONFIG = 4 or 5 is RESERVED.");
      end
// synthesis translate_on
      assign M_PAYLOAD_DATA = 0;
      assign M_VALID        = 1'b0;
      assign S_READY        = 1'b0;    
    end  

  ////////////////////////////////////////////////////////////////////
  //
  // C_REG_CONFIG = 6
  // INPUTS mode
  //
  ////////////////////////////////////////////////////////////////////
    else if (C_REG_CONFIG == 32'h00000006)
    begin
      reg [1:0] state;
      reg [1:0] next_state;
      localparam [1:0] 
        ZERO = 2'b00,
        ONE  = 2'b01,
        TWO  = 2'b11;

      reg [C_DATA_WIDTH-1:0] storage_data1;
      reg [C_DATA_WIDTH-1:0] storage_data2;
      reg                    s_valid_d;
      reg                    s_ready_d;
      reg                    m_ready_d;
      reg                    m_valid_d;
      reg                    load_s2;
      reg                    sel_s2;
      wire                   new_access;
      wire                   access_done;
      wire                   s_ready_i; //local signal of output
      reg                    s_ready_ii;
      reg                    m_valid_i; //local signal of output
      
      (* equivalent_register_removal = "no" *) reg areset_d; // Reset delay register
      always @(posedge ACLK) begin
        areset_d <= ARESET;
      end
      
      // assign local signal to its output signal
      assign S_READY = s_ready_i;
      assign M_VALID = m_valid_i;
      assign s_ready_i = s_ready_ii & ~areset_d;

      // Registrate input control signals
      always @(posedge ACLK) 
      begin
        if (ARESET) begin          
          s_valid_d <= 1'b0;
          s_ready_d <= 1'b0;
          m_ready_d <= 1'b0;
        end else begin
          s_valid_d <= S_VALID;
          s_ready_d <= s_ready_i;
          m_ready_d <= M_READY;
        end
      end // always @ (posedge ACLK)

      // Load storage1 with slave side payload data when slave side ready is high
      always @(posedge ACLK) 
      begin
        if (s_ready_i)
          storage_data1 <= S_PAYLOAD_DATA;          
      end

      // Load storage2 with storage data 
      always @(posedge ACLK) 
      begin
        if (load_s2)
          storage_data2 <= storage_data1;
      end

      always @(posedge ACLK) 
      begin
        if (ARESET) 
          m_valid_d <= 1'b0;
        else 
          m_valid_d <= m_valid_i;
      end

      // Local help signals
      assign new_access  = s_ready_d & s_valid_d;
      assign access_done = m_ready_d & m_valid_d;


      // State Machine for handling output signals
      always @*
      begin
        next_state = state; // Stay in the same state unless we need to move to another state
        load_s2   = 0;
        sel_s2    = 0;
        m_valid_i = 0;
        s_ready_ii = 0;
        case (state)
            // No transaction stored locally
            ZERO: begin
              load_s2   = 0;
              sel_s2    = 0;
              m_valid_i = 0;
              s_ready_ii = 1;
              if (new_access) begin
                next_state = ONE; // Got one so move to ONE
                load_s2   = 1;
                m_valid_i = 0;
              end
              else begin
                next_state = next_state;
                load_s2   = load_s2;
                m_valid_i = m_valid_i;
              end

            end // case: ZERO

            // One transaction stored locally
            ONE: begin
              load_s2   = 0;
              sel_s2    = 1;
              m_valid_i = 1;
              s_ready_ii = 1;
              if (~new_access & access_done) begin
                next_state = ZERO; // Read out one so move to ZERO
                m_valid_i = 0;                      
              end
              else if (new_access & ~access_done) begin
                next_state = TWO;  // Got another one so move to TWO
                s_ready_ii = 0;
              end
              else if (new_access & access_done) begin
                load_s2   = 1;
                sel_s2    = 0;
              end
              else begin
                load_s2   = load_s2;
                sel_s2    = sel_s2;
              end


            end // case: ONE

            // TWO transaction stored locally
            TWO: begin
              load_s2   = 0;
              sel_s2    = 1;
              m_valid_i = 1;
              s_ready_ii = 0;
              if (access_done) begin 
                next_state = ONE; // Read out one so move to ONE
                s_ready_ii  = 1;
                load_s2    = 1;
                sel_s2     = 0;
              end
              else begin
                next_state = next_state;
                s_ready_ii  = s_ready_ii;
                load_s2    = load_s2;
                sel_s2     = sel_s2;
              end
            end // case: TWO
        endcase // case (state)
      end // always @ *


      // State Machine for handling output signals
      always @(posedge ACLK) 
      begin
        if (ARESET) 
          state <= ZERO;
        else
          state <= next_state; // Stay in the same state unless we need to move to another state
      end
      
      // Master Payload mux
      assign M_PAYLOAD_DATA = sel_s2?storage_data2:storage_data1;

    end // if (C_REG_CONFIG == 6)
  ////////////////////////////////////////////////////////////////////
  //
  // C_REG_CONFIG = 7
  // Light-weight mode.
  // 1-stage pipeline register with bubble cycle, both FWD and REV pipelining
  // Operates same as 1-deep FIFO
  //
  ////////////////////////////////////////////////////////////////////
    else if (C_REG_CONFIG == 32'h00000007)
    begin
      reg [C_DATA_WIDTH-1:0] storage_data1;
      reg                    s_ready_i; //local signal of output
      reg                    m_valid_i; //local signal of output

      // assign local signal to its output signal
      assign S_READY = s_ready_i;
      assign M_VALID = m_valid_i;

      reg [1:0] areset_d; // Reset delay register
      always @(posedge ACLK) begin
        areset_d <= {areset_d[0], ARESET};
      end
      
      // Load storage1 with slave side data
      always @(posedge ACLK) 
      begin
        if (ARESET) begin
          s_ready_i <= 1'b0;
          m_valid_i <= 1'b0;
        end else if (areset_d == 2'b10) begin
          s_ready_i <= 1'b1;
        end else if (areset_d == 2'b00) begin
          if (m_valid_i & M_READY) begin
            s_ready_i <= 1'b1;
            m_valid_i <= 1'b0;
          end else if (S_VALID & s_ready_i) begin
            s_ready_i <= 1'b0;
            m_valid_i <= 1'b1;
          end
        end
        if (~m_valid_i) begin
          storage_data1 <= S_PAYLOAD_DATA;        
        end
      end
      assign M_PAYLOAD_DATA = storage_data1;
    end // if (C_REG_CONFIG == 7)
    
    else begin : default_case
      // Passthrough
      assign M_PAYLOAD_DATA = S_PAYLOAD_DATA;
      assign M_VALID        = S_VALID;
      assign S_READY        = M_READY;      
    end

  endgenerate
endmodule // reg_slice


// -- (c) Copyright 2010 - 2011 Xilinx, Inc. All rights reserved.
// --
// -- This file contains confidential and proprietary information
// -- of Xilinx, Inc. and is protected under U.S. and 
// -- international copyright and other intellectual property
// -- laws.
// --
// -- DISCLAIMER
// -- This disclaimer is not a license and does not grant any
// -- rights to the materials distributed herewith. Except as
// -- otherwise provided in a valid license issued to you by
// -- Xilinx, and to the maximum extent permitted by applicable
// -- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
// -- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
// -- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
// -- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
// -- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
// -- (2) Xilinx shall not be liable (whether in contract or tort,
// -- including negligence, or under any other theory of
// -- liability) for any loss or damage of any kind or nature
// -- related to, arising under or in connection with these
// -- materials, including for any direct, or any indirect,
// -- special, incidental, or consequential loss or damage
// -- (including loss of data, profits, goodwill, or any type of
// -- loss or damage suffered as a result of any action brought
// -- by a third party) even if such damage or loss was
// -- reasonably foreseeable or Xilinx had been advised of the
// -- possibility of the same.
// --
// -- CRITICAL APPLICATIONS
// -- Xilinx products are not designed or intended to be fail-
// -- safe, or for use in any application requiring fail-safe
// -- performance, such as life-support or safety devices or
// -- systems, Class III medical devices, nuclear facilities,
// -- applications related to the deployment of airbags, or any
// -- other applications that could lead to death, personal
// -- injury, or severe property or environmental damage
// -- (individually and collectively, "Critical
// -- Applications"). Customer assumes the sole risk and
// -- liability of any use of Xilinx products in Critical
// -- Applications, subject only to applicable laws and
// -- regulations governing limitations on product liability.
// --
// -- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
// -- PART OF THIS FILE AT ALL TIMES.
//-----------------------------------------------------------------------------
// Description: N-deep SRL pipeline element with generic single-channel AXI interfaces.
//   Interface outputs are synchronized using ordinary flops for improved timing.
//--------------------------------------------------------------------------
// Structure:
//   axic_reg_srl_fifo
//     ndeep_srl
//       nto1_mux
//--------------------------------------------------------------------------


`timescale 1ps/1ps
`default_nettype none

(* DowngradeIPIdentifiedWarnings="yes" *) 
module axi_interconnect_v1_7_13_axic_reg_srl_fifo #
  (
   parameter         C_FAMILY   = "none", // FPGA Family
   parameter integer C_FIFO_WIDTH  = 1, // Width of S_MESG/M_MESG.
   parameter integer C_MAX_CTRL_FANOUT = 33, // Maximum number of mesg bits
                                             // the control logic can be used
                                             // on before the control logic
                                             // needs to be replicated.
   parameter integer C_FIFO_DEPTH_LOG =  2,  // Depth of FIFO is 2**C_FIFO_DEPTH_LOG.  
                                             // The minimum size fifo generated is 4-deep.
   parameter         C_USE_FULL =  1         // Prevent overwrite by throttling S_READY.                                              
   )
  (
   input  wire                        ACLK,    // Clock
   input  wire                        ARESET,  // Reset
   input  wire [C_FIFO_WIDTH-1:0]     S_MESG,  // Input data
   input  wire                        S_VALID, // Input data valid
   output wire                        S_READY, // Input data ready
   output wire [C_FIFO_WIDTH-1:0]     M_MESG,  // Output data
   output wire                        M_VALID, // Output data valid
   input  wire                        M_READY  // Output data ready
   );
  
  localparam P_FIFO_DEPTH_LOG = (C_FIFO_DEPTH_LOG>1) ? C_FIFO_DEPTH_LOG : 2;
  localparam P_EMPTY       = {P_FIFO_DEPTH_LOG{1'b1}};
  localparam P_ALMOSTEMPTY = {P_FIFO_DEPTH_LOG{1'b0}};
  localparam P_ALMOSTFULL_TEMP  = {P_EMPTY, 1'b0};
  localparam P_ALMOSTFULL  = P_ALMOSTFULL_TEMP[0+:P_FIFO_DEPTH_LOG];
  localparam P_NUM_REPS    = (((C_FIFO_WIDTH+1)%C_MAX_CTRL_FANOUT) == 0) ?
                             (C_FIFO_WIDTH+1)/C_MAX_CTRL_FANOUT :
                             ((C_FIFO_WIDTH+1)/C_MAX_CTRL_FANOUT)+1;

  (* syn_keep = "1" *) reg [P_NUM_REPS*P_FIFO_DEPTH_LOG-1:0]  fifoaddr;
  (* syn_keep = "1" *) wire [P_NUM_REPS*P_FIFO_DEPTH_LOG-1:0] fifoaddr_i;

  genvar i;
  genvar j;

  reg  m_valid_i;
  reg  s_ready_i;
  wire push;     // FIFO push
  wire pop;      // FIFO pop
  reg  areset_d1; // Reset delay register
  reg  [C_FIFO_WIDTH-1:0] storage_data1;
  wire [C_FIFO_WIDTH-1:0] storage_data2; // Intermediate SRL data
  reg                    load_s1;
  wire                   load_s1_from_s2;

  reg [1:0] state;
  localparam [1:0] 
    ZERO = 2'b10,
    ONE  = 2'b11,
    TWO  = 2'b01;
      
  assign M_VALID = m_valid_i;
  assign S_READY = C_USE_FULL ? s_ready_i : 1'b1;
  assign push = (S_VALID & (C_USE_FULL ? s_ready_i : 1'b1) & (state == TWO)) | (~M_READY & S_VALID & (state == ONE));
  assign pop  = M_READY & (state == TWO);
  assign M_MESG = storage_data1;
  
  always @(posedge ACLK) begin
    areset_d1 <= ARESET;
  end
      
  // Load storage1 with either slave side data or from storage2
  always @(posedge ACLK) 
  begin
    if (load_s1)
      if (load_s1_from_s2)
        storage_data1 <= storage_data2;
      else
        storage_data1 <= S_MESG;        
  end

  // Loading s1
  always @ *
  begin
    if ( ((state == ZERO) && (S_VALID == 1)) || // Load when empty on slave transaction
         // Load when ONE if we both have read and write at the same time
         ((state == ONE) && (S_VALID == 1) && (M_READY == 1)) ||
         // Load when TWO and we have a transaction on Master side
         ((state == TWO) && (M_READY == 1)))
      load_s1 = 1'b1;
    else
      load_s1 = 1'b0;
  end // always @ *

  assign load_s1_from_s2 = (state == TWO);
                   
  // State Machine for handling output signals
  always @(posedge ACLK) 
  begin
    if (areset_d1) begin
      state <= ZERO;
      m_valid_i <= 1'b0;
    end else begin
      case (state)
        // No transaction stored locally
        ZERO: begin
          if (S_VALID) begin
            state <= ONE; // Got one so move to ONE
            m_valid_i <= 1'b1;
          end
        end

        // One transaction stored locally
        ONE: begin
          if (M_READY & ~S_VALID) begin
            state <= ZERO; // Read out one so move to ZERO
            m_valid_i <= 1'b0;
          end else if (~M_READY & S_VALID) begin
            state <= TWO;  // Got another one so move to TWO
            m_valid_i <= 1'b1;
          end
        end

        // TWO transaction stored locally
        TWO: begin
          if ((fifoaddr[P_FIFO_DEPTH_LOG*P_NUM_REPS-1:P_FIFO_DEPTH_LOG*(P_NUM_REPS-1)] == 
                 P_ALMOSTEMPTY) && pop && ~push) begin
            state <= ONE; // Read out one so move to ONE
            m_valid_i <= 1'b1;
          end
        end
      endcase // case (state)
    end
  end // always @ (posedge ACLK)
      
  generate
    //---------------------------------------------------------------------------
    // Create count of number of elements in FIFOs
    //---------------------------------------------------------------------------
    for (i=0;i<P_NUM_REPS;i=i+1) begin : gen_rep
      assign fifoaddr_i[P_FIFO_DEPTH_LOG*(i+1)-1:P_FIFO_DEPTH_LOG*i] = 
         push ? fifoaddr[P_FIFO_DEPTH_LOG*(i+1)-1:P_FIFO_DEPTH_LOG*i] + 1 :
                fifoaddr[P_FIFO_DEPTH_LOG*(i+1)-1:P_FIFO_DEPTH_LOG*i] - 1;
      always @(posedge ACLK) begin
        if (ARESET)
          fifoaddr[P_FIFO_DEPTH_LOG*(i+1)-1:P_FIFO_DEPTH_LOG*i] <= 
                {P_FIFO_DEPTH_LOG{1'b1}};
        else if (push ^ pop)
          fifoaddr[P_FIFO_DEPTH_LOG*(i+1)-1:P_FIFO_DEPTH_LOG*i] <= 
                fifoaddr_i[P_FIFO_DEPTH_LOG*(i+1)-1:P_FIFO_DEPTH_LOG*i];
      end
    end

    always @(posedge ACLK) begin
      if (ARESET) begin
        s_ready_i <= 1'b0;
      end else if (areset_d1) begin
        s_ready_i <= 1'b1;
      end else if (C_USE_FULL && 
        ((fifoaddr[P_FIFO_DEPTH_LOG*P_NUM_REPS-1:P_FIFO_DEPTH_LOG*(P_NUM_REPS-1)] == 
         P_ALMOSTFULL) && push && ~pop)) begin
        s_ready_i <= 1'b0;
      end else if (C_USE_FULL && pop) begin
        s_ready_i <= 1'b1;
      end
    end

    //---------------------------------------------------------------------------
    // Instantiate SRLs
    //---------------------------------------------------------------------------
    for (i=0;i<(C_FIFO_WIDTH/C_MAX_CTRL_FANOUT)+((C_FIFO_WIDTH%C_MAX_CTRL_FANOUT)>0);i=i+1) begin : gen_srls
      for (j=0;((j<C_MAX_CTRL_FANOUT)&&(i*C_MAX_CTRL_FANOUT+j<C_FIFO_WIDTH));j=j+1) begin : gen_rep
  axi_interconnect_v1_7_13_ndeep_srl #
    	  (
    	   .C_FAMILY  (C_FAMILY),
    	   .C_A_WIDTH (P_FIFO_DEPTH_LOG)
    	  )
          srl_nx1
          (
           .CLK (ACLK),
           .A   (fifoaddr[P_FIFO_DEPTH_LOG*(i+1)-1:
                          P_FIFO_DEPTH_LOG*(i)]),
           .CE  (push),
           .D   (S_MESG[i*C_MAX_CTRL_FANOUT+j]),
           .Q   (storage_data2[i*C_MAX_CTRL_FANOUT+j])
          );
      end
    end      
  endgenerate
  
endmodule

`default_nettype wire


// -- (c) Copyright 2011 Xilinx, Inc. All rights reserved.
// --
// -- This file contains confidential and proprietary information
// -- of Xilinx, Inc. and is protected under U.S. and 
// -- international copyright and other intellectual property
// -- laws.
// --
// -- DISCLAIMER
// -- This disclaimer is not a license and does not grant any
// -- rights to the materials distributed herewith. Except as
// -- otherwise provided in a valid license issued to you by
// -- Xilinx, and to the maximum extent permitted by applicable
// -- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
// -- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
// -- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
// -- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
// -- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
// -- (2) Xilinx shall not be liable (whether in contract or tort,
// -- including negligence, or under any other theory of
// -- liability) for any loss or damage of any kind or nature
// -- related to, arising under or in connection with these
// -- materials, including for any direct, or any indirect,
// -- special, incidental, or consequential loss or damage
// -- (including loss of data, profits, goodwill, or any type of
// -- loss or damage suffered as a result of any action brought
// -- by a third party) even if such damage or loss was
// -- reasonably foreseeable or Xilinx had been advised of the
// -- possibility of the same.
// --
// -- CRITICAL APPLICATIONS
// -- Xilinx products are not designed or intended to be fail-
// -- safe, or for use in any application requiring fail-safe
// -- performance, such as life-support or safety devices or
// -- systems, Class III medical devices, nuclear facilities,
// -- applications related to the deployment of airbags, or any
// -- other applications that could lead to death, personal
// -- injury, or severe property or environmental damage
// -- (individually and collectively, "Critical
// -- Applications"). Customer assumes the sole risk and
// -- liability of any use of Xilinx products in Critical
// -- Applications, subject only to applicable laws and
// -- regulations governing limitations on product liability.
// --
// -- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
// -- PART OF THIS FILE AT ALL TIMES.
//-----------------------------------------------------------------------------
//
// File name: axi_crossbar.v
//-----------------------------------------------------------------------------
`timescale 1ps/1ps
`default_nettype none

(* DowngradeIPIdentifiedWarnings="yes" *) 
module axi_interconnect_v1_7_13_axi_crossbar # (
   parameter integer C_MAX_S = 16,
   parameter integer C_MAX_M = 16,
   parameter integer C_NUM_ADDR_RANGES = 16,
   parameter         C_FAMILY                         = "rtl", 
                       // FPGA Base Family. Current version: virtex6 or spartan6.
   parameter integer C_NUM_SLAVE_SLOTS                = 1, 
                       // Number of Slave Interface (SI) slots for connecting 
                       // to master IP. Range: 1-C_MAX_S.
   parameter integer C_NUM_MASTER_SLOTS               = 1, 
                       // Number of Master Interface (MI) slots for connecting 
                       // to slave IP. Range: 1-C_MAX_M.
   parameter integer C_AXI_ID_WIDTH                   = 1, 
                       // Width of ID signals propagated by the Interconnect.
                       // Width of ID signals produced on all MI slots.
                       // Range: 1-16.
   parameter integer C_AXI_ADDR_WIDTH                 = 32, 
                       // Width of S_AXI_AWADDR, S_AXI_ARADDR, M_AXI_AWADDR and 
                       // M_AXI_ARADDR for all SI/MI slots.
                       // Range: 32.
   parameter integer C_INTERCONNECT_DATA_WIDTH        = 32, 
                       // Data width of the internal interconnect write and read 
                       // data paths.
                       // Range: 32, 64, 128, 256, 512, 1024.
   parameter integer C_AXI_DATA_MAX_WIDTH             = 32, 
                       // Largest value specified for any DATA_WIDTH (including C_INTERCONNECT_DATA_WIDTH).
                       // Determines the stride of all DATA signals.
                       // Range: 32, 64, 128, 256, 512, 1024.
   parameter [C_MAX_M*32-1:0] C_M_AXI_DATA_WIDTH               = {C_MAX_M{32'h00000020}}, 
                       // Width of M_AXI_WDATA and M_AXI_RDATA for each MI slot.
                       // Format: C_NUM_MASTER_SLOTS{Bit32};
                       // Range: 'h00000020, 'h00000040, 'h00000080, 'h00000100.
   parameter [C_MAX_S*32-1:0] C_S_AXI_PROTOCOL                 = {C_MAX_S{32'h00000000}}, 
                       // Indicates whether connected master is 
                       // Full-AXI4 ('h00000000),
                       // AXI3 ('h00000001) or 
                       // Axi4Lite ('h00000002), for each SI slot.
                       // Format: C_NUM_MASTER_SLOTS{Bit32}.
   parameter [C_MAX_M*32-1:0] C_M_AXI_PROTOCOL                 = {C_MAX_M{32'h00000000}}, 
                       // Indicates whether connected slave is
                       // Full-AXI4 ('h00000000),
                       // AXI3 ('h00000001) or 
                       // Axi4Lite ('h00000002), for each SI slot.
                       // Format: C_NUM_SLAVE_SLOTS{Bit32}.
   parameter [C_MAX_M*C_NUM_ADDR_RANGES*64-1:0] C_M_AXI_BASE_ADDR                 = {C_MAX_M*C_NUM_ADDR_RANGES{64'hFFFFFFFF_FFFFFFFF}}, 
                       // Base address of each range of each MI slot. 
                       // For unused ranges, set base address to 'hFFFFFFFF.
                       // Format: C_NUM_MASTER_SLOTS{C_NUM_ADDR_RANGES{Bit64}}.
   parameter [C_MAX_M*C_NUM_ADDR_RANGES*64-1:0] C_M_AXI_HIGH_ADDR                 = {C_MAX_M*C_NUM_ADDR_RANGES{64'h00000000_00000000}}, 
                       // High address of each range of each MI slot. 
                       // For unused ranges, set high address to 'h00000000.
                       // Format: C_NUM_MASTER_SLOTS{C_NUM_ADDR_RANGES{Bit64}}.
   parameter [C_MAX_S*64-1:0] C_S_AXI_BASE_ID                  = {C_MAX_S{64'h00000000_00000000}},
                       // Base ID of each SI slot. 
                       // Format: C_NUM_SLAVE_SLOTS{Bit64};
                       // Range: 0 to 2**C_AXI_ID_WIDTH-1.
   parameter [C_MAX_S*64-1:0] C_S_AXI_HIGH_ID                  = {C_MAX_S{64'h00000000_00000000}},
                       // High ID of each SI slot. 
                       // Format: C_NUM_SLAVE_SLOTS{Bit64};
                       // Range: 0 to 2**C_AXI_ID_WIDTH-1.
   parameter [C_MAX_S*32-1:0] C_S_AXI_THREAD_ID_WIDTH                  = {C_MAX_S{32'h00000000}}, 
   parameter [C_MAX_S*1-1:0] C_S_AXI_IS_INTERCONNECT          = {C_MAX_S{1'b0}}, 
                       // Indicates whether connected master is an end-point
                       // master (0) or an interconnect (1), for each SI slot.
                       // Format: C_NUM_SLAVE_SLOTS{Bit1}.
   parameter [C_MAX_S*1-1:0] C_S_AXI_SUPPORTS_WRITE           = {C_MAX_S{1'b1}}, 
                       // Indicates whether each SI supports write transactions.
                       // Format: C_NUM_SLAVE_SLOTS{Bit1}.
   parameter [C_MAX_S*1-1:0] C_S_AXI_SUPPORTS_READ            = {C_MAX_S{1'b1}}, 
                       // Indicates whether each SI supports read transactions.
                       // Format: C_NUM_SLAVE_SLOTS{Bit1}.
   parameter [C_MAX_M*1-1:0] C_M_AXI_SUPPORTS_WRITE           = {C_MAX_M{1'b1}}, 
                       // Indicates whether each MI supports write transactions.
                       // Format: C_NUM_MASTER_SLOTS{Bit1}.
   parameter [C_MAX_M*1-1:0] C_M_AXI_SUPPORTS_READ            = {C_MAX_M{1'b1}}, 
                       // Indicates whether each MI supports read transactions.
                       // Format: C_NUM_MASTER_SLOTS{Bit1}.
   parameter integer C_AXI_SUPPORTS_USER_SIGNALS      = 0,
                       // 1 = Propagate all USER signals, 0 = Dont propagate.
   parameter integer C_AXI_AWUSER_WIDTH               = 1,
                       // Width of AWUSER signals for all SI slots and MI slots. 
                       // Range: >= 1.
   parameter integer C_AXI_ARUSER_WIDTH               = 1,
                       // Width of ARUSER signals for all SI slots and MI slots. 
                       // Range: >= 1.
   parameter integer C_AXI_WUSER_WIDTH                = 1,
                       // Width of WUSER signals for all SI slots and MI slots. 
                       // Range: >= 1.
   parameter integer C_AXI_RUSER_WIDTH                = 1,
                       // Width of RUSER signals for all SI slots and MI slots. 
                       // Range: >= 1.
   parameter integer C_AXI_BUSER_WIDTH                = 1,
                       // Width of BUSER signals for all SI slots and MI slots. 
                       // Range: >= 1.
   parameter [C_MAX_M*32-1:0] C_AXI_CONNECTIVITY               = {C_MAX_M{32'hFFFFFFFF}},
                       // Multi-pathway connectivity from each SI slot (N) to each 
                       // MI slot (M):
                       // 0 = no pathway required; 1 = pathway required.
                       // Format: C_NUM_MASTER_SLOTS{Bit32}; 
                       // Range: C_NUM_SLAVE_SLOTS{Bit1}.
   parameter integer C_INTERCONNECT_R_REGISTER               = 0,
                       // Insert register slice on R channel in the crossbar.
                       // Range: 0-8.
   parameter [C_MAX_S*1-1:0] C_S_AXI_SINGLE_THREAD                 = {C_MAX_S{1'b0}}, 
                       // 0 = Implement separate command queues per ID thread.
                       // 1 = Force corresponding SI slot to be single-threaded.
                       // Format: C_NUM_SLAVE_SLOTS{Bit1}; 
   parameter [C_MAX_M*1-1:0] C_M_AXI_SUPPORTS_REORDERING      = {C_MAX_M{1'b1}},
                       // Indicates whether the slave connected to each MI slot 
                       // supports response reordering.
                       // Format: C_NUM_MASTER_SLOTS{Bit1}; 
   parameter [C_MAX_S*32-1:0] C_S_AXI_WRITE_ACCEPTANCE         = {C_MAX_S{32'h00000001}},
                       // Maximum number of active write transactions that each SI 
                       // slot can accept.
                       // Format: C_NUM_SLAVE_SLOTS{Bit32}; 
                       // Range: 2**0 - 2**5.
   parameter [C_MAX_S*32-1:0] C_S_AXI_READ_ACCEPTANCE          = {C_MAX_S{32'h00000001}},
                       // Maximum number of active read transactions that each SI 
                       // slot can accept.
                       // Format: C_NUM_SLAVE_SLOTS{Bit32};
                       // Range: 2**0 - 2**5.
   parameter [C_MAX_M*32-1:0] C_M_AXI_WRITE_ISSUING            = {C_MAX_M{32'h00000001}},
                       // Maximum number of data-active write transactions that 
                       // each MI slot can generate at any one time.
                       // Format: C_NUM_MASTER_SLOTS{Bit32};
                       // Range: 2**0 - 2**5.
   parameter [C_MAX_M*32-1:0] C_M_AXI_READ_ISSUING            = {C_MAX_M{32'h00000001}},
                       // Maximum number of active read transactions that 
                       // each MI slot can generate at any one time.
                       // Format: C_NUM_MASTER_SLOTS{Bit32};
                       // Range: 2**0 - 2**5.
   parameter [C_MAX_S*32-1:0] C_S_AXI_ARB_PRIORITY             = {C_MAX_S{32'h00000000}},
                       // Arbitration priority among each SI slot. 
                       // Higher values indicate higher priority.
                       // Format: C_NUM_SLAVE_SLOTS{Bit32};
                       // Range: 'h0-'hF.
   parameter [C_MAX_M*1-1:0] C_M_AXI_SECURE                   = {C_MAX_M{1'b0}},
                       // Indicates whether each MI slot connects to a secure slave 
                       // (allows only TrustZone secure access).
                       // Format: C_NUM_MASTER_SLOTS{Bit1}.
   parameter integer C_USE_CTRL_PORT                  = 0,
                       // Indicates whether diagnostic information is accessible 
                       // via the S_AXI_CTRL interface.
   parameter integer C_USE_INTERRUPT                  = 1,
                       // If CTRL interface enabled, indicates whether interrupts 
                       // are generated.
   parameter integer C_RANGE_CHECK                    = 2,
                       // 1 (non-zero) = Detect and issue DECERR on the following conditions:
                       //   a. address range mismatch (no valid MI slot)
                       //   b. Burst or >32-bit transfer to AxiLite slave
                       //   c. TrustZone access violation
                       //   d. R/W direction unsupported by target
                       // 0 = Pass all transactions (no DECERR):
                       //   a. Omit DECERR detection and response logic
                       //   b. Omit address decoder when only 1 MI slot (M_AXI_A*REGION = 0 always)
                       //   c. Unpredictable target MI-slot if address mismatch and >1 MI-slot
                       //   d. Transaction corruption if any burst or >32-bit transfer to AxiLite slave
                       // Illegal combination: C_RANGE_CHECK = 0 && C_M_AXI_SECURE != 0.
   parameter integer C_ADDR_DECODE                    = 0,
                       // 1 = Implement address decoder.
                       // 0 = Propagate address to single slave.
   parameter integer C_S_AXI_CTRL_ADDR_WIDTH          = 32,
                       // ADDR width of CTRL interface.
   parameter integer C_S_AXI_CTRL_DATA_WIDTH          = 32,
                       // DATA width of CTRL interface.
   parameter integer C_INTERCONNECT_CONNECTIVITY_MODE = 1,
                       // 0 = Shared-Address Shared-Data (SASD).
                       // 1 = Shared-Address Multi-Data (SAMD).
   parameter [(C_MAX_M+1)*32-1:0] C_W_ISSUE_WIDTH  = {C_MAX_M+1{32'h00000000}},
   parameter [(C_MAX_M+1)*32-1:0] C_R_ISSUE_WIDTH  = {C_MAX_M+1{32'h00000000}},
   parameter [C_MAX_S*32-1:0] C_W_ACCEPT_WIDTH = {C_MAX_S{32'h00000000}},
   parameter [C_MAX_S*32-1:0] C_R_ACCEPT_WIDTH = {C_MAX_S{32'h00000000}},
   parameter integer C_DEBUG              = 1,
   parameter integer C_MAX_DEBUG_THREADS  = 1
)
(
   // Global Signals
   input  wire                                                    INTERCONNECT_ACLK,
   input  wire                                                    ARESETN,
   output wire                                                    IRQ,
   // Slave Interface Write Address Ports
   input  wire [C_NUM_SLAVE_SLOTS*C_AXI_ID_WIDTH-1:0]             S_AXI_AWID,
   input  wire [C_NUM_SLAVE_SLOTS*C_AXI_ADDR_WIDTH-1:0]           S_AXI_AWADDR,
   input  wire [C_NUM_SLAVE_SLOTS*8-1:0]                          S_AXI_AWLEN,
   input  wire [C_NUM_SLAVE_SLOTS*3-1:0]                          S_AXI_AWSIZE,
   input  wire [C_NUM_SLAVE_SLOTS*2-1:0]                          S_AXI_AWBURST,
   input  wire [C_NUM_SLAVE_SLOTS*2-1:0]                          S_AXI_AWLOCK,
   input  wire [C_NUM_SLAVE_SLOTS*4-1:0]                          S_AXI_AWCACHE,
   input  wire [C_NUM_SLAVE_SLOTS*3-1:0]                          S_AXI_AWPROT,
   input  wire [C_NUM_SLAVE_SLOTS*4-1:0]                          S_AXI_AWQOS,
   input  wire [C_NUM_SLAVE_SLOTS*C_AXI_AWUSER_WIDTH-1:0]         S_AXI_AWUSER,
   input  wire [C_NUM_SLAVE_SLOTS-1:0]                            S_AXI_AWVALID,
   output wire [C_NUM_SLAVE_SLOTS-1:0]                            S_AXI_AWREADY,
   // Slave Interface Write Data Ports
   input  wire [C_NUM_SLAVE_SLOTS*C_AXI_DATA_MAX_WIDTH-1:0]       S_AXI_WDATA,
   input  wire [C_NUM_SLAVE_SLOTS*C_AXI_DATA_MAX_WIDTH/8-1:0]     S_AXI_WSTRB,
   input  wire [C_NUM_SLAVE_SLOTS-1:0]                            S_AXI_WLAST,
   input  wire [C_NUM_SLAVE_SLOTS*C_AXI_WUSER_WIDTH-1:0]          S_AXI_WUSER,
   input  wire [C_NUM_SLAVE_SLOTS-1:0]                            S_AXI_WVALID,
   output wire [C_NUM_SLAVE_SLOTS-1:0]                            S_AXI_WREADY,
   // Slave Interface Write Response Ports
   output wire [C_NUM_SLAVE_SLOTS*C_AXI_ID_WIDTH-1:0]             S_AXI_BID,
   output wire [C_NUM_SLAVE_SLOTS*2-1:0]                          S_AXI_BRESP,
   output wire [C_NUM_SLAVE_SLOTS*C_AXI_BUSER_WIDTH-1:0]          S_AXI_BUSER,
   output wire [C_NUM_SLAVE_SLOTS-1:0]                            S_AXI_BVALID,
   input  wire [C_NUM_SLAVE_SLOTS-1:0]                            S_AXI_BREADY,
   // Slave Interface Read Address Ports
   input  wire [C_NUM_SLAVE_SLOTS*C_AXI_ID_WIDTH-1:0]             S_AXI_ARID,
   input  wire [C_NUM_SLAVE_SLOTS*C_AXI_ADDR_WIDTH-1:0]           S_AXI_ARADDR,
   input  wire [C_NUM_SLAVE_SLOTS*8-1:0]                          S_AXI_ARLEN,
   input  wire [C_NUM_SLAVE_SLOTS*3-1:0]                          S_AXI_ARSIZE,
   input  wire [C_NUM_SLAVE_SLOTS*2-1:0]                          S_AXI_ARBURST,
   input  wire [C_NUM_SLAVE_SLOTS*2-1:0]                          S_AXI_ARLOCK,
   input  wire [C_NUM_SLAVE_SLOTS*4-1:0]                          S_AXI_ARCACHE,
   input  wire [C_NUM_SLAVE_SLOTS*3-1:0]                          S_AXI_ARPROT,
   input  wire [C_NUM_SLAVE_SLOTS*4-1:0]                          S_AXI_ARQOS,
   input  wire [C_NUM_SLAVE_SLOTS*C_AXI_ARUSER_WIDTH-1:0]         S_AXI_ARUSER,
   input  wire [C_NUM_SLAVE_SLOTS-1:0]                            S_AXI_ARVALID,
   output wire [C_NUM_SLAVE_SLOTS-1:0]                            S_AXI_ARREADY,
   // Slave Interface Read Data Ports
   output wire [C_NUM_SLAVE_SLOTS*C_AXI_ID_WIDTH-1:0]             S_AXI_RID,
   output wire [C_NUM_SLAVE_SLOTS*C_AXI_DATA_MAX_WIDTH-1:0]       S_AXI_RDATA,
   output wire [C_NUM_SLAVE_SLOTS*2-1:0]                          S_AXI_RRESP,
   output wire [C_NUM_SLAVE_SLOTS-1:0]                            S_AXI_RLAST,
   output wire [C_NUM_SLAVE_SLOTS*C_AXI_RUSER_WIDTH-1:0]          S_AXI_RUSER,
   output wire [C_NUM_SLAVE_SLOTS-1:0]                            S_AXI_RVALID,
   input  wire [C_NUM_SLAVE_SLOTS-1:0]                            S_AXI_RREADY,
   // Master Interface Write Address Port
   output wire [C_NUM_MASTER_SLOTS*C_AXI_ID_WIDTH-1:0]            M_AXI_AWID,
   output wire [C_NUM_MASTER_SLOTS*C_AXI_ADDR_WIDTH-1:0]          M_AXI_AWADDR,
   output wire [C_NUM_MASTER_SLOTS*8-1:0]                         M_AXI_AWLEN,
   output wire [C_NUM_MASTER_SLOTS*3-1:0]                         M_AXI_AWSIZE,
   output wire [C_NUM_MASTER_SLOTS*2-1:0]                         M_AXI_AWBURST,
   output wire [C_NUM_MASTER_SLOTS*2-1:0]                         M_AXI_AWLOCK,
   output wire [C_NUM_MASTER_SLOTS*4-1:0]                         M_AXI_AWCACHE,
   output wire [C_NUM_MASTER_SLOTS*3-1:0]                         M_AXI_AWPROT,
   output wire [C_NUM_MASTER_SLOTS*4-1:0]                         M_AXI_AWREGION,
   output wire [C_NUM_MASTER_SLOTS*4-1:0]                         M_AXI_AWQOS,
   output wire [C_NUM_MASTER_SLOTS*C_AXI_AWUSER_WIDTH-1:0]        M_AXI_AWUSER,
   output wire [C_NUM_MASTER_SLOTS-1:0]                           M_AXI_AWVALID,
   input  wire [C_NUM_MASTER_SLOTS-1:0]                           M_AXI_AWREADY,
   // Master Interface Write Data Ports
   output wire [C_NUM_MASTER_SLOTS*C_AXI_DATA_MAX_WIDTH-1:0]      M_AXI_WDATA,
   output wire [C_NUM_MASTER_SLOTS*C_AXI_DATA_MAX_WIDTH/8-1:0]    M_AXI_WSTRB,
   output wire [C_NUM_MASTER_SLOTS-1:0]                           M_AXI_WLAST,
   output wire [C_NUM_MASTER_SLOTS*C_AXI_WUSER_WIDTH-1:0]         M_AXI_WUSER,
   output wire [C_NUM_MASTER_SLOTS-1:0]                           M_AXI_WVALID,
   input  wire [C_NUM_MASTER_SLOTS-1:0]                           M_AXI_WREADY,
   // Master Interface Write Response Ports
   input  wire [C_NUM_MASTER_SLOTS*C_AXI_ID_WIDTH-1:0]            M_AXI_BID,
   input  wire [C_NUM_MASTER_SLOTS*2-1:0]                         M_AXI_BRESP,
   input  wire [C_NUM_MASTER_SLOTS*C_AXI_BUSER_WIDTH-1:0]         M_AXI_BUSER,
   input  wire [C_NUM_MASTER_SLOTS-1:0]                           M_AXI_BVALID,
   output wire [C_NUM_MASTER_SLOTS-1:0]                           M_AXI_BREADY,
   // Master Interface Read Address Port
   output wire [C_NUM_MASTER_SLOTS*C_AXI_ID_WIDTH-1:0]            M_AXI_ARID,
   output wire [C_NUM_MASTER_SLOTS*C_AXI_ADDR_WIDTH-1:0]          M_AXI_ARADDR,
   output wire [C_NUM_MASTER_SLOTS*8-1:0]                         M_AXI_ARLEN,
   output wire [C_NUM_MASTER_SLOTS*3-1:0]                         M_AXI_ARSIZE,
   output wire [C_NUM_MASTER_SLOTS*2-1:0]                         M_AXI_ARBURST,
   output wire [C_NUM_MASTER_SLOTS*2-1:0]                         M_AXI_ARLOCK,
   output wire [C_NUM_MASTER_SLOTS*4-1:0]                         M_AXI_ARCACHE,
   output wire [C_NUM_MASTER_SLOTS*3-1:0]                         M_AXI_ARPROT,
   output wire [C_NUM_MASTER_SLOTS*4-1:0]                         M_AXI_ARREGION,
   output wire [C_NUM_MASTER_SLOTS*4-1:0]                         M_AXI_ARQOS,
   output wire [C_NUM_MASTER_SLOTS*C_AXI_ARUSER_WIDTH-1:0]        M_AXI_ARUSER,
   output wire [C_NUM_MASTER_SLOTS-1:0]                           M_AXI_ARVALID,
   input  wire [C_NUM_MASTER_SLOTS-1:0]                           M_AXI_ARREADY,
   // Master Interface Read Data Ports
   input  wire [C_NUM_MASTER_SLOTS*C_AXI_ID_WIDTH-1:0]            M_AXI_RID,
   input  wire [C_NUM_MASTER_SLOTS*C_AXI_DATA_MAX_WIDTH-1:0]      M_AXI_RDATA,
   input  wire [C_NUM_MASTER_SLOTS*2-1:0]                         M_AXI_RRESP,
   input  wire [C_NUM_MASTER_SLOTS-1:0]                           M_AXI_RLAST,
   input wire [C_NUM_MASTER_SLOTS*C_AXI_RUSER_WIDTH-1:0]          M_AXI_RUSER,
   input  wire [C_NUM_MASTER_SLOTS-1:0]                           M_AXI_RVALID,
   output wire [C_NUM_MASTER_SLOTS-1:0]                           M_AXI_RREADY,
   // Diagnostic AxiLite Slave Interface
   input wire [(C_S_AXI_CTRL_ADDR_WIDTH-1):0]                     S_AXI_CTRL_AWADDR,
   input wire                                                     S_AXI_CTRL_AWVALID,
   output wire                                                    S_AXI_CTRL_AWREADY,
   input wire [(C_S_AXI_CTRL_DATA_WIDTH-1):0]                     S_AXI_CTRL_WDATA,
   input wire                                                     S_AXI_CTRL_WVALID,
   output wire                                                    S_AXI_CTRL_WREADY,
   output wire [1:0]                                              S_AXI_CTRL_BRESP,
   output wire                                                    S_AXI_CTRL_BVALID,
   input wire                                                     S_AXI_CTRL_BREADY,
   input wire [(C_S_AXI_CTRL_ADDR_WIDTH-1):0]                     S_AXI_CTRL_ARADDR,
   input wire                                                     S_AXI_CTRL_ARVALID,
   output wire                                                    S_AXI_CTRL_ARREADY,
   output wire [(C_S_AXI_CTRL_DATA_WIDTH-1):0]                    S_AXI_CTRL_RDATA,
   output wire [1:0]                                              S_AXI_CTRL_RRESP,
   output wire                                                    S_AXI_CTRL_RVALID,
   input wire                                                     S_AXI_CTRL_RREADY,
   // Diagnostic Probe Ports
   output wire [8-1:0]                                            DEBUG_AW_TRANS_SEQ,
   output wire [C_NUM_SLAVE_SLOTS*C_MAX_DEBUG_THREADS-1:0]        DEBUG_AW_TRANS_QUAL,
   output wire [C_NUM_SLAVE_SLOTS*C_MAX_DEBUG_THREADS*8-1:0]      DEBUG_AW_ACCEPT_CNT,
   output wire [C_NUM_SLAVE_SLOTS*16-1:0]                         DEBUG_AW_ACTIVE_THREAD,
   output wire [C_NUM_SLAVE_SLOTS*C_MAX_DEBUG_THREADS*8-1:0]      DEBUG_AW_ACTIVE_TARGET,
   output wire [C_NUM_SLAVE_SLOTS*C_MAX_DEBUG_THREADS*8-1:0]      DEBUG_AW_ACTIVE_REGION,
   output wire [C_NUM_SLAVE_SLOTS*8-1:0]                          DEBUG_AW_ERROR,
   output wire [C_NUM_SLAVE_SLOTS*8-1:0]                          DEBUG_AW_TARGET,
   output wire [(C_NUM_MASTER_SLOTS+1)*8-1:0]                     DEBUG_AW_ISSUING_CNT,
   output wire [8-1:0]                                            DEBUG_AW_ARB_GRANT,
   output wire [C_NUM_SLAVE_SLOTS*C_MAX_DEBUG_THREADS*8-1:0]      DEBUG_B_TRANS_SEQ,
   output wire [8-1:0]                                            DEBUG_AR_TRANS_SEQ,
   output wire [C_NUM_SLAVE_SLOTS*C_MAX_DEBUG_THREADS-1:0]        DEBUG_AR_TRANS_QUAL,
   output wire [C_NUM_SLAVE_SLOTS*C_MAX_DEBUG_THREADS*8-1:0]      DEBUG_AR_ACCEPT_CNT,
   output wire [C_NUM_SLAVE_SLOTS*16-1:0]                         DEBUG_AR_ACTIVE_THREAD,
   output wire [C_NUM_SLAVE_SLOTS*C_MAX_DEBUG_THREADS*8-1:0]      DEBUG_AR_ACTIVE_TARGET,
   output wire [C_NUM_SLAVE_SLOTS*C_MAX_DEBUG_THREADS*8-1:0]      DEBUG_AR_ACTIVE_REGION,
   output wire [C_NUM_SLAVE_SLOTS*8-1:0]                          DEBUG_AR_ERROR,
   output wire [C_NUM_SLAVE_SLOTS*8-1:0]                          DEBUG_AR_TARGET,
   output wire [(C_NUM_MASTER_SLOTS+1)*8-1:0]                     DEBUG_AR_ISSUING_CNT,
   output wire [8-1:0]                                            DEBUG_AR_ARB_GRANT,
   output wire [C_NUM_SLAVE_SLOTS*C_MAX_DEBUG_THREADS*8-1:0]      DEBUG_R_BEAT_CNT,
   output wire [C_NUM_SLAVE_SLOTS*C_MAX_DEBUG_THREADS*8-1:0]      DEBUG_R_TRANS_SEQ,
   output wire [(C_NUM_MASTER_SLOTS+1)*8-1:0]                     DEBUG_RID_TARGET,
   output wire [(C_NUM_MASTER_SLOTS+1)-1:0]                       DEBUG_RID_ERROR,
   output wire [(C_NUM_MASTER_SLOTS+1)*8-1:0]                     DEBUG_BID_TARGET,
   output wire [(C_NUM_MASTER_SLOTS+1)-1:0]                       DEBUG_BID_ERROR,
   output wire [(C_NUM_MASTER_SLOTS+1)*8-1:0]                     DEBUG_W_BEAT_CNT,
   output wire [(C_NUM_MASTER_SLOTS+1)*8-1:0]                     DEBUG_W_TRANS_SEQ
);


generate
  if (C_INTERCONNECT_CONNECTIVITY_MODE==1) begin : gen_samd
  axi_interconnect_v1_7_13_crossbar #
      (
        .C_MAX_S                          (C_MAX_S),
        .C_MAX_M                          (C_MAX_M),
        .C_NUM_ADDR_RANGES                (C_NUM_ADDR_RANGES),
        .C_FAMILY                         (C_FAMILY),
        .C_NUM_SLAVE_SLOTS                (C_NUM_SLAVE_SLOTS),
        .C_NUM_MASTER_SLOTS               (C_NUM_MASTER_SLOTS),
        .C_AXI_ID_WIDTH                   (C_AXI_ID_WIDTH),
        .C_S_AXI_THREAD_ID_WIDTH          (C_S_AXI_THREAD_ID_WIDTH),
        .C_AXI_ADDR_WIDTH                 (C_AXI_ADDR_WIDTH),
        .C_INTERCONNECT_DATA_WIDTH        (C_INTERCONNECT_DATA_WIDTH),
        .C_AXI_DATA_MAX_WIDTH             (C_AXI_DATA_MAX_WIDTH),
        .C_M_AXI_DATA_WIDTH               (C_M_AXI_DATA_WIDTH),  // Used to determine whether W-channel gets reg-slice
        .C_S_AXI_PROTOCOL                 (C_S_AXI_PROTOCOL),
        .C_M_AXI_PROTOCOL                 (C_M_AXI_PROTOCOL),
        .C_M_AXI_BASE_ADDR                (C_M_AXI_BASE_ADDR),
        .C_M_AXI_HIGH_ADDR                (C_M_AXI_HIGH_ADDR),
        .C_S_AXI_BASE_ID                  (C_S_AXI_BASE_ID),
        .C_S_AXI_HIGH_ID                  (C_S_AXI_HIGH_ID),
        .C_S_AXI_IS_INTERCONNECT          (C_S_AXI_IS_INTERCONNECT),
        .C_S_AXI_SUPPORTS_WRITE           (C_S_AXI_SUPPORTS_WRITE),
        .C_S_AXI_SUPPORTS_READ            (C_S_AXI_SUPPORTS_READ),
        .C_M_AXI_SUPPORTS_WRITE           (C_M_AXI_SUPPORTS_WRITE),
        .C_M_AXI_SUPPORTS_READ            (C_M_AXI_SUPPORTS_READ),
        .C_AXI_SUPPORTS_USER_SIGNALS      (C_AXI_SUPPORTS_USER_SIGNALS),
        .C_AXI_AWUSER_WIDTH               (C_AXI_AWUSER_WIDTH),
        .C_AXI_ARUSER_WIDTH               (C_AXI_ARUSER_WIDTH),
        .C_AXI_WUSER_WIDTH                (C_AXI_WUSER_WIDTH),
        .C_AXI_RUSER_WIDTH                (C_AXI_RUSER_WIDTH),
        .C_AXI_BUSER_WIDTH                (C_AXI_BUSER_WIDTH),
        .C_AXI_CONNECTIVITY               (C_AXI_CONNECTIVITY),
        .C_S_AXI_SINGLE_THREAD            (C_S_AXI_SINGLE_THREAD),
        .C_M_AXI_SUPPORTS_REORDERING      (C_M_AXI_SUPPORTS_REORDERING),
        .C_S_AXI_WRITE_ACCEPTANCE         (C_S_AXI_WRITE_ACCEPTANCE),
        .C_S_AXI_READ_ACCEPTANCE          (C_S_AXI_READ_ACCEPTANCE),
        .C_M_AXI_WRITE_ISSUING            (C_M_AXI_WRITE_ISSUING),
        .C_M_AXI_READ_ISSUING             (C_M_AXI_READ_ISSUING),
    //    .C_S_AXI_ARB_METHOD               (C_S_AXI_ARB_METHOD), // Reserved for future
        .C_S_AXI_ARB_PRIORITY             (C_S_AXI_ARB_PRIORITY),
    //    .C_S_AXI_ARB_TDM_SLOTS            (C_S_AXI_ARB_TDM_SLOTS), // Reserved for future
    //    .C_S_AXI_ARB_TDM_TOTAL            (C_S_AXI_ARB_TDM_TOTAL), // Reserved for future
        .C_M_AXI_SECURE                   (C_M_AXI_SECURE),
        .C_USE_CTRL_PORT                  (C_USE_CTRL_PORT),
        .C_USE_INTERRUPT                  (C_USE_INTERRUPT),
        .C_RANGE_CHECK                    (C_RANGE_CHECK),
        .C_ADDR_DECODE                    (C_ADDR_DECODE),
        .C_S_AXI_CTRL_ADDR_WIDTH          (C_S_AXI_CTRL_ADDR_WIDTH),
        .C_S_AXI_CTRL_DATA_WIDTH          (C_S_AXI_CTRL_DATA_WIDTH),
        .C_W_ISSUE_WIDTH                  (C_W_ISSUE_WIDTH ),
        .C_R_ISSUE_WIDTH                  (C_R_ISSUE_WIDTH ),
        .C_W_ACCEPT_WIDTH                 (C_W_ACCEPT_WIDTH),
        .C_R_ACCEPT_WIDTH                 (C_R_ACCEPT_WIDTH),
        .C_DEBUG                          (C_DEBUG),
        .C_MAX_DEBUG_THREADS              (C_MAX_DEBUG_THREADS)
      )
      crossbar_samd 
      (
        .INTERCONNECT_ACLK                (INTERCONNECT_ACLK),
        .ARESETN                          (ARESETN),
        .IRQ                              (IRQ),
        .S_AXI_AWID                       (S_AXI_AWID             ),
        .S_AXI_AWADDR                     (S_AXI_AWADDR           ),
        .S_AXI_AWLEN                      (S_AXI_AWLEN            ),
        .S_AXI_AWSIZE                     (S_AXI_AWSIZE           ),
        .S_AXI_AWBURST                    (S_AXI_AWBURST          ),
        .S_AXI_AWLOCK                     (S_AXI_AWLOCK           ),
        .S_AXI_AWCACHE                    (S_AXI_AWCACHE          ),
        .S_AXI_AWPROT                     (S_AXI_AWPROT           ),
        .S_AXI_AWQOS                      (S_AXI_AWQOS            ),
        .S_AXI_AWUSER                     (S_AXI_AWUSER           ),
        .S_AXI_AWVALID                    (S_AXI_AWVALID          ),
        .S_AXI_AWREADY                    (S_AXI_AWREADY          ),
        .S_AXI_WDATA                      (S_AXI_WDATA            ),
        .S_AXI_WSTRB                      (S_AXI_WSTRB            ),
        .S_AXI_WLAST                      (S_AXI_WLAST            ),
        .S_AXI_WUSER                      (S_AXI_WUSER            ),
        .S_AXI_WVALID                     (S_AXI_WVALID           ),
        .S_AXI_WREADY                     (S_AXI_WREADY           ),
        .S_AXI_BID                        (S_AXI_BID              ),
        .S_AXI_BRESP                      (S_AXI_BRESP            ),
        .S_AXI_BUSER                      (S_AXI_BUSER            ),
        .S_AXI_BVALID                     (S_AXI_BVALID           ),
        .S_AXI_BREADY                     (S_AXI_BREADY           ),
        .S_AXI_ARID                       (S_AXI_ARID             ),
        .S_AXI_ARADDR                     (S_AXI_ARADDR           ),
        .S_AXI_ARLEN                      (S_AXI_ARLEN            ),
        .S_AXI_ARSIZE                     (S_AXI_ARSIZE           ),
        .S_AXI_ARBURST                    (S_AXI_ARBURST          ),
        .S_AXI_ARLOCK                     (S_AXI_ARLOCK           ),
        .S_AXI_ARCACHE                    (S_AXI_ARCACHE          ),
        .S_AXI_ARPROT                     (S_AXI_ARPROT           ),
        .S_AXI_ARQOS                      (S_AXI_ARQOS            ),
        .S_AXI_ARUSER                     (S_AXI_ARUSER           ),
        .S_AXI_ARVALID                    (S_AXI_ARVALID          ),
        .S_AXI_ARREADY                    (S_AXI_ARREADY          ),
        .S_AXI_RID                        (S_AXI_RID              ),
        .S_AXI_RDATA                      (S_AXI_RDATA            ),
        .S_AXI_RRESP                      (S_AXI_RRESP            ),
        .S_AXI_RLAST                      (S_AXI_RLAST            ),
        .S_AXI_RUSER                      (S_AXI_RUSER            ),
        .S_AXI_RVALID                     (S_AXI_RVALID           ),
        .S_AXI_RREADY                     (S_AXI_RREADY           ),
        .M_AXI_AWID                       (M_AXI_AWID             ),
        .M_AXI_AWADDR                     (M_AXI_AWADDR           ),
        .M_AXI_AWLEN                      (M_AXI_AWLEN            ),
        .M_AXI_AWSIZE                     (M_AXI_AWSIZE           ),
        .M_AXI_AWBURST                    (M_AXI_AWBURST          ),
        .M_AXI_AWLOCK                     (M_AXI_AWLOCK           ),
        .M_AXI_AWCACHE                    (M_AXI_AWCACHE          ),
        .M_AXI_AWPROT                     (M_AXI_AWPROT           ),
        .M_AXI_AWREGION                   (M_AXI_AWREGION         ),
        .M_AXI_AWQOS                      (M_AXI_AWQOS            ),
        .M_AXI_AWUSER                     (M_AXI_AWUSER           ),
        .M_AXI_AWVALID                    (M_AXI_AWVALID          ),
        .M_AXI_AWREADY                    (M_AXI_AWREADY          ),
        .M_AXI_WDATA                      (M_AXI_WDATA            ),
        .M_AXI_WSTRB                      (M_AXI_WSTRB            ),
        .M_AXI_WLAST                      (M_AXI_WLAST            ),
        .M_AXI_WUSER                      (M_AXI_WUSER            ),
        .M_AXI_WVALID                     (M_AXI_WVALID           ),
        .M_AXI_WREADY                     (M_AXI_WREADY           ),
        .M_AXI_BID                        (M_AXI_BID              ),
        .M_AXI_BRESP                      (M_AXI_BRESP            ),
        .M_AXI_BUSER                      (M_AXI_BUSER            ),
        .M_AXI_BVALID                     (M_AXI_BVALID           ),
        .M_AXI_BREADY                     (M_AXI_BREADY           ),
        .M_AXI_ARID                       (M_AXI_ARID             ),
        .M_AXI_ARADDR                     (M_AXI_ARADDR           ),
        .M_AXI_ARLEN                      (M_AXI_ARLEN            ),
        .M_AXI_ARSIZE                     (M_AXI_ARSIZE           ),
        .M_AXI_ARBURST                    (M_AXI_ARBURST          ),
        .M_AXI_ARLOCK                     (M_AXI_ARLOCK           ),
        .M_AXI_ARCACHE                    (M_AXI_ARCACHE          ),
        .M_AXI_ARPROT                     (M_AXI_ARPROT           ),
        .M_AXI_ARREGION                   (M_AXI_ARREGION         ),
        .M_AXI_ARQOS                      (M_AXI_ARQOS            ),
        .M_AXI_ARUSER                     (M_AXI_ARUSER           ),
        .M_AXI_ARVALID                    (M_AXI_ARVALID          ),
        .M_AXI_ARREADY                    (M_AXI_ARREADY          ),
        .M_AXI_RID                        (M_AXI_RID              ),
        .M_AXI_RDATA                      (M_AXI_RDATA            ),
        .M_AXI_RRESP                      (M_AXI_RRESP            ),
        .M_AXI_RLAST                      (M_AXI_RLAST            ),
        .M_AXI_RUSER                      (M_AXI_RUSER            ),
        .M_AXI_RVALID                     (M_AXI_RVALID           ),
        .M_AXI_RREADY                     (M_AXI_RREADY           ),
        .S_AXI_CTRL_AWADDR                (S_AXI_CTRL_AWADDR      ),
        .S_AXI_CTRL_AWVALID               (S_AXI_CTRL_AWVALID     ),
        .S_AXI_CTRL_AWREADY               (S_AXI_CTRL_AWREADY     ),
        .S_AXI_CTRL_WDATA                 (S_AXI_CTRL_WDATA       ),
        .S_AXI_CTRL_WVALID                (S_AXI_CTRL_WVALID      ),
        .S_AXI_CTRL_WREADY                (S_AXI_CTRL_WREADY      ),
        .S_AXI_CTRL_BRESP                 (S_AXI_CTRL_BRESP       ),
        .S_AXI_CTRL_BVALID                (S_AXI_CTRL_BVALID      ),
        .S_AXI_CTRL_BREADY                (S_AXI_CTRL_BREADY      ),
        .S_AXI_CTRL_ARADDR                (S_AXI_CTRL_ARADDR      ),
        .S_AXI_CTRL_ARVALID               (S_AXI_CTRL_ARVALID     ),
        .S_AXI_CTRL_ARREADY               (S_AXI_CTRL_ARREADY     ),
        .S_AXI_CTRL_RDATA                 (S_AXI_CTRL_RDATA       ),
        .S_AXI_CTRL_RRESP                 (S_AXI_CTRL_RRESP       ),
        .S_AXI_CTRL_RVALID                (S_AXI_CTRL_RVALID      ),
        .S_AXI_CTRL_RREADY                (S_AXI_CTRL_RREADY      ),
        .DEBUG_AW_TRANS_SEQ               (DEBUG_AW_TRANS_SEQ     ),
        .DEBUG_AW_TRANS_QUAL              (DEBUG_AW_TRANS_QUAL    ),
        .DEBUG_AW_ACCEPT_CNT              (DEBUG_AW_ACCEPT_CNT    ),
        .DEBUG_AW_ACTIVE_THREAD           (DEBUG_AW_ACTIVE_THREAD ),
        .DEBUG_AW_ACTIVE_TARGET           (DEBUG_AW_ACTIVE_TARGET ),
        .DEBUG_AW_ACTIVE_REGION           (DEBUG_AW_ACTIVE_REGION ),
        .DEBUG_AW_ERROR                   (DEBUG_AW_ERROR         ),
        .DEBUG_AW_TARGET                  (DEBUG_AW_TARGET        ),
        .DEBUG_AW_ISSUING_CNT             (DEBUG_AW_ISSUING_CNT   ),
        .DEBUG_AW_ARB_GRANT               (DEBUG_AW_ARB_GRANT     ),
        .DEBUG_B_TRANS_SEQ                (DEBUG_B_TRANS_SEQ      ),
        .DEBUG_AR_TRANS_SEQ               (DEBUG_AR_TRANS_SEQ     ),
        .DEBUG_AR_TRANS_QUAL              (DEBUG_AR_TRANS_QUAL    ),
        .DEBUG_AR_ACCEPT_CNT              (DEBUG_AR_ACCEPT_CNT    ),
        .DEBUG_AR_ACTIVE_THREAD           (DEBUG_AR_ACTIVE_THREAD ),
        .DEBUG_AR_ACTIVE_TARGET           (DEBUG_AR_ACTIVE_TARGET ),
        .DEBUG_AR_ACTIVE_REGION           (DEBUG_AR_ACTIVE_REGION ),
        .DEBUG_AR_ERROR                   (DEBUG_AR_ERROR         ),
        .DEBUG_AR_TARGET                  (DEBUG_AR_TARGET        ),
        .DEBUG_AR_ISSUING_CNT             (DEBUG_AR_ISSUING_CNT   ),
        .DEBUG_AR_ARB_GRANT               (DEBUG_AR_ARB_GRANT     ),
        .DEBUG_R_BEAT_CNT                 (DEBUG_R_BEAT_CNT       ),
        .DEBUG_R_TRANS_SEQ                (DEBUG_R_TRANS_SEQ      ),
        .DEBUG_RID_TARGET                 (DEBUG_RID_TARGET       ),
        .DEBUG_RID_ERROR                  (DEBUG_RID_ERROR        ),
        .DEBUG_BID_TARGET                 (DEBUG_BID_TARGET       ),
        .DEBUG_BID_ERROR                  (DEBUG_BID_ERROR        ),
        .DEBUG_W_BEAT_CNT                 (DEBUG_W_BEAT_CNT       ),
        .DEBUG_W_TRANS_SEQ                (DEBUG_W_TRANS_SEQ      )
      );
  end else begin : gen_sasd
  axi_interconnect_v1_7_13_crossbar_sasd #
      (
        .C_MAX_S                          (C_MAX_S),
        .C_MAX_M                          (C_MAX_M),
        .C_NUM_ADDR_RANGES                (C_NUM_ADDR_RANGES),
        .C_FAMILY                         (C_FAMILY),
        .C_NUM_SLAVE_SLOTS                (C_NUM_SLAVE_SLOTS),
        .C_NUM_MASTER_SLOTS               (C_NUM_MASTER_SLOTS),
        .C_AXI_ID_WIDTH                   (C_AXI_ID_WIDTH),
        .C_AXI_ADDR_WIDTH                 (C_AXI_ADDR_WIDTH),
        .C_INTERCONNECT_DATA_WIDTH        (C_INTERCONNECT_DATA_WIDTH),
        .C_AXI_DATA_MAX_WIDTH             (C_AXI_DATA_MAX_WIDTH),
        .C_S_AXI_PROTOCOL                 (C_S_AXI_PROTOCOL),
        .C_M_AXI_PROTOCOL                 (C_M_AXI_PROTOCOL),
        .C_M_AXI_BASE_ADDR                (C_M_AXI_BASE_ADDR),
        .C_M_AXI_HIGH_ADDR                (C_M_AXI_HIGH_ADDR),
        .C_S_AXI_BASE_ID                  (C_S_AXI_BASE_ID),
        .C_S_AXI_HIGH_ID                  (C_S_AXI_HIGH_ID),
        .C_S_AXI_SUPPORTS_WRITE           (C_S_AXI_SUPPORTS_WRITE),
        .C_S_AXI_SUPPORTS_READ            (C_S_AXI_SUPPORTS_READ),
        .C_M_AXI_SUPPORTS_WRITE           (C_M_AXI_SUPPORTS_WRITE),
        .C_M_AXI_SUPPORTS_READ            (C_M_AXI_SUPPORTS_READ),
        .C_AXI_SUPPORTS_USER_SIGNALS      (C_AXI_SUPPORTS_USER_SIGNALS),
        .C_AXI_AWUSER_WIDTH               (C_AXI_AWUSER_WIDTH),
        .C_AXI_ARUSER_WIDTH               (C_AXI_ARUSER_WIDTH),
        .C_AXI_WUSER_WIDTH                (C_AXI_WUSER_WIDTH),
        .C_AXI_RUSER_WIDTH                (C_AXI_RUSER_WIDTH),
        .C_AXI_BUSER_WIDTH                (C_AXI_BUSER_WIDTH),
    //    .C_S_AXI_ARB_METHOD               (C_S_AXI_ARB_METHOD), // Reserved for future
        .C_S_AXI_ARB_PRIORITY             (C_S_AXI_ARB_PRIORITY),
    //    .C_S_AXI_ARB_TDM_SLOTS            (C_S_AXI_ARB_TDM_SLOTS), // Reserved for future
    //    .C_S_AXI_ARB_TDM_TOTAL            (C_S_AXI_ARB_TDM_TOTAL), // Reserved for future
        .C_M_AXI_SECURE                   (C_M_AXI_SECURE),
        .C_INTERCONNECT_R_REGISTER        (C_INTERCONNECT_R_REGISTER),
        .C_USE_CTRL_PORT                  (C_USE_CTRL_PORT),
        .C_USE_INTERRUPT                  (C_USE_INTERRUPT),
        .C_RANGE_CHECK                    (C_RANGE_CHECK),
        .C_ADDR_DECODE                    (C_ADDR_DECODE),
        .C_S_AXI_CTRL_ADDR_WIDTH          (C_S_AXI_CTRL_ADDR_WIDTH),
        .C_S_AXI_CTRL_DATA_WIDTH          (C_S_AXI_CTRL_DATA_WIDTH),
        .C_DEBUG                          (C_DEBUG),
        .C_MAX_DEBUG_THREADS              (C_MAX_DEBUG_THREADS)
      )
      crossbar_sasd_0
      (
        .INTERCONNECT_ACLK                (INTERCONNECT_ACLK),
        .ARESETN                          (ARESETN),
        .IRQ                              (IRQ),
        .S_AXI_AWID                       (S_AXI_AWID           ),
        .S_AXI_AWADDR                     (S_AXI_AWADDR         ),
        .S_AXI_AWLEN                      (S_AXI_AWLEN          ),
        .S_AXI_AWSIZE                     (S_AXI_AWSIZE         ),
        .S_AXI_AWBURST                    (S_AXI_AWBURST        ),
        .S_AXI_AWLOCK                     (S_AXI_AWLOCK         ),
        .S_AXI_AWCACHE                    (S_AXI_AWCACHE        ),
        .S_AXI_AWPROT                     (S_AXI_AWPROT         ),
        .S_AXI_AWQOS                      (S_AXI_AWQOS          ),
        .S_AXI_AWUSER                     (S_AXI_AWUSER         ),
        .S_AXI_AWVALID                    (S_AXI_AWVALID        ),
        .S_AXI_AWREADY                    (S_AXI_AWREADY        ),
        .S_AXI_WDATA                      (S_AXI_WDATA          ),
        .S_AXI_WSTRB                      (S_AXI_WSTRB          ),
        .S_AXI_WLAST                      (S_AXI_WLAST          ),
        .S_AXI_WUSER                      (S_AXI_WUSER          ),
        .S_AXI_WVALID                     (S_AXI_WVALID         ),
        .S_AXI_WREADY                     (S_AXI_WREADY         ),
        .S_AXI_BID                        (S_AXI_BID            ),
        .S_AXI_BRESP                      (S_AXI_BRESP          ),
        .S_AXI_BUSER                      (S_AXI_BUSER          ),
        .S_AXI_BVALID                     (S_AXI_BVALID         ),
        .S_AXI_BREADY                     (S_AXI_BREADY         ),
        .S_AXI_ARID                       (S_AXI_ARID           ),
        .S_AXI_ARADDR                     (S_AXI_ARADDR         ),
        .S_AXI_ARLEN                      (S_AXI_ARLEN          ),
        .S_AXI_ARSIZE                     (S_AXI_ARSIZE         ),
        .S_AXI_ARBURST                    (S_AXI_ARBURST        ),
        .S_AXI_ARLOCK                     (S_AXI_ARLOCK         ),
        .S_AXI_ARCACHE                    (S_AXI_ARCACHE        ),
        .S_AXI_ARPROT                     (S_AXI_ARPROT         ),
        .S_AXI_ARQOS                      (S_AXI_ARQOS          ),
        .S_AXI_ARUSER                     (S_AXI_ARUSER         ),
        .S_AXI_ARVALID                    (S_AXI_ARVALID        ),
        .S_AXI_ARREADY                    (S_AXI_ARREADY        ),
        .S_AXI_RID                        (S_AXI_RID            ),
        .S_AXI_RDATA                      (S_AXI_RDATA          ),
        .S_AXI_RRESP                      (S_AXI_RRESP          ),
        .S_AXI_RLAST                      (S_AXI_RLAST          ),
        .S_AXI_RUSER                      (S_AXI_RUSER          ),
        .S_AXI_RVALID                     (S_AXI_RVALID         ),
        .S_AXI_RREADY                     (S_AXI_RREADY         ),
        .M_AXI_AWID                       (M_AXI_AWID           ),
        .M_AXI_AWADDR                     (M_AXI_AWADDR         ),
        .M_AXI_AWLEN                      (M_AXI_AWLEN          ),
        .M_AXI_AWSIZE                     (M_AXI_AWSIZE         ),
        .M_AXI_AWBURST                    (M_AXI_AWBURST        ),
        .M_AXI_AWLOCK                     (M_AXI_AWLOCK         ),
        .M_AXI_AWCACHE                    (M_AXI_AWCACHE        ),
        .M_AXI_AWPROT                     (M_AXI_AWPROT         ),
        .M_AXI_AWREGION                   (M_AXI_AWREGION       ),
        .M_AXI_AWQOS                      (M_AXI_AWQOS          ),
        .M_AXI_AWUSER                     (M_AXI_AWUSER         ),
        .M_AXI_AWVALID                    (M_AXI_AWVALID        ),
        .M_AXI_AWREADY                    (M_AXI_AWREADY        ),
        .M_AXI_WDATA                      (M_AXI_WDATA          ),
        .M_AXI_WSTRB                      (M_AXI_WSTRB          ),
        .M_AXI_WLAST                      (M_AXI_WLAST          ),
        .M_AXI_WUSER                      (M_AXI_WUSER          ),
        .M_AXI_WVALID                     (M_AXI_WVALID         ),
        .M_AXI_WREADY                     (M_AXI_WREADY         ),
        .M_AXI_BID                        (M_AXI_BID            ),
        .M_AXI_BRESP                      (M_AXI_BRESP          ),
        .M_AXI_BUSER                      (M_AXI_BUSER          ),
        .M_AXI_BVALID                     (M_AXI_BVALID         ),
        .M_AXI_BREADY                     (M_AXI_BREADY         ),
        .M_AXI_ARID                       (M_AXI_ARID           ),
        .M_AXI_ARADDR                     (M_AXI_ARADDR         ),
        .M_AXI_ARLEN                      (M_AXI_ARLEN          ),
        .M_AXI_ARSIZE                     (M_AXI_ARSIZE         ),
        .M_AXI_ARBURST                    (M_AXI_ARBURST        ),
        .M_AXI_ARLOCK                     (M_AXI_ARLOCK         ),
        .M_AXI_ARCACHE                    (M_AXI_ARCACHE        ),
        .M_AXI_ARPROT                     (M_AXI_ARPROT         ),
        .M_AXI_ARREGION                   (M_AXI_ARREGION       ),
        .M_AXI_ARQOS                      (M_AXI_ARQOS          ),
        .M_AXI_ARUSER                     (M_AXI_ARUSER         ),
        .M_AXI_ARVALID                    (M_AXI_ARVALID        ),
        .M_AXI_ARREADY                    (M_AXI_ARREADY        ),
        .M_AXI_RID                        (M_AXI_RID            ),
        .M_AXI_RDATA                      (M_AXI_RDATA          ),
        .M_AXI_RRESP                      (M_AXI_RRESP          ),
        .M_AXI_RLAST                      (M_AXI_RLAST          ),
        .M_AXI_RUSER                      (M_AXI_RUSER          ),
        .M_AXI_RVALID                     (M_AXI_RVALID         ),
        .M_AXI_RREADY                     (M_AXI_RREADY         ),
        .S_AXI_CTRL_AWADDR                (S_AXI_CTRL_AWADDR    ),
        .S_AXI_CTRL_AWVALID               (S_AXI_CTRL_AWVALID   ),
        .S_AXI_CTRL_AWREADY               (S_AXI_CTRL_AWREADY   ),
        .S_AXI_CTRL_WDATA                 (S_AXI_CTRL_WDATA     ),
        .S_AXI_CTRL_WVALID                (S_AXI_CTRL_WVALID    ),
        .S_AXI_CTRL_WREADY                (S_AXI_CTRL_WREADY    ),
        .S_AXI_CTRL_BRESP                 (S_AXI_CTRL_BRESP     ),
        .S_AXI_CTRL_BVALID                (S_AXI_CTRL_BVALID    ),
        .S_AXI_CTRL_BREADY                (S_AXI_CTRL_BREADY    ),
        .S_AXI_CTRL_ARADDR                (S_AXI_CTRL_ARADDR    ),
        .S_AXI_CTRL_ARVALID               (S_AXI_CTRL_ARVALID   ),
        .S_AXI_CTRL_ARREADY               (S_AXI_CTRL_ARREADY   ),
        .S_AXI_CTRL_RDATA                 (S_AXI_CTRL_RDATA     ),
        .S_AXI_CTRL_RRESP                 (S_AXI_CTRL_RRESP     ),
        .S_AXI_CTRL_RVALID                (S_AXI_CTRL_RVALID    ),
        .S_AXI_CTRL_RREADY                (S_AXI_CTRL_RREADY    ),
        .DEBUG_AW_TRANS_SEQ               (DEBUG_AW_TRANS_SEQ   ),
        .DEBUG_AW_ERROR                   (DEBUG_AW_ERROR       ),
        .DEBUG_AW_TARGET                  (DEBUG_AW_TARGET      ),
        .DEBUG_AW_ARB_GRANT               (DEBUG_AW_ARB_GRANT   ),
        .DEBUG_AR_TRANS_SEQ               (DEBUG_AR_TRANS_SEQ   ),
        .DEBUG_AR_ERROR                   (DEBUG_AR_ERROR       ),
        .DEBUG_AR_TARGET                  (DEBUG_AR_TARGET      ),
        .DEBUG_AR_ARB_GRANT               (DEBUG_AR_ARB_GRANT   ),
        .DEBUG_R_BEAT_CNT                 (DEBUG_R_BEAT_CNT     ),
        .DEBUG_W_BEAT_CNT                 (DEBUG_W_BEAT_CNT     )
      );
    assign DEBUG_AW_TRANS_QUAL     = 0;
    assign DEBUG_AW_ACCEPT_CNT     = 0;
    assign DEBUG_AW_ACTIVE_THREAD  = 0;
    assign DEBUG_AW_ACTIVE_TARGET  = 0;
    assign DEBUG_AW_ACTIVE_REGION  = 0;
    assign DEBUG_AW_ISSUING_CNT    = 0;
    assign DEBUG_AR_TRANS_QUAL     = 0;
    assign DEBUG_AR_ACCEPT_CNT     = 0;
    assign DEBUG_AR_ACTIVE_THREAD  = 0;
    assign DEBUG_AR_ACTIVE_TARGET  = 0;
    assign DEBUG_AR_ACTIVE_REGION  = 0;
    assign DEBUG_AR_ISSUING_CNT    = 0;
    assign DEBUG_B_TRANS_SEQ       = 0;
    assign DEBUG_R_TRANS_SEQ       = 0;
    assign DEBUG_W_TRANS_SEQ       = 0;
    assign DEBUG_RID_TARGET        = 0;
    assign DEBUG_RID_ERROR         = 0;
    assign DEBUG_BID_TARGET        = 0;
    assign DEBUG_BID_ERROR         = 0;
  end
endgenerate

endmodule

`default_nettype wire



// -- (c) Copyright 2008 - 2011 Xilinx, Inc. All rights reserved.
// --
// -- This file contains confidential and proprietary information
// -- of Xilinx, Inc. and is protected under U.S. and 
// -- international copyright and other intellectual property
// -- laws.
// --
// -- DISCLAIMER
// -- This disclaimer is not a license and does not grant any
// -- rights to the materials distributed herewith. Except as
// -- otherwise provided in a valid license issued to you by
// -- Xilinx, and to the maximum extent permitted by applicable
// -- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
// -- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
// -- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
// -- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
// -- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
// -- (2) Xilinx shall not be liable (whether in contract or tort,
// -- including negligence, or under any other theory of
// -- liability) for any loss or damage of any kind or nature
// -- related to, arising under or in connection with these
// -- materials, including for any direct, or any indirect,
// -- special, incidental, or consequential loss or damage
// -- (including loss of data, profits, goodwill, or any type of
// -- loss or damage suffered as a result of any action brought
// -- by a third party) even if such damage or loss was
// -- reasonably foreseeable or Xilinx had been advised of the
// -- possibility of the same.
// --
// -- CRITICAL APPLICATIONS
// -- Xilinx products are not designed or intended to be fail-
// -- safe, or for use in any application requiring fail-safe
// -- performance, such as life-support or safety devices or
// -- systems, Class III medical devices, nuclear facilities,
// -- applications related to the deployment of airbags, or any
// -- other applications that could lead to death, personal
// -- injury, or severe property or environmental damage
// -- (individually and collectively, "Critical
// -- Applications"). Customer assumes the sole risk and
// -- liability of any use of Xilinx products in Critical
// -- Applications, subject only to applicable laws and
// -- regulations governing limitations on product liability.
// --
// -- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
// -- PART OF THIS FILE AT ALL TIMES.
//-----------------------------------------------------------------------------
//
// Description: N-deep SRL pipeline element with generic single-channel AXI interfaces.
// Verilog-standard:  Verilog 2001
//--------------------------------------------------------------------------
// Structure:
//   axic_srl_fifo
//     ndeep_srl
//       nto1_mux
//--------------------------------------------------------------------------

`timescale 1ps/1ps
`default_nettype none

(* DowngradeIPIdentifiedWarnings="yes" *) 
module axi_interconnect_v1_7_13_axic_srl_fifo #
  (
   parameter         C_FAMILY   = "none", // FPGA Family
   parameter integer C_FIFO_WIDTH  = 1, // Width of S_MESG/M_MESG.
   parameter integer C_MAX_CTRL_FANOUT = 33, // Maximum number of mesg bits
                                             // the control logic can be used
                                             // on before the control logic
                                             // needs to be replicated.
   parameter integer C_FIFO_DEPTH_LOG =  2,  // Depth of FIFO is 2**C_FIFO_DEPTH_LOG.  
                                             // The minimum size fifo generated is 4-deep.
   parameter         C_USE_FULL =  1         // Prevent overwrite by throttling S_READY.                                              
   )
  (
   input  wire                        ACLK,    // Clock
   input  wire                        ARESET,  // Reset
   input  wire [C_FIFO_WIDTH-1:0]     S_MESG,  // Input data
   input  wire                        S_VALID, // Input data valid
   output wire                        S_READY, // Input data ready
   output wire [C_FIFO_WIDTH-1:0]     M_MESG,  // Output data
   output wire                        M_VALID, // Output data valid
   input  wire                        M_READY  // Output data ready
   );
  
  localparam P_FIFO_DEPTH_LOG = (C_FIFO_DEPTH_LOG>1) ? C_FIFO_DEPTH_LOG : 2;
  localparam P_EMPTY       = {P_FIFO_DEPTH_LOG{1'b1}};
  localparam P_ALMOSTEMPTY = {P_FIFO_DEPTH_LOG{1'b0}};
  localparam P_ALMOSTFULL_TEMP  = {P_EMPTY, 1'b0};
  localparam P_ALMOSTFULL  = P_ALMOSTFULL_TEMP[0+:P_FIFO_DEPTH_LOG];
  localparam P_NUM_REPS    = (((C_FIFO_WIDTH+1)%C_MAX_CTRL_FANOUT) == 0) ?
                             (C_FIFO_WIDTH+1)/C_MAX_CTRL_FANOUT :
                             ((C_FIFO_WIDTH+1)/C_MAX_CTRL_FANOUT)+1;

  (* syn_keep = "1" *) reg [P_NUM_REPS*P_FIFO_DEPTH_LOG-1:0]  fifoaddr;
  (* syn_keep = "1" *) wire [P_NUM_REPS*P_FIFO_DEPTH_LOG-1:0] fifoaddr_i;

  genvar i;
  genvar j;

  reg  M_VALID_i;
  reg  S_READY_i;
  wire push;     // FIFO push
  wire pop;      // FIFO pop
  reg  areset_d1; // Reset delay register
  wire [C_FIFO_WIDTH-1:0] m_axi_mesg_i; // Intermediate SRL data

  assign M_VALID = M_VALID_i;
  assign S_READY = C_USE_FULL ? S_READY_i : 1'b1;
  assign M_MESG = m_axi_mesg_i;
  assign push = S_VALID & (C_USE_FULL ? S_READY_i : 1'b1);
  assign pop  = M_VALID_i & M_READY;
  
  always @(posedge ACLK) begin
    areset_d1 <= ARESET;
  end
      
  generate
    //---------------------------------------------------------------------------
    // Create count of number of elements in FIFOs
    //---------------------------------------------------------------------------
    for (i=0;i<P_NUM_REPS;i=i+1) begin : gen_rep
      assign fifoaddr_i[P_FIFO_DEPTH_LOG*(i+1)-1:P_FIFO_DEPTH_LOG*i] = 
         push ? fifoaddr[P_FIFO_DEPTH_LOG*(i+1)-1:P_FIFO_DEPTH_LOG*i] + 1 :
                fifoaddr[P_FIFO_DEPTH_LOG*(i+1)-1:P_FIFO_DEPTH_LOG*i] - 1;
      always @(posedge ACLK) begin
        if (ARESET)
          fifoaddr[P_FIFO_DEPTH_LOG*(i+1)-1:P_FIFO_DEPTH_LOG*i] <= 
                {P_FIFO_DEPTH_LOG{1'b1}};
        else if (push ^ pop)
          fifoaddr[P_FIFO_DEPTH_LOG*(i+1)-1:P_FIFO_DEPTH_LOG*i] <= 
                fifoaddr_i[P_FIFO_DEPTH_LOG*(i+1)-1:P_FIFO_DEPTH_LOG*i];
      end
    end

    //---------------------------------------------------------------------------
    // When FIFO is empty, reset master valid bit.  When not empty set valid bit.
    // When FIFO is full,  reset slave  ready bit.  When not full  set ready bit.
    //---------------------------------------------------------------------------
    
    always @(posedge ACLK) begin
      if (ARESET) begin
        M_VALID_i <= 1'b0;
      end else if ((fifoaddr[P_FIFO_DEPTH_LOG*P_NUM_REPS-1:P_FIFO_DEPTH_LOG*(P_NUM_REPS-1)] == 
                               P_ALMOSTEMPTY) && pop && ~push) begin
        M_VALID_i <= 1'b0;
      end else if (push) begin
        M_VALID_i <= 1'b1;
      end
    end
      
    always @(posedge ACLK) begin
      if (ARESET) begin
        S_READY_i <= 1'b0;
      end else if (areset_d1) begin
        S_READY_i <= 1'b1;
      end else if (C_USE_FULL && 
        ((fifoaddr[P_FIFO_DEPTH_LOG*P_NUM_REPS-1:P_FIFO_DEPTH_LOG*(P_NUM_REPS-1)] == 
         P_ALMOSTFULL) && push && ~pop)) begin
        S_READY_i <= 1'b0;
      end else if (C_USE_FULL && pop) begin
        S_READY_i <= 1'b1;
      end
    end

    //---------------------------------------------------------------------------
    // Instantiate SRLs
    //---------------------------------------------------------------------------
    for (i=0;i<(C_FIFO_WIDTH/C_MAX_CTRL_FANOUT)+((C_FIFO_WIDTH%C_MAX_CTRL_FANOUT)>0);i=i+1) begin : gen_srls
      for (j=0;((j<C_MAX_CTRL_FANOUT)&&(i*C_MAX_CTRL_FANOUT+j<C_FIFO_WIDTH));j=j+1) begin : gen_rep
  axi_interconnect_v1_7_13_ndeep_srl #
    	  (
    	   .C_FAMILY  (C_FAMILY),
    	   .C_A_WIDTH (P_FIFO_DEPTH_LOG)
    	  )
          srl_nx1
          (
           .CLK (ACLK),
           .A   (fifoaddr[P_FIFO_DEPTH_LOG*(i+1)-1:
                          P_FIFO_DEPTH_LOG*(i)]),
           .CE  (push),
           .D   (S_MESG[i*C_MAX_CTRL_FANOUT+j]),
           .Q   (m_axi_mesg_i[i*C_MAX_CTRL_FANOUT+j])
          );
      end
    end      
  endgenerate
  
endmodule

`default_nettype wire


// -- (c) Copyright 2010 - 2013 Xilinx, Inc. All rights reserved.
// --
// -- This file contains confidential and proprietary information
// -- of Xilinx, Inc. and is protected under U.S. and 
// -- international copyright and other intellectual property
// -- laws.
// --
// -- DISCLAIMER
// -- This disclaimer is not a license and does not grant any
// -- rights to the materials distributed herewith. Except as
// -- otherwise provided in a valid license issued to you by
// -- Xilinx, and to the maximum extent permitted by applicable
// -- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
// -- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
// -- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
// -- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
// -- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
// -- (2) Xilinx shall not be liable (whether in contract or tort,
// -- including negligence, or under any other theory of
// -- liability) for any loss or damage of any kind or nature
// -- related to, arising under or in connection with these
// -- materials, including for any direct, or any indirect,
// -- special, incidental, or consequential loss or damage
// -- (including loss of data, profits, goodwill, or any type of
// -- loss or damage suffered as a result of any action brought
// -- by a third party) even if such damage or loss was
// -- reasonably foreseeable or Xilinx had been advised of the
// -- possibility of the same.
// --
// -- CRITICAL APPLICATIONS
// -- Xilinx products are not designed or intended to be fail-
// -- safe, or for use in any application requiring fail-safe
// -- performance, such as life-support or safety devices or
// -- systems, Class III medical devices, nuclear facilities,
// -- applications related to the deployment of airbags, or any
// -- other applications that could lead to death, personal
// -- injury, or severe property or environmental damage
// -- (individually and collectively, "Critical
// -- Applications"). Customer assumes the sole risk and
// -- liability of any use of Xilinx products in Critical
// -- Applications, subject only to applicable laws and
// -- regulations governing limitations on product liability.
// --
// -- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
// -- PART OF THIS FILE AT ALL TIMES.
//-----------------------------------------------------------------------------
//
// AXI data fifo module:    
//   5-channel memory-mapped AXI4 interfaces.
//   SRL or BRAM based FIFO on AXI W and/or R channels.
//   FIFO to accommodate various data flow rates through the AXI interconnect
//
// Verilog-standard:  Verilog 2001
//-----------------------------------------------------------------------------
//
// Structure:
//   axi_data_fifo
//     fifo_generator
//
//-----------------------------------------------------------------------------

`timescale 1ps/1ps

(* DowngradeIPIdentifiedWarnings="yes" *) 
module axi_interconnect_v1_7_13_axi_data_fifo #
  (
   parameter         C_FAMILY                    = "virtex7",
   parameter integer C_AXI_ID_WIDTH              = 4,
   parameter integer C_AXI_ADDR_WIDTH            = 32,
   parameter integer C_AXI_DATA_WIDTH            = 32,
   parameter integer C_AXI_SUPPORTS_USER_SIGNALS = 0,
   parameter integer C_AXI_AWUSER_WIDTH          = 1,
   parameter integer C_AXI_ARUSER_WIDTH          = 1,
   parameter integer C_AXI_WUSER_WIDTH           = 1,
   parameter integer C_AXI_RUSER_WIDTH           = 1,
   parameter integer C_AXI_BUSER_WIDTH           = 1,
   parameter integer C_AXI_WRITE_FIFO_DEPTH      = 0,      // Range: (0, 32, 512)
   parameter         C_AXI_WRITE_FIFO_TYPE       = "lut",  // "lut" = LUT (SRL) based,
                                                           // "bram" = BRAM based
   parameter integer C_AXI_WRITE_FIFO_DELAY      = 0,      // 0 = No, 1 = Yes (FUTURE FEATURE)
                       // Indicates whether AWVALID and WVALID assertion is delayed until:
                       //   a. the corresponding WLAST is stored in the FIFO, or
                       //   b. no WLAST is stored and the FIFO is full.
                       // 0 means AW channel is pass-through and 
                       //   WVALID is asserted whenever FIFO is not empty.
   parameter integer C_AXI_READ_FIFO_DEPTH       = 0,      // Range: (0, 32, 512)
   parameter         C_AXI_READ_FIFO_TYPE        = "lut",  // "lut" = LUT (SRL) based,
                                                           // "bram" = BRAM based
   parameter integer C_AXI_READ_FIFO_DELAY       = 0)      // 0 = No, 1 = Yes (FUTURE FEATURE)
                       // Indicates whether ARVALID assertion is delayed until the 
                       //   the remaining vacancy of the FIFO is at least the burst length
                       //   as indicated by ARLEN.
                       // 0 means AR channel is pass-through.
   // System Signals
  (input wire ACLK,
   input wire ARESETN,

   // Slave Interface Write Address Ports
   input  wire [C_AXI_ID_WIDTH-1:0]     S_AXI_AWID,
   input  wire [C_AXI_ADDR_WIDTH-1:0]   S_AXI_AWADDR,
   input  wire [8-1:0]                  S_AXI_AWLEN,
   input  wire [3-1:0]                  S_AXI_AWSIZE,
   input  wire [2-1:0]                  S_AXI_AWBURST,
   input  wire [2-1:0]                  S_AXI_AWLOCK,
   input  wire [4-1:0]                  S_AXI_AWCACHE,
   input  wire [3-1:0]                  S_AXI_AWPROT,
   input  wire [4-1:0]                  S_AXI_AWREGION,
   input  wire [4-1:0]                  S_AXI_AWQOS,
   input  wire [C_AXI_AWUSER_WIDTH-1:0] S_AXI_AWUSER,
   input  wire                          S_AXI_AWVALID,
   output wire                          S_AXI_AWREADY,

   // Slave Interface Write Data Ports
   input  wire [C_AXI_DATA_WIDTH-1:0]   S_AXI_WDATA,
   input  wire [C_AXI_DATA_WIDTH/8-1:0] S_AXI_WSTRB,
   input  wire                          S_AXI_WLAST,
   input  wire [C_AXI_WUSER_WIDTH-1:0]  S_AXI_WUSER,
   input  wire                          S_AXI_WVALID,
   output wire                          S_AXI_WREADY,

   // Slave Interface Write Response Ports
   output wire [C_AXI_ID_WIDTH-1:0]     S_AXI_BID,
   output wire [2-1:0]                  S_AXI_BRESP,
   output wire [C_AXI_BUSER_WIDTH-1:0]  S_AXI_BUSER,
   output wire                          S_AXI_BVALID,
   input  wire                          S_AXI_BREADY,

   // Slave Interface Read Address Ports
   input  wire [C_AXI_ID_WIDTH-1:0]     S_AXI_ARID,
   input  wire [C_AXI_ADDR_WIDTH-1:0]   S_AXI_ARADDR,
   input  wire [8-1:0]                  S_AXI_ARLEN,
   input  wire [3-1:0]                  S_AXI_ARSIZE,
   input  wire [2-1:0]                  S_AXI_ARBURST,
   input  wire [2-1:0]                  S_AXI_ARLOCK,
   input  wire [4-1:0]                  S_AXI_ARCACHE,
   input  wire [3-1:0]                  S_AXI_ARPROT,
   input  wire [4-1:0]                  S_AXI_ARREGION,
   input  wire [4-1:0]                  S_AXI_ARQOS,
   input  wire [C_AXI_ARUSER_WIDTH-1:0] S_AXI_ARUSER,
   input  wire                          S_AXI_ARVALID,
   output wire                          S_AXI_ARREADY,

   // Slave Interface Read Data Ports
   output wire [C_AXI_ID_WIDTH-1:0]     S_AXI_RID,
   output wire [C_AXI_DATA_WIDTH-1:0]   S_AXI_RDATA,
   output wire [2-1:0]                  S_AXI_RRESP,
   output wire                          S_AXI_RLAST,
   output wire [C_AXI_RUSER_WIDTH-1:0]  S_AXI_RUSER,
   output wire                          S_AXI_RVALID,
   input  wire                          S_AXI_RREADY,
   
   // Master Interface Write Address Port
   output wire [C_AXI_ID_WIDTH-1:0]     M_AXI_AWID,
   output wire [C_AXI_ADDR_WIDTH-1:0]   M_AXI_AWADDR,
   output wire [8-1:0]                  M_AXI_AWLEN,
   output wire [3-1:0]                  M_AXI_AWSIZE,
   output wire [2-1:0]                  M_AXI_AWBURST,
   output wire [2-1:0]                  M_AXI_AWLOCK,
   output wire [4-1:0]                  M_AXI_AWCACHE,
   output wire [3-1:0]                  M_AXI_AWPROT,
   output wire [4-1:0]                  M_AXI_AWREGION,
   output wire [4-1:0]                  M_AXI_AWQOS,
   output wire [C_AXI_AWUSER_WIDTH-1:0] M_AXI_AWUSER,
   output wire                          M_AXI_AWVALID,
   input  wire                          M_AXI_AWREADY,
   
   // Master Interface Write Data Ports
   output wire [C_AXI_DATA_WIDTH-1:0]   M_AXI_WDATA,
   output wire [C_AXI_DATA_WIDTH/8-1:0] M_AXI_WSTRB,
   output wire                          M_AXI_WLAST,
   output wire [C_AXI_WUSER_WIDTH-1:0]  M_AXI_WUSER,
   output wire                          M_AXI_WVALID,
   input  wire                          M_AXI_WREADY,
   
   // Master Interface Write Response Ports
   input  wire [C_AXI_ID_WIDTH-1:0]     M_AXI_BID,
   input  wire [2-1:0]                  M_AXI_BRESP,
   input  wire [C_AXI_BUSER_WIDTH-1:0]  M_AXI_BUSER,
   input  wire                          M_AXI_BVALID,
   output wire                          M_AXI_BREADY,
   
   // Master Interface Read Address Port
   output wire [C_AXI_ID_WIDTH-1:0]     M_AXI_ARID,
   output wire [C_AXI_ADDR_WIDTH-1:0]   M_AXI_ARADDR,
   output wire [8-1:0]                  M_AXI_ARLEN,
   output wire [3-1:0]                  M_AXI_ARSIZE,
   output wire [2-1:0]                  M_AXI_ARBURST,
   output wire [2-1:0]                  M_AXI_ARLOCK,
   output wire [4-1:0]                  M_AXI_ARCACHE,
   output wire [3-1:0]                  M_AXI_ARPROT,
   output wire [4-1:0]                  M_AXI_ARREGION,
   output wire [4-1:0]                  M_AXI_ARQOS,
   output wire [C_AXI_ARUSER_WIDTH-1:0] M_AXI_ARUSER,
   output wire                          M_AXI_ARVALID,
   input  wire                          M_AXI_ARREADY,
   
   // Master Interface Read Data Ports
   input  wire [C_AXI_ID_WIDTH-1:0]     M_AXI_RID,
   input  wire [C_AXI_DATA_WIDTH-1:0]   M_AXI_RDATA,
   input  wire [2-1:0]                  M_AXI_RRESP,
   input  wire                          M_AXI_RLAST,
   input  wire [C_AXI_RUSER_WIDTH-1:0]  M_AXI_RUSER,
   input  wire                          M_AXI_RVALID,
   output wire                          M_AXI_RREADY);
  
  localparam integer P_WIDTH_RACH = 4+4+3+4+2+3+9+C_AXI_ADDR_WIDTH+C_AXI_ID_WIDTH;
  localparam integer P_WIDTH_WACH = 4+4+3+4+2+3+9+C_AXI_ADDR_WIDTH+C_AXI_ID_WIDTH;
  localparam integer P_WIDTH_RDCH = 1 + 2 + C_AXI_DATA_WIDTH + C_AXI_ID_WIDTH;
  localparam integer P_WIDTH_WDCH = 1+C_AXI_DATA_WIDTH+C_AXI_DATA_WIDTH/8;
  
  localparam P_PRIM_FIFO_TYPE = "512x72" ;
  localparam integer P_WRITE_FIFO_DEPTH_LOG = (C_AXI_WRITE_FIFO_DEPTH > 1) ? f_ceil_log2(C_AXI_WRITE_FIFO_DEPTH) : 1;
  localparam integer P_READ_FIFO_DEPTH_LOG = (C_AXI_READ_FIFO_DEPTH > 1) ? f_ceil_log2(C_AXI_READ_FIFO_DEPTH) : 1;
  
  // Ceiling of log2(x)
  function integer f_ceil_log2
    (
     input integer x
     );
    integer acc;
    begin
      acc=0;
      while ((2**acc) < x)
        acc = acc + 1;
      f_ceil_log2 = acc;
    end
  endfunction

  generate
    if ((C_AXI_WRITE_FIFO_DEPTH == 0) && (C_AXI_READ_FIFO_DEPTH == 0)) begin : gen_bypass
      assign M_AXI_AWID     = S_AXI_AWID;
      assign M_AXI_AWADDR   = S_AXI_AWADDR;
      assign M_AXI_AWLEN    = S_AXI_AWLEN;
      assign M_AXI_AWSIZE   = S_AXI_AWSIZE;
      assign M_AXI_AWBURST  = S_AXI_AWBURST;
      assign M_AXI_AWLOCK   = S_AXI_AWLOCK;
      assign M_AXI_AWCACHE  = S_AXI_AWCACHE;
      assign M_AXI_AWPROT   = S_AXI_AWPROT;
      assign M_AXI_AWREGION = S_AXI_AWREGION;
      assign M_AXI_AWQOS    = S_AXI_AWQOS;
      assign M_AXI_AWUSER   = S_AXI_AWUSER;
      assign M_AXI_AWVALID  = S_AXI_AWVALID;
      assign S_AXI_AWREADY  = M_AXI_AWREADY;
      
      assign M_AXI_WDATA    = S_AXI_WDATA;
      assign M_AXI_WSTRB    = S_AXI_WSTRB;
      assign M_AXI_WLAST    = S_AXI_WLAST;
      assign M_AXI_WUSER    = S_AXI_WUSER;
      assign M_AXI_WVALID   = S_AXI_WVALID;
      assign S_AXI_WREADY   = M_AXI_WREADY;
    
      assign S_AXI_BID      = M_AXI_BID;
      assign S_AXI_BRESP    = M_AXI_BRESP;
      assign S_AXI_BUSER    = M_AXI_BUSER;
      assign S_AXI_BVALID   = M_AXI_BVALID;
      assign M_AXI_BREADY   = S_AXI_BREADY;
    
      assign M_AXI_ARID     = S_AXI_ARID;
      assign M_AXI_ARADDR   = S_AXI_ARADDR;
      assign M_AXI_ARLEN    = S_AXI_ARLEN;
      assign M_AXI_ARSIZE   = S_AXI_ARSIZE;
      assign M_AXI_ARBURST  = S_AXI_ARBURST;
      assign M_AXI_ARLOCK   = S_AXI_ARLOCK;
      assign M_AXI_ARCACHE  = S_AXI_ARCACHE;
      assign M_AXI_ARPROT   = S_AXI_ARPROT;
      assign M_AXI_ARREGION = S_AXI_ARREGION;
      assign M_AXI_ARQOS    = S_AXI_ARQOS;
      assign M_AXI_ARUSER   = S_AXI_ARUSER;
      assign M_AXI_ARVALID  = S_AXI_ARVALID;
      assign S_AXI_ARREADY  = M_AXI_ARREADY;
  
      assign S_AXI_RID      = M_AXI_RID;
      assign S_AXI_RDATA    = M_AXI_RDATA;
      assign S_AXI_RRESP    = M_AXI_RRESP;
      assign S_AXI_RLAST    = M_AXI_RLAST;
      assign S_AXI_RUSER    = M_AXI_RUSER;
      assign S_AXI_RVALID   = M_AXI_RVALID;
      assign M_AXI_RREADY   = S_AXI_RREADY;
    end else begin : gen_fifo

    wire M_AXI_AWLOCK_I;
    wire M_AXI_ARLOCK_I;
    assign M_AXI_AWLOCK   = {1'b0,M_AXI_AWLOCK_I};
    assign M_AXI_ARLOCK   = {1'b0,M_AXI_ARLOCK_I};

  fifo_generator_v13_1_4 #(
          .C_ADD_NGC_CONSTRAINT(0),
          .C_APPLICATION_TYPE_AXIS(0),
          .C_APPLICATION_TYPE_RACH(C_AXI_READ_FIFO_DELAY ? 1 : 0),
          .C_APPLICATION_TYPE_RDCH(0),
          .C_APPLICATION_TYPE_WACH(C_AXI_WRITE_FIFO_DELAY ? 1 : 0),
          .C_APPLICATION_TYPE_WDCH(0),
          .C_APPLICATION_TYPE_WRCH(0),
          .C_AXI_ADDR_WIDTH(C_AXI_ADDR_WIDTH),
          .C_AXI_ARUSER_WIDTH(1),
          .C_AXI_AWUSER_WIDTH(1),
          .C_AXI_BUSER_WIDTH(1),
          .C_AXI_DATA_WIDTH(C_AXI_DATA_WIDTH),
          .C_AXI_ID_WIDTH(C_AXI_ID_WIDTH),
          .C_AXI_LEN_WIDTH(8),
          .C_AXI_LOCK_WIDTH(1),
          .C_AXI_RUSER_WIDTH(1),
          .C_AXI_TYPE(1),
          .C_AXI_WUSER_WIDTH(1),
          .C_AXIS_TDATA_WIDTH(64),
          .C_AXIS_TDEST_WIDTH(4),
          .C_AXIS_TID_WIDTH(8),
          .C_AXIS_TKEEP_WIDTH(4),
          .C_AXIS_TSTRB_WIDTH(4),
          .C_AXIS_TUSER_WIDTH(4),
          .C_AXIS_TYPE(0),
          .C_COMMON_CLOCK(1),
          .C_COUNT_TYPE(0),
          .C_DATA_COUNT_WIDTH(10),
          .C_DEFAULT_VALUE("BlankString"),
          .C_DIN_WIDTH(18),
          .C_DIN_WIDTH_AXIS(1),
          .C_DIN_WIDTH_RACH(P_WIDTH_RACH),
          .C_DIN_WIDTH_RDCH(P_WIDTH_RDCH),
          .C_DIN_WIDTH_WACH(P_WIDTH_WACH),
          .C_DIN_WIDTH_WDCH(P_WIDTH_WDCH),
          .C_DIN_WIDTH_WRCH(6),
          .C_DOUT_RST_VAL("0"),
          .C_DOUT_WIDTH(18),
          .C_ENABLE_RLOCS(0),
          .C_ENABLE_RST_SYNC(1),
          .C_ERROR_INJECTION_TYPE(0),
          .C_ERROR_INJECTION_TYPE_AXIS(0),
          .C_ERROR_INJECTION_TYPE_RACH(0),
          .C_ERROR_INJECTION_TYPE_RDCH(0),
          .C_ERROR_INJECTION_TYPE_WACH(0),
          .C_ERROR_INJECTION_TYPE_WDCH(0),
          .C_ERROR_INJECTION_TYPE_WRCH(0),
          .C_FAMILY(C_FAMILY),
          .C_FULL_FLAGS_RST_VAL(1),
          .C_HAS_ALMOST_EMPTY(0),
          .C_HAS_ALMOST_FULL(0),
          .C_HAS_AXI_ARUSER(0),
          .C_HAS_AXI_AWUSER(0),
          .C_HAS_AXI_BUSER(0),
          .C_HAS_AXI_ID(1),
          .C_HAS_AXI_RD_CHANNEL(1),
          .C_HAS_AXI_RUSER(0),
          .C_HAS_AXI_WR_CHANNEL(1),
          .C_HAS_AXI_WUSER(0),
          .C_HAS_AXIS_TDATA(0),
          .C_HAS_AXIS_TDEST(0),
          .C_HAS_AXIS_TID(0),
          .C_HAS_AXIS_TKEEP(0),
          .C_HAS_AXIS_TLAST(0),
          .C_HAS_AXIS_TREADY(1),
          .C_HAS_AXIS_TSTRB(0),
          .C_HAS_AXIS_TUSER(0),
          .C_HAS_BACKUP(0),
          .C_HAS_DATA_COUNT(0),
          .C_HAS_DATA_COUNTS_AXIS(0),
          .C_HAS_DATA_COUNTS_RACH(0),
          .C_HAS_DATA_COUNTS_RDCH(0),
          .C_HAS_DATA_COUNTS_WACH(0),
          .C_HAS_DATA_COUNTS_WDCH(0),
          .C_HAS_DATA_COUNTS_WRCH(0),
          .C_HAS_INT_CLK(0),
          .C_HAS_MASTER_CE(0),
          .C_HAS_MEMINIT_FILE(0),
          .C_HAS_OVERFLOW(0),
          .C_HAS_PROG_FLAGS_AXIS(0),
          .C_HAS_PROG_FLAGS_RACH(0),
          .C_HAS_PROG_FLAGS_RDCH(0),
          .C_HAS_PROG_FLAGS_WACH(0),
          .C_HAS_PROG_FLAGS_WDCH(0),
          .C_HAS_PROG_FLAGS_WRCH(0),
          .C_HAS_RD_DATA_COUNT(0),
          .C_HAS_RD_RST(0),
          .C_HAS_RST(1),
          .C_HAS_SLAVE_CE(0),
          .C_HAS_SRST(0),
          .C_HAS_UNDERFLOW(0),
          .C_HAS_VALID(0),
          .C_HAS_WR_ACK(0),
          .C_HAS_WR_DATA_COUNT(0),
          .C_HAS_WR_RST(0),
          .C_IMPLEMENTATION_TYPE(0),
          .C_IMPLEMENTATION_TYPE_AXIS(1),
          .C_IMPLEMENTATION_TYPE_RACH(2),
          .C_IMPLEMENTATION_TYPE_RDCH((C_AXI_READ_FIFO_TYPE == "bram") ? 1 : 2),
          .C_IMPLEMENTATION_TYPE_WACH(2),
          .C_IMPLEMENTATION_TYPE_WDCH((C_AXI_WRITE_FIFO_TYPE == "bram") ? 1 : 2),
          .C_IMPLEMENTATION_TYPE_WRCH(2),
          .C_INIT_WR_PNTR_VAL(0),
          .C_INTERFACE_TYPE(2),
          .C_MEMORY_TYPE(1),
          .C_MIF_FILE_NAME("BlankString"),
          .C_MSGON_VAL(1),
          .C_OPTIMIZATION_MODE(0),
          .C_OVERFLOW_LOW(0),
          .C_PRELOAD_LATENCY(1),
          .C_PRELOAD_REGS(0),
          .C_PRIM_FIFO_TYPE(P_PRIM_FIFO_TYPE),
          .C_PROG_EMPTY_THRESH_ASSERT_VAL(2),
          .C_PROG_EMPTY_THRESH_ASSERT_VAL_AXIS(1022),
          .C_PROG_EMPTY_THRESH_ASSERT_VAL_RACH(30),
          .C_PROG_EMPTY_THRESH_ASSERT_VAL_RDCH(510),
          .C_PROG_EMPTY_THRESH_ASSERT_VAL_WACH(30),
          .C_PROG_EMPTY_THRESH_ASSERT_VAL_WDCH(510),
          .C_PROG_EMPTY_THRESH_ASSERT_VAL_WRCH(14),
          .C_PROG_EMPTY_THRESH_NEGATE_VAL(3),
          .C_PROG_EMPTY_TYPE(0),
          .C_PROG_EMPTY_TYPE_AXIS(5),
          .C_PROG_EMPTY_TYPE_RACH(5),
          .C_PROG_EMPTY_TYPE_RDCH(5),
          .C_PROG_EMPTY_TYPE_WACH(5),
          .C_PROG_EMPTY_TYPE_WDCH(5),
          .C_PROG_EMPTY_TYPE_WRCH(5),
          .C_PROG_FULL_THRESH_ASSERT_VAL(1022),
          .C_PROG_FULL_THRESH_ASSERT_VAL_AXIS(1023),
          .C_PROG_FULL_THRESH_ASSERT_VAL_RACH(31),
          .C_PROG_FULL_THRESH_ASSERT_VAL_RDCH(511),
          .C_PROG_FULL_THRESH_ASSERT_VAL_WACH(31),
          .C_PROG_FULL_THRESH_ASSERT_VAL_WDCH(511),
          .C_PROG_FULL_THRESH_ASSERT_VAL_WRCH(15),
          .C_PROG_FULL_THRESH_NEGATE_VAL(1021),
          .C_PROG_FULL_TYPE(0),
          .C_PROG_FULL_TYPE_AXIS(5),
          .C_PROG_FULL_TYPE_RACH(5),
          .C_PROG_FULL_TYPE_RDCH(5),
          .C_PROG_FULL_TYPE_WACH(5),
          .C_PROG_FULL_TYPE_WDCH(5),
          .C_PROG_FULL_TYPE_WRCH(5),
          .C_RACH_TYPE(((C_AXI_READ_FIFO_DEPTH != 0) && C_AXI_READ_FIFO_DELAY) ? 0 : 2),
          .C_RD_DATA_COUNT_WIDTH(10),
          .C_RD_DEPTH(1024),
          .C_RD_FREQ(1),
          .C_RD_PNTR_WIDTH(10),
          .C_RDCH_TYPE((C_AXI_READ_FIFO_DEPTH != 0) ? 0 : 2),
          .C_REG_SLICE_MODE_AXIS(0),
          .C_REG_SLICE_MODE_RACH(0),
          .C_REG_SLICE_MODE_RDCH(0),
          .C_REG_SLICE_MODE_WACH(0),
          .C_REG_SLICE_MODE_WDCH(0),
          .C_REG_SLICE_MODE_WRCH(0),
          .C_UNDERFLOW_LOW(0),
          .C_USE_COMMON_OVERFLOW(0),
          .C_USE_COMMON_UNDERFLOW(0),
          .C_USE_DEFAULT_SETTINGS(0),
          .C_USE_DOUT_RST(1),
          .C_USE_ECC(0),
          .C_USE_ECC_AXIS(0),
          .C_USE_ECC_RACH(0),
          .C_USE_ECC_RDCH(0),
          .C_USE_ECC_WACH(0),
          .C_USE_ECC_WDCH(0),
          .C_USE_ECC_WRCH(0),
          .C_USE_EMBEDDED_REG(0),
          .C_USE_FIFO16_FLAGS(0),
          .C_USE_FWFT_DATA_COUNT(0),
          .C_VALID_LOW(0),
          .C_WACH_TYPE(((C_AXI_WRITE_FIFO_DEPTH != 0) && C_AXI_WRITE_FIFO_DELAY) ? 0 : 2),
          .C_WDCH_TYPE((C_AXI_WRITE_FIFO_DEPTH != 0) ? 0 : 2),
          .C_WR_ACK_LOW(0),
          .C_WR_DATA_COUNT_WIDTH(10),
          .C_WR_DEPTH(1024),
          .C_WR_DEPTH_AXIS(1024),
          .C_WR_DEPTH_RACH(32),
          .C_WR_DEPTH_RDCH(C_AXI_READ_FIFO_DEPTH),
          .C_WR_DEPTH_WACH(32),
          .C_WR_DEPTH_WDCH(C_AXI_WRITE_FIFO_DEPTH),
          .C_WR_DEPTH_WRCH(16),
          .C_WR_FREQ(1),
          .C_WR_PNTR_WIDTH(10),
          .C_WR_PNTR_WIDTH_AXIS(10),
          .C_WR_PNTR_WIDTH_RACH(5),
          .C_WR_PNTR_WIDTH_RDCH((C_AXI_READ_FIFO_DEPTH> 1) ? f_ceil_log2(C_AXI_READ_FIFO_DEPTH) : 1),
          .C_WR_PNTR_WIDTH_WACH(5),
          .C_WR_PNTR_WIDTH_WDCH((C_AXI_WRITE_FIFO_DEPTH > 1) ? f_ceil_log2(C_AXI_WRITE_FIFO_DEPTH) : 1),
          .C_WR_PNTR_WIDTH_WRCH(4),
          .C_WR_RESPONSE_LATENCY(1),
          .C_WRCH_TYPE(2)
        )
        fifo_gen_inst (
          .s_aclk(ACLK),
          .s_aresetn(ARESETN),
          .s_axi_awid(S_AXI_AWID),
          .s_axi_awaddr(S_AXI_AWADDR),
          .s_axi_awlen(S_AXI_AWLEN),
          .s_axi_awsize(S_AXI_AWSIZE),
          .s_axi_awburst(S_AXI_AWBURST),
          .s_axi_awlock(S_AXI_AWLOCK[0]),
          .s_axi_awcache(S_AXI_AWCACHE),
          .s_axi_awprot(S_AXI_AWPROT),
          .s_axi_awqos(S_AXI_AWQOS),
          .s_axi_awregion(S_AXI_AWREGION),
          .s_axi_awuser(S_AXI_AWUSER),
          .s_axi_awvalid(S_AXI_AWVALID),
          .s_axi_awready(S_AXI_AWREADY),
          .s_axi_wid({C_AXI_ID_WIDTH{1'b0}}),
          .s_axi_wdata(S_AXI_WDATA),
          .s_axi_wstrb(S_AXI_WSTRB),
          .s_axi_wlast(S_AXI_WLAST),
          .s_axi_wvalid(S_AXI_WVALID),
          .s_axi_wready(S_AXI_WREADY),
          .s_axi_bid(S_AXI_BID),
          .s_axi_bresp(S_AXI_BRESP),
          .s_axi_bvalid(S_AXI_BVALID),
          .s_axi_bready(S_AXI_BREADY),
          .m_axi_awid(M_AXI_AWID),
          .m_axi_awaddr(M_AXI_AWADDR),
          .m_axi_awlen(M_AXI_AWLEN),
          .m_axi_awsize(M_AXI_AWSIZE),
          .m_axi_awburst(M_AXI_AWBURST),
          .m_axi_awlock(M_AXI_AWLOCK_I),
          .m_axi_awcache(M_AXI_AWCACHE),
          .m_axi_awprot(M_AXI_AWPROT),
          .m_axi_awqos(M_AXI_AWQOS),
          .m_axi_awregion(M_AXI_AWREGION),
          .m_axi_awuser(M_AXI_AWUSER),
          .m_axi_awvalid(M_AXI_AWVALID),
          .m_axi_awready(M_AXI_AWREADY),
          .m_axi_wid(),
          .m_axi_wdata(M_AXI_WDATA),
          .m_axi_wstrb(M_AXI_WSTRB),
          .m_axi_wlast(M_AXI_WLAST),
          .m_axi_wvalid(M_AXI_WVALID),
          .m_axi_wready(M_AXI_WREADY),
          .m_axi_bid(M_AXI_BID),
          .m_axi_bresp(M_AXI_BRESP),
          .m_axi_bvalid(M_AXI_BVALID),
          .m_axi_bready(M_AXI_BREADY),
          .s_axi_arid(S_AXI_ARID),
          .s_axi_araddr(S_AXI_ARADDR),
          .s_axi_arlen(S_AXI_ARLEN),
          .s_axi_arsize(S_AXI_ARSIZE),
          .s_axi_arburst(S_AXI_ARBURST),
          .s_axi_arlock(S_AXI_ARLOCK[0]),
          .s_axi_arcache(S_AXI_ARCACHE),
          .s_axi_arprot(S_AXI_ARPROT),
          .s_axi_arqos(S_AXI_ARQOS),
          .s_axi_arregion(S_AXI_ARREGION),
          .s_axi_arvalid(S_AXI_ARVALID),
          .s_axi_arready(S_AXI_ARREADY),
          .s_axi_rid(S_AXI_RID),
          .s_axi_rdata(S_AXI_RDATA),
          .s_axi_rresp(S_AXI_RRESP),
          .s_axi_rlast(S_AXI_RLAST),
          .s_axi_rvalid(S_AXI_RVALID),
          .s_axi_rready(S_AXI_RREADY),
          .m_axi_arid(M_AXI_ARID),
          .m_axi_araddr(M_AXI_ARADDR),
          .m_axi_arlen(M_AXI_ARLEN),
          .m_axi_arsize(M_AXI_ARSIZE),
          .m_axi_arburst(M_AXI_ARBURST),
          .m_axi_arlock(M_AXI_ARLOCK_I),
          .m_axi_arcache(M_AXI_ARCACHE),
          .m_axi_arprot(M_AXI_ARPROT),
          .m_axi_arqos(M_AXI_ARQOS),
          .m_axi_arregion(M_AXI_ARREGION),
          .m_axi_arvalid(M_AXI_ARVALID),
          .m_axi_arready(M_AXI_ARREADY),
          .m_axi_rid(M_AXI_RID),
          .m_axi_rdata(M_AXI_RDATA),
          .m_axi_rresp(M_AXI_RRESP),
          .m_axi_rlast(M_AXI_RLAST),
          .m_axi_rvalid(M_AXI_RVALID),
          .m_axi_rready(M_AXI_RREADY),
          .m_aclk(ACLK),
          .m_aclk_en(1'b1),
          .s_aclk_en(1'b1),
          .s_axi_wuser(S_AXI_WUSER),
          .s_axi_buser(S_AXI_BUSER),
          .m_axi_wuser(M_AXI_WUSER),
          .m_axi_buser(M_AXI_BUSER),
          .s_axi_aruser(S_AXI_ARUSER),
          .s_axi_ruser(S_AXI_RUSER),
          .m_axi_aruser(M_AXI_ARUSER),
          .m_axi_ruser(M_AXI_RUSER),
          .almost_empty(),
          .almost_full(),
          .axis_data_count(),
          .axis_dbiterr(),
          .axis_injectdbiterr(1'b0),
          .axis_injectsbiterr(1'b0),
          .axis_overflow(),
          .axis_prog_empty(),
          .axis_prog_empty_thresh(10'b0),
          .axis_prog_full(),
          .axis_prog_full_thresh(10'b0),
          .axis_rd_data_count(),
          .axis_sbiterr(),
          .axis_underflow(),
          .axis_wr_data_count(),
          .axi_ar_data_count(),
          .axi_ar_dbiterr(),
          .axi_ar_injectdbiterr(1'b0),
          .axi_ar_injectsbiterr(1'b0),
          .axi_ar_overflow(),
          .axi_ar_prog_empty(),
          .axi_ar_prog_empty_thresh(5'b0),
          .axi_ar_prog_full(),
          .axi_ar_prog_full_thresh(5'b0),
          .axi_ar_rd_data_count(),
          .axi_ar_sbiterr(),
          .axi_ar_underflow(),
          .axi_ar_wr_data_count(),
          .axi_aw_data_count(),
          .axi_aw_dbiterr(),
          .axi_aw_injectdbiterr(1'b0),
          .axi_aw_injectsbiterr(1'b0),
          .axi_aw_overflow(),
          .axi_aw_prog_empty(),
          .axi_aw_prog_empty_thresh(5'b0),
          .axi_aw_prog_full(),
          .axi_aw_prog_full_thresh(5'b0),
          .axi_aw_rd_data_count(),
          .axi_aw_sbiterr(),
          .axi_aw_underflow(),
          .axi_aw_wr_data_count(),
          .axi_b_data_count(),
          .axi_b_dbiterr(),
          .axi_b_injectdbiterr(1'b0),
          .axi_b_injectsbiterr(1'b0),
          .axi_b_overflow(),
          .axi_b_prog_empty(),
          .axi_b_prog_empty_thresh(4'b0),
          .axi_b_prog_full(),
          .axi_b_prog_full_thresh(4'b0),
          .axi_b_rd_data_count(),
          .axi_b_sbiterr(),
          .axi_b_underflow(),
          .axi_b_wr_data_count(),
          .axi_r_data_count(),
          .axi_r_dbiterr(),
          .axi_r_injectdbiterr(1'b0),
          .axi_r_injectsbiterr(1'b0),
          .axi_r_overflow(),
          .axi_r_prog_empty(),
          .axi_r_prog_empty_thresh({P_READ_FIFO_DEPTH_LOG{1'b0}}),
          .axi_r_prog_full(),
          .axi_r_prog_full_thresh({P_READ_FIFO_DEPTH_LOG{1'b0}}),
          .axi_r_rd_data_count(),
          .axi_r_sbiterr(),
          .axi_r_underflow(),
          .axi_r_wr_data_count(),
          .axi_w_data_count(),
          .axi_w_dbiterr(),
          .axi_w_injectdbiterr(1'b0),
          .axi_w_injectsbiterr(1'b0),
          .axi_w_overflow(),
          .axi_w_prog_empty(),
          .axi_w_prog_empty_thresh({P_WRITE_FIFO_DEPTH_LOG{1'b0}}),
          .axi_w_prog_full(),
          .axi_w_prog_full_thresh({P_WRITE_FIFO_DEPTH_LOG{1'b0}}),
          .axi_w_rd_data_count(),
          .axi_w_sbiterr(),
          .axi_w_underflow(),
          .axi_w_wr_data_count(),
          .backup(1'b0),
          .backup_marker(1'b0),
          .clk(1'b0),
          .data_count(),
          .dbiterr(),
          .din(18'b0),
          .dout(),
          .empty(),
          .full(),
          .injectdbiterr(1'b0),
          .injectsbiterr(1'b0),
          .int_clk(1'b0),
          .m_axis_tdata(),
          .m_axis_tdest(),
          .m_axis_tid(),
          .m_axis_tkeep(),
          .m_axis_tlast(),
          .m_axis_tready(1'b0),
          .m_axis_tstrb(),
          .m_axis_tuser(),
          .m_axis_tvalid(),
          .overflow(),
          .prog_empty(),
          .prog_empty_thresh(10'b0),
          .prog_empty_thresh_assert(10'b0),
          .prog_empty_thresh_negate(10'b0),
          .prog_full(),
          .prog_full_thresh(10'b0),
          .prog_full_thresh_assert(10'b0),
          .prog_full_thresh_negate(10'b0),
          .rd_clk(1'b0),
          .rd_data_count(),
          .rd_en(1'b0),
          .rd_rst(1'b0),
          .rd_rst_busy(),
          .rst(1'b0),
          .sbiterr(),
          .sleep(1'b0),
          .srst(1'b0),
          .s_axis_tdata(64'b0),
          .s_axis_tdest(4'b0),
          .s_axis_tid(8'b0),
          .s_axis_tkeep(4'b0),
          .s_axis_tlast(1'b0),
          .s_axis_tready(),
          .s_axis_tstrb(4'b0),
          .s_axis_tuser(4'b0),
          .s_axis_tvalid(1'b0),
          .underflow(),
          .valid(),
          .wr_ack(),
          .wr_clk(1'b0),
          .wr_data_count(),
          .wr_en(1'b0),
          .wr_rst(1'b0),
          .wr_rst_busy()
      );
    end
  endgenerate
endmodule



// -- (c) Copyright 2010 - 2011 Xilinx, Inc. All rights reserved.
// --
// -- This file contains confidential and proprietary information
// -- of Xilinx, Inc. and is protected under U.S. and 
// -- international copyright and other intellectual property
// -- laws.
// --
// -- DISCLAIMER
// -- This disclaimer is not a license and does not grant any
// -- rights to the materials distributed herewith. Except as
// -- otherwise provided in a valid license issued to you by
// -- Xilinx, and to the maximum extent permitted by applicable
// -- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
// -- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
// -- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
// -- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
// -- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
// -- (2) Xilinx shall not be liable (whether in contract or tort,
// -- including negligence, or under any other theory of
// -- liability) for any loss or damage of any kind or nature
// -- related to, arising under or in connection with these
// -- materials, including for any direct, or any indirect,
// -- special, incidental, or consequential loss or damage
// -- (including loss of data, profits, goodwill, or any type of
// -- loss or damage suffered as a result of any action brought
// -- by a third party) even if such damage or loss was
// -- reasonably foreseeable or Xilinx had been advised of the
// -- possibility of the same.
// --
// -- CRITICAL APPLICATIONS
// -- Xilinx products are not designed or intended to be fail-
// -- safe, or for use in any application requiring fail-safe
// -- performance, such as life-support or safety devices or
// -- systems, Class III medical devices, nuclear facilities,
// -- applications related to the deployment of airbags, or any
// -- other applications that could lead to death, personal
// -- injury, or severe property or environmental damage
// -- (individually and collectively, "Critical
// -- Applications"). Customer assumes the sole risk and
// -- liability of any use of Xilinx products in Critical
// -- Applications, subject only to applicable laws and
// -- regulations governing limitations on product liability.
// --
// -- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
// -- PART OF THIS FILE AT ALL TIMES.
//-----------------------------------------------------------------------------
//
// Description: Down-Sizer
// Down-Sizer for generic SI- and MI-side data widths. This module instantiates
// Address, Write Data, Write Response and Read Data Down-Sizer modules, each one taking care
// of the channel specific tasks.
// The Address Down-Sizer can handle both AR and AW channels.
//
// Verilog-standard:  Verilog 2001
//--------------------------------------------------------------------------
//
// Structure:
//   downsizer
//     a_downsizer
//       axic_fifo
//         fifo_gen
//           fifo_coregen
//     w_downsizer
//     b_downsizer
//     r_downsizer
//
//--------------------------------------------------------------------------
`timescale 1ps/1ps

(* DowngradeIPIdentifiedWarnings="yes" *) 
module axi_interconnect_v1_7_13_axi_downsizer #
  (
   parameter         C_FAMILY                         = "none", 
                       // FPGA Family. Current version: virtex6 or spartan6.
   parameter integer C_AXI_ID_WIDTH                   = 4, 
                       // Width of all ID signals on SI and MI side of converter.
                       // Range: >= 1.
   parameter integer C_AXI_ADDR_WIDTH                 = 32, 
                       // Width of all ADDR signals on SI and MI side of converter.
                       // Range: 32.
   parameter         C_S_AXI_DATA_WIDTH               = 32'h00000040,
                       // Width of S_AXI_WDATA and S_AXI_RDATA.
                       // Format: Bit32;
                       // Range: 'h00000040, 'h00000080, 'h00000100.
   parameter         C_M_AXI_DATA_WIDTH               = 32'h00000020, 
                       // Width of M_AXI_WDATA and M_AXI_RDATA. 
                       // Assume always smaller than C_S_AXI_DATA_WIDTH.
                       // Format: Bit32; 
                       // Range: 'h00000020, 'h00000040, 'h00000080.
   parameter integer C_AXI_SUPPORTS_USER_SIGNALS      = 0,
                       // 1 = Propagate all USER signals, 0 = Dont propagate.
   parameter integer C_AXI_AWUSER_WIDTH               = 1,
                       // Width of AWUSER signals. 
                       // Range: >= 1.
   parameter integer C_AXI_ARUSER_WIDTH               = 1,
                       // Width of ARUSER signals. 
                       // Range: >= 1.
   parameter integer C_AXI_WUSER_WIDTH                = 1,
                       // Width of WUSER signals. 
                       // Range: >= 1.
   parameter integer C_AXI_RUSER_WIDTH                = 1,
                       // Width of RUSER signals. 
                       // Range: >= 1.
   parameter integer C_AXI_BUSER_WIDTH                = 1,
                       // Width of BUSER signals. 
                       // Range: >= 1.
   parameter integer C_AXI_SUPPORTS_WRITE             = 1,
   parameter integer C_AXI_SUPPORTS_READ              = 1,
   parameter integer C_SUPPORT_SPLITTING              = 1,
                       // Implement transaction splitting logic.
   parameter integer C_SUPPORT_BURSTS                 = 1,
                       // Disabled when all connected slaves and masters are AxiLite,
                       //   allowing logic to be simplified.
   parameter integer C_SINGLE_THREAD                  = 1
                       // 0 = Ignore ID when propagating transactions (assume all responses are in order).
                       // 1 = Allow multiple outstanding transactions only if the IDs are the same
                       //   to prevent response reordering.
                       //   (If ID mismatches, stall until outstanding transaction counter = 0.)
   )
  (
   // Global Signals
   input  wire                              ARESETN,
   input  wire                              ACLK,

   // Slave Interface Write Address Ports
   input  wire [C_AXI_ID_WIDTH-1:0]         S_AXI_AWID,
   input  wire [C_AXI_ADDR_WIDTH-1:0]       S_AXI_AWADDR,
   input  wire [8-1:0]                      S_AXI_AWLEN,
   input  wire [3-1:0]                      S_AXI_AWSIZE,
   input  wire [2-1:0]                      S_AXI_AWBURST,
   input  wire [2-1:0]                      S_AXI_AWLOCK,
   input  wire [4-1:0]                      S_AXI_AWCACHE,
   input  wire [3-1:0]                      S_AXI_AWPROT,
   input  wire [4-1:0]                      S_AXI_AWREGION,
   input  wire [4-1:0]                      S_AXI_AWQOS,
   input  wire [C_AXI_AWUSER_WIDTH-1:0]     S_AXI_AWUSER,
   input  wire                              S_AXI_AWVALID,
   output wire                              S_AXI_AWREADY,
   // Slave Interface Write Data Ports
   input  wire [C_S_AXI_DATA_WIDTH-1:0]     S_AXI_WDATA,
   input  wire [C_S_AXI_DATA_WIDTH/8-1:0]   S_AXI_WSTRB,
   input  wire                              S_AXI_WLAST,
   input  wire [C_AXI_WUSER_WIDTH-1:0]      S_AXI_WUSER,
   input  wire                              S_AXI_WVALID,
   output wire                              S_AXI_WREADY,
   // Slave Interface Write Response Ports
   output wire [C_AXI_ID_WIDTH-1:0]         S_AXI_BID,
   output wire [2-1:0]                      S_AXI_BRESP,
   output wire [C_AXI_BUSER_WIDTH-1:0]      S_AXI_BUSER,
   output wire                              S_AXI_BVALID,
   input  wire                              S_AXI_BREADY,
   // Slave Interface Read Address Ports
   input  wire [C_AXI_ID_WIDTH-1:0]         S_AXI_ARID,
   input  wire [C_AXI_ADDR_WIDTH-1:0]       S_AXI_ARADDR,
   input  wire [8-1:0]                      S_AXI_ARLEN,
   input  wire [3-1:0]                      S_AXI_ARSIZE,
   input  wire [2-1:0]                      S_AXI_ARBURST,
   input  wire [2-1:0]                      S_AXI_ARLOCK,
   input  wire [4-1:0]                      S_AXI_ARCACHE,
   input  wire [3-1:0]                      S_AXI_ARPROT,
   input  wire [4-1:0]                      S_AXI_ARREGION,
   input  wire [4-1:0]                      S_AXI_ARQOS,
   input  wire [C_AXI_ARUSER_WIDTH-1:0]     S_AXI_ARUSER,
   input  wire                              S_AXI_ARVALID,
   output wire                              S_AXI_ARREADY,
   // Slave Interface Read Data Ports
   output wire [C_AXI_ID_WIDTH-1:0]         S_AXI_RID,
   output wire [C_S_AXI_DATA_WIDTH-1:0]     S_AXI_RDATA,
   output wire [2-1:0]                      S_AXI_RRESP,
   output wire                              S_AXI_RLAST,
   output wire [C_AXI_RUSER_WIDTH-1:0]      S_AXI_RUSER,
   output wire                              S_AXI_RVALID,
   input  wire                              S_AXI_RREADY,

   // Master Interface Write Address Port
   output wire [C_AXI_ID_WIDTH-1:0]         M_AXI_AWID,
   output wire [C_AXI_ADDR_WIDTH-1:0]       M_AXI_AWADDR,
   output wire [8-1:0]                      M_AXI_AWLEN,
   output wire [3-1:0]                      M_AXI_AWSIZE,
   output wire [2-1:0]                      M_AXI_AWBURST,
   output wire [2-1:0]                      M_AXI_AWLOCK,
   output wire [4-1:0]                      M_AXI_AWCACHE,
   output wire [3-1:0]                      M_AXI_AWPROT,
   output wire [4-1:0]                      M_AXI_AWREGION,
   output wire [4-1:0]                      M_AXI_AWQOS,
   output wire [C_AXI_AWUSER_WIDTH-1:0]     M_AXI_AWUSER,
   output wire                              M_AXI_AWVALID,
   input  wire                              M_AXI_AWREADY,
   // Master Interface Write Data Ports
   output wire [C_M_AXI_DATA_WIDTH-1:0]     M_AXI_WDATA,
   output wire [C_M_AXI_DATA_WIDTH/8-1:0]   M_AXI_WSTRB,
   output wire                              M_AXI_WLAST,
   output wire [C_AXI_WUSER_WIDTH-1:0]      M_AXI_WUSER,
   output wire                              M_AXI_WVALID,
   input  wire                              M_AXI_WREADY,
   // Master Interface Write Response Ports
   input  wire [C_AXI_ID_WIDTH-1:0]         M_AXI_BID,
   input  wire [2-1:0]                      M_AXI_BRESP,
   input  wire [C_AXI_BUSER_WIDTH-1:0]      M_AXI_BUSER,
   input  wire                              M_AXI_BVALID,
   output wire                              M_AXI_BREADY,
   // Master Interface Read Address Port
   output wire [C_AXI_ID_WIDTH-1:0]         M_AXI_ARID,
   output wire [C_AXI_ADDR_WIDTH-1:0]       M_AXI_ARADDR,
   output wire [8-1:0]                      M_AXI_ARLEN,
   output wire [3-1:0]                      M_AXI_ARSIZE,
   output wire [2-1:0]                      M_AXI_ARBURST,
   output wire [2-1:0]                      M_AXI_ARLOCK,
   output wire [4-1:0]                      M_AXI_ARCACHE,
   output wire [3-1:0]                      M_AXI_ARPROT,
   output wire [4-1:0]                      M_AXI_ARREGION,
   output wire [4-1:0]                      M_AXI_ARQOS,
   output wire [C_AXI_ARUSER_WIDTH-1:0]     M_AXI_ARUSER,
   output wire                              M_AXI_ARVALID,
   input  wire                              M_AXI_ARREADY,
   // Master Interface Read Data Ports
   input  wire [C_AXI_ID_WIDTH-1:0]         M_AXI_RID,
   input  wire [C_M_AXI_DATA_WIDTH-1:0]     M_AXI_RDATA,
   input  wire [2-1:0]                      M_AXI_RRESP,
   input  wire                              M_AXI_RLAST,
   input  wire [C_AXI_RUSER_WIDTH-1:0]      M_AXI_RUSER,
   input  wire                              M_AXI_RVALID,
   output wire                              M_AXI_RREADY
   );

   
  /////////////////////////////////////////////////////////////////////////////
  // Functions
  /////////////////////////////////////////////////////////////////////////////
  
  // Log2.
  function integer log2;
    input integer value;
  begin
    for (log2=0; value>1; log2=log2+1) begin
      value = value >> 1;
    end
  end
  endfunction
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Local params
  /////////////////////////////////////////////////////////////////////////////
  
  // Log2 of number of 32bit word on SI-side.
  localparam integer C_S_AXI_BYTES_LOG                = log2(C_S_AXI_DATA_WIDTH/8);
  
  // Log2 of number of 32bit word on MI-side.
  localparam integer C_M_AXI_BYTES_LOG                = log2(C_M_AXI_DATA_WIDTH/8);
  
  // Log2 of Up-Sizing ratio for data.
  localparam integer C_RATIO                          = C_S_AXI_DATA_WIDTH / C_M_AXI_DATA_WIDTH;
  localparam integer C_RATIO_LOG                      = log2(C_RATIO);
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Variables for generating parameter controlled instances.
  /////////////////////////////////////////////////////////////////////////////
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Internal signals
  /////////////////////////////////////////////////////////////////////////////
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Handle Write Channels (AW/W/B)
  /////////////////////////////////////////////////////////////////////////////
  generate
    if (C_AXI_SUPPORTS_WRITE == 1) begin : USE_WRITE
    
      // Write Channel Signals for Commands Queue Interface.
      wire                              wr_cmd_valid;
      wire                              wr_cmd_split;
      wire                              wr_cmd_mirror;
      wire                              wr_cmd_fix;
      wire [C_S_AXI_BYTES_LOG-1:0]      wr_cmd_first_word;
      wire [C_S_AXI_BYTES_LOG-1:0]      wr_cmd_offset;
      wire [C_S_AXI_BYTES_LOG-1:0]      wr_cmd_mask;
      wire [C_M_AXI_BYTES_LOG:0]        wr_cmd_step;
      wire [3-1:0]                      wr_cmd_size;
      wire [8-1:0]                      wr_cmd_length;
      wire                              wr_cmd_ready;
      
      wire                              wr_cmd_b_valid;
      wire                              wr_cmd_b_split;
      wire [4-1:0]                      wr_cmd_b_repeat;
      wire                              wr_cmd_b_ready;
      
      // Write Address Channel.
  axi_interconnect_v1_7_13_a_downsizer #
      (
       .C_FAMILY                    (C_FAMILY),
       .C_AXI_ID_WIDTH              (C_AXI_ID_WIDTH),
       .C_AXI_ADDR_WIDTH            (C_AXI_ADDR_WIDTH),
       .C_S_AXI_DATA_WIDTH          (C_S_AXI_DATA_WIDTH),
       .C_M_AXI_DATA_WIDTH          (C_M_AXI_DATA_WIDTH),
       .C_AXI_SUPPORTS_USER_SIGNALS (C_AXI_SUPPORTS_USER_SIGNALS),
       .C_AXI_AUSER_WIDTH           (C_AXI_AWUSER_WIDTH),
       .C_AXI_CHANNEL               (0),
       .C_SUPPORT_SPLITTING         (C_SUPPORT_SPLITTING),
       .C_SUPPORT_BURSTS            (C_SUPPORT_BURSTS),
       .C_SINGLE_THREAD             (C_SINGLE_THREAD),
       .C_S_AXI_BYTES_LOG           (C_S_AXI_BYTES_LOG),
       .C_M_AXI_BYTES_LOG           (C_M_AXI_BYTES_LOG),
       .C_RATIO_LOG                 (C_RATIO_LOG)
        ) write_addr_inst
       (
        // Global Signals
        .ARESET                     (!ARESETN),
        .ACLK                       (ACLK),
    
        // Command Interface (W)
        .cmd_valid                  (wr_cmd_valid),
        .cmd_split                  (wr_cmd_split),
        .cmd_mirror                 (wr_cmd_mirror),
        .cmd_fix                    (wr_cmd_fix),
        .cmd_first_word             (wr_cmd_first_word),
        .cmd_offset                 (wr_cmd_offset),
        .cmd_mask                   (wr_cmd_mask),
        .cmd_step                   (wr_cmd_step),
        .cmd_size                   (wr_cmd_size),
        .cmd_length                 (wr_cmd_length),
        .cmd_ready                  (wr_cmd_ready),
       
        // Command Interface (B)
        .cmd_b_valid                (wr_cmd_b_valid),
        .cmd_b_split                (wr_cmd_b_split),
        .cmd_b_repeat               (wr_cmd_b_repeat),
        .cmd_b_ready                (wr_cmd_b_ready),
       
        // Slave Interface Write Address Ports
        .S_AXI_AID                  (S_AXI_AWID),
        .S_AXI_AADDR                (S_AXI_AWADDR),
        .S_AXI_ALEN                 (S_AXI_AWLEN),
        .S_AXI_ASIZE                (S_AXI_AWSIZE),
        .S_AXI_ABURST               (S_AXI_AWBURST),
        .S_AXI_ALOCK                (S_AXI_AWLOCK),
        .S_AXI_ACACHE               (S_AXI_AWCACHE),
        .S_AXI_APROT                (S_AXI_AWPROT),
        .S_AXI_AREGION              (S_AXI_AWREGION),
        .S_AXI_AQOS                 (S_AXI_AWQOS),
        .S_AXI_AUSER                (S_AXI_AWUSER),
        .S_AXI_AVALID               (S_AXI_AWVALID),
        .S_AXI_AREADY               (S_AXI_AWREADY),
        
        // Master Interface Write Address Port
        .M_AXI_AID                  (M_AXI_AWID),
        .M_AXI_AADDR                (M_AXI_AWADDR),
        .M_AXI_ALEN                 (M_AXI_AWLEN),
        .M_AXI_ASIZE                (M_AXI_AWSIZE),
        .M_AXI_ABURST               (M_AXI_AWBURST),
        .M_AXI_ALOCK                (M_AXI_AWLOCK),
        .M_AXI_ACACHE               (M_AXI_AWCACHE),
        .M_AXI_APROT                (M_AXI_AWPROT),
        .M_AXI_AREGION              (M_AXI_AWREGION),
        .M_AXI_AQOS                 (M_AXI_AWQOS),
        .M_AXI_AUSER                (M_AXI_AWUSER),
        .M_AXI_AVALID               (M_AXI_AWVALID),
        .M_AXI_AREADY               (M_AXI_AWREADY)
       );
       
      // Write Data channel.
  axi_interconnect_v1_7_13_w_downsizer #
      (
       .C_FAMILY                    (C_FAMILY),
       .C_AXI_ID_WIDTH              (C_AXI_ID_WIDTH),
       .C_S_AXI_DATA_WIDTH          (C_S_AXI_DATA_WIDTH),
       .C_M_AXI_DATA_WIDTH          (C_M_AXI_DATA_WIDTH),
       .C_AXI_SUPPORTS_USER_SIGNALS (C_AXI_SUPPORTS_USER_SIGNALS),
       .C_AXI_WUSER_WIDTH           (C_AXI_WUSER_WIDTH),
       .C_SUPPORT_SPLITTING         (C_SUPPORT_SPLITTING),
       .C_SUPPORT_BURSTS            (C_SUPPORT_BURSTS),
       .C_SINGLE_THREAD             (C_SINGLE_THREAD),
       .C_S_AXI_BYTES_LOG           (C_S_AXI_BYTES_LOG),
       .C_M_AXI_BYTES_LOG           (C_M_AXI_BYTES_LOG),
       .C_RATIO_LOG                 (C_RATIO_LOG)
        ) write_data_inst
       (
        // Global Signals
        .ARESET                     (!ARESETN),
        .ACLK                       (ACLK),
    
        // Command Interface
        .cmd_valid                  (wr_cmd_valid),
        .cmd_mirror                 (wr_cmd_mirror),
        .cmd_fix                    (wr_cmd_fix),
        .cmd_first_word             (wr_cmd_first_word),
        .cmd_offset                 (wr_cmd_offset),
        .cmd_mask                   (wr_cmd_mask),
        .cmd_step                   (wr_cmd_step),
        .cmd_size                   (wr_cmd_size),
        .cmd_length                 (wr_cmd_length),
        .cmd_ready                  (wr_cmd_ready),
       
        // Slave Interface Write Data Ports
        .S_AXI_WDATA                (S_AXI_WDATA),
        .S_AXI_WSTRB                (S_AXI_WSTRB),
        .S_AXI_WLAST                (S_AXI_WLAST),
        .S_AXI_WUSER                (S_AXI_WUSER),
        .S_AXI_WVALID               (S_AXI_WVALID),
        .S_AXI_WREADY               (S_AXI_WREADY),
        
        // Master Interface Write Data Ports
        .M_AXI_WDATA                (M_AXI_WDATA),
        .M_AXI_WSTRB                (M_AXI_WSTRB),
        .M_AXI_WLAST                (M_AXI_WLAST),
        .M_AXI_WUSER                (),
        .M_AXI_WVALID               (M_AXI_WVALID),
        .M_AXI_WREADY               (M_AXI_WREADY)
       );
      
      // Write Response channel.
      if ( C_SUPPORT_SPLITTING == 1 && C_SUPPORT_BURSTS == 1 ) begin : USE_SPLIT
  axi_interconnect_v1_7_13_b_downsizer #
        (
         .C_FAMILY                    (C_FAMILY),
         .C_AXI_ID_WIDTH              (C_AXI_ID_WIDTH),
         .C_AXI_SUPPORTS_USER_SIGNALS (C_AXI_SUPPORTS_USER_SIGNALS),
         .C_AXI_BUSER_WIDTH           (C_AXI_BUSER_WIDTH)
          ) write_resp_inst
         (
          // Global Signals
          .ARESET                     (!ARESETN),
          .ACLK                       (ACLK),
      
          // Command Interface
          .cmd_valid                  (wr_cmd_b_valid),
          .cmd_split                  (wr_cmd_b_split),
          .cmd_repeat                 (wr_cmd_b_repeat),
          .cmd_ready                  (wr_cmd_b_ready),
          
          // Slave Interface Write Response Ports
          .S_AXI_BID                  (S_AXI_BID),
          .S_AXI_BRESP                (S_AXI_BRESP),
          .S_AXI_BUSER                (S_AXI_BUSER),
          .S_AXI_BVALID               (S_AXI_BVALID),
          .S_AXI_BREADY               (S_AXI_BREADY),
          
          // Master Interface Write Response Ports
          .M_AXI_BID                  (M_AXI_BID),
          .M_AXI_BRESP                (M_AXI_BRESP),
          .M_AXI_BUSER                (M_AXI_BUSER),
          .M_AXI_BVALID               (M_AXI_BVALID),
          .M_AXI_BREADY               (M_AXI_BREADY)
         );
        
      end else begin : NO_SPLIT
        assign S_AXI_BID     = M_AXI_BID;
        assign S_AXI_BRESP   = M_AXI_BRESP;
        assign S_AXI_BUSER   = M_AXI_BUSER;
        assign S_AXI_BVALID  = M_AXI_BVALID;
        assign M_AXI_BREADY  = S_AXI_BREADY;
        
      end
    end else begin : NO_WRITE
      // Slave Interface Write Address Ports
      assign S_AXI_AWREADY = 1'b0;
      // Slave Interface Write Data Ports
      assign S_AXI_WREADY  = 1'b0;
      // Slave Interface Write Response Ports
      assign S_AXI_BID     = {C_AXI_ID_WIDTH{1'b0}};
      assign S_AXI_BRESP   = 2'b0;
      assign S_AXI_BUSER   = {C_AXI_BUSER_WIDTH{1'b0}};
      assign S_AXI_BVALID  = 1'b0;
      
      // Master Interface Write Address Port
      assign M_AXI_AWID    = {C_AXI_ID_WIDTH{1'b0}};
      assign M_AXI_AWADDR  = {C_AXI_ADDR_WIDTH{1'b0}};
      assign M_AXI_AWLEN   = 8'b0;
      assign M_AXI_AWSIZE  = 3'b0;
      assign M_AXI_AWBURST = 2'b0;
      assign M_AXI_AWLOCK  = 2'b0;
      assign M_AXI_AWCACHE = 4'b0;
      assign M_AXI_AWPROT  = 3'b0;
      assign M_AXI_AWQOS   = 4'b0;
      assign M_AXI_AWUSER  = {C_AXI_AWUSER_WIDTH{1'b0}};
      assign M_AXI_AWVALID = 1'b0;
      // Master Interface Write Data Ports
      assign M_AXI_WDATA   = {C_M_AXI_DATA_WIDTH{1'b0}};
      assign M_AXI_WSTRB   = {C_M_AXI_DATA_WIDTH/8{1'b0}};
      assign M_AXI_WLAST   = 1'b0;
//      assign M_AXI_WUSER   = {C_AXI_WUSER_WIDTH{1'b0}};
      assign M_AXI_WVALID  = 1'b0;
      // Master Interface Write Response Ports
      assign M_AXI_BREADY  = 1'b0;
      
    end
  endgenerate
  
  assign M_AXI_WUSER   = {C_AXI_WUSER_WIDTH{1'b0}};
  assign S_AXI_RUSER   = {C_AXI_RUSER_WIDTH{1'b0}};
  /////////////////////////////////////////////////////////////////////////////
  // Handle Read Channels (AR/R)
  /////////////////////////////////////////////////////////////////////////////
  generate
    if (C_AXI_SUPPORTS_READ == 1) begin : USE_READ
    
      // Read Channel Signals for Commands Queue Interface.
      wire                              rd_cmd_valid;
      wire                              rd_cmd_split;
      wire                              rd_cmd_mirror;
      wire                              rd_cmd_fix;
      wire [C_S_AXI_BYTES_LOG-1:0]      rd_cmd_first_word;
      wire [C_S_AXI_BYTES_LOG-1:0]      rd_cmd_offset;
      wire [C_S_AXI_BYTES_LOG-1:0]      rd_cmd_mask;
      wire [C_M_AXI_BYTES_LOG:0]        rd_cmd_step;
      wire [3-1:0]                      rd_cmd_size;
      wire [8-1:0]                      rd_cmd_length;
      wire                              rd_cmd_ready;
      
      // Write Address Channel.
  axi_interconnect_v1_7_13_a_downsizer #
      (
       .C_FAMILY                    (C_FAMILY),
       .C_AXI_ID_WIDTH              (C_AXI_ID_WIDTH),
       .C_AXI_ADDR_WIDTH            (C_AXI_ADDR_WIDTH),
       .C_S_AXI_DATA_WIDTH          (C_S_AXI_DATA_WIDTH),
       .C_M_AXI_DATA_WIDTH          (C_M_AXI_DATA_WIDTH),
       .C_AXI_SUPPORTS_USER_SIGNALS (C_AXI_SUPPORTS_USER_SIGNALS),
       .C_AXI_AUSER_WIDTH           (C_AXI_ARUSER_WIDTH),
       .C_AXI_CHANNEL               (1),
       .C_SUPPORT_SPLITTING         (C_SUPPORT_SPLITTING),
       .C_SUPPORT_BURSTS            (C_SUPPORT_BURSTS),
       .C_SINGLE_THREAD             (C_SINGLE_THREAD),
       .C_S_AXI_BYTES_LOG           (C_S_AXI_BYTES_LOG),
       .C_M_AXI_BYTES_LOG           (C_M_AXI_BYTES_LOG),
       .C_RATIO_LOG                 (C_RATIO_LOG)
        ) read_addr_inst
       (
        // Global Signals
        .ARESET                     (!ARESETN),
        .ACLK                       (ACLK),
    
        // Command Interface (R)
        .cmd_valid                  (rd_cmd_valid),
        .cmd_split                  (rd_cmd_split),
        .cmd_mirror                 (rd_cmd_mirror),
        .cmd_fix                    (rd_cmd_fix),
        .cmd_first_word             (rd_cmd_first_word),
        .cmd_offset                 (rd_cmd_offset),
        .cmd_mask                   (rd_cmd_mask),
        .cmd_step                   (rd_cmd_step),
        .cmd_size                   (rd_cmd_size),
        .cmd_length                 (rd_cmd_length),
        .cmd_ready                  (rd_cmd_ready),
       
        // Command Interface (B)
        .cmd_b_valid                (),
        .cmd_b_split                (),
        .cmd_b_repeat               (),
        .cmd_b_ready                (1'b0),
       
        // Slave Interface Write Address Ports
        .S_AXI_AID                  (S_AXI_ARID),
        .S_AXI_AADDR                (S_AXI_ARADDR),
        .S_AXI_ALEN                 (S_AXI_ARLEN),
        .S_AXI_ASIZE                (S_AXI_ARSIZE),
        .S_AXI_ABURST               (S_AXI_ARBURST),
        .S_AXI_ALOCK                (S_AXI_ARLOCK),
        .S_AXI_ACACHE               (S_AXI_ARCACHE),
        .S_AXI_APROT                (S_AXI_ARPROT),
        .S_AXI_AREGION              (S_AXI_ARREGION),
        .S_AXI_AQOS                 (S_AXI_ARQOS),
        .S_AXI_AUSER                (S_AXI_ARUSER),
        .S_AXI_AVALID               (S_AXI_ARVALID),
        .S_AXI_AREADY               (S_AXI_ARREADY),
        
        // Master Interface Write Address Port
        .M_AXI_AID                  (M_AXI_ARID),
        .M_AXI_AADDR                (M_AXI_ARADDR),
        .M_AXI_ALEN                 (M_AXI_ARLEN),
        .M_AXI_ASIZE                (M_AXI_ARSIZE),
        .M_AXI_ABURST               (M_AXI_ARBURST),
        .M_AXI_ALOCK                (M_AXI_ARLOCK),
        .M_AXI_ACACHE               (M_AXI_ARCACHE),
        .M_AXI_APROT                (M_AXI_ARPROT),
        .M_AXI_AREGION              (M_AXI_ARREGION),
        .M_AXI_AQOS                 (M_AXI_ARQOS),
        .M_AXI_AUSER                (M_AXI_ARUSER),
        .M_AXI_AVALID               (M_AXI_ARVALID),
        .M_AXI_AREADY               (M_AXI_ARREADY)
       );
       
      // Read Data channel.
  axi_interconnect_v1_7_13_r_downsizer #
      (
       .C_FAMILY                    (C_FAMILY),
       .C_AXI_ID_WIDTH              (C_AXI_ID_WIDTH),
       .C_S_AXI_DATA_WIDTH          (C_S_AXI_DATA_WIDTH),
       .C_M_AXI_DATA_WIDTH          (C_M_AXI_DATA_WIDTH),
       .C_AXI_SUPPORTS_USER_SIGNALS (C_AXI_SUPPORTS_USER_SIGNALS),
       .C_AXI_RUSER_WIDTH           (C_AXI_RUSER_WIDTH),
       .C_SUPPORT_SPLITTING         (C_SUPPORT_SPLITTING),
       .C_SUPPORT_BURSTS            (C_SUPPORT_BURSTS),
       .C_SINGLE_THREAD             (C_SINGLE_THREAD),
       .C_S_AXI_BYTES_LOG           (C_S_AXI_BYTES_LOG),
       .C_M_AXI_BYTES_LOG           (C_M_AXI_BYTES_LOG),
       .C_RATIO_LOG                 (C_RATIO_LOG)
        ) read_data_inst
       (
        // Global Signals
        .ARESET                     (!ARESETN),
        .ACLK                       (ACLK),
    
        // Command Interface
        .cmd_valid                  (rd_cmd_valid),
        .cmd_split                  (rd_cmd_split),
        .cmd_mirror                 (rd_cmd_mirror),
        .cmd_fix                    (rd_cmd_fix),
        .cmd_first_word             (rd_cmd_first_word),
        .cmd_offset                 (rd_cmd_offset),
        .cmd_mask                   (rd_cmd_mask),
        .cmd_step                   (rd_cmd_step),
        .cmd_size                   (rd_cmd_size),
        .cmd_length                 (rd_cmd_length),
        .cmd_ready                  (rd_cmd_ready),
       
        // Slave Interface Read Data Ports
        .S_AXI_RID                  (S_AXI_RID),
        .S_AXI_RDATA                (S_AXI_RDATA),
        .S_AXI_RRESP                (S_AXI_RRESP),
        .S_AXI_RLAST                (S_AXI_RLAST),
        .S_AXI_RUSER                (),
        .S_AXI_RVALID               (S_AXI_RVALID),
        .S_AXI_RREADY               (S_AXI_RREADY),
        
        // Master Interface Read Data Ports
        .M_AXI_RID                  (M_AXI_RID),
        .M_AXI_RDATA                (M_AXI_RDATA),
        .M_AXI_RRESP                (M_AXI_RRESP),
        .M_AXI_RLAST                (M_AXI_RLAST),
        .M_AXI_RUSER                (M_AXI_RUSER),
        .M_AXI_RVALID               (M_AXI_RVALID),
        .M_AXI_RREADY               (M_AXI_RREADY)
       );
       
    end else begin : NO_READ
      // Slave Interface Read Address Ports
      assign S_AXI_ARREADY = 1'b0;
      // Slave Interface Read Data Ports
      assign S_AXI_RID     = {C_AXI_ID_WIDTH{1'b0}};
      assign S_AXI_RDATA   = {C_S_AXI_DATA_WIDTH{1'b0}};
      assign S_AXI_RRESP   = 2'b0;
      assign S_AXI_RLAST   = 1'b0;
//      assign S_AXI_RUSER   = {C_AXI_RUSER_WIDTH{1'b0}};
      assign S_AXI_RVALID  = 1'b0;
      
      // Master Interface Read Address Port
      assign M_AXI_ARID    = {C_AXI_ID_WIDTH{1'b0}};
      assign M_AXI_ARADDR  = {C_AXI_ADDR_WIDTH{1'b0}};
      assign M_AXI_ARLEN   = 8'b0;
      assign M_AXI_ARSIZE  = 3'b0;
      assign M_AXI_ARBURST = 2'b0;
      assign M_AXI_ARLOCK  = 2'b0;
      assign M_AXI_ARCACHE = 4'b0;
      assign M_AXI_ARPROT  = 3'b0;
      assign M_AXI_ARQOS   = 4'b0;
      assign M_AXI_ARUSER  = {C_AXI_ARUSER_WIDTH{1'b0}};
      assign M_AXI_ARVALID = 1'b0;
      // Master Interface Read Data Ports
      assign M_AXI_RREADY  = 1'b0;
      
    end
  endgenerate
  
  
endmodule


// -- (c) Copyright 2010 - 2011 Xilinx, Inc. All rights reserved.
// --
// -- This file contains confidential and proprietary information
// -- of Xilinx, Inc. and is protected under U.S. and 
// -- international copyright and other intellectual property
// -- laws.
// --
// -- DISCLAIMER
// -- This disclaimer is not a license and does not grant any
// -- rights to the materials distributed herewith. Except as
// -- otherwise provided in a valid license issued to you by
// -- Xilinx, and to the maximum extent permitted by applicable
// -- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
// -- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
// -- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
// -- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
// -- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
// -- (2) Xilinx shall not be liable (whether in contract or tort,
// -- including negligence, or under any other theory of
// -- liability) for any loss or damage of any kind or nature
// -- related to, arising under or in connection with these
// -- materials, including for any direct, or any indirect,
// -- special, incidental, or consequential loss or damage
// -- (including loss of data, profits, goodwill, or any type of
// -- loss or damage suffered as a result of any action brought
// -- by a third party) even if such damage or loss was
// -- reasonably foreseeable or Xilinx had been advised of the
// -- possibility of the same.
// --
// -- CRITICAL APPLICATIONS
// -- Xilinx products are not designed or intended to be fail-
// -- safe, or for use in any application requiring fail-safe
// -- performance, such as life-support or safety devices or
// -- systems, Class III medical devices, nuclear facilities,
// -- applications related to the deployment of airbags, or any
// -- other applications that could lead to death, personal
// -- injury, or severe property or environmental damage
// -- (individually and collectively, "Critical
// -- Applications"). Customer assumes the sole risk and
// -- liability of any use of Xilinx products in Critical
// -- Applications, subject only to applicable laws and
// -- regulations governing limitations on product liability.
// --
// -- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
// -- PART OF THIS FILE AT ALL TIMES.
//-----------------------------------------------------------------------------
//
// Description: AxiLite Slave Conversion
//
// Verilog-standard:  Verilog 2001
//--------------------------------------------------------------------------
//
// Structure:
//   axilite_conv
//
//--------------------------------------------------------------------------
`timescale 1ps/1ps

(* DowngradeIPIdentifiedWarnings="yes" *) 
module axi_interconnect_v1_7_13_axilite_conv #
  (
   parameter         C_FAMILY                    = "virtex6",
   parameter integer C_AXI_ID_WIDTH              = 4,
   parameter integer C_AXI_ADDR_WIDTH            = 32,
   parameter integer C_AXI_DATA_WIDTH            = 32, // CONSTANT
   parameter integer C_AXI_SUPPORTS_WRITE        = 1,
   parameter integer C_AXI_SUPPORTS_READ         = 1,
   parameter integer C_AXI_AWUSER_WIDTH               = 1,
   parameter integer C_AXI_ARUSER_WIDTH               = 1,
   parameter integer C_AXI_WUSER_WIDTH                = 1,
   parameter integer C_AXI_RUSER_WIDTH                = 1,
   parameter integer C_AXI_BUSER_WIDTH                = 1
   )
  (
   // System Signals
   input  wire                          ACLK,
   input  wire                          ARESETN,
   // Slave Interface Write Address Ports
   input  wire [C_AXI_ID_WIDTH-1:0]     S_AXI_AWID,
   input  wire [C_AXI_ADDR_WIDTH-1:0]   S_AXI_AWADDR,
   input  wire [3-1:0]                  S_AXI_AWPROT,
   input  wire                          S_AXI_AWVALID,
   output wire                          S_AXI_AWREADY,
   // Slave Interface Write Data Ports
   input  wire [C_AXI_DATA_WIDTH-1:0]   S_AXI_WDATA,
   input  wire [C_AXI_DATA_WIDTH/8-1:0] S_AXI_WSTRB,
   input  wire                          S_AXI_WVALID,
   output wire                          S_AXI_WREADY,
   // Slave Interface Write Response Ports
   output wire [C_AXI_ID_WIDTH-1:0]     S_AXI_BID,
   output wire [2-1:0]                  S_AXI_BRESP,
   output wire [C_AXI_BUSER_WIDTH-1:0]  S_AXI_BUSER,
   output wire                          S_AXI_BVALID,
   input  wire                          S_AXI_BREADY,
   // Slave Interface Read Address Ports
   input  wire [C_AXI_ID_WIDTH-1:0]     S_AXI_ARID,
   input  wire [C_AXI_ADDR_WIDTH-1:0]   S_AXI_ARADDR,
   input  wire [3-1:0]                  S_AXI_ARPROT,
   input  wire                          S_AXI_ARVALID,
   output wire                          S_AXI_ARREADY,
   // Slave Interface Read Data Ports
   output wire [C_AXI_ID_WIDTH-1:0]     S_AXI_RID,
   output wire [C_AXI_DATA_WIDTH-1:0]   S_AXI_RDATA,
   output wire [2-1:0]                  S_AXI_RRESP,
   output wire                          S_AXI_RLAST,    // Constant =1
   output wire [C_AXI_RUSER_WIDTH-1:0]  S_AXI_RUSER,
   output wire                          S_AXI_RVALID,
   input  wire                          S_AXI_RREADY,
   
   // Master Interface Write Address Port
   output wire [C_AXI_ID_WIDTH-1:0]     M_AXI_AWID,     // Constant =0
   output wire [C_AXI_ADDR_WIDTH-1:0]   M_AXI_AWADDR,
   output wire [8-1:0]                  M_AXI_AWLEN,    // Constant =0
   output wire [3-1:0]                  M_AXI_AWSIZE,   // Constant ='b010
   output wire [2-1:0]                  M_AXI_AWBURST,  // Constant =0
   output wire [2-1:0]                  M_AXI_AWLOCK,   // Constant =0
   output wire [4-1:0]                  M_AXI_AWCACHE,  // Constant =0
   output wire [3-1:0]                  M_AXI_AWPROT,
   output wire [4-1:0]                  M_AXI_AWREGION, // Constant =0
   output wire [4-1:0]                  M_AXI_AWQOS,    // Constant =0
   output wire [C_AXI_AWUSER_WIDTH-1:0] M_AXI_AWUSER,
   output wire                          M_AXI_AWVALID,
   input  wire                          M_AXI_AWREADY,
   // Master Interface Write Data Ports
   output wire [C_AXI_ID_WIDTH-1:0]     M_AXI_WID,      // Constant =0
   output wire [C_AXI_DATA_WIDTH-1:0]   M_AXI_WDATA,
   output wire [C_AXI_DATA_WIDTH/8-1:0] M_AXI_WSTRB,
   output wire                          M_AXI_WLAST,    // Constant =1
   output wire [C_AXI_WUSER_WIDTH-1:0]  M_AXI_WUSER,
   output wire                          M_AXI_WVALID,
   input  wire                          M_AXI_WREADY,
   // Master Interface Write Response Ports
   input  wire [2-1:0]                  M_AXI_BRESP,
   input  wire                          M_AXI_BVALID,
   output wire                          M_AXI_BREADY,
   // Master Interface Read Address Port
   output wire [C_AXI_ID_WIDTH-1:0]     M_AXI_ARID,     // Constant =0
   output wire [C_AXI_ADDR_WIDTH-1:0]   M_AXI_ARADDR,
   output wire [8-1:0]                  M_AXI_ARLEN,    // Constant =0
   output wire [3-1:0]                  M_AXI_ARSIZE,   // Constant ='b010
   output wire [2-1:0]                  M_AXI_ARBURST,  // Constant =0
   output wire [2-1:0]                  M_AXI_ARLOCK,   // Constant =0
   output wire [4-1:0]                  M_AXI_ARCACHE,  // Constant =0
   output wire [3-1:0]                  M_AXI_ARPROT,
   output wire [4-1:0]                  M_AXI_ARREGION, // Constant =0
   output wire [4-1:0]                  M_AXI_ARQOS,    // Constant =0
   output wire [C_AXI_ARUSER_WIDTH-1:0] M_AXI_ARUSER,
   output wire                          M_AXI_ARVALID,
   input  wire                          M_AXI_ARREADY,
   // Master Interface Read Data Ports
   input  wire [C_AXI_DATA_WIDTH-1:0]   M_AXI_RDATA,
   input  wire [2-1:0]                  M_AXI_RRESP,
   input  wire                          M_AXI_RVALID,
   output wire                          M_AXI_RREADY
  );

  localparam P_AXILITE_SIZE = 3'b010;
  localparam P_INCR = 2'b01;
  
  wire s_awvalid_i;
  wire s_arvalid_i;
  wire [31:0] m_axaddr;

  // Arbiter
  reg read_active;
  reg write_active;
  reg busy;

  wire read_req;
  wire write_req;
  wire read_complete;
  wire write_complete;
  
  reg [1:0] areset_d; // Reset delay register
  always @(posedge ACLK) begin
    areset_d <= {areset_d[0], ~ARESETN};
  end
  
  assign s_awvalid_i = S_AXI_AWVALID & (C_AXI_SUPPORTS_WRITE != 0);
  assign s_arvalid_i = S_AXI_ARVALID & (C_AXI_SUPPORTS_READ != 0);

  assign read_req  = s_arvalid_i & ~write_active & ~busy & ~|areset_d;
  assign write_req = (s_awvalid_i & ~read_active & ~busy & ~S_AXI_ARVALID & ~|areset_d) | (write_active & ~busy);

  assign read_complete  = M_AXI_RVALID & S_AXI_RREADY;
  assign write_complete = M_AXI_BVALID & S_AXI_BREADY;

  always @(posedge ACLK) begin : arbiter_read_ff
    if (~ARESETN)
      read_active <= 1'b0;
    else if (read_complete)
      read_active <= 1'b0;
    else if (read_req)
      read_active <= 1'b1;
  end

  always @(posedge ACLK) begin : arbiter_write_ff
    if (~ARESETN)
      write_active <= 1'b0;
    else if (write_complete)
      write_active <= 1'b0;
    else if (write_req)
      write_active <= 1'b1;
  end

  always @(posedge ACLK) begin : arbiter_busy_ff
    if (~ARESETN)
      busy <= 1'b0;
    else if (read_complete | write_complete)
      busy <= 1'b0;
    else if ((s_awvalid_i & M_AXI_AWREADY & ~read_req) | (s_arvalid_i & M_AXI_ARREADY & ~write_req))
      busy <= 1'b1;
  end

  assign M_AXI_ARVALID = read_req;
  assign S_AXI_ARREADY = M_AXI_ARREADY & read_req;

  assign M_AXI_AWVALID = write_req;
  assign S_AXI_AWREADY = M_AXI_AWREADY & write_req;

  assign M_AXI_RREADY  = S_AXI_RREADY & read_active;
  assign S_AXI_RVALID  = M_AXI_RVALID & read_active;

  assign M_AXI_BREADY  = S_AXI_BREADY & write_active;
  assign S_AXI_BVALID  = M_AXI_BVALID & write_active;

  // Address multiplexer
  assign m_axaddr = (read_req | (C_AXI_SUPPORTS_WRITE == 0)) ? S_AXI_ARADDR : S_AXI_AWADDR;

  // Id multiplexer and flip-flop
  reg [C_AXI_ID_WIDTH-1:0] s_axid;

  always @(posedge ACLK) begin : axid
    if      (~ARESETN)    s_axid <= {C_AXI_ID_WIDTH{1'b0}};
    else if (read_req)  s_axid <= S_AXI_ARID;
    else if (write_req) s_axid <= S_AXI_AWID;
  end

  assign S_AXI_BID = s_axid;
  assign S_AXI_RID = s_axid;

  assign M_AXI_AWADDR = m_axaddr;
  assign M_AXI_ARADDR = m_axaddr;


  // Feed-through signals
  assign S_AXI_WREADY   = M_AXI_WREADY & ~|areset_d;
  assign S_AXI_BRESP    = M_AXI_BRESP;
  assign S_AXI_RDATA    = M_AXI_RDATA;
  assign S_AXI_RRESP    = M_AXI_RRESP;
  assign S_AXI_RLAST    = 1'b1;

  assign M_AXI_AWID     = {C_AXI_ID_WIDTH{1'b0}};
  assign M_AXI_AWLEN    = 8'b0;
  assign M_AXI_AWSIZE   = P_AXILITE_SIZE;
  assign M_AXI_AWBURST  = P_INCR;
  assign M_AXI_AWLOCK   = 2'b0;
  assign M_AXI_AWCACHE  = 4'b0;
  assign M_AXI_AWPROT   = S_AXI_AWPROT;
  assign M_AXI_AWREGION = 4'b0;
  assign M_AXI_AWQOS    = 4'b0;
  assign M_AXI_WVALID   = S_AXI_WVALID & ~|areset_d;
  assign M_AXI_WID      = {C_AXI_ID_WIDTH{1'b0}};
  assign M_AXI_WDATA    = S_AXI_WDATA;
  assign M_AXI_WSTRB    = S_AXI_WSTRB;
  assign M_AXI_WLAST    = 1'b1;
  assign M_AXI_ARID     = {C_AXI_ID_WIDTH{1'b0}};
  assign M_AXI_ARLEN    = 8'b0;
  assign M_AXI_ARSIZE   = P_AXILITE_SIZE;
  assign M_AXI_ARBURST  = P_INCR;
  assign M_AXI_ARLOCK   = 2'b0;
  assign M_AXI_ARCACHE  = 4'b0;
  assign M_AXI_ARPROT   = S_AXI_ARPROT;
  assign M_AXI_ARREGION = 4'b0;
  assign M_AXI_ARQOS    = 4'b0;
  assign S_AXI_BUSER    = {C_AXI_BUSER_WIDTH{1'b0}};
  assign S_AXI_RUSER    = {C_AXI_RUSER_WIDTH{1'b0}};
  assign M_AXI_AWUSER   = {C_AXI_AWUSER_WIDTH{1'b0}};
  assign M_AXI_WUSER    = {C_AXI_WUSER_WIDTH{1'b0}};
  assign M_AXI_ARUSER   = {C_AXI_ARUSER_WIDTH{1'b0}};

endmodule


// -- (c) Copyright 2011 Xilinx, Inc. All rights reserved.
// --
// -- This file contains confidential and proprietary information
// -- of Xilinx, Inc. and is protected under U.S. and 
// -- international copyright and other intellectual property
// -- laws.
// --
// -- DISCLAIMER
// -- This disclaimer is not a license and does not grant any
// -- rights to the materials distributed herewith. Except as
// -- otherwise provided in a valid license issued to you by
// -- Xilinx, and to the maximum extent permitted by applicable
// -- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
// -- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
// -- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
// -- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
// -- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
// -- (2) Xilinx shall not be liable (whether in contract or tort,
// -- including negligence, or under any other theory of
// -- liability) for any loss or damage of any kind or nature
// -- related to, arising under or in connection with these
// -- materials, including for any direct, or any indirect,
// -- special, incidental, or consequential loss or damage
// -- (including loss of data, profits, goodwill, or any type of
// -- loss or damage suffered as a result of any action brought
// -- by a third party) even if such damage or loss was
// -- reasonably foreseeable or Xilinx had been advised of the
// -- possibility of the same.
// --
// -- CRITICAL APPLICATIONS
// -- Xilinx products are not designed or intended to be fail-
// -- safe, or for use in any application requiring fail-safe
// -- performance, such as life-support or safety devices or
// -- systems, Class III medical devices, nuclear facilities,
// -- applications related to the deployment of airbags, or any
// -- other applications that could lead to death, personal
// -- injury, or severe property or environmental damage
// -- (individually and collectively, "Critical
// -- Applications"). Customer assumes the sole risk and
// -- liability of any use of Xilinx products in Critical
// -- Applications, subject only to applicable laws and
// -- regulations governing limitations on product liability.
// --
// -- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
// -- PART OF THIS FILE AT ALL TIMES.
//-----------------------------------------------------------------------------
//
// File name: axi_protocol_converter.v
//
// Description: 
//   This module is a bank of AXI4-Lite and AXI3 protocol converters for a vectored AXI interface.
//   The interface of this module consists of a vectored slave and master interface
//     which are each concatenations of upper-level AXI pathways,
//     plus various vectored parameters.
//   This module instantiates a set of individual protocol converter modules.
//
//-----------------------------------------------------------------------------
`timescale 1ps/1ps
`default_nettype none

(* DowngradeIPIdentifiedWarnings="yes" *) 
module axi_interconnect_v1_7_13_axi_protocol_converter #(
  parameter         C_FAMILY                    = "virtex6",
  parameter         C_AXI_PROTOCOL              = 0, 
  parameter integer C_IGNORE_RID               = 0,
                     // 1 = RID/BID are stored within SASD crossbar.
                     // 0 = RID/BID must be stored by axilite_conv.
  parameter integer C_AXI_ID_WIDTH              = 4,
  parameter integer C_AXI_ADDR_WIDTH            = 32,
  parameter integer C_AXI_DATA_WIDTH            = 32,
  parameter integer C_AXI_SUPPORTS_WRITE        = 1,
  parameter integer C_AXI_SUPPORTS_READ         = 1,
  parameter integer C_AXI_SUPPORTS_USER_SIGNALS = 0,
                     // 1 = Propagate all USER signals, 0 = Dont propagate.
  parameter integer C_AXI_AWUSER_WIDTH          = 1,
  parameter integer C_AXI_ARUSER_WIDTH          = 1,
  parameter integer C_AXI_WUSER_WIDTH           = 1,
  parameter integer C_AXI_RUSER_WIDTH           = 1,
  parameter integer C_AXI_BUSER_WIDTH           = 1,
  parameter integer C_AXI3_BYPASS               = 0
) (
  // Global Signals
  input  wire                                 ACLK,
  input  wire                                 ARESETN,
  // Slave Interface Write Address Ports
  input  wire [C_AXI_ID_WIDTH-1:0]            S_AXI_AWID,
  input  wire [C_AXI_ADDR_WIDTH-1:0]          S_AXI_AWADDR,
  input  wire [8-1:0]                         S_AXI_AWLEN,
  input  wire [3-1:0]                         S_AXI_AWSIZE,
  input  wire [2-1:0]                         S_AXI_AWBURST,
  input  wire [2-1:0]                         S_AXI_AWLOCK,
  input  wire [4-1:0]                         S_AXI_AWCACHE,
  input  wire [3-1:0]                         S_AXI_AWPROT,
  input  wire [4-1:0]                         S_AXI_AWREGION,
  input  wire [4-1:0]                         S_AXI_AWQOS,
  input  wire [C_AXI_AWUSER_WIDTH-1:0]        S_AXI_AWUSER,
  input  wire                                 S_AXI_AWVALID,
  output wire                                 S_AXI_AWREADY,
  // Slave Interface Write Data Ports
  input  wire [C_AXI_ID_WIDTH-1:0]            S_AXI_WID,
  input  wire [C_AXI_DATA_WIDTH-1:0]          S_AXI_WDATA,
  input  wire [C_AXI_DATA_WIDTH/8-1:0]        S_AXI_WSTRB,
  input  wire                                 S_AXI_WLAST,
  input  wire [C_AXI_WUSER_WIDTH-1:0]         S_AXI_WUSER,
  input  wire                                 S_AXI_WVALID,
  output wire                                 S_AXI_WREADY,
  // Slave Interface Write Response Ports
  output wire [C_AXI_ID_WIDTH-1:0]            S_AXI_BID,
  output wire [2-1:0]                         S_AXI_BRESP,
  output wire [C_AXI_BUSER_WIDTH-1:0]         S_AXI_BUSER,
  output wire                                 S_AXI_BVALID,
  input  wire                                 S_AXI_BREADY,
  // Slave Interface Read Address Ports
  input  wire [C_AXI_ID_WIDTH-1:0]            S_AXI_ARID,
  input  wire [C_AXI_ADDR_WIDTH-1:0]          S_AXI_ARADDR,
  input  wire [8-1:0]                         S_AXI_ARLEN,
  input  wire [3-1:0]                         S_AXI_ARSIZE,
  input  wire [2-1:0]                         S_AXI_ARBURST,
  input  wire [2-1:0]                         S_AXI_ARLOCK,
  input  wire [4-1:0]                         S_AXI_ARCACHE,
  input  wire [3-1:0]                         S_AXI_ARPROT,
  input  wire [4-1:0]                         S_AXI_ARREGION,
  input  wire [4-1:0]                         S_AXI_ARQOS,
  input  wire [C_AXI_ARUSER_WIDTH-1:0]        S_AXI_ARUSER,
  input  wire                                 S_AXI_ARVALID,
  output wire                                 S_AXI_ARREADY,
  // Slave Interface Read Data Ports
  output wire [C_AXI_ID_WIDTH-1:0]            S_AXI_RID,
  output wire [C_AXI_DATA_WIDTH-1:0]          S_AXI_RDATA,
  output wire [2-1:0]                         S_AXI_RRESP,
  output wire                                 S_AXI_RLAST,
  output wire [C_AXI_RUSER_WIDTH-1:0]         S_AXI_RUSER,
  output wire                                 S_AXI_RVALID,
  input  wire                                 S_AXI_RREADY,
  // Master Interface Write Address Port
  output wire [C_AXI_ID_WIDTH-1:0]            M_AXI_AWID,
  output wire [C_AXI_ADDR_WIDTH-1:0]          M_AXI_AWADDR,
  output wire [8-1:0]                         M_AXI_AWLEN,
  output wire [3-1:0]                         M_AXI_AWSIZE,
  output wire [2-1:0]                         M_AXI_AWBURST,
  output wire [2-1:0]                         M_AXI_AWLOCK,
  output wire [4-1:0]                         M_AXI_AWCACHE,
  output wire [3-1:0]                         M_AXI_AWPROT,
  output wire [4-1:0]                         M_AXI_AWREGION,
  output wire [4-1:0]                         M_AXI_AWQOS,
  output wire [C_AXI_AWUSER_WIDTH-1:0]        M_AXI_AWUSER,
  output wire                                 M_AXI_AWVALID,
  input  wire                                 M_AXI_AWREADY,
  // Master Interface Write Data Ports
  output wire [C_AXI_ID_WIDTH-1:0]            M_AXI_WID,
  output wire [C_AXI_DATA_WIDTH-1:0]          M_AXI_WDATA,
  output wire [C_AXI_DATA_WIDTH/8-1:0]        M_AXI_WSTRB,
  output wire                                 M_AXI_WLAST,
  output wire [C_AXI_WUSER_WIDTH-1:0]         M_AXI_WUSER,
  output wire                                 M_AXI_WVALID,
  input  wire                                 M_AXI_WREADY,
  // Master Interface Write Response Ports
  input  wire [C_AXI_ID_WIDTH-1:0]            M_AXI_BID,
  input  wire [2-1:0]                         M_AXI_BRESP,
  input  wire [C_AXI_BUSER_WIDTH-1:0]         M_AXI_BUSER,
  input  wire                                 M_AXI_BVALID,
  output wire                                 M_AXI_BREADY,
  // Master Interface Read Address Port
  output wire [C_AXI_ID_WIDTH-1:0]            M_AXI_ARID,
  output wire [C_AXI_ADDR_WIDTH-1:0]          M_AXI_ARADDR,
  output wire [8-1:0]                         M_AXI_ARLEN,
  output wire [3-1:0]                         M_AXI_ARSIZE,
  output wire [2-1:0]                         M_AXI_ARBURST,
  output wire [2-1:0]                         M_AXI_ARLOCK,
  output wire [4-1:0]                         M_AXI_ARCACHE,
  output wire [3-1:0]                         M_AXI_ARPROT,
  output wire [4-1:0]                         M_AXI_ARREGION,
  output wire [4-1:0]                         M_AXI_ARQOS,
  output wire [C_AXI_ARUSER_WIDTH-1:0]        M_AXI_ARUSER,
  output wire                                 M_AXI_ARVALID,
  input  wire                                 M_AXI_ARREADY,
  // Master Interface Read Data Ports
  input  wire [C_AXI_ID_WIDTH-1:0]            M_AXI_RID,
  input  wire [C_AXI_DATA_WIDTH-1:0]          M_AXI_RDATA,
  input  wire [2-1:0]                         M_AXI_RRESP,
  input  wire                                 M_AXI_RLAST,
  input  wire [C_AXI_RUSER_WIDTH-1:0]         M_AXI_RUSER,
  input  wire                                 M_AXI_RVALID,
  output wire                                 M_AXI_RREADY
);

localparam P_AXI3 = 32'h1;
localparam P_AXILITE = 32'h2;
localparam P_AXILITE_SIZE = 3'b010;
localparam P_INCR = 2'b01;

generate
  if (C_AXI_PROTOCOL == P_AXILITE) begin : gen_axilite
    if (C_IGNORE_RID) begin : gen_axilite_passthru
      assign M_AXI_AWID         = 0;
      assign M_AXI_AWADDR       = S_AXI_AWADDR;
      assign M_AXI_AWLEN        = 0;
      assign M_AXI_AWSIZE       = P_AXILITE_SIZE;
      assign M_AXI_AWBURST      = P_INCR;
      assign M_AXI_AWLOCK       = 0;
      assign M_AXI_AWCACHE      = 0;
      assign M_AXI_AWPROT       = S_AXI_AWPROT;
      assign M_AXI_AWREGION     = 0;
      assign M_AXI_AWQOS        = 0;
      assign M_AXI_AWUSER       = 0;
      assign M_AXI_AWVALID      = S_AXI_AWVALID;
      assign S_AXI_AWREADY      = M_AXI_AWREADY;
      assign M_AXI_WID          = 0;
      assign M_AXI_WDATA        = S_AXI_WDATA;
      assign M_AXI_WSTRB        = S_AXI_WSTRB;
      assign M_AXI_WLAST        = 1'b1;
      assign M_AXI_WUSER        = 0;
      assign M_AXI_WVALID       = S_AXI_WVALID;
      assign S_AXI_WREADY       = M_AXI_WREADY;
      assign S_AXI_BID          = 0;
      assign S_AXI_BRESP        = M_AXI_BRESP;
      assign S_AXI_BUSER        = 0;
      assign S_AXI_BVALID       = M_AXI_BVALID;
      assign M_AXI_BREADY       = S_AXI_BREADY;
      assign M_AXI_ARID         = 0;
      assign M_AXI_ARADDR       = S_AXI_ARADDR;
      assign M_AXI_ARLEN        = 0;
      assign M_AXI_ARSIZE       = P_AXILITE_SIZE;
      assign M_AXI_ARBURST      = P_INCR;
      assign M_AXI_ARLOCK       = 0;
      assign M_AXI_ARCACHE      = 0;
      assign M_AXI_ARPROT       = S_AXI_ARPROT;
      assign M_AXI_ARREGION     = 0;
      assign M_AXI_ARQOS        = 0;
      assign M_AXI_ARUSER       = 0;
      assign M_AXI_ARVALID      = S_AXI_ARVALID;
      assign S_AXI_ARREADY      = M_AXI_ARREADY;
      assign S_AXI_RID          = 0;
      assign S_AXI_RDATA        = M_AXI_RDATA;
      assign S_AXI_RRESP        = M_AXI_RRESP;
      assign S_AXI_RLAST        = 1'b1;
      assign S_AXI_RUSER          = 0;
      assign S_AXI_RVALID       = M_AXI_RVALID;
      assign M_AXI_RREADY       = S_AXI_RREADY;
    end else begin : gen_axilite_conv
  axi_interconnect_v1_7_13_axilite_conv #(
        .C_FAMILY                         (C_FAMILY),
        .C_AXI_ID_WIDTH                   (C_AXI_ID_WIDTH),
        .C_AXI_ADDR_WIDTH                 (C_AXI_ADDR_WIDTH),
        .C_AXI_DATA_WIDTH                 (C_AXI_DATA_WIDTH),
        .C_AXI_SUPPORTS_WRITE             (C_AXI_SUPPORTS_WRITE),
        .C_AXI_SUPPORTS_READ              (C_AXI_SUPPORTS_READ),
        .C_AXI_AWUSER_WIDTH               (C_AXI_AWUSER_WIDTH),
        .C_AXI_ARUSER_WIDTH               (C_AXI_ARUSER_WIDTH),
        .C_AXI_WUSER_WIDTH                (C_AXI_WUSER_WIDTH),
        .C_AXI_RUSER_WIDTH                (C_AXI_RUSER_WIDTH),
        .C_AXI_BUSER_WIDTH                (C_AXI_BUSER_WIDTH)
      ) axilite_conv_inst (
        .ARESETN                          (ARESETN),
        .ACLK                             (ACLK),
        .S_AXI_AWID                       (S_AXI_AWID),
        .S_AXI_AWADDR                     (S_AXI_AWADDR),
        .S_AXI_AWPROT                     (S_AXI_AWPROT),
        .S_AXI_AWVALID                    (S_AXI_AWVALID),
        .S_AXI_AWREADY                    (S_AXI_AWREADY),
        .S_AXI_WDATA                      (S_AXI_WDATA),
        .S_AXI_WSTRB                      (S_AXI_WSTRB),
        .S_AXI_WVALID                     (S_AXI_WVALID),
        .S_AXI_WREADY                     (S_AXI_WREADY),
        .S_AXI_BID                        (S_AXI_BID),
        .S_AXI_BRESP                      (S_AXI_BRESP),
        .S_AXI_BUSER                      (S_AXI_BUSER),
        .S_AXI_BVALID                     (S_AXI_BVALID),
        .S_AXI_BREADY                     (S_AXI_BREADY),
        .S_AXI_ARID                       (S_AXI_ARID),
        .S_AXI_ARADDR                     (S_AXI_ARADDR),
        .S_AXI_ARPROT                     (S_AXI_ARPROT),
        .S_AXI_ARVALID                    (S_AXI_ARVALID),
        .S_AXI_ARREADY                    (S_AXI_ARREADY),
        .S_AXI_RID                        (S_AXI_RID),
        .S_AXI_RDATA                      (S_AXI_RDATA),
        .S_AXI_RRESP                      (S_AXI_RRESP),
        .S_AXI_RLAST                      (S_AXI_RLAST),
        .S_AXI_RUSER                      (S_AXI_RUSER),
        .S_AXI_RVALID                     (S_AXI_RVALID),
        .S_AXI_RREADY                     (S_AXI_RREADY),
        .M_AXI_AWID                       (M_AXI_AWID),
        .M_AXI_AWADDR                     (M_AXI_AWADDR),
        .M_AXI_AWLEN                      (M_AXI_AWLEN),
        .M_AXI_AWSIZE                     (M_AXI_AWSIZE),
        .M_AXI_AWBURST                    (M_AXI_AWBURST),
        .M_AXI_AWLOCK                     (M_AXI_AWLOCK),
        .M_AXI_AWCACHE                    (M_AXI_AWCACHE),
        .M_AXI_AWPROT                     (M_AXI_AWPROT),
        .M_AXI_AWREGION                   (M_AXI_AWREGION),
        .M_AXI_AWQOS                      (M_AXI_AWQOS),
        .M_AXI_AWUSER                     (M_AXI_AWUSER),
        .M_AXI_AWVALID                    (M_AXI_AWVALID),
        .M_AXI_AWREADY                    (M_AXI_AWREADY),
        .M_AXI_WID                        (M_AXI_WID),
        .M_AXI_WDATA                      (M_AXI_WDATA),
        .M_AXI_WSTRB                      (M_AXI_WSTRB),
        .M_AXI_WLAST                      (M_AXI_WLAST),
        .M_AXI_WUSER                      (M_AXI_WUSER),
        .M_AXI_WVALID                     (M_AXI_WVALID),
        .M_AXI_WREADY                     (M_AXI_WREADY),
        .M_AXI_BRESP                      (M_AXI_BRESP),
        .M_AXI_BVALID                     (M_AXI_BVALID),
        .M_AXI_BREADY                     (M_AXI_BREADY),
        .M_AXI_ARID                       (M_AXI_ARID),
        .M_AXI_ARADDR                     (M_AXI_ARADDR),
        .M_AXI_ARLEN                      (M_AXI_ARLEN),
        .M_AXI_ARSIZE                     (M_AXI_ARSIZE),
        .M_AXI_ARBURST                    (M_AXI_ARBURST),
        .M_AXI_ARLOCK                     (M_AXI_ARLOCK),
        .M_AXI_ARCACHE                    (M_AXI_ARCACHE),
        .M_AXI_ARPROT                     (M_AXI_ARPROT),
        .M_AXI_ARREGION                   (M_AXI_ARREGION),
        .M_AXI_ARQOS                      (M_AXI_ARQOS),
        .M_AXI_ARUSER                     (M_AXI_ARUSER),
        .M_AXI_ARVALID                    (M_AXI_ARVALID),
        .M_AXI_ARREADY                    (M_AXI_ARREADY),
        .M_AXI_RDATA                      (M_AXI_RDATA),
        .M_AXI_RRESP                      (M_AXI_RRESP),
        .M_AXI_RVALID                     (M_AXI_RVALID),
        .M_AXI_RREADY                     (M_AXI_RREADY)
      );
    end
  end else if ((C_AXI_PROTOCOL == P_AXI3) && (C_AXI3_BYPASS == 0)) begin : gen_axi3
  axi_interconnect_v1_7_13_axi3_conv #(
      .C_FAMILY                         (C_FAMILY),
      .C_AXI_ID_WIDTH                   (C_AXI_ID_WIDTH),
      .C_AXI_ADDR_WIDTH                 (C_AXI_ADDR_WIDTH),
      .C_AXI_DATA_WIDTH                 (C_AXI_DATA_WIDTH),
      .C_AXI_SUPPORTS_USER_SIGNALS      (C_AXI_SUPPORTS_USER_SIGNALS),
      .C_AXI_AWUSER_WIDTH               (C_AXI_AWUSER_WIDTH),
      .C_AXI_ARUSER_WIDTH               (C_AXI_ARUSER_WIDTH),
      .C_AXI_WUSER_WIDTH                (C_AXI_WUSER_WIDTH),
      .C_AXI_RUSER_WIDTH                (C_AXI_RUSER_WIDTH),
      .C_AXI_BUSER_WIDTH                (C_AXI_BUSER_WIDTH),
      .C_AXI_SUPPORTS_WRITE             (C_AXI_SUPPORTS_WRITE),
      .C_AXI_SUPPORTS_READ              (C_AXI_SUPPORTS_READ)
    ) axi3_conv_inst (
      .ARESETN                          (ARESETN),
      .ACLK                             (ACLK),
      .S_AXI_AWID                       (S_AXI_AWID),
      .S_AXI_AWADDR                     (S_AXI_AWADDR),
      .S_AXI_AWLEN                      (S_AXI_AWLEN),
      .S_AXI_AWSIZE                     (S_AXI_AWSIZE),
      .S_AXI_AWBURST                    (S_AXI_AWBURST),
      .S_AXI_AWLOCK                     (S_AXI_AWLOCK),
      .S_AXI_AWCACHE                    (S_AXI_AWCACHE),
      .S_AXI_AWPROT                     (S_AXI_AWPROT),
      .S_AXI_AWQOS                      (S_AXI_AWQOS),
      .S_AXI_AWUSER                     (S_AXI_AWUSER),
      .S_AXI_AWVALID                    (S_AXI_AWVALID),
      .S_AXI_AWREADY                    (S_AXI_AWREADY),
      .S_AXI_WDATA                      (S_AXI_WDATA),
      .S_AXI_WSTRB                      (S_AXI_WSTRB),
      .S_AXI_WLAST                      (S_AXI_WLAST),
      .S_AXI_WUSER                      (S_AXI_WUSER),
      .S_AXI_WVALID                     (S_AXI_WVALID),
      .S_AXI_WREADY                     (S_AXI_WREADY),
      .S_AXI_BID                        (S_AXI_BID),
      .S_AXI_BRESP                      (S_AXI_BRESP),
      .S_AXI_BUSER                      (S_AXI_BUSER),
      .S_AXI_BVALID                     (S_AXI_BVALID),
      .S_AXI_BREADY                     (S_AXI_BREADY),
      .S_AXI_ARID                       (S_AXI_ARID),
      .S_AXI_ARADDR                     (S_AXI_ARADDR),
      .S_AXI_ARLEN                      (S_AXI_ARLEN),
      .S_AXI_ARSIZE                     (S_AXI_ARSIZE),
      .S_AXI_ARBURST                    (S_AXI_ARBURST),
      .S_AXI_ARLOCK                     (S_AXI_ARLOCK),
      .S_AXI_ARCACHE                    (S_AXI_ARCACHE),
      .S_AXI_ARPROT                     (S_AXI_ARPROT),
      .S_AXI_ARQOS                      (S_AXI_ARQOS),
      .S_AXI_ARUSER                     (S_AXI_ARUSER),
      .S_AXI_ARVALID                    (S_AXI_ARVALID),
      .S_AXI_ARREADY                    (S_AXI_ARREADY),
      .S_AXI_RID                        (S_AXI_RID),
      .S_AXI_RDATA                      (S_AXI_RDATA),
      .S_AXI_RRESP                      (S_AXI_RRESP),
      .S_AXI_RLAST                      (S_AXI_RLAST),
      .S_AXI_RUSER                      (S_AXI_RUSER),
      .S_AXI_RVALID                     (S_AXI_RVALID),
      .S_AXI_RREADY                     (S_AXI_RREADY),
      .M_AXI_AWID                       (M_AXI_AWID),
      .M_AXI_AWADDR                     (M_AXI_AWADDR),
      .M_AXI_AWLEN                      (M_AXI_AWLEN),
      .M_AXI_AWSIZE                     (M_AXI_AWSIZE),
      .M_AXI_AWBURST                    (M_AXI_AWBURST),
      .M_AXI_AWLOCK                     (M_AXI_AWLOCK),
      .M_AXI_AWCACHE                    (M_AXI_AWCACHE),
      .M_AXI_AWPROT                     (M_AXI_AWPROT),
      .M_AXI_AWREGION                   (M_AXI_AWREGION),
      .M_AXI_AWQOS                      (M_AXI_AWQOS),
      .M_AXI_AWUSER                     (M_AXI_AWUSER),
      .M_AXI_AWVALID                    (M_AXI_AWVALID),
      .M_AXI_AWREADY                    (M_AXI_AWREADY),
      .M_AXI_WID                        (M_AXI_WID),
      .M_AXI_WDATA                      (M_AXI_WDATA),
      .M_AXI_WSTRB                      (M_AXI_WSTRB),
      .M_AXI_WLAST                      (M_AXI_WLAST),
      .M_AXI_WUSER                      (M_AXI_WUSER),
      .M_AXI_WVALID                     (M_AXI_WVALID),
      .M_AXI_WREADY                     (M_AXI_WREADY),
      .M_AXI_BID                        (M_AXI_BID),
      .M_AXI_BRESP                      (M_AXI_BRESP),
      .M_AXI_BUSER                      (M_AXI_BUSER),
      .M_AXI_BVALID                     (M_AXI_BVALID),
      .M_AXI_BREADY                     (M_AXI_BREADY),
      .M_AXI_ARID                       (M_AXI_ARID),
      .M_AXI_ARADDR                     (M_AXI_ARADDR),
      .M_AXI_ARLEN                      (M_AXI_ARLEN),
      .M_AXI_ARSIZE                     (M_AXI_ARSIZE),
      .M_AXI_ARBURST                    (M_AXI_ARBURST),
      .M_AXI_ARLOCK                     (M_AXI_ARLOCK),
      .M_AXI_ARCACHE                    (M_AXI_ARCACHE),
      .M_AXI_ARPROT                     (M_AXI_ARPROT),
      .M_AXI_ARREGION                   (M_AXI_ARREGION),
      .M_AXI_ARQOS                      (M_AXI_ARQOS),
      .M_AXI_ARUSER                     (M_AXI_ARUSER),
      .M_AXI_ARVALID                    (M_AXI_ARVALID),
      .M_AXI_ARREADY                    (M_AXI_ARREADY),
      .M_AXI_RID                        (M_AXI_RID),
      .M_AXI_RDATA                      (M_AXI_RDATA),
      .M_AXI_RRESP                      (M_AXI_RRESP),
      .M_AXI_RLAST                      (M_AXI_RLAST),
      .M_AXI_RUSER                      (M_AXI_RUSER),
      .M_AXI_RVALID                     (M_AXI_RVALID),
      .M_AXI_RREADY                     (M_AXI_RREADY)
    );
  end else begin :gen_no_conv
    assign M_AXI_AWID = S_AXI_AWID;
    assign M_AXI_AWADDR = S_AXI_AWADDR;
    assign M_AXI_AWLEN = S_AXI_AWLEN;
    assign M_AXI_AWSIZE = S_AXI_AWSIZE;
    assign M_AXI_AWBURST = S_AXI_AWBURST;
    assign M_AXI_AWLOCK = S_AXI_AWLOCK;
    assign M_AXI_AWCACHE = S_AXI_AWCACHE;
    assign M_AXI_AWPROT = S_AXI_AWPROT;
    assign M_AXI_AWREGION = S_AXI_AWREGION;
    assign M_AXI_AWQOS = S_AXI_AWQOS;
    assign M_AXI_AWUSER = S_AXI_AWUSER;
    assign M_AXI_AWVALID = S_AXI_AWVALID;
    assign S_AXI_AWREADY = M_AXI_AWREADY;
    assign M_AXI_WID = C_AXI3_BYPASS ? S_AXI_WID : {C_AXI_ID_WIDTH{1'b0}} ;
    assign M_AXI_WDATA = S_AXI_WDATA;
    assign M_AXI_WSTRB = S_AXI_WSTRB;
    assign M_AXI_WLAST = S_AXI_WLAST;
    assign M_AXI_WUSER = S_AXI_WUSER;
    assign M_AXI_WVALID = S_AXI_WVALID;
    assign S_AXI_WREADY = M_AXI_WREADY;
    assign S_AXI_BID = M_AXI_BID;
    assign S_AXI_BRESP = M_AXI_BRESP;
    assign S_AXI_BUSER = M_AXI_BUSER;
    assign S_AXI_BVALID = M_AXI_BVALID;
    assign M_AXI_BREADY = S_AXI_BREADY;
    assign M_AXI_ARID = S_AXI_ARID;
    assign M_AXI_ARADDR = S_AXI_ARADDR;
    assign M_AXI_ARLEN = S_AXI_ARLEN;
    assign M_AXI_ARSIZE = S_AXI_ARSIZE;
    assign M_AXI_ARBURST = S_AXI_ARBURST;
    assign M_AXI_ARLOCK = S_AXI_ARLOCK;
    assign M_AXI_ARCACHE = S_AXI_ARCACHE;
    assign M_AXI_ARPROT = S_AXI_ARPROT;
    assign M_AXI_ARREGION = S_AXI_ARREGION;
    assign M_AXI_ARQOS = S_AXI_ARQOS;
    assign M_AXI_ARUSER = S_AXI_ARUSER;
    assign M_AXI_ARVALID = S_AXI_ARVALID;
    assign S_AXI_ARREADY = M_AXI_ARREADY;
    assign S_AXI_RID = M_AXI_RID;
    assign S_AXI_RDATA = M_AXI_RDATA;
    assign S_AXI_RRESP = M_AXI_RRESP;
    assign S_AXI_RLAST = M_AXI_RLAST;
    assign S_AXI_RUSER = M_AXI_RUSER;
    assign S_AXI_RVALID = M_AXI_RVALID;
    assign M_AXI_RREADY = S_AXI_RREADY;
  end
endgenerate


endmodule

`default_nettype wire


// -- (c) Copyright 2010 - 2011 Xilinx, Inc. All rights reserved.
// --
// -- This file contains confidential and proprietary information
// -- of Xilinx, Inc. and is protected under U.S. and 
// -- international copyright and other intellectual property
// -- laws.
// --
// -- DISCLAIMER
// -- This disclaimer is not a license and does not grant any
// -- rights to the materials distributed herewith. Except as
// -- otherwise provided in a valid license issued to you by
// -- Xilinx, and to the maximum extent permitted by applicable
// -- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
// -- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
// -- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
// -- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
// -- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
// -- (2) Xilinx shall not be liable (whether in contract or tort,
// -- including negligence, or under any other theory of
// -- liability) for any loss or damage of any kind or nature
// -- related to, arising under or in connection with these
// -- materials, including for any direct, or any indirect,
// -- special, incidental, or consequential loss or damage
// -- (including loss of data, profits, goodwill, or any type of
// -- loss or damage suffered as a result of any action brought
// -- by a third party) even if such damage or loss was
// -- reasonably foreseeable or Xilinx had been advised of the
// -- possibility of the same.
// --
// -- CRITICAL APPLICATIONS
// -- Xilinx products are not designed or intended to be fail-
// -- safe, or for use in any application requiring fail-safe
// -- performance, such as life-support or safety devices or
// -- systems, Class III medical devices, nuclear facilities,
// -- applications related to the deployment of airbags, or any
// -- other applications that could lead to death, personal
// -- injury, or severe property or environmental damage
// -- (individually and collectively, "Critical
// -- Applications"). Customer assumes the sole risk and
// -- liability of any use of Xilinx products in Critical
// -- Applications, subject only to applicable laws and
// -- regulations governing limitations on product liability.
// --
// -- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
// -- PART OF THIS FILE AT ALL TIMES.
//-----------------------------------------------------------------------------
//
// AXI Register Slice
//   Register selected channels on the forward and/or reverse signal paths.
//   5-channel memory-mapped AXI4 interfaces.
//
// Verilog-standard:  Verilog 2001
//--------------------------------------------------------------------------
//
// Structure:
//   axi_register_slice
//      axic_register_slice
//
//--------------------------------------------------------------------------

`timescale 1ps/1ps

(* DowngradeIPIdentifiedWarnings="yes" *) 
module axi_interconnect_v1_7_13_axi_register_slice #
  (
   parameter C_FAMILY                            = "virtex6",
   parameter integer C_AXI_ID_WIDTH              = 4,
   parameter integer C_AXI_ADDR_WIDTH            = 32,
   parameter integer C_AXI_DATA_WIDTH            = 32,
   parameter integer C_AXI_SUPPORTS_USER_SIGNALS = 0,
   parameter integer C_AXI_AWUSER_WIDTH          = 1,
   parameter integer C_AXI_ARUSER_WIDTH          = 1,
   parameter integer C_AXI_WUSER_WIDTH           = 1,
   parameter integer C_AXI_RUSER_WIDTH           = 1,
   parameter integer C_AXI_BUSER_WIDTH           = 1,
   // C_REG_CONFIG_*:
   //   0 => BYPASS    = The channel is just wired through the module.
   //   1 => FWD_REV   = Both FWD and REV (fully-registered)
   //   2 => FWD       = The master VALID and payload signals are registrated. 
   //   3 => REV       = The slave ready signal is registrated
   //   4 => SLAVE_FWD = All slave side signals and master VALID and payload are registrated.
   //   5 => SLAVE_RDY = All slave side signals and master READY are registrated.
   //   6 => INPUTS    = Slave and Master side inputs are registrated.
   //   7 => LIGHT_WT  = 1-stage pipeline register with bubble cycle, both FWD and REV pipelining
   parameter         C_REG_CONFIG_AW = 32'h00000000,
   parameter         C_REG_CONFIG_W  = 32'h00000000,
   parameter         C_REG_CONFIG_B  = 32'h00000000,
   parameter         C_REG_CONFIG_AR = 32'h00000000,
   parameter         C_REG_CONFIG_R  = 32'h00000000
   )
  (
   // System Signals
   input wire ACLK,
   input wire ARESETN,

   // Slave Interface Write Address Ports
   input  wire [C_AXI_ID_WIDTH-1:0]     S_AXI_AWID,
   input  wire [C_AXI_ADDR_WIDTH-1:0]   S_AXI_AWADDR,
   input  wire [8-1:0]                  S_AXI_AWLEN,
   input  wire [3-1:0]                  S_AXI_AWSIZE,
   input  wire [2-1:0]                  S_AXI_AWBURST,
   input  wire [2-1:0]                  S_AXI_AWLOCK,
   input  wire [4-1:0]                  S_AXI_AWCACHE,
   input  wire [3-1:0]                  S_AXI_AWPROT,
   input  wire [4-1:0]                  S_AXI_AWREGION,
   input  wire [4-1:0]                  S_AXI_AWQOS,
   input  wire [C_AXI_AWUSER_WIDTH-1:0] S_AXI_AWUSER,
   input  wire                          S_AXI_AWVALID,
   output wire                          S_AXI_AWREADY,

   // Slave Interface Write Data Ports
   input wire [C_AXI_ID_WIDTH-1:0]      S_AXI_WID,
   input  wire [C_AXI_DATA_WIDTH-1:0]   S_AXI_WDATA,
   input  wire [C_AXI_DATA_WIDTH/8-1:0] S_AXI_WSTRB,
   input  wire                          S_AXI_WLAST,
   input  wire [C_AXI_WUSER_WIDTH-1:0]  S_AXI_WUSER,
   input  wire                          S_AXI_WVALID,
   output wire                          S_AXI_WREADY,

   // Slave Interface Write Response Ports
   output wire [C_AXI_ID_WIDTH-1:0]    S_AXI_BID,
   output wire [2-1:0]                 S_AXI_BRESP,
   output wire [C_AXI_BUSER_WIDTH-1:0] S_AXI_BUSER,
   output wire                         S_AXI_BVALID,
   input  wire                         S_AXI_BREADY,

   // Slave Interface Read Address Ports
   input  wire [C_AXI_ID_WIDTH-1:0]     S_AXI_ARID,
   input  wire [C_AXI_ADDR_WIDTH-1:0]   S_AXI_ARADDR,
   input  wire [8-1:0]                  S_AXI_ARLEN,
   input  wire [3-1:0]                  S_AXI_ARSIZE,
   input  wire [2-1:0]                  S_AXI_ARBURST,
   input  wire [2-1:0]                  S_AXI_ARLOCK,
   input  wire [4-1:0]                  S_AXI_ARCACHE,
   input  wire [3-1:0]                  S_AXI_ARPROT,
   input  wire [4-1:0]                  S_AXI_ARREGION,
   input  wire [4-1:0]                  S_AXI_ARQOS,
   input  wire [C_AXI_ARUSER_WIDTH-1:0] S_AXI_ARUSER,
   input  wire                          S_AXI_ARVALID,
   output wire                          S_AXI_ARREADY,

   // Slave Interface Read Data Ports
   output wire [C_AXI_ID_WIDTH-1:0]    S_AXI_RID,
   output wire [C_AXI_DATA_WIDTH-1:0]  S_AXI_RDATA,
   output wire [2-1:0]                 S_AXI_RRESP,
   output wire                         S_AXI_RLAST,
   output wire [C_AXI_RUSER_WIDTH-1:0] S_AXI_RUSER,
   output wire                         S_AXI_RVALID,
   input  wire                         S_AXI_RREADY,
   
   // Master Interface Write Address Port
   output wire [C_AXI_ID_WIDTH-1:0]     M_AXI_AWID,
   output wire [C_AXI_ADDR_WIDTH-1:0]   M_AXI_AWADDR,
   output wire [8-1:0]                  M_AXI_AWLEN,
   output wire [3-1:0]                  M_AXI_AWSIZE,
   output wire [2-1:0]                  M_AXI_AWBURST,
   output wire [2-1:0]                  M_AXI_AWLOCK,
   output wire [4-1:0]                  M_AXI_AWCACHE,
   output wire [3-1:0]                  M_AXI_AWPROT,
   output wire [4-1:0]                  M_AXI_AWREGION,
   output wire [4-1:0]                  M_AXI_AWQOS,
   output wire [C_AXI_AWUSER_WIDTH-1:0] M_AXI_AWUSER,
   output wire                          M_AXI_AWVALID,
   input  wire                          M_AXI_AWREADY,
   
   // Master Interface Write Data Ports
   output wire [C_AXI_ID_WIDTH-1:0]     M_AXI_WID,
   output wire [C_AXI_DATA_WIDTH-1:0]   M_AXI_WDATA,
   output wire [C_AXI_DATA_WIDTH/8-1:0] M_AXI_WSTRB,
   output wire                          M_AXI_WLAST,
   output wire [C_AXI_WUSER_WIDTH-1:0]  M_AXI_WUSER,
   output wire                          M_AXI_WVALID,
   input  wire                          M_AXI_WREADY,
   
   // Master Interface Write Response Ports
   input  wire [C_AXI_ID_WIDTH-1:0]    M_AXI_BID,
   input  wire [2-1:0]                 M_AXI_BRESP,
   input  wire [C_AXI_BUSER_WIDTH-1:0] M_AXI_BUSER,
   input  wire                         M_AXI_BVALID,
   output wire                         M_AXI_BREADY,
   
   // Master Interface Read Address Port
   output wire [C_AXI_ID_WIDTH-1:0]     M_AXI_ARID,
   output wire [C_AXI_ADDR_WIDTH-1:0]   M_AXI_ARADDR,
   output wire [8-1:0]                  M_AXI_ARLEN,
   output wire [3-1:0]                  M_AXI_ARSIZE,
   output wire [2-1:0]                  M_AXI_ARBURST,
   output wire [2-1:0]                  M_AXI_ARLOCK,
   output wire [4-1:0]                  M_AXI_ARCACHE,
   output wire [3-1:0]                  M_AXI_ARPROT,
   output wire [4-1:0]                  M_AXI_ARREGION,
   output wire [4-1:0]                  M_AXI_ARQOS,
   output wire [C_AXI_ARUSER_WIDTH-1:0] M_AXI_ARUSER,
   output wire                          M_AXI_ARVALID,
   input  wire                          M_AXI_ARREADY,
   
   // Master Interface Read Data Ports
   input  wire [C_AXI_ID_WIDTH-1:0]    M_AXI_RID,
   input  wire [C_AXI_DATA_WIDTH-1:0]  M_AXI_RDATA,
   input  wire [2-1:0]                 M_AXI_RRESP,
   input  wire                         M_AXI_RLAST,
   input  wire [C_AXI_RUSER_WIDTH-1:0] M_AXI_RUSER,
   input  wire                         M_AXI_RVALID,
   output wire                         M_AXI_RREADY
  );

  (* shreg_extract="no", iob="false", equivalent_register_removal = "no" *) reg reset;
  always @(posedge ACLK) begin
    reset <= ~ARESETN;
  end

  // Write Address Port bit positions
  localparam C_AWUSER_RIGHT   = 0;
  localparam C_AWUSER_LEN     = C_AXI_SUPPORTS_USER_SIGNALS*C_AXI_AWUSER_WIDTH;
  localparam C_AWQOS_RIGHT    = C_AWUSER_RIGHT + C_AWUSER_LEN;
  localparam C_AWQOS_LEN      = 4;
  localparam C_AWREGION_RIGHT = C_AWQOS_RIGHT + C_AWQOS_LEN;
  localparam C_AWREGION_LEN   = 4;
  localparam C_AWPROT_RIGHT   = C_AWREGION_RIGHT + C_AWREGION_LEN;
  localparam C_AWPROT_LEN     = 3;
  localparam C_AWCACHE_RIGHT  = C_AWPROT_RIGHT + C_AWPROT_LEN;
  localparam C_AWCACHE_LEN    = 4;
  localparam C_AWLOCK_RIGHT   = C_AWCACHE_RIGHT + C_AWCACHE_LEN;
  localparam C_AWLOCK_LEN     = 2;
  localparam C_AWBURST_RIGHT  = C_AWLOCK_RIGHT + C_AWLOCK_LEN;
  localparam C_AWBURST_LEN    = 2;
  localparam C_AWSIZE_RIGHT   = C_AWBURST_RIGHT + C_AWBURST_LEN;
  localparam C_AWSIZE_LEN     = 3;
  localparam C_AWLEN_RIGHT    = C_AWSIZE_RIGHT + C_AWSIZE_LEN;
  localparam C_AWLEN_LEN      = 8;
  localparam C_AWADDR_RIGHT   = C_AWLEN_RIGHT + C_AWLEN_LEN;
  localparam C_AWADDR_LEN     = C_AXI_ADDR_WIDTH;
  localparam C_AWID_RIGHT     = C_AWADDR_RIGHT + C_AWADDR_LEN;
  localparam C_AWID_LEN       = C_AXI_ID_WIDTH;
  localparam C_AW_SIZE        = C_AWID_RIGHT+C_AWID_LEN;

  // Write Address Port FIFO data read and write
  wire [C_AW_SIZE-1:0] s_aw_data ;
  wire [C_AW_SIZE-1:0] m_aw_data ;
  
  // Write Data Port bit positions
  localparam C_WUSER_RIGHT   = 0;
  localparam C_WUSER_LEN     = C_AXI_SUPPORTS_USER_SIGNALS*C_AXI_WUSER_WIDTH;
  localparam C_WLAST_RIGHT   = C_WUSER_RIGHT + C_WUSER_LEN;
  localparam C_WLAST_LEN     = 1;
  localparam C_WSTRB_RIGHT   = C_WLAST_RIGHT + C_WLAST_LEN;
  localparam C_WSTRB_LEN     = C_AXI_DATA_WIDTH/8;
  localparam C_WDATA_RIGHT   = C_WSTRB_RIGHT + C_WSTRB_LEN;
  localparam C_WDATA_LEN     = C_AXI_DATA_WIDTH;
  localparam C_WID_RIGHT     = C_WDATA_RIGHT + C_WDATA_LEN;
  localparam C_WID_LEN       = C_AXI_ID_WIDTH;
  localparam C_W_SIZE        = C_WID_RIGHT+C_WID_LEN;

  // Write Data Port FIFO data read and write
  wire [C_W_SIZE-1:0] s_w_data;
  wire [C_W_SIZE-1:0] m_w_data;

  // Write Response Port bit positions
  localparam C_BUSER_RIGHT   = 0;
  localparam C_BUSER_LEN     = C_AXI_SUPPORTS_USER_SIGNALS*C_AXI_BUSER_WIDTH;
  localparam C_BRESP_RIGHT   = C_BUSER_RIGHT + C_BUSER_LEN;
  localparam C_BRESP_LEN     = 2;
  localparam C_BID_RIGHT     = C_BRESP_RIGHT + C_BRESP_LEN;
  localparam C_BID_LEN       = C_AXI_ID_WIDTH;
  localparam C_B_SIZE        = C_BID_RIGHT+C_BID_LEN;

  // Write Response Port FIFO data read and write
  wire [C_B_SIZE-1:0] s_b_data;
  wire [C_B_SIZE-1:0] m_b_data;

  // Read Address Port bit positions
  localparam C_ARUSER_RIGHT   = 0;
  localparam C_ARUSER_LEN     = C_AXI_SUPPORTS_USER_SIGNALS*C_AXI_ARUSER_WIDTH;
  localparam C_ARQOS_RIGHT    = C_ARUSER_RIGHT + C_ARUSER_LEN;
  localparam C_ARQOS_LEN      = 4;
  localparam C_ARREGION_RIGHT = C_ARQOS_RIGHT + C_ARQOS_LEN;
  localparam C_ARREGION_LEN   = 4;
  localparam C_ARPROT_RIGHT   = C_ARREGION_RIGHT + C_ARREGION_LEN;
  localparam C_ARPROT_LEN     = 3;
  localparam C_ARCACHE_RIGHT  = C_ARPROT_RIGHT + C_ARPROT_LEN;
  localparam C_ARCACHE_LEN    = 4;
  localparam C_ARLOCK_RIGHT   = C_ARCACHE_RIGHT + C_ARCACHE_LEN;
  localparam C_ARLOCK_LEN     = 2;
  localparam C_ARBURST_RIGHT  = C_ARLOCK_RIGHT + C_ARLOCK_LEN;
  localparam C_ARBURST_LEN    = 2;
  localparam C_ARSIZE_RIGHT   = C_ARBURST_RIGHT + C_ARBURST_LEN;
  localparam C_ARSIZE_LEN     = 3;
  localparam C_ARLEN_RIGHT    = C_ARSIZE_RIGHT + C_ARSIZE_LEN;
  localparam C_ARLEN_LEN      = 8;
  localparam C_ARADDR_RIGHT   = C_ARLEN_RIGHT + C_ARLEN_LEN;
  localparam C_ARADDR_LEN     = C_AXI_ADDR_WIDTH;
  localparam C_ARID_RIGHT     = C_ARADDR_RIGHT + C_ARADDR_LEN;
  localparam C_ARID_LEN       = C_AXI_ID_WIDTH;
  localparam C_AR_SIZE        = C_ARID_RIGHT+C_ARID_LEN;

  // Read Address Port FIFO data read and write
  wire [C_AR_SIZE-1:0] s_ar_data;
  wire [C_AR_SIZE-1:0] m_ar_data;

  // Read Data Ports bit positions
  localparam C_RUSER_RIGHT   = 0;
  localparam C_RUSER_LEN     = C_AXI_SUPPORTS_USER_SIGNALS*C_AXI_RUSER_WIDTH;
  localparam C_RLAST_RIGHT   = C_RUSER_RIGHT + C_RUSER_LEN;
  localparam C_RLAST_LEN     = 1;
  localparam C_RRESP_RIGHT   = C_RLAST_RIGHT + C_RLAST_LEN;
  localparam C_RRESP_LEN     = 2;
  localparam C_RDATA_RIGHT   = C_RRESP_RIGHT + C_RRESP_LEN;
  localparam C_RDATA_LEN     = C_AXI_DATA_WIDTH;
  localparam C_RID_RIGHT     = C_RDATA_RIGHT + C_RDATA_LEN;
  localparam C_RID_LEN       = C_AXI_ID_WIDTH;
  localparam C_R_SIZE        = C_RID_RIGHT+C_RID_LEN;

  // Read Data Ports FIFO data read and write
  wire [C_R_SIZE-1:0] s_r_data;
  wire [C_R_SIZE-1:0] m_r_data;

  generate
    
    ///////////////////////////////////////////////////////
    //
    // AW PIPE
    //
    ///////////////////////////////////////////////////////
    
    if (C_AXI_SUPPORTS_USER_SIGNALS == 1) begin : gen_async_aw_user
      assign s_aw_data    = {S_AXI_AWID, S_AXI_AWADDR, S_AXI_AWLEN, S_AXI_AWSIZE, 
                             S_AXI_AWBURST, S_AXI_AWLOCK, S_AXI_AWCACHE, S_AXI_AWPROT, 
                             S_AXI_AWREGION, S_AXI_AWQOS, S_AXI_AWUSER};
      assign M_AXI_AWUSER = m_aw_data[C_AWUSER_RIGHT+:C_AWUSER_LEN];
    end
    else begin : gen_asynch_aw_no_user
      assign s_aw_data    = {S_AXI_AWID, S_AXI_AWADDR, S_AXI_AWLEN, S_AXI_AWSIZE, 
                             S_AXI_AWBURST, S_AXI_AWLOCK, S_AXI_AWCACHE, S_AXI_AWPROT, 
                             S_AXI_AWREGION, S_AXI_AWQOS};
      assign M_AXI_AWUSER = {C_AXI_AWUSER_WIDTH{1'b0}};
    end

    assign M_AXI_AWID     = m_aw_data[C_AWID_RIGHT+:C_AWID_LEN];
    assign M_AXI_AWADDR   = m_aw_data[C_AWADDR_RIGHT+:C_AWADDR_LEN];
    assign M_AXI_AWLEN    = m_aw_data[C_AWLEN_RIGHT+:C_AWLEN_LEN];
    assign M_AXI_AWSIZE   = m_aw_data[C_AWSIZE_RIGHT+:C_AWSIZE_LEN];
    assign M_AXI_AWBURST  = m_aw_data[C_AWBURST_RIGHT+:C_AWBURST_LEN];
    assign M_AXI_AWLOCK   = m_aw_data[C_AWLOCK_RIGHT+:C_AWLOCK_LEN];
    assign M_AXI_AWCACHE  = m_aw_data[C_AWCACHE_RIGHT+:C_AWCACHE_LEN];
    assign M_AXI_AWPROT   = m_aw_data[C_AWPROT_RIGHT+:C_AWPROT_LEN];
    assign M_AXI_AWREGION = m_aw_data[C_AWREGION_RIGHT+:C_AWREGION_LEN];
    assign M_AXI_AWQOS    = m_aw_data[C_AWQOS_RIGHT+:C_AWQOS_LEN];
    
  axi_interconnect_v1_7_13_axic_register_slice #
      (
       .C_FAMILY(C_FAMILY),
       .C_DATA_WIDTH(C_AW_SIZE),
       .C_REG_CONFIG(C_REG_CONFIG_AW)
       )
    aw_pipe
      (
       // System Signals
       .ACLK(ACLK),
       .ARESET(reset),

       // Slave side
       .S_PAYLOAD_DATA(s_aw_data),
       .S_VALID(S_AXI_AWVALID),
       .S_READY(S_AXI_AWREADY),

       // Master side
       .M_PAYLOAD_DATA(m_aw_data),
       .M_VALID(M_AXI_AWVALID),
       .M_READY(M_AXI_AWREADY)
       );
    

    ///////////////////////////////////////////////////////
    //
    //  Data Write PIPE
    //
    ///////////////////////////////////////////////////////  
    if (C_AXI_SUPPORTS_USER_SIGNALS == 1) begin : gen_async_w_user
      assign s_w_data     = {S_AXI_WID, S_AXI_WDATA, S_AXI_WSTRB, S_AXI_WLAST, S_AXI_WUSER};
      assign M_AXI_WUSER = m_w_data[C_WUSER_RIGHT+:C_WUSER_LEN];
    end
    else begin : gen_asynch_w_no_user
      assign s_w_data     = {S_AXI_WID, S_AXI_WDATA, S_AXI_WSTRB, S_AXI_WLAST};
      assign M_AXI_WUSER  = {C_AXI_WUSER_WIDTH{1'b0}};
    end

    assign M_AXI_WID      = m_w_data[C_WID_RIGHT+:C_WID_LEN];
    assign M_AXI_WDATA    = m_w_data[C_WDATA_RIGHT+:C_WDATA_LEN];
    assign M_AXI_WSTRB    = m_w_data[C_WSTRB_RIGHT+:C_WSTRB_LEN];
    assign M_AXI_WLAST    = m_w_data[C_WLAST_RIGHT+:C_WLAST_LEN];

  axi_interconnect_v1_7_13_axic_register_slice #
      (
       .C_FAMILY(C_FAMILY),
       .C_DATA_WIDTH(C_W_SIZE),
       .C_REG_CONFIG(C_REG_CONFIG_W)
       )
      w_pipe
      (
       // System Signals
       .ACLK(ACLK),
       .ARESET(reset),

       // Slave side
       .S_PAYLOAD_DATA(s_w_data),
       .S_VALID(S_AXI_WVALID),
       .S_READY(S_AXI_WREADY),

       // Master side
       .M_PAYLOAD_DATA(m_w_data),
       .M_VALID(M_AXI_WVALID),
       .M_READY(M_AXI_WREADY)
       );

    
    ///////////////////////////////////////////////////////
    //
    // Write Response PIPE
    //
    ///////////////////////////////////////////////////////  
    if (C_AXI_SUPPORTS_USER_SIGNALS == 1) begin : gen_async_b_user
      assign m_b_data     = {M_AXI_BID, M_AXI_BRESP, M_AXI_BUSER};
      assign S_AXI_BUSER  = s_b_data[C_BUSER_RIGHT+:C_BUSER_LEN];
    end
    else begin : gen_asynch_b_no_user
      assign m_b_data     = {M_AXI_BID, M_AXI_BRESP};
      assign S_AXI_BUSER  = {C_AXI_BUSER_WIDTH{1'b0}};
    end

    assign S_AXI_BID      = s_b_data[C_BID_RIGHT+:C_BID_LEN];
    assign S_AXI_BRESP    = s_b_data[C_BRESP_RIGHT+:C_BRESP_LEN];

  axi_interconnect_v1_7_13_axic_register_slice #
      (
       .C_FAMILY(C_FAMILY),
       .C_DATA_WIDTH(C_B_SIZE),
       .C_REG_CONFIG(C_REG_CONFIG_B)
       )
      b_pipe
      (
       // System Signals
       .ACLK(ACLK),
       .ARESET(reset),

       // Slave side
       .S_PAYLOAD_DATA(m_b_data),
       .S_VALID(M_AXI_BVALID),
       .S_READY(M_AXI_BREADY),

       // Master side
       .M_PAYLOAD_DATA(s_b_data),
       .M_VALID(S_AXI_BVALID),
       .M_READY(S_AXI_BREADY)
       );
 
    ///////////////////////////////////////////////////////
    //
    // Address Read PIPE
    //
    ///////////////////////////////////////////////////////  

    if (C_AXI_SUPPORTS_USER_SIGNALS == 1) begin : gen_async_ar_user
      assign s_ar_data    = {S_AXI_ARID, S_AXI_ARADDR, S_AXI_ARLEN, S_AXI_ARSIZE, 
                             S_AXI_ARBURST, S_AXI_ARLOCK, S_AXI_ARCACHE, S_AXI_ARPROT, 
                             S_AXI_ARREGION, S_AXI_ARQOS, S_AXI_ARUSER};
      assign M_AXI_ARUSER = m_ar_data[C_ARUSER_RIGHT+:C_ARUSER_LEN];
    end
    else begin : gen_asynch_ar_no_user
      assign s_ar_data    = {S_AXI_ARID, S_AXI_ARADDR, S_AXI_ARLEN, S_AXI_ARSIZE, 
                             S_AXI_ARBURST, S_AXI_ARLOCK, S_AXI_ARCACHE, S_AXI_ARPROT, 
                             S_AXI_ARREGION, S_AXI_ARQOS};
      
      assign M_AXI_ARUSER = {C_AXI_ARUSER_WIDTH{1'b0}};
    end

    assign M_AXI_ARID     = m_ar_data[C_ARID_RIGHT+:C_ARID_LEN];
    assign M_AXI_ARADDR   = m_ar_data[C_ARADDR_RIGHT+:C_ARADDR_LEN];
    assign M_AXI_ARLEN    = m_ar_data[C_ARLEN_RIGHT+:C_ARLEN_LEN];
    assign M_AXI_ARSIZE   = m_ar_data[C_ARSIZE_RIGHT+:C_ARSIZE_LEN];
    assign M_AXI_ARBURST  = m_ar_data[C_ARBURST_RIGHT+:C_ARBURST_LEN];
    assign M_AXI_ARLOCK   = m_ar_data[C_ARLOCK_RIGHT+:C_ARLOCK_LEN];
    assign M_AXI_ARCACHE  = m_ar_data[C_ARCACHE_RIGHT+:C_ARCACHE_LEN];
    assign M_AXI_ARPROT   = m_ar_data[C_ARPROT_RIGHT+:C_ARPROT_LEN];
    assign M_AXI_ARREGION = m_ar_data[C_ARREGION_RIGHT+:C_ARREGION_LEN];
    assign M_AXI_ARQOS    = m_ar_data[C_ARQOS_RIGHT+:C_ARQOS_LEN];

  axi_interconnect_v1_7_13_axic_register_slice #
      (
       .C_FAMILY(C_FAMILY),
       .C_DATA_WIDTH(C_AR_SIZE),
       .C_REG_CONFIG(C_REG_CONFIG_AR)
       )
      ar_pipe
      (
       // System Signals
       .ACLK(ACLK),
       .ARESET(reset),

       // Slave side
       .S_PAYLOAD_DATA(s_ar_data),
       .S_VALID(S_AXI_ARVALID),
       .S_READY(S_AXI_ARREADY),

       // Master side
       .M_PAYLOAD_DATA(m_ar_data),
       .M_VALID(M_AXI_ARVALID),
       .M_READY(M_AXI_ARREADY)
       );
        
    ///////////////////////////////////////////////////////
    //
    //  Data Read PIPE
    //
    ///////////////////////////////////////////////////////
    
    if (C_AXI_SUPPORTS_USER_SIGNALS == 1) begin : gen_async_r_user
      assign m_r_data     = {M_AXI_RID, M_AXI_RDATA, M_AXI_RRESP, M_AXI_RLAST, M_AXI_RUSER};
      assign S_AXI_RUSER  = s_r_data[C_RUSER_RIGHT+:C_RUSER_LEN];
    end
    else begin : gen_asynch_r_no_user
      assign m_r_data     = {M_AXI_RID, M_AXI_RDATA, M_AXI_RRESP, M_AXI_RLAST};
      assign S_AXI_RUSER  = {C_AXI_RUSER_WIDTH{1'b0}};
    end
    
    assign S_AXI_RID      = s_r_data[C_RID_RIGHT+:C_RID_LEN];
    assign S_AXI_RDATA    = s_r_data[C_RDATA_RIGHT+:C_RDATA_LEN];
    assign S_AXI_RRESP    = s_r_data[C_RRESP_RIGHT+:C_RRESP_LEN];
    assign S_AXI_RLAST    = s_r_data[C_RLAST_RIGHT+:C_RLAST_LEN];

  axi_interconnect_v1_7_13_axic_register_slice #
      (
       .C_FAMILY(C_FAMILY),
       .C_DATA_WIDTH(C_R_SIZE),
       .C_REG_CONFIG(C_REG_CONFIG_R)
       )
      r_pipe
      (
       // System Signals
       .ACLK(ACLK),
       .ARESET(reset),

       // Slave side
       .S_PAYLOAD_DATA(m_r_data),
       .S_VALID(M_AXI_RVALID),
       .S_READY(M_AXI_RREADY),

       // Master side
       .M_PAYLOAD_DATA(s_r_data),
       .M_VALID(S_AXI_RVALID),
       .M_READY(S_AXI_RREADY)
       );

  endgenerate

endmodule // axi_register_slice


//-----------------------------------------------------------------------------
//-- (c) Copyright 2010 Xilinx, Inc. All rights reserved.
//--
//-- This file contains confidential and proprietary information
//-- of Xilinx, Inc. and is protected under U.S. and
//-- international copyright and other intellectual property
//-- laws.
//--
//-- DISCLAIMER
//-- This disclaimer is not a license and does not grant any
//-- rights to the materials distributed herewith. Except as
//-- otherwise provided in a valid license issued to you by
//-- Xilinx, and to the maximum extent permitted by applicable
//-- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
//-- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
//-- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
//-- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
//-- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
//-- (2) Xilinx shall not be liable (whether in contract or tort,
//-- including negligence, or under any other theory of
//-- liability) for any loss or damage of any kind or nature
//-- related to, arising under or in connection with these
//-- materials, including for any direct, or any indirect,
//-- special, incidental, or consequential loss or damage
//-- (including loss of data, profits, goodwill, or any type of
//-- loss or damage suffered as a result of any action brought
//-- by a third party) even if such damage or loss was
//-- reasonably foreseeable or Xilinx had been advised of the
//-- possibility of the same.
//--
//-- CRITICAL APPLICATIONS
//-- Xilinx products are not designed or intended to be fail-
//-- safe, or for use in any application requiring fail-safe
//-- performance, such as life-support or safety devices or
//-- systems, Class III medical devices, nuclear facilities,
//-- applications related to the deployment of airbags, or any
//-- other applications that could lead to death, personal
//-- injury, or severe property or environmental damage
//-- (individually and collectively, "Critical
//-- Applications"). Customer assumes the sole risk and
//-- liability of any use of Xilinx products in Critical
//-- Applications, subject only to applicable laws and
//-- regulations governing limitations on product liability.
//--
//-- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
//-- PART OF THIS FILE AT ALL TIMES.
//-----------------------------------------------------------------------------
//
// Description: Up-Sizer
// Up-Sizer for generic SI- and MI-side data widths. This module instantiates
// Address, Write Data and Read Data Up-Sizer modules, each one taking care
// of the channel specific tasks.
// The Address Up-Sizer can handle both AR and AW channels.
//
// Verilog-standard:  Verilog 2001
//--------------------------------------------------------------------------
//
// Structure:
//   axi_upsizer
//     a_upsizer
//       fifo
//         fifo_gen
//           fifo_coregen
//     w_upsizer
//     r_upsizer
//
//--------------------------------------------------------------------------
`timescale 1ps/1ps
`default_nettype none

(* DowngradeIPIdentifiedWarnings="yes" *) 
module axi_interconnect_v1_7_13_axi_upsizer #
  (
   parameter         C_FAMILY                         = "rtl", 
                       // FPGA Family. Current version: virtex6 or spartan6.
   parameter integer C_AXI_ID_WIDTH                 = 4, 
                       // Width of all ID signals on SI and MI side of converter.
                       // Range: >= 1.
   parameter integer C_AXI_ADDR_WIDTH                 = 32, 
                       // Width of all ADDR signals on SI and MI side of converter.
                       // Range: 32.
   parameter         C_S_AXI_DATA_WIDTH               = 32'h00000020, 
                       // Width of S_AXI_WDATA and S_AXI_RDATA.
                       // Format: Bit32; 
                       // Range: 'h00000020, 'h00000040, 'h00000080, 'h00000100.
   parameter         C_M_AXI_DATA_WIDTH               = 32'h00000040, 
                       // Width of M_AXI_WDATA and M_AXI_RDATA.
                       // Assume greater than or equal to C_S_AXI_DATA_WIDTH.
                       // Format: Bit32;
                       // Range: 'h00000020, 'h00000040, 'h00000080, 'h00000100.
   parameter integer C_M_AXI_AW_REGISTER              = 0,
                       // Simple register AW output.
                       // Range: 0, 1
   parameter integer C_M_AXI_W_REGISTER               = 1,  // Parameter not used; W reg always implemented.
   parameter integer C_M_AXI_AR_REGISTER              = 0,
                       // Simple register AR output.
                       // Range: 0, 1
   parameter integer C_S_AXI_R_REGISTER               = 0,
                       // Simple register R output (SI).
                       // Range: 0, 1
   parameter integer C_M_AXI_R_REGISTER               = 1,
                       // Register slice on R input (MI) side.
                       // 0 = Bypass (not recommended due to combinatorial M_RVALID -> M_RREADY path)
                       // 1 = Fully-registered (needed only when upsizer propagates bursts at 1:1 width ratio)
                       // 7 = Light-weight (safe when upsizer always packs at 1:n width ratio, as in interconnect)
   parameter integer C_AXI_SUPPORTS_USER_SIGNALS      = 0,
                       // 1 = Propagate all USER signals, 0 = Dont propagate.
   parameter integer C_AXI_AWUSER_WIDTH               = 1,
                       // Width of AWUSER signals. 
                       // Range: >= 1.
   parameter integer C_AXI_ARUSER_WIDTH               = 1,
                       // Width of ARUSER signals. 
                       // Range: >= 1.
   parameter integer C_AXI_WUSER_WIDTH                = 1,
                       // Width of WUSER signals. 
                       // Range: >= 1.
   parameter integer C_AXI_RUSER_WIDTH                = 1,
                       // Width of RUSER signals. 
                       // Range: >= 1.
   parameter integer C_AXI_BUSER_WIDTH                = 1,
                       // Width of BUSER signals. 
                       // Range: >= 1.
   parameter integer C_AXI_SUPPORTS_WRITE             = 1,
   parameter integer C_AXI_SUPPORTS_READ              = 1,
   parameter integer C_PACKING_LEVEL                    = 1,
                       // 0 = Never pack (expander only); packing logic is omitted.
                       // 1 = Pack only when CACHE[1] (Modifiable) is high.
                       // 2 = Always pack, regardless of sub-size transaction or Modifiable bit.
                       //     (Required when used as helper-core by mem-con. Same size AXI interfaces
                       //      should only be used when always packing)
   parameter integer C_SUPPORT_BURSTS                 = 1,
                       // Disabled when all connected masters and slaves are AxiLite,
                       //   allowing logic to be simplified.
   parameter integer C_SINGLE_THREAD                  = 1
                       // 0 = Ignore ID when propagating transactions (assume all responses are in order).
                       // 1 = Allow multiple outstanding transactions only if the IDs are the same
                       //   to prevent response reordering.
                       //   (If ID mismatches, stall until outstanding transaction counter = 0.)
   )
  (
   // Global Signals
   input  wire                                                    ARESETN,
   input  wire                                                    ACLK,

   // Slave Interface Write Address Ports
   input  wire [C_AXI_ID_WIDTH-1:0]             S_AXI_AWID,
   input  wire [C_AXI_ADDR_WIDTH-1:0]           S_AXI_AWADDR,
   input  wire [8-1:0]                          S_AXI_AWLEN,
   input  wire [3-1:0]                          S_AXI_AWSIZE,
   input  wire [2-1:0]                          S_AXI_AWBURST,
   input  wire [2-1:0]                          S_AXI_AWLOCK,
   input  wire [4-1:0]                          S_AXI_AWCACHE,
   input  wire [3-1:0]                          S_AXI_AWPROT,
   input  wire [4-1:0]                          S_AXI_AWREGION,
   input  wire [4-1:0]                          S_AXI_AWQOS,
   input  wire [C_AXI_AWUSER_WIDTH-1:0]         S_AXI_AWUSER,
   input  wire                                  S_AXI_AWVALID,
   output wire                                  S_AXI_AWREADY,
   // Slave Interface Write Data Ports
   input  wire [C_S_AXI_DATA_WIDTH-1:0]         S_AXI_WDATA,
   input  wire [C_S_AXI_DATA_WIDTH/8-1:0]       S_AXI_WSTRB,
   input  wire                                  S_AXI_WLAST,
   input  wire [C_AXI_WUSER_WIDTH-1:0]          S_AXI_WUSER,
   input  wire                                  S_AXI_WVALID,
   output wire                                  S_AXI_WREADY,
   // Slave Interface Write Response Ports
   output wire [C_AXI_ID_WIDTH-1:0]             S_AXI_BID,
   output wire [2-1:0]                          S_AXI_BRESP,
   output wire [C_AXI_BUSER_WIDTH-1:0]          S_AXI_BUSER,
   output wire                                  S_AXI_BVALID,
   input  wire                                  S_AXI_BREADY,
   // Slave Interface Read Address Ports
   input  wire [C_AXI_ID_WIDTH-1:0]             S_AXI_ARID,
   input  wire [C_AXI_ADDR_WIDTH-1:0]           S_AXI_ARADDR,
   input  wire [8-1:0]                          S_AXI_ARLEN,
   input  wire [3-1:0]                          S_AXI_ARSIZE,
   input  wire [2-1:0]                          S_AXI_ARBURST,
   input  wire [2-1:0]                          S_AXI_ARLOCK,
   input  wire [4-1:0]                          S_AXI_ARCACHE,
   input  wire [3-1:0]                          S_AXI_ARPROT,
   input  wire [4-1:0]                          S_AXI_ARREGION,
   input  wire [4-1:0]                          S_AXI_ARQOS,
   input  wire [C_AXI_ARUSER_WIDTH-1:0]         S_AXI_ARUSER,
   input  wire                                  S_AXI_ARVALID,
   output wire                                  S_AXI_ARREADY,
   // Slave Interface Read Data Ports
   output wire [C_AXI_ID_WIDTH-1:0]             S_AXI_RID,
   output wire [C_S_AXI_DATA_WIDTH-1:0]         S_AXI_RDATA,
   output wire [2-1:0]                          S_AXI_RRESP,
   output wire                                  S_AXI_RLAST,
   output wire [C_AXI_RUSER_WIDTH-1:0]          S_AXI_RUSER,
   output wire                                  S_AXI_RVALID,
   input  wire                                  S_AXI_RREADY,

   // Master Interface Write Address Port
   output wire [C_AXI_ID_WIDTH-1:0]          M_AXI_AWID,
   output wire [C_AXI_ADDR_WIDTH-1:0]          M_AXI_AWADDR,
   output wire [8-1:0]                         M_AXI_AWLEN,
   output wire [3-1:0]                         M_AXI_AWSIZE,
   output wire [2-1:0]                         M_AXI_AWBURST,
   output wire [2-1:0]                         M_AXI_AWLOCK,
   output wire [4-1:0]                         M_AXI_AWCACHE,
   output wire [3-1:0]                         M_AXI_AWPROT,
   output wire [4-1:0]                         M_AXI_AWREGION,
   output wire [4-1:0]                         M_AXI_AWQOS,
   output wire [C_AXI_AWUSER_WIDTH-1:0]        M_AXI_AWUSER,
   output wire                                                   M_AXI_AWVALID,
   input  wire                                                   M_AXI_AWREADY,
   // Master Interface Write Data Ports
   output wire [C_M_AXI_DATA_WIDTH-1:0]    M_AXI_WDATA,
   output wire [C_M_AXI_DATA_WIDTH/8-1:0]  M_AXI_WSTRB,
   output wire                                                   M_AXI_WLAST,
   output wire [C_AXI_WUSER_WIDTH-1:0]         M_AXI_WUSER,
   output wire                                                   M_AXI_WVALID,
   input  wire                                                   M_AXI_WREADY,
   // Master Interface Write Response Ports
   input  wire [C_AXI_ID_WIDTH-1:0]          M_AXI_BID,
   input  wire [2-1:0]                         M_AXI_BRESP,
   input  wire [C_AXI_BUSER_WIDTH-1:0]         M_AXI_BUSER,
   input  wire                                                   M_AXI_BVALID,
   output wire                                                   M_AXI_BREADY,
   // Master Interface Read Address Port
   output wire [C_AXI_ID_WIDTH-1:0]          M_AXI_ARID,
   output wire [C_AXI_ADDR_WIDTH-1:0]          M_AXI_ARADDR,
   output wire [8-1:0]                         M_AXI_ARLEN,
   output wire [3-1:0]                         M_AXI_ARSIZE,
   output wire [2-1:0]                         M_AXI_ARBURST,
   output wire [2-1:0]                         M_AXI_ARLOCK,
   output wire [4-1:0]                         M_AXI_ARCACHE,
   output wire [3-1:0]                         M_AXI_ARPROT,
   output wire [4-1:0]                         M_AXI_ARREGION,
   output wire [4-1:0]                         M_AXI_ARQOS,
   output wire [C_AXI_ARUSER_WIDTH-1:0]        M_AXI_ARUSER,
   output wire                                                   M_AXI_ARVALID,
   input  wire                                                   M_AXI_ARREADY,
   // Master Interface Read Data Ports
   input  wire [C_AXI_ID_WIDTH-1:0]          M_AXI_RID,
   input  wire [C_M_AXI_DATA_WIDTH-1:0]      M_AXI_RDATA,
   input  wire [2-1:0]                       M_AXI_RRESP,
   input  wire                               M_AXI_RLAST,
   input  wire [C_AXI_RUSER_WIDTH-1:0]       M_AXI_RUSER,
   input  wire                               M_AXI_RVALID,
   output wire                               M_AXI_RREADY
   );

   
  /////////////////////////////////////////////////////////////////////////////
  // Functions
  /////////////////////////////////////////////////////////////////////////////
  
  // Log2.
  function integer log2;
    input integer value;
  begin
    for (log2=0; value>1; log2=log2+1) begin
      value = value >> 1;
    end
  end
  endfunction
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Local params
  /////////////////////////////////////////////////////////////////////////////
  
  // Log2 of number of 32bit word on SI-side.
  localparam integer C_S_AXI_BYTES_LOG                = log2(C_S_AXI_DATA_WIDTH/8);
  
  // Log2 of number of 32bit word on MI-side.
  localparam integer C_M_AXI_BYTES_LOG                = log2(C_M_AXI_DATA_WIDTH/8);
  
  // Log2 of Up-Sizing ratio for data.
  localparam integer C_RATIO                          = C_M_AXI_DATA_WIDTH / C_S_AXI_DATA_WIDTH;
  localparam integer C_RATIO_LOG                      = log2(C_RATIO);
  localparam P_BYPASS = 32'h0;
  localparam P_LIGHTWT = 32'h7;
  localparam P_FWD_REV = 32'h1;
  
  /////////////////////////////////////////////////////////////////////////////
  // Internal signals
  /////////////////////////////////////////////////////////////////////////////
  
  wire [C_AXI_ID_WIDTH-1:0]          sr_AWID      ;   
  wire [C_AXI_ADDR_WIDTH-1:0]        sr_AWADDR    ;   
  wire [8-1:0]                       sr_AWLEN     ;   
  wire [3-1:0]                       sr_AWSIZE    ;   
  wire [2-1:0]                       sr_AWBURST   ;   
  wire [2-1:0]                       sr_AWLOCK    ;   
  wire [4-1:0]                       sr_AWCACHE   ;   
  wire [3-1:0]                       sr_AWPROT    ;   
  wire [4-1:0]                       sr_AWREGION  ;   
  wire [4-1:0]                       sr_AWQOS     ;   
  wire [C_AXI_AWUSER_WIDTH-1:0]      sr_AWUSER    ;   
  wire                               sr_AWVALID   ;   
  wire                               sr_AWREADY   ;   
  wire [C_AXI_ID_WIDTH-1:0]          sr_ARID      ;    
  wire [C_AXI_ADDR_WIDTH-1:0]        sr_ARADDR    ;    
  wire [8-1:0]                       sr_ARLEN     ;    
  wire [3-1:0]                       sr_ARSIZE    ;    
  wire [2-1:0]                       sr_ARBURST   ;    
  wire [2-1:0]                       sr_ARLOCK    ;    
  wire [4-1:0]                       sr_ARCACHE   ;    
  wire [3-1:0]                       sr_ARPROT    ;    
  wire [4-1:0]                       sr_ARREGION  ;    
  wire [4-1:0]                       sr_ARQOS     ;    
  wire [C_AXI_ARUSER_WIDTH-1:0]      sr_ARUSER    ;    
  wire                               sr_ARVALID   ;    
  wire                               sr_ARREADY   ;    
  
  wire [C_S_AXI_DATA_WIDTH-1:0]      sr_WDATA     ;
  wire [(C_S_AXI_DATA_WIDTH/8)-1:0]  sr_WSTRB     ;
  wire                               sr_WLAST     ;
  wire                               sr_WVALID    ;
  wire                               sr_WREADY    ;
  
  wire [C_AXI_ID_WIDTH-1:0]          mr_RID       ;  
  wire [C_M_AXI_DATA_WIDTH-1:0]      mr_RDATA     ;  
  wire [2-1:0]                       mr_RRESP     ;  
  wire                               mr_RLAST     ;  
  wire [C_AXI_RUSER_WIDTH-1:0]       mr_RUSER     ;  
  wire                               mr_RVALID    ;  
  wire                               mr_RREADY    ;   
  (* equivalent_register_removal = "no" *) reg ARESET ;
  
  assign M_AXI_WUSER   = {C_AXI_WUSER_WIDTH{1'b0}};
  assign S_AXI_RUSER   = {C_AXI_RUSER_WIDTH{1'b0}};

  axi_interconnect_v1_7_13_axi_register_slice #
      (
        .C_FAMILY                         (C_FAMILY),
        .C_AXI_ID_WIDTH                   (C_AXI_ID_WIDTH),
        .C_AXI_ADDR_WIDTH                 (C_AXI_ADDR_WIDTH),
        .C_AXI_DATA_WIDTH                 (C_S_AXI_DATA_WIDTH),
        .C_AXI_SUPPORTS_USER_SIGNALS      (C_AXI_SUPPORTS_USER_SIGNALS),
        .C_AXI_AWUSER_WIDTH               (C_AXI_AWUSER_WIDTH),
        .C_AXI_ARUSER_WIDTH               (C_AXI_ARUSER_WIDTH),
        .C_REG_CONFIG_AW                  (C_AXI_SUPPORTS_WRITE ? P_LIGHTWT : P_BYPASS),
        .C_REG_CONFIG_AR                  (C_AXI_SUPPORTS_READ ? P_LIGHTWT : P_BYPASS)
      )
      si_register_slice_inst 
      (
        .ARESETN                          (ARESETN),
        .ACLK                             (ACLK),
        .S_AXI_AWID                       (S_AXI_AWID     ),
        .S_AXI_AWADDR                     (S_AXI_AWADDR   ),
        .S_AXI_AWLEN                      (S_AXI_AWLEN    ),
        .S_AXI_AWSIZE                     (S_AXI_AWSIZE   ),
        .S_AXI_AWBURST                    (S_AXI_AWBURST  ),
        .S_AXI_AWLOCK                     (S_AXI_AWLOCK   ),
        .S_AXI_AWCACHE                    (S_AXI_AWCACHE  ),
        .S_AXI_AWPROT                     (S_AXI_AWPROT   ),
        .S_AXI_AWREGION                   (S_AXI_AWREGION ),
        .S_AXI_AWQOS                      (S_AXI_AWQOS    ),
        .S_AXI_AWUSER                     (S_AXI_AWUSER   ),
        .S_AXI_AWVALID                    (S_AXI_AWVALID  ),
        .S_AXI_AWREADY                    (S_AXI_AWREADY  ),
        .S_AXI_WID                        ( {C_AXI_ID_WIDTH{1'b0}}),
        .S_AXI_WDATA                      ( {C_S_AXI_DATA_WIDTH{1'b0}}    ),
        .S_AXI_WSTRB                      ( {C_S_AXI_DATA_WIDTH/8{1'b0}}  ),
        .S_AXI_WLAST                      ( 1'b0 ),
        .S_AXI_WUSER                      ( 1'b0  ),
        .S_AXI_WVALID                     ( 1'b0 ),
        .S_AXI_WREADY                     ( ),
        .S_AXI_BID                        ( ),
        .S_AXI_BRESP                      ( ),
        .S_AXI_BUSER                      ( ),
        .S_AXI_BVALID                     ( ),
        .S_AXI_BREADY                     ( 1'b0 ),
        .S_AXI_ARID                       (S_AXI_ARID     ),
        .S_AXI_ARADDR                     (S_AXI_ARADDR   ),
        .S_AXI_ARLEN                      (S_AXI_ARLEN    ),
        .S_AXI_ARSIZE                     (S_AXI_ARSIZE   ),
        .S_AXI_ARBURST                    (S_AXI_ARBURST  ),
        .S_AXI_ARLOCK                     (S_AXI_ARLOCK   ),
        .S_AXI_ARCACHE                    (S_AXI_ARCACHE  ),
        .S_AXI_ARPROT                     (S_AXI_ARPROT   ),
        .S_AXI_ARREGION                   (S_AXI_ARREGION ),
        .S_AXI_ARQOS                      (S_AXI_ARQOS    ),
        .S_AXI_ARUSER                     (S_AXI_ARUSER   ),
        .S_AXI_ARVALID                    (S_AXI_ARVALID  ),
        .S_AXI_ARREADY                    (S_AXI_ARREADY  ),
        .S_AXI_RID                        ( ) ,
        .S_AXI_RDATA                      ( ) ,
        .S_AXI_RRESP                      ( ) ,
        .S_AXI_RLAST                      ( ) ,
        .S_AXI_RUSER                      ( ) ,
        .S_AXI_RVALID                     ( ) ,
        .S_AXI_RREADY                     ( 1'b0 ) ,
        .M_AXI_AWID                       (sr_AWID     ),
        .M_AXI_AWADDR                     (sr_AWADDR   ),
        .M_AXI_AWLEN                      (sr_AWLEN    ),
        .M_AXI_AWSIZE                     (sr_AWSIZE   ),
        .M_AXI_AWBURST                    (sr_AWBURST  ),
        .M_AXI_AWLOCK                     (sr_AWLOCK   ),
        .M_AXI_AWCACHE                    (sr_AWCACHE  ),
        .M_AXI_AWPROT                     (sr_AWPROT   ),
        .M_AXI_AWREGION                   (sr_AWREGION ),
        .M_AXI_AWQOS                      (sr_AWQOS    ),
        .M_AXI_AWUSER                     (sr_AWUSER   ),
        .M_AXI_AWVALID                    (sr_AWVALID  ),
        .M_AXI_AWREADY                    (sr_AWREADY  ),
        .M_AXI_WID                        () ,
        .M_AXI_WDATA                      (),
        .M_AXI_WSTRB                      (),
        .M_AXI_WLAST                      (),
        .M_AXI_WUSER                      (),
        .M_AXI_WVALID                     (),
        .M_AXI_WREADY                     (1'b0),
        .M_AXI_BID                        ( {C_AXI_ID_WIDTH{1'b0}} ) ,
        .M_AXI_BRESP                      ( 2'b0 ) ,
        .M_AXI_BUSER                      ( 1'b0 ) ,
        .M_AXI_BVALID                     ( 1'b0 ) ,
        .M_AXI_BREADY                     ( ) ,
        .M_AXI_ARID                       (sr_ARID     ),
        .M_AXI_ARADDR                     (sr_ARADDR   ),
        .M_AXI_ARLEN                      (sr_ARLEN    ),
        .M_AXI_ARSIZE                     (sr_ARSIZE   ),
        .M_AXI_ARBURST                    (sr_ARBURST  ),
        .M_AXI_ARLOCK                     (sr_ARLOCK   ),
        .M_AXI_ARCACHE                    (sr_ARCACHE  ),
        .M_AXI_ARPROT                     (sr_ARPROT   ),
        .M_AXI_ARREGION                   (sr_ARREGION ),
        .M_AXI_ARQOS                      (sr_ARQOS    ),
        .M_AXI_ARUSER                     (sr_ARUSER   ),
        .M_AXI_ARVALID                    (sr_ARVALID  ),
        .M_AXI_ARREADY                    (sr_ARREADY  ),
        .M_AXI_RID                        ( {C_AXI_ID_WIDTH{1'b0}}),
        .M_AXI_RDATA                      ( {C_S_AXI_DATA_WIDTH{1'b0}}    ),
        .M_AXI_RRESP                      ( 2'b00 ),
        .M_AXI_RLAST                      ( 1'b0  ),
        .M_AXI_RUSER                      ( 1'b0  ),
        .M_AXI_RVALID                     ( 1'b0  ),
        .M_AXI_RREADY                     (  )
      );
  
  axi_interconnect_v1_7_13_axi_register_slice #
      (
        .C_FAMILY                         (C_FAMILY),
        .C_AXI_ID_WIDTH                   (C_AXI_ID_WIDTH),
        .C_AXI_ADDR_WIDTH                 (C_AXI_ADDR_WIDTH),
        .C_AXI_DATA_WIDTH                 (C_M_AXI_DATA_WIDTH),
        .C_AXI_SUPPORTS_USER_SIGNALS      (C_AXI_SUPPORTS_USER_SIGNALS),
        .C_AXI_RUSER_WIDTH                (C_AXI_RUSER_WIDTH),
        .C_REG_CONFIG_R                   (C_AXI_SUPPORTS_READ ? C_M_AXI_R_REGISTER : P_BYPASS)
      )
      mi_register_slice_inst 
      (
        .ARESETN                          (ARESETN),
        .ACLK                             (ACLK),
        .S_AXI_AWID                       ({C_AXI_ID_WIDTH{1'b0}}     ),
        .S_AXI_AWADDR                     ( {C_AXI_ADDR_WIDTH{1'b0}} ),
        .S_AXI_AWLEN                      ( 8'b0 ),
        .S_AXI_AWSIZE                     ( 3'b0 ),
        .S_AXI_AWBURST                    ( 2'b0 ),
        .S_AXI_AWLOCK                     ( 2'b0 ),
        .S_AXI_AWCACHE                    ( 4'b0 ),
        .S_AXI_AWPROT                     ( 3'b0 ),
        .S_AXI_AWREGION                   ( 4'b0 ),
        .S_AXI_AWQOS                      ( 4'b0 ),
        .S_AXI_AWUSER                     ( 1'b0 ),
        .S_AXI_AWVALID                    ( 1'b0 ),
        .S_AXI_AWREADY                    (     ),
        .S_AXI_WID                        ( {C_AXI_ID_WIDTH{1'b0}}),
        .S_AXI_WDATA                      ( {C_M_AXI_DATA_WIDTH{1'b0}}  ),
        .S_AXI_WSTRB                      ( {C_M_AXI_DATA_WIDTH/8{1'b0}}  ),
        .S_AXI_WLAST                      ( 1'b0 ),
        .S_AXI_WUSER                      ( 1'b0  ),
        .S_AXI_WVALID                     ( 1'b0 ),
        .S_AXI_WREADY                     ( ),
        .S_AXI_BID                        ( ),
        .S_AXI_BRESP                      ( ),
        .S_AXI_BUSER                      ( ),
        .S_AXI_BVALID                     ( ),
        .S_AXI_BREADY                     ( 1'b0 ),
        .S_AXI_ARID                       ({C_AXI_ID_WIDTH{1'b0}}     ),
        .S_AXI_ARADDR                     ( {C_AXI_ADDR_WIDTH{1'b0}} ),
        .S_AXI_ARLEN                      ( 8'b0 ),
        .S_AXI_ARSIZE                     ( 3'b0 ),
        .S_AXI_ARBURST                    ( 2'b0 ),
        .S_AXI_ARLOCK                     ( 2'b0 ),
        .S_AXI_ARCACHE                    ( 4'b0 ),
        .S_AXI_ARPROT                     ( 3'b0 ),
        .S_AXI_ARREGION                   ( 4'b0 ),
        .S_AXI_ARQOS                      ( 4'b0 ),
        .S_AXI_ARUSER                     ( 1'b0 ),
        .S_AXI_ARVALID                    ( 1'b0 ),
        .S_AXI_ARREADY                    (     ),
        .S_AXI_RID                        (mr_RID       ),
        .S_AXI_RDATA                      (mr_RDATA     ),
        .S_AXI_RRESP                      (mr_RRESP     ),
        .S_AXI_RLAST                      (mr_RLAST     ),
        .S_AXI_RUSER                      (mr_RUSER     ),
        .S_AXI_RVALID                     (mr_RVALID    ),
        .S_AXI_RREADY                     (mr_RREADY    ),
        .M_AXI_AWID                       (),
        .M_AXI_AWADDR                     (),
        .M_AXI_AWLEN                      (),
        .M_AXI_AWSIZE                     (),
        .M_AXI_AWBURST                    (),
        .M_AXI_AWLOCK                     (),
        .M_AXI_AWCACHE                    (),
        .M_AXI_AWPROT                     (),
        .M_AXI_AWREGION                   (),
        .M_AXI_AWQOS                      (),
        .M_AXI_AWUSER                     (),
        .M_AXI_AWVALID                    (),
        .M_AXI_AWREADY                    (1'b0),
        .M_AXI_WID                        () ,
        .M_AXI_WDATA                      (),
        .M_AXI_WSTRB                      (),
        .M_AXI_WLAST                      (),
        .M_AXI_WUSER                      (),
        .M_AXI_WVALID                     (),
        .M_AXI_WREADY                     (1'b0),
        .M_AXI_BID                        ( {C_AXI_ID_WIDTH{1'b0}} ) ,
        .M_AXI_BRESP                      ( 2'b0 ) ,
        .M_AXI_BUSER                      ( 1'b0 ) ,
        .M_AXI_BVALID                     ( 1'b0 ) ,
        .M_AXI_BREADY                     ( ) ,
        .M_AXI_ARID                       (),
        .M_AXI_ARADDR                     (),
        .M_AXI_ARLEN                      (),
        .M_AXI_ARSIZE                     (),
        .M_AXI_ARBURST                    (),
        .M_AXI_ARLOCK                     (),
        .M_AXI_ARCACHE                    (),
        .M_AXI_ARPROT                     (),
        .M_AXI_ARREGION                   (),
        .M_AXI_ARQOS                      (),
        .M_AXI_ARUSER                     (),
        .M_AXI_ARVALID                    (),
        .M_AXI_ARREADY                    (1'b0),
        .M_AXI_RID                        (M_AXI_RID    ),
        .M_AXI_RDATA                      (M_AXI_RDATA  ),
        .M_AXI_RRESP                      (M_AXI_RRESP  ),
        .M_AXI_RLAST                      (M_AXI_RLAST  ),
        .M_AXI_RUSER                      (M_AXI_RUSER  ),
        .M_AXI_RVALID                     (M_AXI_RVALID ),
        .M_AXI_RREADY                     (M_AXI_RREADY )
      );
  
  /////////////////////////////////////////////////////////////////////////////
  // Handle Internal Reset
  /////////////////////////////////////////////////////////////////////////////
  always @ (posedge ACLK) begin
    ARESET <= !ARESETN;
  end
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Handle Write Channels (AW/W/B)
  /////////////////////////////////////////////////////////////////////////////
  generate
    if (C_AXI_SUPPORTS_WRITE == 1) begin : USE_WRITE
    
      // Write Channel Signals for Commands Queue Interface.
      wire                              wr_cmd_valid;
      wire                              wr_cmd_fix;
      wire                              wr_cmd_modified;
      wire                              wr_cmd_complete_wrap;
      wire                              wr_cmd_packed_wrap;
      wire [C_M_AXI_BYTES_LOG-1:0]      wr_cmd_first_word;
      wire [C_M_AXI_BYTES_LOG-1:0]      wr_cmd_next_word;
      wire [C_M_AXI_BYTES_LOG-1:0]      wr_cmd_last_word;
      wire [C_M_AXI_BYTES_LOG-1:0]      wr_cmd_offset;
      wire [C_M_AXI_BYTES_LOG-1:0]      wr_cmd_mask;
      wire [C_S_AXI_BYTES_LOG:0]        wr_cmd_step;
      wire [8-1:0]                      wr_cmd_length;
      wire                              wr_cmd_ready;
      
      // Write Address Channel.
  axi_interconnect_v1_7_13_a_upsizer #
      (
       .C_FAMILY                    (C_FAMILY),
       .C_AXI_ID_WIDTH              (C_AXI_ID_WIDTH),
       .C_AXI_ADDR_WIDTH            (C_AXI_ADDR_WIDTH),
       .C_S_AXI_DATA_WIDTH          (C_S_AXI_DATA_WIDTH),
       .C_M_AXI_DATA_WIDTH          (C_M_AXI_DATA_WIDTH),
       .C_M_AXI_REGISTER            (C_M_AXI_AW_REGISTER),
       .C_AXI_SUPPORTS_USER_SIGNALS (C_AXI_SUPPORTS_USER_SIGNALS),
       .C_AXI_AUSER_WIDTH           (C_AXI_AWUSER_WIDTH),
       .C_AXI_CHANNEL               (0),
       .C_PACKING_LEVEL             (C_PACKING_LEVEL),
       .C_SUPPORT_BURSTS            (C_SUPPORT_BURSTS),
       .C_SINGLE_THREAD             (C_SINGLE_THREAD),
       .C_S_AXI_BYTES_LOG           (C_S_AXI_BYTES_LOG),
       .C_M_AXI_BYTES_LOG           (C_M_AXI_BYTES_LOG)
        ) write_addr_inst
       (
        // Global Signals
        .ARESET                     (ARESET),
        .ACLK                       (ACLK),
    
        // Command Interface
        .cmd_valid                  (wr_cmd_valid),
        .cmd_fix                    (wr_cmd_fix),
        .cmd_modified               (wr_cmd_modified),
        .cmd_complete_wrap          (wr_cmd_complete_wrap),
        .cmd_packed_wrap            (wr_cmd_packed_wrap),
        .cmd_first_word             (wr_cmd_first_word),
        .cmd_next_word              (wr_cmd_next_word),
        .cmd_last_word              (wr_cmd_last_word),
        .cmd_offset                 (wr_cmd_offset),
        .cmd_mask                   (wr_cmd_mask),
        .cmd_step                   (wr_cmd_step),
        .cmd_length                 (wr_cmd_length),
        .cmd_ready                  (wr_cmd_ready),
       
        // Slave Interface Write Address Ports
        .S_AXI_AID                  (sr_AWID),
        .S_AXI_AADDR                (sr_AWADDR),
        .S_AXI_ALEN                 (sr_AWLEN),
        .S_AXI_ASIZE                (sr_AWSIZE),
        .S_AXI_ABURST               (sr_AWBURST),
        .S_AXI_ALOCK                (sr_AWLOCK),
        .S_AXI_ACACHE               (sr_AWCACHE),
        .S_AXI_APROT                (sr_AWPROT),
        .S_AXI_AREGION              (sr_AWREGION),
        .S_AXI_AQOS                 (sr_AWQOS),
        .S_AXI_AUSER                (sr_AWUSER),
        .S_AXI_AVALID               (sr_AWVALID),
        .S_AXI_AREADY               (sr_AWREADY),
        
        // Master Interface Write Address Port
        .M_AXI_AID                  (M_AXI_AWID),
        .M_AXI_AADDR                (M_AXI_AWADDR),
        .M_AXI_ALEN                 (M_AXI_AWLEN),
        .M_AXI_ASIZE                (M_AXI_AWSIZE),
        .M_AXI_ABURST               (M_AXI_AWBURST),
        .M_AXI_ALOCK                (M_AXI_AWLOCK),
        .M_AXI_ACACHE               (M_AXI_AWCACHE),
        .M_AXI_APROT                (M_AXI_AWPROT),
        .M_AXI_AREGION              (M_AXI_AWREGION),
        .M_AXI_AQOS                 (M_AXI_AWQOS),
        .M_AXI_AUSER                (M_AXI_AWUSER),
        .M_AXI_AVALID               (M_AXI_AWVALID),
        .M_AXI_AREADY               (M_AXI_AWREADY)
       );
       
      // Write Data channel.
  axi_interconnect_v1_7_13_w_upsizer #
      (
       .C_FAMILY                    (C_FAMILY),
       .C_S_AXI_DATA_WIDTH          (C_S_AXI_DATA_WIDTH),
       .C_M_AXI_DATA_WIDTH          (C_M_AXI_DATA_WIDTH),
       .C_M_AXI_REGISTER            (1),
       .C_AXI_SUPPORTS_USER_SIGNALS (C_AXI_SUPPORTS_USER_SIGNALS),
       .C_AXI_WUSER_WIDTH           (C_AXI_WUSER_WIDTH),
       .C_PACKING_LEVEL             (C_PACKING_LEVEL),
       .C_SUPPORT_BURSTS            (C_SUPPORT_BURSTS),
       .C_S_AXI_BYTES_LOG           (C_S_AXI_BYTES_LOG),
       .C_M_AXI_BYTES_LOG           (C_M_AXI_BYTES_LOG),
       .C_RATIO                     (C_RATIO),
       .C_RATIO_LOG                 (C_RATIO_LOG)
        ) write_data_inst
       (
        // Global Signals
        .ARESET                     (ARESET),
        .ACLK                       (ACLK),
    
        // Command Interface
        .cmd_valid                  (wr_cmd_valid),
        .cmd_fix                    (wr_cmd_fix),
        .cmd_modified               (wr_cmd_modified),
        .cmd_complete_wrap          (wr_cmd_complete_wrap),
        .cmd_packed_wrap            (wr_cmd_packed_wrap),
        .cmd_first_word             (wr_cmd_first_word),
        .cmd_next_word              (wr_cmd_next_word),
        .cmd_last_word              (wr_cmd_last_word),
        .cmd_offset                 (wr_cmd_offset),
        .cmd_mask                   (wr_cmd_mask),
        .cmd_step                   (wr_cmd_step),
        .cmd_length                 (wr_cmd_length),
        .cmd_ready                  (wr_cmd_ready),
       
        // Slave Interface Write Data Ports
        .S_AXI_WDATA                (S_AXI_WDATA),
        .S_AXI_WSTRB                (S_AXI_WSTRB),
        .S_AXI_WLAST                (S_AXI_WLAST),
        .S_AXI_WUSER                (S_AXI_WUSER),
        .S_AXI_WVALID               (S_AXI_WVALID),
        .S_AXI_WREADY               (S_AXI_WREADY),
        
        // Master Interface Write Data Ports
        .M_AXI_WDATA                (M_AXI_WDATA),
        .M_AXI_WSTRB                (M_AXI_WSTRB),
        .M_AXI_WLAST                (M_AXI_WLAST),
        .M_AXI_WUSER                (),
        .M_AXI_WVALID               (M_AXI_WVALID),
        .M_AXI_WREADY               (M_AXI_WREADY)
       );
      
      // Write Response channel.
      assign S_AXI_BID     = M_AXI_BID;
      assign S_AXI_BRESP   = M_AXI_BRESP;
      assign S_AXI_BUSER   = M_AXI_BUSER;
      assign S_AXI_BVALID  = M_AXI_BVALID;
      assign M_AXI_BREADY  = S_AXI_BREADY;
       
    end else begin : NO_WRITE
      assign sr_AWREADY = 1'b0;
      assign S_AXI_WREADY  = 1'b0;
      assign S_AXI_BID     = {C_AXI_ID_WIDTH{1'b0}};
      assign S_AXI_BRESP   = 2'b0;
      assign S_AXI_BUSER   = {C_AXI_BUSER_WIDTH{1'b0}};
      assign S_AXI_BVALID  = 1'b0;
      
      assign M_AXI_AWID    = {C_AXI_ID_WIDTH{1'b0}};
      assign M_AXI_AWADDR  = {C_AXI_ADDR_WIDTH{1'b0}};
      assign M_AXI_AWLEN   = 8'b0;
      assign M_AXI_AWSIZE  = 3'b0;
      assign M_AXI_AWBURST = 2'b0;
      assign M_AXI_AWLOCK  = 2'b0;
      assign M_AXI_AWCACHE = 4'b0;
      assign M_AXI_AWPROT  = 3'b0;
      assign M_AXI_AWQOS   = 4'b0;
      assign M_AXI_AWUSER  = {C_AXI_AWUSER_WIDTH{1'b0}};
      assign M_AXI_AWVALID = 1'b0;
      assign M_AXI_WDATA   = {C_M_AXI_DATA_WIDTH{1'b0}};
      assign M_AXI_WSTRB   = {C_M_AXI_DATA_WIDTH/8{1'b0}};
      assign M_AXI_WLAST   = 1'b0;
      assign M_AXI_WVALID  = 1'b0;
      assign M_AXI_BREADY  = 1'b0;
      
    end
  endgenerate
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Handle Read Channels (AR/R)
  /////////////////////////////////////////////////////////////////////////////
  generate
    if (C_AXI_SUPPORTS_READ == 1) begin : USE_READ
    
      // Read Channel Signals for Commands Queue Interface.
      wire                              rd_cmd_valid;
      wire                              rd_cmd_fix;
      wire                              rd_cmd_modified;
      wire                              rd_cmd_complete_wrap;
      wire                              rd_cmd_packed_wrap;
      wire [C_M_AXI_BYTES_LOG-1:0]      rd_cmd_first_word;
      wire [C_M_AXI_BYTES_LOG-1:0]      rd_cmd_next_word;
      wire [C_M_AXI_BYTES_LOG-1:0]      rd_cmd_last_word;
      wire [C_M_AXI_BYTES_LOG-1:0]      rd_cmd_offset;
      wire [C_M_AXI_BYTES_LOG-1:0]      rd_cmd_mask;
      wire [C_S_AXI_BYTES_LOG:0]        rd_cmd_step;
      wire [8-1:0]                      rd_cmd_length;
      wire                              rd_cmd_ready;
      
      // Write Address Channel.
  axi_interconnect_v1_7_13_a_upsizer #
      (
       .C_FAMILY                    (C_FAMILY),
       .C_AXI_ID_WIDTH              (C_AXI_ID_WIDTH),
       .C_AXI_ADDR_WIDTH            (C_AXI_ADDR_WIDTH),
       .C_S_AXI_DATA_WIDTH          (C_S_AXI_DATA_WIDTH),
       .C_M_AXI_DATA_WIDTH          (C_M_AXI_DATA_WIDTH),
       .C_M_AXI_REGISTER            (C_M_AXI_AR_REGISTER),
       .C_AXI_SUPPORTS_USER_SIGNALS (C_AXI_SUPPORTS_USER_SIGNALS),
       .C_AXI_AUSER_WIDTH           (C_AXI_ARUSER_WIDTH),
       .C_AXI_CHANNEL               (1),
       .C_PACKING_LEVEL             (C_PACKING_LEVEL),
       .C_SUPPORT_BURSTS            (C_SUPPORT_BURSTS),
       .C_SINGLE_THREAD             (C_SINGLE_THREAD),
       .C_S_AXI_BYTES_LOG           (C_S_AXI_BYTES_LOG),
       .C_M_AXI_BYTES_LOG           (C_M_AXI_BYTES_LOG)
        ) read_addr_inst
       (
        // Global Signals
        .ARESET                     (ARESET),
        .ACLK                       (ACLK),
    
        // Command Interface
        .cmd_valid                  (rd_cmd_valid),
        .cmd_fix                    (rd_cmd_fix),
        .cmd_modified               (rd_cmd_modified),
        .cmd_complete_wrap          (rd_cmd_complete_wrap),
        .cmd_packed_wrap            (rd_cmd_packed_wrap),
        .cmd_first_word             (rd_cmd_first_word),
        .cmd_next_word              (rd_cmd_next_word),
        .cmd_last_word              (rd_cmd_last_word),
        .cmd_offset                 (rd_cmd_offset),
        .cmd_mask                   (rd_cmd_mask),
        .cmd_step                   (rd_cmd_step),
        .cmd_length                 (rd_cmd_length),
        .cmd_ready                  (rd_cmd_ready),
       
        // Slave Interface Write Address Ports
        .S_AXI_AID                  (sr_ARID),
        .S_AXI_AADDR                (sr_ARADDR),
        .S_AXI_ALEN                 (sr_ARLEN),
        .S_AXI_ASIZE                (sr_ARSIZE),
        .S_AXI_ABURST               (sr_ARBURST),
        .S_AXI_ALOCK                (sr_ARLOCK),
        .S_AXI_ACACHE               (sr_ARCACHE),
        .S_AXI_APROT                (sr_ARPROT),
        .S_AXI_AREGION              (sr_ARREGION),
        .S_AXI_AQOS                 (sr_ARQOS),
        .S_AXI_AUSER                (sr_ARUSER),
        .S_AXI_AVALID               (sr_ARVALID),
        .S_AXI_AREADY               (sr_ARREADY),
        
        // Master Interface Write Address Port
        .M_AXI_AID                  (M_AXI_ARID),
        .M_AXI_AADDR                (M_AXI_ARADDR),
        .M_AXI_ALEN                 (M_AXI_ARLEN),
        .M_AXI_ASIZE                (M_AXI_ARSIZE),
        .M_AXI_ABURST               (M_AXI_ARBURST),
        .M_AXI_ALOCK                (M_AXI_ARLOCK),
        .M_AXI_ACACHE               (M_AXI_ARCACHE),
        .M_AXI_APROT                (M_AXI_ARPROT),
        .M_AXI_AREGION              (M_AXI_ARREGION),
        .M_AXI_AQOS                 (M_AXI_ARQOS),
        .M_AXI_AUSER                (M_AXI_ARUSER),
        .M_AXI_AVALID               (M_AXI_ARVALID),
        .M_AXI_AREADY               (M_AXI_ARREADY)
       );
       
      // Read Data channel.
  axi_interconnect_v1_7_13_r_upsizer #
      (
       .C_FAMILY                    (C_FAMILY),
       .C_AXI_ID_WIDTH              (C_AXI_ID_WIDTH),
       .C_S_AXI_DATA_WIDTH          (C_S_AXI_DATA_WIDTH),
       .C_M_AXI_DATA_WIDTH          (C_M_AXI_DATA_WIDTH),
       .C_S_AXI_REGISTER            (C_S_AXI_R_REGISTER),
       .C_AXI_SUPPORTS_USER_SIGNALS (C_AXI_SUPPORTS_USER_SIGNALS),
       .C_AXI_RUSER_WIDTH           (C_AXI_RUSER_WIDTH),
       .C_PACKING_LEVEL             (C_PACKING_LEVEL),
       .C_SUPPORT_BURSTS            (C_SUPPORT_BURSTS),
       .C_S_AXI_BYTES_LOG           (C_S_AXI_BYTES_LOG),
       .C_M_AXI_BYTES_LOG           (C_M_AXI_BYTES_LOG),
       .C_RATIO                     (C_RATIO),
       .C_RATIO_LOG                 (C_RATIO_LOG)
        ) read_data_inst
       (
        // Global Signals
        .ARESET                     (ARESET),
        .ACLK                       (ACLK),
    
        // Command Interface
        .cmd_valid                  (rd_cmd_valid),
        .cmd_fix                    (rd_cmd_fix),
        .cmd_modified               (rd_cmd_modified),
        .cmd_complete_wrap          (rd_cmd_complete_wrap),
        .cmd_packed_wrap            (rd_cmd_packed_wrap),
        .cmd_first_word             (rd_cmd_first_word),
        .cmd_next_word              (rd_cmd_next_word),
        .cmd_last_word              (rd_cmd_last_word),
        .cmd_offset                 (rd_cmd_offset),
        .cmd_mask                   (rd_cmd_mask),
        .cmd_step                   (rd_cmd_step),
        .cmd_length                 (rd_cmd_length),
        .cmd_ready                  (rd_cmd_ready),
       
        // Slave Interface Read Data Ports
        .S_AXI_RID                  (S_AXI_RID),
        .S_AXI_RDATA                (S_AXI_RDATA),
        .S_AXI_RRESP                (S_AXI_RRESP),
        .S_AXI_RLAST                (S_AXI_RLAST),
        .S_AXI_RUSER                (),
        .S_AXI_RVALID               (S_AXI_RVALID),
        .S_AXI_RREADY               (S_AXI_RREADY),
        
        // Master Interface Read Data Ports
        .M_AXI_RID                  (mr_RID),
        .M_AXI_RDATA                (mr_RDATA),
        .M_AXI_RRESP                (mr_RRESP),
        .M_AXI_RLAST                (mr_RLAST),
        .M_AXI_RUSER                (mr_RUSER),
        .M_AXI_RVALID               (mr_RVALID),
        .M_AXI_RREADY               (mr_RREADY)
       );
       
    end else begin : NO_READ
      assign sr_ARREADY = 1'b0;
      assign S_AXI_RID     = {C_AXI_ID_WIDTH{1'b0}};
      assign S_AXI_RDATA   = {C_S_AXI_DATA_WIDTH{1'b0}};
      assign S_AXI_RRESP   = 2'b0;
      assign S_AXI_RLAST   = 1'b0;
      assign S_AXI_RVALID  = 1'b0;
      
      assign M_AXI_ARID    = {C_AXI_ID_WIDTH{1'b0}};
      assign M_AXI_ARADDR  = {C_AXI_ADDR_WIDTH{1'b0}};
      assign M_AXI_ARLEN   = 8'b0;
      assign M_AXI_ARSIZE  = 3'b0;
      assign M_AXI_ARBURST = 2'b0;
      assign M_AXI_ARLOCK  = 2'b0;
      assign M_AXI_ARCACHE = 4'b0;
      assign M_AXI_ARPROT  = 3'b0;
      assign M_AXI_ARQOS   = 4'b0;
      assign M_AXI_ARUSER  = {C_AXI_ARUSER_WIDTH{1'b0}};
      assign M_AXI_ARVALID = 1'b0;
      assign mr_RREADY  = 1'b0;
      
    end
  endgenerate
  
  
endmodule
`default_nettype wire


// -- (c) Copyright 2010 - 2011 Xilinx, Inc. All rights reserved.
// --
// -- This file contains confidential and proprietary information
// -- of Xilinx, Inc. and is protected under U.S. and 
// -- international copyright and other intellectual property
// -- laws.
// --
// -- DISCLAIMER
// -- This disclaimer is not a license and does not grant any
// -- rights to the materials distributed herewith. Except as
// -- otherwise provided in a valid license issued to you by
// -- Xilinx, and to the maximum extent permitted by applicable
// -- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
// -- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
// -- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
// -- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
// -- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
// -- (2) Xilinx shall not be liable (whether in contract or tort,
// -- including negligence, or under any other theory of
// -- liability) for any loss or damage of any kind or nature
// -- related to, arising under or in connection with these
// -- materials, including for any direct, or any indirect,
// -- special, incidental, or consequential loss or damage
// -- (including loss of data, profits, goodwill, or any type of
// -- loss or damage suffered as a result of any action brought
// -- by a third party) even if such damage or loss was
// -- reasonably foreseeable or Xilinx had been advised of the
// -- possibility of the same.
// --
// -- CRITICAL APPLICATIONS
// -- Xilinx products are not designed or intended to be fail-
// -- safe, or for use in any application requiring fail-safe
// -- performance, such as life-support or safety devices or
// -- systems, Class III medical devices, nuclear facilities,
// -- applications related to the deployment of airbags, or any
// -- other applications that could lead to death, personal
// -- injury, or severe property or environmental damage
// -- (individually and collectively, "Critical
// -- Applications"). Customer assumes the sole risk and
// -- liability of any use of Xilinx products in Critical
// -- Applications, subject only to applicable laws and
// -- regulations governing limitations on product liability.
// --
// -- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
// -- PART OF THIS FILE AT ALL TIMES.
//-----------------------------------------------------------------------------
//
// Description: Write Data Response Down-Sizer
// Collect MI-side responses and set the SI-side response to the most critical
// level (in descending order):
//    DECERR, SLVERROR and OKAY.
// EXOKAY cannot occur for split transactions. 
//
//
// Verilog-standard:  Verilog 2001
//--------------------------------------------------------------------------
//
// Structure:
//   wr_upsizer
//
//--------------------------------------------------------------------------
`timescale 1ps/1ps

(* DowngradeIPIdentifiedWarnings="yes" *) 
module axi_interconnect_v1_7_13_b_downsizer #
  (
   parameter         C_FAMILY                         = "none", 
                       // FPGA Family. Current version: virtex6 or spartan6.
   parameter integer C_AXI_ID_WIDTH                   = 4, 
                       // Width of all ID signals on SI and MI side of converter.
                       // Range: >= 1.
   parameter integer C_AXI_SUPPORTS_USER_SIGNALS      = 0,
                       // 1 = Propagate all USER signals, 0 = Dont propagate.
   parameter integer C_AXI_BUSER_WIDTH                = 1
                       // Width of BUSER signals. 
                       // Range: >= 1.
   )
  (
   // Global Signals
   input  wire                                                    ARESET,
   input  wire                                                    ACLK,

   // Command Interface
   input  wire                              cmd_valid,
   input  wire                              cmd_split,
   input  wire [4-1:0]                      cmd_repeat,
   output wire                              cmd_ready,
   
   // Slave Interface Write Response Ports
   output wire [C_AXI_ID_WIDTH-1:0]           S_AXI_BID,
   output wire [2-1:0]                          S_AXI_BRESP,
   output wire [C_AXI_BUSER_WIDTH-1:0]          S_AXI_BUSER,
   output wire                                                    S_AXI_BVALID,
   input  wire                                                    S_AXI_BREADY,

   // Master Interface Write Response Ports
   input  wire [C_AXI_ID_WIDTH-1:0]          M_AXI_BID,
   input  wire [2-1:0]                         M_AXI_BRESP,
   input  wire [C_AXI_BUSER_WIDTH-1:0]         M_AXI_BUSER,
   input  wire                                                   M_AXI_BVALID,
   output wire                                                   M_AXI_BREADY
   );
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Variables for generating parameter controlled instances.
  /////////////////////////////////////////////////////////////////////////////
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Local params
  /////////////////////////////////////////////////////////////////////////////
  
  // Constants for packing levels.
  localparam [2-1:0] C_RESP_OKAY        = 2'b00;
  localparam [2-1:0] C_RESP_EXOKAY      = 2'b01;
  localparam [2-1:0] C_RESP_SLVERROR    = 2'b10;
  localparam [2-1:0] C_RESP_DECERR      = 2'b11;
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Functions
  /////////////////////////////////////////////////////////////////////////////
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Internal signals
  /////////////////////////////////////////////////////////////////////////////
  
  // Throttling help signals.
  wire                            cmd_ready_i;
  wire                            pop_mi_data;
  wire                            mi_stalling;
  
  // Repeat handling related.
  reg  [4-1:0]                    repeat_cnt_pre;
  reg  [4-1:0]                    repeat_cnt;
  wire [4-1:0]                    next_repeat_cnt;
  reg                             first_mi_word;
  wire                            last_word;
  
  // Ongoing split transaction.
  wire                            load_bresp;
  wire                            need_to_update_bresp;
  reg  [2-1:0]                    S_AXI_BRESP_ACC;
  
  // Internal signals for MI-side.
  wire                            M_AXI_BREADY_I;
  
  // Internal signals for SI-side.
  wire [C_AXI_ID_WIDTH-1:0]       S_AXI_BID_I;
  reg  [2-1:0]                    S_AXI_BRESP_I;
  wire [C_AXI_BUSER_WIDTH-1:0]    S_AXI_BUSER_I;
  wire                            S_AXI_BVALID_I;
  wire                            S_AXI_BREADY_I;
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Handle interface handshaking:
  // 
  // The MI-side BRESP is popped when at once for split transactions, except 
  // for the last cycle that behaves like a "normal" transaction.
  // A "normal" BRESP is popped once the SI-side is able to use it,
  // 
  // 
  /////////////////////////////////////////////////////////////////////////////
  
  // Pop word from MI-side.
  assign M_AXI_BREADY_I = M_AXI_BVALID & ~mi_stalling;
  assign M_AXI_BREADY   = M_AXI_BREADY_I;
  
  // Indicate when there is a BRESP available @ SI-side.
  assign S_AXI_BVALID_I = M_AXI_BVALID & last_word;
  
  // Get MI-side data.
  assign pop_mi_data    = M_AXI_BVALID & M_AXI_BREADY_I;
  
  // Signal that the command is done (so that it can be poped from command queue).
  assign cmd_ready_i    = cmd_valid & pop_mi_data & last_word;
  assign cmd_ready      = cmd_ready_i;
  
  // Detect when MI-side is stalling.
  assign mi_stalling    = (~S_AXI_BREADY_I & last_word);
                          
  
  /////////////////////////////////////////////////////////////////////////////
  // Handle the accumulation of BRESP.
  // 
  // Forward the accumulated or MI-side BRESP value depending on state:
  //  * MI-side BRESP is forwarded untouched when it is a non split cycle.
  //    (MI-side BRESP value is also used when updating the accumulated for
  //     the last access during a split access).
  //  * The accumulated BRESP is for a split transaction.
  // 
  // The accumulated BRESP register is updated for each MI-side response that 
  // is used.
  // 
  /////////////////////////////////////////////////////////////////////////////
  
  // Force load accumulated BRESPs to first value
  assign load_bresp           = (cmd_split & first_mi_word);
  
  // Update if more critical.
  assign need_to_update_bresp = ( M_AXI_BRESP > S_AXI_BRESP_ACC );
  
  // Select accumultated or direct depending on setting.
  always @ *
  begin
    if ( cmd_split ) begin
      if ( load_bresp || need_to_update_bresp ) begin
        S_AXI_BRESP_I = M_AXI_BRESP;
      end else begin
        S_AXI_BRESP_I = S_AXI_BRESP_ACC;
      end
    end else begin
      S_AXI_BRESP_I = M_AXI_BRESP;
    end
  end
  
  // Accumulate MI-side BRESP.
  always @ (posedge ACLK) begin
    if (ARESET) begin
      S_AXI_BRESP_ACC <= C_RESP_OKAY;
    end else begin
      if ( pop_mi_data ) begin
        S_AXI_BRESP_ACC <= S_AXI_BRESP_I;
      end
    end
  end
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Keep track of BRESP repeat counter.
  //
  // Last BRESP word is either:
  //  * The first and only word when not merging.
  //  * The last value when merging.
  // 
  // The internal counter is taken from the external command interface during
  // the first response when merging. The counter is updated each time a
  // BRESP is popped from the MI-side interface.
  // 
  /////////////////////////////////////////////////////////////////////////////
  
  // Determine last BRESP cycle.
  assign last_word  = ( ( repeat_cnt == 4'b0 ) & ~first_mi_word ) | 
                      ~cmd_split;
  
  // Select command reapeat or counted repeat value.
  always @ *
  begin
    if ( first_mi_word ) begin
      repeat_cnt_pre  =  cmd_repeat;
    end else begin
      repeat_cnt_pre  =  repeat_cnt;
    end
  end
  
  // Calculate next repeat counter value.
  assign next_repeat_cnt  = repeat_cnt_pre - 1'b1;
  
  // Keep track of the repeat count.
  always @ (posedge ACLK) begin
    if (ARESET) begin
      repeat_cnt    <= 4'b0;
      first_mi_word <= 1'b1;
    end else begin
      if ( pop_mi_data ) begin
        repeat_cnt    <= next_repeat_cnt;
        first_mi_word <= last_word;
      end
    end
  end
  
  
  /////////////////////////////////////////////////////////////////////////////
  // BID Handling
  /////////////////////////////////////////////////////////////////////////////
  
  assign S_AXI_BID_I  = M_AXI_BID;
  
  
  /////////////////////////////////////////////////////////////////////////////
  // USER Data bits
  // 
  // The last USER bits are simply taken from the last BRESP that is merged.
  // Ground USER bits when unused.
  /////////////////////////////////////////////////////////////////////////////
  
  // Select USER bits.
  assign S_AXI_BUSER_I = {C_AXI_BUSER_WIDTH{1'b0}};
  
  
  /////////////////////////////////////////////////////////////////////////////
  // SI-side output handling
  /////////////////////////////////////////////////////////////////////////////
// TODO: registered?  
  assign S_AXI_BID      = S_AXI_BID_I;
  assign S_AXI_BRESP    = S_AXI_BRESP_I;
  assign S_AXI_BUSER    = S_AXI_BUSER_I;
  assign S_AXI_BVALID   = S_AXI_BVALID_I;
  assign S_AXI_BREADY_I = S_AXI_BREADY;
  
  
endmodule



// -- (c) Copyright 2010 - 2011 Xilinx, Inc. All rights reserved.
// --
// -- This file contains confidential and proprietary information
// -- of Xilinx, Inc. and is protected under U.S. and 
// -- international copyright and other intellectual property
// -- laws.
// --
// -- DISCLAIMER
// -- This disclaimer is not a license and does not grant any
// -- rights to the materials distributed herewith. Except as
// -- otherwise provided in a valid license issued to you by
// -- Xilinx, and to the maximum extent permitted by applicable
// -- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
// -- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
// -- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
// -- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
// -- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
// -- (2) Xilinx shall not be liable (whether in contract or tort,
// -- including negligence, or under any other theory of
// -- liability) for any loss or damage of any kind or nature
// -- related to, arising under or in connection with these
// -- materials, including for any direct, or any indirect,
// -- special, incidental, or consequential loss or damage
// -- (including loss of data, profits, goodwill, or any type of
// -- loss or damage suffered as a result of any action brought
// -- by a third party) even if such damage or loss was
// -- reasonably foreseeable or Xilinx had been advised of the
// -- possibility of the same.
// --
// -- CRITICAL APPLICATIONS
// -- Xilinx products are not designed or intended to be fail-
// -- safe, or for use in any application requiring fail-safe
// -- performance, such as life-support or safety devices or
// -- systems, Class III medical devices, nuclear facilities,
// -- applications related to the deployment of airbags, or any
// -- other applications that could lead to death, personal
// -- injury, or severe property or environmental damage
// -- (individually and collectively, "Critical
// -- Applications"). Customer assumes the sole risk and
// -- liability of any use of Xilinx products in Critical
// -- Applications, subject only to applicable laws and
// -- regulations governing limitations on product liability.
// --
// -- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
// -- PART OF THIS FILE AT ALL TIMES.
//-----------------------------------------------------------------------------
//
// Description: 
//  Optimized AND with carry logic.
//
// Verilog-standard:  Verilog 2001
//--------------------------------------------------------------------------
//
// Structure:
//   
//
//--------------------------------------------------------------------------
`timescale 1ps/1ps


(* DowngradeIPIdentifiedWarnings="yes" *) 
module axi_interconnect_v1_7_13_carry_and #
  (
   parameter         C_FAMILY                         = "virtex6"
                       // FPGA Family. Current version: virtex6 or spartan6.
   )
  (
   input  wire        CIN,
   input  wire        S,
   output wire        COUT
   );
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Variables for generating parameter controlled instances.
  /////////////////////////////////////////////////////////////////////////////
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Local params
  /////////////////////////////////////////////////////////////////////////////
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Functions
  /////////////////////////////////////////////////////////////////////////////
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Internal signals
  /////////////////////////////////////////////////////////////////////////////

  
  /////////////////////////////////////////////////////////////////////////////
  // Instantiate or use RTL code
  /////////////////////////////////////////////////////////////////////////////
  
  generate
    if ( C_FAMILY == "rtl" ) begin : USE_RTL
      assign COUT = CIN & S;
      
    end else begin : USE_FPGA
      MUXCY and_inst 
      (
       .O (COUT), 
       .CI (CIN), 
       .DI (1'b0), 
       .S (S)
      ); 
      
    end
  endgenerate
  
  
endmodule



// -- (c) Copyright 2010 - 2011 Xilinx, Inc. All rights reserved.
// --
// -- This file contains confidential and proprietary information
// -- of Xilinx, Inc. and is protected under U.S. and 
// -- international copyright and other intellectual property
// -- laws.
// --
// -- DISCLAIMER
// -- This disclaimer is not a license and does not grant any
// -- rights to the materials distributed herewith. Except as
// -- otherwise provided in a valid license issued to you by
// -- Xilinx, and to the maximum extent permitted by applicable
// -- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
// -- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
// -- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
// -- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
// -- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
// -- (2) Xilinx shall not be liable (whether in contract or tort,
// -- including negligence, or under any other theory of
// -- liability) for any loss or damage of any kind or nature
// -- related to, arising under or in connection with these
// -- materials, including for any direct, or any indirect,
// -- special, incidental, or consequential loss or damage
// -- (including loss of data, profits, goodwill, or any type of
// -- loss or damage suffered as a result of any action brought
// -- by a third party) even if such damage or loss was
// -- reasonably foreseeable or Xilinx had been advised of the
// -- possibility of the same.
// --
// -- CRITICAL APPLICATIONS
// -- Xilinx products are not designed or intended to be fail-
// -- safe, or for use in any application requiring fail-safe
// -- performance, such as life-support or safety devices or
// -- systems, Class III medical devices, nuclear facilities,
// -- applications related to the deployment of airbags, or any
// -- other applications that could lead to death, personal
// -- injury, or severe property or environmental damage
// -- (individually and collectively, "Critical
// -- Applications"). Customer assumes the sole risk and
// -- liability of any use of Xilinx products in Critical
// -- Applications, subject only to applicable laws and
// -- regulations governing limitations on product liability.
// --
// -- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
// -- PART OF THIS FILE AT ALL TIMES.
//-----------------------------------------------------------------------------
//
// Description: 
//  Optimized AND with carry logic.
//
// Verilog-standard:  Verilog 2001
//--------------------------------------------------------------------------
//
// Structure:
//   
//
//--------------------------------------------------------------------------
`timescale 1ps/1ps


(* DowngradeIPIdentifiedWarnings="yes" *) 
module axi_interconnect_v1_7_13_carry_latch_and #
  (
   parameter          C_FAMILY                         = "virtex6"
                       // FPGA Family. Current version: virtex6 or spartan6.
   )
  (
   input  wire        CIN,
   input  wire        I,
   output wire        O
   );
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Variables for generating parameter controlled instances.
  /////////////////////////////////////////////////////////////////////////////
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Local params
  /////////////////////////////////////////////////////////////////////////////
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Functions
  /////////////////////////////////////////////////////////////////////////////
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Internal signals
  /////////////////////////////////////////////////////////////////////////////

  
  /////////////////////////////////////////////////////////////////////////////
  // Instantiate or use RTL code
  /////////////////////////////////////////////////////////////////////////////
  
  generate
    if ( C_FAMILY == "rtl" ) begin : USE_RTL
      assign O = CIN & ~I;
      
    end else begin : USE_FPGA
      wire I_n;
      
      assign I_n = ~I;
    
      AND2B1L and2b1l_inst 
        (
         .O(O),
         .DI(CIN),
         .SRI(I_n)
        );
      
    end
  endgenerate
  
  
endmodule



// -- (c) Copyright 2010 - 2011 Xilinx, Inc. All rights reserved.
// --
// -- This file contains confidential and proprietary information
// -- of Xilinx, Inc. and is protected under U.S. and 
// -- international copyright and other intellectual property
// -- laws.
// --
// -- DISCLAIMER
// -- This disclaimer is not a license and does not grant any
// -- rights to the materials distributed herewith. Except as
// -- otherwise provided in a valid license issued to you by
// -- Xilinx, and to the maximum extent permitted by applicable
// -- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
// -- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
// -- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
// -- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
// -- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
// -- (2) Xilinx shall not be liable (whether in contract or tort,
// -- including negligence, or under any other theory of
// -- liability) for any loss or damage of any kind or nature
// -- related to, arising under or in connection with these
// -- materials, including for any direct, or any indirect,
// -- special, incidental, or consequential loss or damage
// -- (including loss of data, profits, goodwill, or any type of
// -- loss or damage suffered as a result of any action brought
// -- by a third party) even if such damage or loss was
// -- reasonably foreseeable or Xilinx had been advised of the
// -- possibility of the same.
// --
// -- CRITICAL APPLICATIONS
// -- Xilinx products are not designed or intended to be fail-
// -- safe, or for use in any application requiring fail-safe
// -- performance, such as life-support or safety devices or
// -- systems, Class III medical devices, nuclear facilities,
// -- applications related to the deployment of airbags, or any
// -- other applications that could lead to death, personal
// -- injury, or severe property or environmental damage
// -- (individually and collectively, "Critical
// -- Applications"). Customer assumes the sole risk and
// -- liability of any use of Xilinx products in Critical
// -- Applications, subject only to applicable laws and
// -- regulations governing limitations on product liability.
// --
// -- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
// -- PART OF THIS FILE AT ALL TIMES.
//-----------------------------------------------------------------------------
//
// Description: 
//  Optimized OR with carry logic.
//
// Verilog-standard:  Verilog 2001
//--------------------------------------------------------------------------
//
// Structure:
//   
//
//--------------------------------------------------------------------------
`timescale 1ps/1ps


(* DowngradeIPIdentifiedWarnings="yes" *) 
module axi_interconnect_v1_7_13_carry_latch_or #
  (
   parameter          C_FAMILY                         = "virtex6"
                       // FPGA Family. Current version: virtex6 or spartan6.
   )
  (
   input  wire        CIN,
   input  wire        I,
   output wire        O
   );
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Variables for generating parameter controlled instances.
  /////////////////////////////////////////////////////////////////////////////
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Local params
  /////////////////////////////////////////////////////////////////////////////
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Functions
  /////////////////////////////////////////////////////////////////////////////
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Internal signals
  /////////////////////////////////////////////////////////////////////////////
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Instantiate or use RTL code
  /////////////////////////////////////////////////////////////////////////////
  
  generate
    if ( C_FAMILY == "rtl" ) begin : USE_RTL
      assign O = CIN | I;
      
    end else begin : USE_FPGA
      OR2L or2l_inst1
        (
         .O(O),
         .DI(CIN),
         .SRI(I)
        );
      
    end
  endgenerate
  
  
endmodule



// -- (c) Copyright 2010 - 2011 Xilinx, Inc. All rights reserved.
// --
// -- This file contains confidential and proprietary information
// -- of Xilinx, Inc. and is protected under U.S. and 
// -- international copyright and other intellectual property
// -- laws.
// --
// -- DISCLAIMER
// -- This disclaimer is not a license and does not grant any
// -- rights to the materials distributed herewith. Except as
// -- otherwise provided in a valid license issued to you by
// -- Xilinx, and to the maximum extent permitted by applicable
// -- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
// -- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
// -- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
// -- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
// -- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
// -- (2) Xilinx shall not be liable (whether in contract or tort,
// -- including negligence, or under any other theory of
// -- liability) for any loss or damage of any kind or nature
// -- related to, arising under or in connection with these
// -- materials, including for any direct, or any indirect,
// -- special, incidental, or consequential loss or damage
// -- (including loss of data, profits, goodwill, or any type of
// -- loss or damage suffered as a result of any action brought
// -- by a third party) even if such damage or loss was
// -- reasonably foreseeable or Xilinx had been advised of the
// -- possibility of the same.
// --
// -- CRITICAL APPLICATIONS
// -- Xilinx products are not designed or intended to be fail-
// -- safe, or for use in any application requiring fail-safe
// -- performance, such as life-support or safety devices or
// -- systems, Class III medical devices, nuclear facilities,
// -- applications related to the deployment of airbags, or any
// -- other applications that could lead to death, personal
// -- injury, or severe property or environmental damage
// -- (individually and collectively, "Critical
// -- Applications"). Customer assumes the sole risk and
// -- liability of any use of Xilinx products in Critical
// -- Applications, subject only to applicable laws and
// -- regulations governing limitations on product liability.
// --
// -- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
// -- PART OF THIS FILE AT ALL TIMES.
//-----------------------------------------------------------------------------
//
// Description: 
//  Optimized OR with carry logic.
//
// Verilog-standard:  Verilog 2001
//--------------------------------------------------------------------------
//
// Structure:
//   
//
//--------------------------------------------------------------------------
`timescale 1ps/1ps


(* DowngradeIPIdentifiedWarnings="yes" *) 
module axi_interconnect_v1_7_13_carry_or #
  (
   parameter         C_FAMILY                         = "virtex6"
                       // FPGA Family. Current version: virtex6 or spartan6.
   )
  (
   input  wire        CIN,
   input  wire        S,
   output wire        COUT
   );
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Variables for generating parameter controlled instances.
  /////////////////////////////////////////////////////////////////////////////
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Local params
  /////////////////////////////////////////////////////////////////////////////
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Functions
  /////////////////////////////////////////////////////////////////////////////
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Internal signals
  /////////////////////////////////////////////////////////////////////////////
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Instantiate or use RTL code
  /////////////////////////////////////////////////////////////////////////////
  
  generate
    if ( C_FAMILY == "rtl" ) begin : USE_RTL
      assign COUT = CIN | S;
      
    end else begin : USE_FPGA
      wire S_n;
      
      assign S_n = ~S;
    
      MUXCY and_inst 
      (
       .O (COUT), 
       .CI (CIN), 
       .DI (1'b1), 
       .S (S_n)
      ); 
      
    end
  endgenerate
  
  
endmodule



// -- (c) Copyright 2010 - 2011 Xilinx, Inc. All rights reserved.
// --
// -- This file contains confidential and proprietary information
// -- of Xilinx, Inc. and is protected under U.S. and 
// -- international copyright and other intellectual property
// -- laws.
// --
// -- DISCLAIMER
// -- This disclaimer is not a license and does not grant any
// -- rights to the materials distributed herewith. Except as
// -- otherwise provided in a valid license issued to you by
// -- Xilinx, and to the maximum extent permitted by applicable
// -- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
// -- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
// -- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
// -- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
// -- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
// -- (2) Xilinx shall not be liable (whether in contract or tort,
// -- including negligence, or under any other theory of
// -- liability) for any loss or damage of any kind or nature
// -- related to, arising under or in connection with these
// -- materials, including for any direct, or any indirect,
// -- special, incidental, or consequential loss or damage
// -- (including loss of data, profits, goodwill, or any type of
// -- loss or damage suffered as a result of any action brought
// -- by a third party) even if such damage or loss was
// -- reasonably foreseeable or Xilinx had been advised of the
// -- possibility of the same.
// --
// -- CRITICAL APPLICATIONS
// -- Xilinx products are not designed or intended to be fail-
// -- safe, or for use in any application requiring fail-safe
// -- performance, such as life-support or safety devices or
// -- systems, Class III medical devices, nuclear facilities,
// -- applications related to the deployment of airbags, or any
// -- other applications that could lead to death, personal
// -- injury, or severe property or environmental damage
// -- (individually and collectively, "Critical
// -- Applications"). Customer assumes the sole risk and
// -- liability of any use of Xilinx products in Critical
// -- Applications, subject only to applicable laws and
// -- regulations governing limitations on product liability.
// --
// -- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
// -- PART OF THIS FILE AT ALL TIMES.
//-----------------------------------------------------------------------------
//
// Description: 
//  Carry logic.
//
// Verilog-standard:  Verilog 2001
//--------------------------------------------------------------------------
//
// Structure:
//   
//
//--------------------------------------------------------------------------
`timescale 1ps/1ps


(* DowngradeIPIdentifiedWarnings="yes" *) 
module axi_interconnect_v1_7_13_carry #
  (
   parameter         C_FAMILY                         = "virtex6"
                       // FPGA Family. Current version: virtex6 or spartan6.
   )
  (
   input  wire        CIN,
   input  wire        S,
   input  wire        DI,
   output wire        COUT
   );
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Variables for generating parameter controlled instances.
  /////////////////////////////////////////////////////////////////////////////
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Local params
  /////////////////////////////////////////////////////////////////////////////
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Functions
  /////////////////////////////////////////////////////////////////////////////
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Internal signals
  /////////////////////////////////////////////////////////////////////////////
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Instantiate or use RTL code
  /////////////////////////////////////////////////////////////////////////////
  
  generate
    if ( C_FAMILY == "rtl" ) begin : USE_RTL
      assign COUT = (CIN & S) | (DI & ~S);
      
    end else begin : USE_FPGA
    
      MUXCY and_inst 
      (
       .O (COUT), 
       .CI (CIN), 
       .DI (DI), 
       .S (S)
      ); 
      
    end
  endgenerate
  
  
endmodule



// -- (c) Copyright 2010 - 2011 Xilinx, Inc. All rights reserved.
// --
// -- This file contains confidential and proprietary information
// -- of Xilinx, Inc. and is protected under U.S. and 
// -- international copyright and other intellectual property
// -- laws.
// --
// -- DISCLAIMER
// -- This disclaimer is not a license and does not grant any
// -- rights to the materials distributed herewith. Except as
// -- otherwise provided in a valid license issued to you by
// -- Xilinx, and to the maximum extent permitted by applicable
// -- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
// -- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
// -- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
// -- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
// -- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
// -- (2) Xilinx shall not be liable (whether in contract or tort,
// -- including negligence, or under any other theory of
// -- liability) for any loss or damage of any kind or nature
// -- related to, arising under or in connection with these
// -- materials, including for any direct, or any indirect,
// -- special, incidental, or consequential loss or damage
// -- (including loss of data, profits, goodwill, or any type of
// -- loss or damage suffered as a result of any action brought
// -- by a third party) even if such damage or loss was
// -- reasonably foreseeable or Xilinx had been advised of the
// -- possibility of the same.
// --
// -- CRITICAL APPLICATIONS
// -- Xilinx products are not designed or intended to be fail-
// -- safe, or for use in any application requiring fail-safe
// -- performance, such as life-support or safety devices or
// -- systems, Class III medical devices, nuclear facilities,
// -- applications related to the deployment of airbags, or any
// -- other applications that could lead to death, personal
// -- injury, or severe property or environmental damage
// -- (individually and collectively, "Critical
// -- Applications"). Customer assumes the sole risk and
// -- liability of any use of Xilinx products in Critical
// -- Applications, subject only to applicable laws and
// -- regulations governing limitations on product liability.
// --
// -- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
// -- PART OF THIS FILE AT ALL TIMES.
//-----------------------------------------------------------------------------
//
// Description: 
//  Optimized 16/32 word deep FIFO.
//
// Verilog-standard:  Verilog 2001
//--------------------------------------------------------------------------
//
// Structure:
//   
//
//--------------------------------------------------------------------------
`timescale 1ps/1ps


(* DowngradeIPIdentifiedWarnings="yes" *) 
module axi_interconnect_v1_7_13_command_fifo #
  (
   parameter         C_FAMILY                        = "virtex6",
   parameter integer C_ENABLE_S_VALID_CARRY          = 0,
   parameter integer C_ENABLE_REGISTERED_OUTPUT      = 0,
   parameter integer C_FIFO_DEPTH_LOG                = 5,      // FIFO depth = 2**C_FIFO_DEPTH_LOG
                                                               // Range = [4:5].
   parameter integer C_FIFO_WIDTH                    = 64      // Width of payload [1:512]
   )
  (
   // Global inputs
   input  wire                        ACLK,    // Clock
   input  wire                        ARESET,  // Reset
   // Information
   output wire                        EMPTY,   // FIFO empty (all stages)
   // Slave  Port
   input  wire [C_FIFO_WIDTH-1:0]     S_MESG,  // Payload (may be any set of channel signals)
   input  wire                        S_VALID, // FIFO push
   output wire                        S_READY, // FIFO not full
   // Master  Port
   output wire [C_FIFO_WIDTH-1:0]     M_MESG,  // Payload
   output wire                        M_VALID, // FIFO not empty
   input  wire                        M_READY  // FIFO pop
   );

  /////////////////////////////////////////////////////////////////////////////
  // Variables for generating parameter controlled instances.
  /////////////////////////////////////////////////////////////////////////////
  
  // Generate variable for data vector.
  genvar addr_cnt;
  genvar bit_cnt;
  integer index;
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Internal signals
  /////////////////////////////////////////////////////////////////////////////
  
  wire [C_FIFO_DEPTH_LOG-1:0] addr;
  wire                        buffer_Full;
  wire                        buffer_Empty;
  
  wire                        next_Data_Exists;
  reg                         data_Exists_I;
  
  wire                        valid_Write;
  wire                        new_write;
  
  wire [C_FIFO_DEPTH_LOG-1:0] hsum_A;
  wire [C_FIFO_DEPTH_LOG-1:0] sum_A;
  wire [C_FIFO_DEPTH_LOG-1:0] addr_cy;

  wire                        buffer_full_early;
  
  wire [C_FIFO_WIDTH-1:0]     M_MESG_I;   // Payload
  wire                        M_VALID_I;  // FIFO not empty
  wire                        M_READY_I;  // FIFO pop
  
  /////////////////////////////////////////////////////////////////////////////
  // Create Flags 
  /////////////////////////////////////////////////////////////////////////////
  
  assign buffer_full_early  = ( (addr == {{C_FIFO_DEPTH_LOG-1{1'b1}}, 1'b0}) & valid_Write & ~M_READY_I ) |
                              ( buffer_Full & ~M_READY_I );

  assign S_READY            = ~buffer_Full;

  assign buffer_Empty       = (addr == {C_FIFO_DEPTH_LOG{1'b0}});

  assign next_Data_Exists   = (data_Exists_I & ~buffer_Empty) |
                              (buffer_Empty & S_VALID) |
                              (data_Exists_I & ~(M_READY_I & data_Exists_I));

  always @ (posedge ACLK) begin
    if (ARESET) begin
      data_Exists_I <= 1'b0;
    end else begin
      data_Exists_I <= next_Data_Exists;
    end
  end

  assign M_VALID_I = data_Exists_I;
  
  // Select RTL or FPGA optimized instatiations for critical parts.
  generate
    if ( C_FAMILY == "rtl" || C_ENABLE_S_VALID_CARRY == 0 ) begin : USE_RTL_VALID_WRITE
      reg                         buffer_Full_q;
      
      assign valid_Write = S_VALID & ~buffer_Full;
      
      assign new_write = (S_VALID | ~buffer_Empty);
     
      assign addr_cy[0] = valid_Write;
      
      always @ (posedge ACLK) begin
        if (ARESET) begin
          buffer_Full_q <= 1'b0;
        end else if ( data_Exists_I ) begin
          buffer_Full_q <= buffer_full_early;
        end
      end
      assign buffer_Full = buffer_Full_q;
      
    end else begin : USE_FPGA_VALID_WRITE
      wire s_valid_dummy1;
      wire s_valid_dummy2;
      wire sel_s_valid;
      wire sel_new_write;
      wire valid_Write_dummy1;
      wire valid_Write_dummy2;
      
      assign sel_s_valid = ~buffer_Full;
      
  axi_interconnect_v1_7_13_carry_and #
        (
         .C_FAMILY(C_FAMILY)
         ) s_valid_dummy_inst1
        (
         .CIN(S_VALID),
         .S(1'b1),
         .COUT(s_valid_dummy1)
         );
      
  axi_interconnect_v1_7_13_carry_and #
        (
         .C_FAMILY(C_FAMILY)
         ) s_valid_dummy_inst2
        (
         .CIN(s_valid_dummy1),
         .S(1'b1),
         .COUT(s_valid_dummy2)
         );
      
  axi_interconnect_v1_7_13_carry_and #
        (
         .C_FAMILY(C_FAMILY)
         ) valid_write_inst
        (
         .CIN(s_valid_dummy2),
         .S(sel_s_valid),
         .COUT(valid_Write)
         );
      
      assign sel_new_write = ~buffer_Empty;
       
  axi_interconnect_v1_7_13_carry_latch_or #
        (
         .C_FAMILY(C_FAMILY)
         ) new_write_inst
        (
         .CIN(valid_Write),
         .I(sel_new_write),
         .O(new_write)
         );
         
  axi_interconnect_v1_7_13_carry_and #
        (
         .C_FAMILY(C_FAMILY)
         ) valid_write_dummy_inst1
        (
         .CIN(valid_Write),
         .S(1'b1),
         .COUT(valid_Write_dummy1)
         );
      
  axi_interconnect_v1_7_13_carry_and #
        (
         .C_FAMILY(C_FAMILY)
         ) valid_write_dummy_inst2
        (
         .CIN(valid_Write_dummy1),
         .S(1'b1),
         .COUT(valid_Write_dummy2)
         );
      
  axi_interconnect_v1_7_13_carry_and #
        (
         .C_FAMILY(C_FAMILY)
         ) valid_write_dummy_inst3
        (
         .CIN(valid_Write_dummy2),
         .S(1'b1),
         .COUT(addr_cy[0])
         );
      
      FDRE #(
       .INIT(1'b0)              // Initial value of register (1'b0 or 1'b1)
       ) FDRE_I1 (
       .Q(buffer_Full),         // Data output
       .C(ACLK),                // Clock input
       .CE(data_Exists_I),      // Clock enable input
       .R(ARESET),              // Synchronous reset input
       .D(buffer_full_early)    // Data input
       );
       
    end
  endgenerate
      
    
  /////////////////////////////////////////////////////////////////////////////
  // Create address pointer
  /////////////////////////////////////////////////////////////////////////////

  generate
    if ( C_FAMILY == "rtl" ) begin : USE_RTL_ADDR
    
      reg  [C_FIFO_DEPTH_LOG-1:0] addr_q;
      
      always @ (posedge ACLK) begin
        if (ARESET) begin
          addr_q <= {C_FIFO_DEPTH_LOG{1'b0}};
        end else if ( data_Exists_I ) begin
          if ( valid_Write & ~(M_READY_I & data_Exists_I) ) begin
            addr_q <= addr_q + 1'b1;
          end else if ( ~valid_Write & (M_READY_I & data_Exists_I) & ~buffer_Empty ) begin
            addr_q <= addr_q - 1'b1;
          end
          else begin
            addr_q <= addr_q;
          end
        end
        else begin
          addr_q <= addr_q;
        end
      end
      
      assign addr = addr_q;
      
    end else begin : USE_FPGA_ADDR
      for (addr_cnt = 0; addr_cnt < C_FIFO_DEPTH_LOG ; addr_cnt = addr_cnt + 1) begin : ADDR_GEN
        assign hsum_A[addr_cnt] = ((M_READY_I & data_Exists_I) ^ addr[addr_cnt]) & new_write;
        
        // Don't need the last muxcy, addr_cy(last) is not used anywhere
        if ( addr_cnt < C_FIFO_DEPTH_LOG - 1 ) begin : USE_MUXCY
          MUXCY MUXCY_inst (
           .DI(addr[addr_cnt]),
           .CI(addr_cy[addr_cnt]),
           .S(hsum_A[addr_cnt]),
           .O(addr_cy[addr_cnt+1])
           );
           
        end
        else begin : NO_MUXCY
        end
        
        XORCY XORCY_inst (
         .LI(hsum_A[addr_cnt]),
         .CI(addr_cy[addr_cnt]),
         .O(sum_A[addr_cnt])
         );
        
        FDRE #(
         .INIT(1'b0)             // Initial value of register (1'b0 or 1'b1)
         ) FDRE_inst (
         .Q(addr[addr_cnt]),     // Data output
         .C(ACLK),               // Clock input
         .CE(data_Exists_I),     // Clock enable input
         .R(ARESET),             // Synchronous reset input
         .D(sum_A[addr_cnt])     // Data input
         );
        
      end // end for bit_cnt
    end // C_FAMILY
  endgenerate
      
      
  /////////////////////////////////////////////////////////////////////////////
  // Data storage
  /////////////////////////////////////////////////////////////////////////////
  
  generate
    if ( C_FAMILY == "rtl" ) begin : USE_RTL_FIFO
      reg  [C_FIFO_WIDTH-1:0] data_srl[2 ** C_FIFO_DEPTH_LOG-1:0];
      
      always @ (posedge ACLK) begin
        if ( valid_Write ) begin
          for (index = 0; index < 2 ** C_FIFO_DEPTH_LOG-1 ; index = index + 1) begin
            data_srl[index+1] <= data_srl[index];
          end
          data_srl[0]   <= S_MESG;
        end
      end
      
      assign M_MESG_I = data_srl[addr];
      
    end else begin : USE_FPGA_FIFO
      for (bit_cnt = 0; bit_cnt < C_FIFO_WIDTH ; bit_cnt = bit_cnt + 1) begin : DATA_GEN
        
        if ( C_FIFO_DEPTH_LOG == 5 ) begin : USE_32
            SRLC32E # (
             .INIT(32'h00000000)    // Initial Value of Shift Register
            ) SRLC32E_inst (
             .Q(M_MESG_I[bit_cnt]), // SRL data output
             .Q31(),                // SRL cascade output pin
             .A(addr),              // 5-bit shift depth select input
             .CE(valid_Write),      // Clock enable input
             .CLK(ACLK),            // Clock input
             .D(S_MESG[bit_cnt])    // SRL data input
            );
        end else begin : USE_16
            SRLC16E # (
             .INIT(32'h00000000)    // Initial Value of Shift Register
            ) SRLC16E_inst (
             .Q(M_MESG_I[bit_cnt]), // SRL data output
             .Q15(),                // SRL cascade output pin
             .A0(addr[0]),          // 4-bit shift depth select input 0
             .A1(addr[1]),          // 4-bit shift depth select input 1
             .A2(addr[2]),          // 4-bit shift depth select input 2
             .A3(addr[3]),          // 4-bit shift depth select input 3
             .CE(valid_Write),      // Clock enable input
             .CLK(ACLK),            // Clock input
             .D(S_MESG[bit_cnt])    // SRL data input
            );
        end // C_FIFO_DEPTH_LOG
      
      end // end for bit_cnt
    end // C_FAMILY
  endgenerate
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Pipeline stage
  /////////////////////////////////////////////////////////////////////////////
  
  generate
    if ( C_ENABLE_REGISTERED_OUTPUT != 0 ) begin : USE_FF_OUT
      
      wire [C_FIFO_WIDTH-1:0]     M_MESG_FF;    // Payload
      wire                        M_VALID_FF;   // FIFO not empty
      
      // Select RTL or FPGA optimized instatiations for critical parts.
      if ( C_FAMILY == "rtl" ) begin : USE_RTL_OUTPUT_PIPELINE
      
        reg  [C_FIFO_WIDTH-1:0]     M_MESG_Q;   // Payload
        reg                         M_VALID_Q;  // FIFO not empty
        
        always @ (posedge ACLK) begin
          if (ARESET) begin
            M_MESG_Q    <= {C_FIFO_WIDTH{1'b0}};
            M_VALID_Q   <= 1'b0;
          end else begin
            if ( M_READY_I ) begin
              M_MESG_Q    <= M_MESG_I;
              M_VALID_Q   <= M_VALID_I;
            end
          end
        end
      
        assign M_MESG_FF     = M_MESG_Q;
        assign M_VALID_FF    = M_VALID_Q;
        
      end else begin : USE_FPGA_OUTPUT_PIPELINE
      
        reg  [C_FIFO_WIDTH-1:0]     M_MESG_CMB;   // Payload
        reg                         M_VALID_CMB;  // FIFO not empty
        
        always @ *
        begin
          if ( M_READY_I ) begin
            M_MESG_CMB  <= M_MESG_I;
            M_VALID_CMB <= M_VALID_I;
          end else begin
            M_MESG_CMB  <= M_MESG_FF;
            M_VALID_CMB <= M_VALID_FF;
          end
        end
        
        for (bit_cnt = 0; bit_cnt < C_FIFO_WIDTH ; bit_cnt = bit_cnt + 1) begin : DATA_GEN
              
          FDRE #(
           .INIT(1'b0)                    // Initial value of register (1'b0 or 1'b1)
           ) FDRE_inst (
           .Q(M_MESG_FF[bit_cnt]),        // Data output
           .C(ACLK),                      // Clock input
           .CE(1'b1),                     // Clock enable input
           .R(ARESET),                    // Synchronous reset input
           .D(M_MESG_CMB[bit_cnt])        // Data input
           );
        end // end for bit_cnt
            
        FDRE #(
         .INIT(1'b0)                    // Initial value of register (1'b0 or 1'b1)
         ) FDRE_inst (
         .Q(M_VALID_FF),                // Data output
         .C(ACLK),                      // Clock input
         .CE(1'b1),                     // Clock enable input
         .R(ARESET),                    // Synchronous reset input
         .D(M_VALID_CMB)                // Data input
         );
      
      end
      
      assign EMPTY      = ~M_VALID_I & ~M_VALID_FF;
      assign M_MESG     = M_MESG_FF;
      assign M_VALID    = M_VALID_FF;
      assign M_READY_I  = ( M_READY & M_VALID_FF ) | ~M_VALID_FF;
      
    end else begin : NO_FF_OUT
      
      assign EMPTY      = ~M_VALID_I;
      assign M_MESG     = M_MESG_I;
      assign M_VALID    = M_VALID_I;
      assign M_READY_I  = M_READY;
      
    end
  endgenerate

endmodule



// -- (c) Copyright 2010 - 2011 Xilinx, Inc. All rights reserved.
// --
// -- This file contains confidential and proprietary information
// -- of Xilinx, Inc. and is protected under U.S. and 
// -- international copyright and other intellectual property
// -- laws.
// --
// -- DISCLAIMER
// -- This disclaimer is not a license and does not grant any
// -- rights to the materials distributed herewith. Except as
// -- otherwise provided in a valid license issued to you by
// -- Xilinx, and to the maximum extent permitted by applicable
// -- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
// -- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
// -- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
// -- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
// -- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
// -- (2) Xilinx shall not be liable (whether in contract or tort,
// -- including negligence, or under any other theory of
// -- liability) for any loss or damage of any kind or nature
// -- related to, arising under or in connection with these
// -- materials, including for any direct, or any indirect,
// -- special, incidental, or consequential loss or damage
// -- (including loss of data, profits, goodwill, or any type of
// -- loss or damage suffered as a result of any action brought
// -- by a third party) even if such damage or loss was
// -- reasonably foreseeable or Xilinx had been advised of the
// -- possibility of the same.
// --
// -- CRITICAL APPLICATIONS
// -- Xilinx products are not designed or intended to be fail-
// -- safe, or for use in any application requiring fail-safe
// -- performance, such as life-support or safety devices or
// -- systems, Class III medical devices, nuclear facilities,
// -- applications related to the deployment of airbags, or any
// -- other applications that could lead to death, personal
// -- injury, or severe property or environmental damage
// -- (individually and collectively, "Critical
// -- Applications"). Customer assumes the sole risk and
// -- liability of any use of Xilinx products in Critical
// -- Applications, subject only to applicable laws and
// -- regulations governing limitations on product liability.
// --
// -- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
// -- PART OF THIS FILE AT ALL TIMES.
//-----------------------------------------------------------------------------
//
// Description: 
//  Optimized COMPARATOR (against constant) with carry logic.
//
// Verilog-standard:  Verilog 2001
//--------------------------------------------------------------------------
//
// Structure:
//   
//
//--------------------------------------------------------------------------
`timescale 1ps/1ps

(* DowngradeIPIdentifiedWarnings="yes" *) 
module axi_interconnect_v1_7_13_comparator_mask_static #
  (
   parameter         C_FAMILY                         = "virtex6", 
                       // FPGA Family. Current version: virtex6 or spartan6.
   parameter         C_VALUE                          = 4'b0,
                       // Static value to compare against.
   parameter integer C_DATA_WIDTH                     = 4
                       // Data width for comparator.
   )
  (
   input  wire                    CIN,
   input  wire [C_DATA_WIDTH-1:0] A,
   input  wire [C_DATA_WIDTH-1:0] M,
   output wire                    COUT
   );
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Variables for generating parameter controlled instances.
  /////////////////////////////////////////////////////////////////////////////
  
  // Generate variable for bit vector.
  genvar lut_cnt;
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Local params
  /////////////////////////////////////////////////////////////////////////////
  
  // Bits per LUT for this architecture.
  localparam integer C_BITS_PER_LUT   = 3;
  
  // Constants for packing levels.
  localparam integer C_NUM_LUT        = ( C_DATA_WIDTH + C_BITS_PER_LUT - 1 ) / C_BITS_PER_LUT;
  
  // 
  localparam integer C_FIX_DATA_WIDTH = ( C_NUM_LUT * C_BITS_PER_LUT > C_DATA_WIDTH ) ? C_NUM_LUT * C_BITS_PER_LUT :
                                        C_DATA_WIDTH;
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Functions
  /////////////////////////////////////////////////////////////////////////////
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Internal signals
  /////////////////////////////////////////////////////////////////////////////
  
  wire [C_FIX_DATA_WIDTH-1:0] a_local;
  wire [C_FIX_DATA_WIDTH-1:0] b_local;
  wire [C_FIX_DATA_WIDTH-1:0] m_local;
  wire [C_NUM_LUT-1:0]        sel;
  wire [C_NUM_LUT:0]          carry_local;
  
  
  /////////////////////////////////////////////////////////////////////////////
  // 
  /////////////////////////////////////////////////////////////////////////////
  
  generate
    // Assign input to local vectors.
    assign carry_local[0] = CIN;
    
    // Extend input data to fit.
    if ( C_NUM_LUT * C_BITS_PER_LUT > C_DATA_WIDTH ) begin : USE_EXTENDED_DATA
      assign a_local        = {A,       {C_NUM_LUT * C_BITS_PER_LUT - C_DATA_WIDTH{1'b0}}};
      assign b_local        = {C_VALUE, {C_NUM_LUT * C_BITS_PER_LUT - C_DATA_WIDTH{1'b0}}};
      assign m_local        = {M, {C_NUM_LUT * C_BITS_PER_LUT - C_DATA_WIDTH{1'b0}}};
    end else begin : NO_EXTENDED_DATA
      assign a_local        = A;
      assign b_local        = C_VALUE;
      assign m_local        = M;
    end
    
    // Instantiate one carry and per level.
    for (lut_cnt = 0; lut_cnt < C_NUM_LUT ; lut_cnt = lut_cnt + 1) begin : LUT_LEVEL
      // Create the local select signal
      assign sel[lut_cnt] = ( ( a_local[lut_cnt*C_BITS_PER_LUT +: C_BITS_PER_LUT] &
                                m_local[lut_cnt*C_BITS_PER_LUT +: C_BITS_PER_LUT] ) == 
                              ( b_local[lut_cnt*C_BITS_PER_LUT +: C_BITS_PER_LUT] &
                                m_local[lut_cnt*C_BITS_PER_LUT +: C_BITS_PER_LUT] ) );
    
      // Instantiate each LUT level.
  axi_interconnect_v1_7_13_carry_and # 
      (
       .C_FAMILY(C_FAMILY)
      ) compare_inst 
      (
       .COUT  (carry_local[lut_cnt+1]),
       .CIN   (carry_local[lut_cnt]),
       .S     (sel[lut_cnt])
      ); 
      
    end // end for lut_cnt
    
    // Assign output from local vector.
    assign COUT = carry_local[C_NUM_LUT];
    
  endgenerate
  
  
endmodule



// -- (c) Copyright 2010 - 2011 Xilinx, Inc. All rights reserved.
// --
// -- This file contains confidential and proprietary information
// -- of Xilinx, Inc. and is protected under U.S. and 
// -- international copyright and other intellectual property
// -- laws.
// --
// -- DISCLAIMER
// -- This disclaimer is not a license and does not grant any
// -- rights to the materials distributed herewith. Except as
// -- otherwise provided in a valid license issued to you by
// -- Xilinx, and to the maximum extent permitted by applicable
// -- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
// -- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
// -- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
// -- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
// -- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
// -- (2) Xilinx shall not be liable (whether in contract or tort,
// -- including negligence, or under any other theory of
// -- liability) for any loss or damage of any kind or nature
// -- related to, arising under or in connection with these
// -- materials, including for any direct, or any indirect,
// -- special, incidental, or consequential loss or damage
// -- (including loss of data, profits, goodwill, or any type of
// -- loss or damage suffered as a result of any action brought
// -- by a third party) even if such damage or loss was
// -- reasonably foreseeable or Xilinx had been advised of the
// -- possibility of the same.
// --
// -- CRITICAL APPLICATIONS
// -- Xilinx products are not designed or intended to be fail-
// -- safe, or for use in any application requiring fail-safe
// -- performance, such as life-support or safety devices or
// -- systems, Class III medical devices, nuclear facilities,
// -- applications related to the deployment of airbags, or any
// -- other applications that could lead to death, personal
// -- injury, or severe property or environmental damage
// -- (individually and collectively, "Critical
// -- Applications"). Customer assumes the sole risk and
// -- liability of any use of Xilinx products in Critical
// -- Applications, subject only to applicable laws and
// -- regulations governing limitations on product liability.
// --
// -- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
// -- PART OF THIS FILE AT ALL TIMES.
//-----------------------------------------------------------------------------
//
// Description: 
//  Optimized COMPARATOR with carry logic.
//
// Verilog-standard:  Verilog 2001
//--------------------------------------------------------------------------
//
// Structure:
//   
//
//--------------------------------------------------------------------------
`timescale 1ps/1ps

(* DowngradeIPIdentifiedWarnings="yes" *) 
module axi_interconnect_v1_7_13_comparator_mask #
  (
   parameter         C_FAMILY                         = "virtex6", 
                       // FPGA Family. Current version: virtex6 or spartan6.
   parameter integer C_DATA_WIDTH                     = 4
                       // Data width for comparator.
   )
  (
   input  wire                    CIN,
   input  wire [C_DATA_WIDTH-1:0] A,
   input  wire [C_DATA_WIDTH-1:0] B,
   input  wire [C_DATA_WIDTH-1:0] M,
   output wire                    COUT
   );
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Variables for generating parameter controlled instances.
  /////////////////////////////////////////////////////////////////////////////
  
  // Generate variable for bit vector.
  genvar lut_cnt;
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Local params
  /////////////////////////////////////////////////////////////////////////////
  
  // Bits per LUT for this architecture.
  localparam integer C_BITS_PER_LUT   = 2;
  
  // Constants for packing levels.
  localparam integer C_NUM_LUT        = ( C_DATA_WIDTH + C_BITS_PER_LUT - 1 ) / C_BITS_PER_LUT;
  
  // 
  localparam integer C_FIX_DATA_WIDTH = ( C_NUM_LUT * C_BITS_PER_LUT > C_DATA_WIDTH ) ? C_NUM_LUT * C_BITS_PER_LUT :
                                        C_DATA_WIDTH;
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Functions
  /////////////////////////////////////////////////////////////////////////////
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Internal signals
  /////////////////////////////////////////////////////////////////////////////
  
  wire [C_FIX_DATA_WIDTH-1:0] a_local;
  wire [C_FIX_DATA_WIDTH-1:0] b_local;
  wire [C_FIX_DATA_WIDTH-1:0] m_local;
  wire [C_NUM_LUT-1:0]        sel;
  wire [C_NUM_LUT:0]          carry_local;
  
  
  /////////////////////////////////////////////////////////////////////////////
  // 
  /////////////////////////////////////////////////////////////////////////////
  
  generate
    // Assign input to local vectors.
    assign carry_local[0] = CIN;
    
    // Extend input data to fit.
    if ( C_NUM_LUT * C_BITS_PER_LUT > C_DATA_WIDTH ) begin : USE_EXTENDED_DATA
      assign a_local        = {A, {C_NUM_LUT * C_BITS_PER_LUT - C_DATA_WIDTH{1'b0}}};
      assign b_local        = {B, {C_NUM_LUT * C_BITS_PER_LUT - C_DATA_WIDTH{1'b0}}};
      assign m_local        = {M, {C_NUM_LUT * C_BITS_PER_LUT - C_DATA_WIDTH{1'b0}}};
    end else begin : NO_EXTENDED_DATA
      assign a_local        = A;
      assign b_local        = B;
      assign m_local        = M;
    end
  
    // Instantiate one carry and per level.
    for (lut_cnt = 0; lut_cnt < C_NUM_LUT ; lut_cnt = lut_cnt + 1) begin : LUT_LEVEL
      // Create the local select signal
      assign sel[lut_cnt] = ( ( a_local[lut_cnt*C_BITS_PER_LUT +: C_BITS_PER_LUT] &
                                m_local[lut_cnt*C_BITS_PER_LUT +: C_BITS_PER_LUT] ) == 
                              ( b_local[lut_cnt*C_BITS_PER_LUT +: C_BITS_PER_LUT] &
                                m_local[lut_cnt*C_BITS_PER_LUT +: C_BITS_PER_LUT] ) );
    
      // Instantiate each LUT level.
  axi_interconnect_v1_7_13_carry_and # 
      (
       .C_FAMILY(C_FAMILY)
      ) compare_inst 
      (
       .COUT  (carry_local[lut_cnt+1]),
       .CIN   (carry_local[lut_cnt]),
       .S     (sel[lut_cnt])
      ); 
      
    end // end for lut_cnt
    
    // Assign output from local vector.
    assign COUT = carry_local[C_NUM_LUT];
    
  endgenerate
  
  
endmodule



// -- (c) Copyright 2010 - 2011 Xilinx, Inc. All rights reserved.
// --
// -- This file contains confidential and proprietary information
// -- of Xilinx, Inc. and is protected under U.S. and 
// -- international copyright and other intellectual property
// -- laws.
// --
// -- DISCLAIMER
// -- This disclaimer is not a license and does not grant any
// -- rights to the materials distributed herewith. Except as
// -- otherwise provided in a valid license issued to you by
// -- Xilinx, and to the maximum extent permitted by applicable
// -- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
// -- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
// -- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
// -- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
// -- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
// -- (2) Xilinx shall not be liable (whether in contract or tort,
// -- including negligence, or under any other theory of
// -- liability) for any loss or damage of any kind or nature
// -- related to, arising under or in connection with these
// -- materials, including for any direct, or any indirect,
// -- special, incidental, or consequential loss or damage
// -- (including loss of data, profits, goodwill, or any type of
// -- loss or damage suffered as a result of any action brought
// -- by a third party) even if such damage or loss was
// -- reasonably foreseeable or Xilinx had been advised of the
// -- possibility of the same.
// --
// -- CRITICAL APPLICATIONS
// -- Xilinx products are not designed or intended to be fail-
// -- safe, or for use in any application requiring fail-safe
// -- performance, such as life-support or safety devices or
// -- systems, Class III medical devices, nuclear facilities,
// -- applications related to the deployment of airbags, or any
// -- other applications that could lead to death, personal
// -- injury, or severe property or environmental damage
// -- (individually and collectively, "Critical
// -- Applications"). Customer assumes the sole risk and
// -- liability of any use of Xilinx products in Critical
// -- Applications, subject only to applicable laws and
// -- regulations governing limitations on product liability.
// --
// -- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
// -- PART OF THIS FILE AT ALL TIMES.
//-----------------------------------------------------------------------------
//
// Description: 
//  Optimized COMPARATOR (against constant) with carry logic.
//
// Verilog-standard:  Verilog 2001
//--------------------------------------------------------------------------
//
// Structure:
//   
//
//--------------------------------------------------------------------------
`timescale 1ps/1ps

(* DowngradeIPIdentifiedWarnings="yes" *) 
module axi_interconnect_v1_7_13_comparator_sel_mask_static #
  (
   parameter         C_FAMILY                         = "virtex6", 
                       // FPGA Family. Current version: virtex6 or spartan6.
   parameter         C_VALUE                          = 4'b0,
                       // Static value to compare against.
   parameter integer C_DATA_WIDTH                     = 4
                       // Data width for comparator.
   )
  (
   input  wire                    CIN,
   input  wire                    S,
   input  wire [C_DATA_WIDTH-1:0] A,
   input  wire [C_DATA_WIDTH-1:0] B,
   input  wire [C_DATA_WIDTH-1:0] M,
   output wire                    COUT
   );
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Variables for generating parameter controlled instances.
  /////////////////////////////////////////////////////////////////////////////
  
  // Generate variable for bit vector.
  genvar lut_cnt;
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Local params
  /////////////////////////////////////////////////////////////////////////////
  
  // Bits per LUT for this architecture.
  localparam integer C_BITS_PER_LUT   = 1;
  
  // Constants for packing levels.
  localparam integer C_NUM_LUT        = ( C_DATA_WIDTH + C_BITS_PER_LUT - 1 ) / C_BITS_PER_LUT;
  
  // 
  localparam integer C_FIX_DATA_WIDTH = ( C_NUM_LUT * C_BITS_PER_LUT > C_DATA_WIDTH ) ? C_NUM_LUT * C_BITS_PER_LUT :
                                        C_DATA_WIDTH;
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Functions
  /////////////////////////////////////////////////////////////////////////////
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Internal signals
  /////////////////////////////////////////////////////////////////////////////
  
  wire [C_FIX_DATA_WIDTH-1:0] a_local;
  wire [C_FIX_DATA_WIDTH-1:0] b_local;
  wire [C_FIX_DATA_WIDTH-1:0] m_local;
  wire [C_FIX_DATA_WIDTH-1:0] v_local;
  wire [C_NUM_LUT-1:0]        sel;
  wire [C_NUM_LUT:0]          carry_local;
  
  
  /////////////////////////////////////////////////////////////////////////////
  // 
  /////////////////////////////////////////////////////////////////////////////
  
  generate
    // Assign input to local vectors.
    assign carry_local[0] = CIN;
    
    // Extend input data to fit.
    if ( C_NUM_LUT * C_BITS_PER_LUT > C_DATA_WIDTH ) begin : USE_EXTENDED_DATA
      assign a_local        = {A,       {C_NUM_LUT * C_BITS_PER_LUT - C_DATA_WIDTH{1'b0}}};
      assign b_local        = {B,       {C_NUM_LUT * C_BITS_PER_LUT - C_DATA_WIDTH{1'b0}}};
      assign m_local        = {M,       {C_NUM_LUT * C_BITS_PER_LUT - C_DATA_WIDTH{1'b0}}};
      assign v_local        = {C_VALUE, {C_NUM_LUT * C_BITS_PER_LUT - C_DATA_WIDTH{1'b0}}};
    end else begin : NO_EXTENDED_DATA
      assign a_local        = A;
      assign b_local        = B;
      assign m_local        = M;
      assign v_local        = C_VALUE;
    end
    
    // Instantiate one carry and per level.
    for (lut_cnt = 0; lut_cnt < C_NUM_LUT ; lut_cnt = lut_cnt + 1) begin : LUT_LEVEL
      // Create the local select signal
      assign sel[lut_cnt] = ( ( ( a_local[lut_cnt*C_BITS_PER_LUT +: C_BITS_PER_LUT] &
                                  m_local[lut_cnt*C_BITS_PER_LUT +: C_BITS_PER_LUT] ) ==
                                ( v_local[lut_cnt*C_BITS_PER_LUT +: C_BITS_PER_LUT] &
                                  m_local[lut_cnt*C_BITS_PER_LUT +: C_BITS_PER_LUT] ) ) & ( S == 1'b0 ) ) |
                            ( ( ( b_local[lut_cnt*C_BITS_PER_LUT +: C_BITS_PER_LUT] &
                                  m_local[lut_cnt*C_BITS_PER_LUT +: C_BITS_PER_LUT] ) ==
                                ( v_local[lut_cnt*C_BITS_PER_LUT +: C_BITS_PER_LUT] &
                                  m_local[lut_cnt*C_BITS_PER_LUT +: C_BITS_PER_LUT] ) ) & ( S == 1'b1 ) );
    
      // Instantiate each LUT level.
  axi_interconnect_v1_7_13_carry_and # 
      (
       .C_FAMILY(C_FAMILY)
      ) compare_inst 
      (
       .COUT  (carry_local[lut_cnt+1]),
       .CIN   (carry_local[lut_cnt]),
       .S     (sel[lut_cnt])
      ); 
      
    end // end for lut_cnt
    
    // Assign output from local vector.
    assign COUT = carry_local[C_NUM_LUT];
    
  endgenerate
  
  
endmodule



// -- (c) Copyright 2010 - 2011 Xilinx, Inc. All rights reserved.
// --
// -- This file contains confidential and proprietary information
// -- of Xilinx, Inc. and is protected under U.S. and 
// -- international copyright and other intellectual property
// -- laws.
// --
// -- DISCLAIMER
// -- This disclaimer is not a license and does not grant any
// -- rights to the materials distributed herewith. Except as
// -- otherwise provided in a valid license issued to you by
// -- Xilinx, and to the maximum extent permitted by applicable
// -- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
// -- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
// -- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
// -- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
// -- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
// -- (2) Xilinx shall not be liable (whether in contract or tort,
// -- including negligence, or under any other theory of
// -- liability) for any loss or damage of any kind or nature
// -- related to, arising under or in connection with these
// -- materials, including for any direct, or any indirect,
// -- special, incidental, or consequential loss or damage
// -- (including loss of data, profits, goodwill, or any type of
// -- loss or damage suffered as a result of any action brought
// -- by a third party) even if such damage or loss was
// -- reasonably foreseeable or Xilinx had been advised of the
// -- possibility of the same.
// --
// -- CRITICAL APPLICATIONS
// -- Xilinx products are not designed or intended to be fail-
// -- safe, or for use in any application requiring fail-safe
// -- performance, such as life-support or safety devices or
// -- systems, Class III medical devices, nuclear facilities,
// -- applications related to the deployment of airbags, or any
// -- other applications that could lead to death, personal
// -- injury, or severe property or environmental damage
// -- (individually and collectively, "Critical
// -- Applications"). Customer assumes the sole risk and
// -- liability of any use of Xilinx products in Critical
// -- Applications, subject only to applicable laws and
// -- regulations governing limitations on product liability.
// --
// -- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
// -- PART OF THIS FILE AT ALL TIMES.
//-----------------------------------------------------------------------------
//
// Description: 
//  Optimized COMPARATOR with carry logic.
//
// Verilog-standard:  Verilog 2001
//--------------------------------------------------------------------------
//
// Structure:
//   
//
//--------------------------------------------------------------------------
`timescale 1ps/1ps

(* DowngradeIPIdentifiedWarnings="yes" *) 
module axi_interconnect_v1_7_13_comparator_sel_mask #
  (
   parameter         C_FAMILY                         = "virtex6", 
                       // FPGA Family. Current version: virtex6 or spartan6.
   parameter integer C_DATA_WIDTH                     = 4
                       // Data width for comparator.
   )
  (
   input  wire                    CIN,
   input  wire                    S,
   input  wire [C_DATA_WIDTH-1:0] A,
   input  wire [C_DATA_WIDTH-1:0] B,
   input  wire [C_DATA_WIDTH-1:0] M,
   input  wire [C_DATA_WIDTH-1:0] V,
   output wire                    COUT
   );
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Variables for generating parameter controlled instances.
  /////////////////////////////////////////////////////////////////////////////
  
  // Generate variable for bit vector.
  genvar lut_cnt;
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Local params
  /////////////////////////////////////////////////////////////////////////////
  
  // Bits per LUT for this architecture.
  localparam integer C_BITS_PER_LUT   = 1;
  
  // Constants for packing levels.
  localparam integer C_NUM_LUT        = ( C_DATA_WIDTH + C_BITS_PER_LUT - 1 ) / C_BITS_PER_LUT;
  
  // 
  localparam integer C_FIX_DATA_WIDTH = ( C_NUM_LUT * C_BITS_PER_LUT > C_DATA_WIDTH ) ? C_NUM_LUT * C_BITS_PER_LUT :
                                        C_DATA_WIDTH;
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Functions
  /////////////////////////////////////////////////////////////////////////////
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Internal signals
  /////////////////////////////////////////////////////////////////////////////
  
  wire [C_FIX_DATA_WIDTH-1:0] a_local;
  wire [C_FIX_DATA_WIDTH-1:0] b_local;
  wire [C_FIX_DATA_WIDTH-1:0] m_local;
  wire [C_FIX_DATA_WIDTH-1:0] v_local;
  wire [C_NUM_LUT-1:0]        sel;
  wire [C_NUM_LUT:0]          carry_local;
  
  
  /////////////////////////////////////////////////////////////////////////////
  // 
  /////////////////////////////////////////////////////////////////////////////
  
  generate
    // Assign input to local vectors.
    assign carry_local[0] = CIN;
    
    // Extend input data to fit.
    if ( C_NUM_LUT * C_BITS_PER_LUT > C_DATA_WIDTH ) begin : USE_EXTENDED_DATA
      assign a_local        = {A, {C_NUM_LUT * C_BITS_PER_LUT - C_DATA_WIDTH{1'b0}}};
      assign b_local        = {B, {C_NUM_LUT * C_BITS_PER_LUT - C_DATA_WIDTH{1'b0}}};
      assign m_local        = {M, {C_NUM_LUT * C_BITS_PER_LUT - C_DATA_WIDTH{1'b0}}};
      assign v_local        = {V, {C_NUM_LUT * C_BITS_PER_LUT - C_DATA_WIDTH{1'b0}}};
    end else begin : NO_EXTENDED_DATA
      assign a_local        = A;
      assign b_local        = B;
      assign m_local        = M;
      assign v_local        = V;
    end
    
    // Instantiate one carry and per level.
    for (lut_cnt = 0; lut_cnt < C_NUM_LUT ; lut_cnt = lut_cnt + 1) begin : LUT_LEVEL
      // Create the local select signal
      assign sel[lut_cnt] = ( ( ( a_local[lut_cnt*C_BITS_PER_LUT +: C_BITS_PER_LUT] &
                                  m_local[lut_cnt*C_BITS_PER_LUT +: C_BITS_PER_LUT] ) ==
                                ( v_local[lut_cnt*C_BITS_PER_LUT +: C_BITS_PER_LUT] &
                                  m_local[lut_cnt*C_BITS_PER_LUT +: C_BITS_PER_LUT] ) ) & ( S == 1'b0 ) ) |
                            ( ( ( b_local[lut_cnt*C_BITS_PER_LUT +: C_BITS_PER_LUT] &
                                  m_local[lut_cnt*C_BITS_PER_LUT +: C_BITS_PER_LUT] ) ==
                                ( v_local[lut_cnt*C_BITS_PER_LUT +: C_BITS_PER_LUT] &
                                  m_local[lut_cnt*C_BITS_PER_LUT +: C_BITS_PER_LUT] ) ) & ( S == 1'b1 ) );
    
      // Instantiate each LUT level.
  axi_interconnect_v1_7_13_carry_and # 
      (
       .C_FAMILY(C_FAMILY)
      ) compare_inst 
      (
       .COUT  (carry_local[lut_cnt+1]),
       .CIN   (carry_local[lut_cnt]),
       .S     (sel[lut_cnt])
      ); 
      
    end // end for lut_cnt
    
    // Assign output from local vector.
    assign COUT = carry_local[C_NUM_LUT];
    
  endgenerate
  
  
endmodule



// -- (c) Copyright 2010 - 2011 Xilinx, Inc. All rights reserved.
// --
// -- This file contains confidential and proprietary information
// -- of Xilinx, Inc. and is protected under U.S. and 
// -- international copyright and other intellectual property
// -- laws.
// --
// -- DISCLAIMER
// -- This disclaimer is not a license and does not grant any
// -- rights to the materials distributed herewith. Except as
// -- otherwise provided in a valid license issued to you by
// -- Xilinx, and to the maximum extent permitted by applicable
// -- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
// -- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
// -- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
// -- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
// -- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
// -- (2) Xilinx shall not be liable (whether in contract or tort,
// -- including negligence, or under any other theory of
// -- liability) for any loss or damage of any kind or nature
// -- related to, arising under or in connection with these
// -- materials, including for any direct, or any indirect,
// -- special, incidental, or consequential loss or damage
// -- (including loss of data, profits, goodwill, or any type of
// -- loss or damage suffered as a result of any action brought
// -- by a third party) even if such damage or loss was
// -- reasonably foreseeable or Xilinx had been advised of the
// -- possibility of the same.
// --
// -- CRITICAL APPLICATIONS
// -- Xilinx products are not designed or intended to be fail-
// -- safe, or for use in any application requiring fail-safe
// -- performance, such as life-support or safety devices or
// -- systems, Class III medical devices, nuclear facilities,
// -- applications related to the deployment of airbags, or any
// -- other applications that could lead to death, personal
// -- injury, or severe property or environmental damage
// -- (individually and collectively, "Critical
// -- Applications"). Customer assumes the sole risk and
// -- liability of any use of Xilinx products in Critical
// -- Applications, subject only to applicable laws and
// -- regulations governing limitations on product liability.
// --
// -- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
// -- PART OF THIS FILE AT ALL TIMES.
//-----------------------------------------------------------------------------
//
// Description: 
//  Optimized COMPARATOR (against constant) with carry logic.
//
// Verilog-standard:  Verilog 2001
//--------------------------------------------------------------------------
//
// Structure:
//   
//
//--------------------------------------------------------------------------
`timescale 1ps/1ps

(* DowngradeIPIdentifiedWarnings="yes" *) 
module axi_interconnect_v1_7_13_comparator_sel_static #
  (
   parameter         C_FAMILY                         = "virtex6", 
                       // FPGA Family. Current version: virtex6 or spartan6.
   parameter         C_VALUE                          = 4'b0,
                       // Static value to compare against.
   parameter integer C_DATA_WIDTH                     = 4
                       // Data width for comparator.
   )
  (
   input  wire                    CIN,
   input  wire                    S,
   input  wire [C_DATA_WIDTH-1:0] A,
   input  wire [C_DATA_WIDTH-1:0] B,
   output wire                    COUT
   );
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Variables for generating parameter controlled instances.
  /////////////////////////////////////////////////////////////////////////////
  
  // Generate variable for bit vector.
  genvar bit_cnt;
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Local params
  /////////////////////////////////////////////////////////////////////////////
  
  // Bits per LUT for this architecture.
  localparam integer C_BITS_PER_LUT   = 2;
  
  // Constants for packing levels.
  localparam integer C_NUM_LUT        = ( C_DATA_WIDTH + C_BITS_PER_LUT - 1 ) / C_BITS_PER_LUT;
  
  // 
  localparam integer C_FIX_DATA_WIDTH = ( C_NUM_LUT * C_BITS_PER_LUT > C_DATA_WIDTH ) ? C_NUM_LUT * C_BITS_PER_LUT :
                                        C_DATA_WIDTH;
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Functions
  /////////////////////////////////////////////////////////////////////////////
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Internal signals
  /////////////////////////////////////////////////////////////////////////////
  
  wire [C_FIX_DATA_WIDTH-1:0] a_local;
  wire [C_FIX_DATA_WIDTH-1:0] b_local;
  wire [C_FIX_DATA_WIDTH-1:0] v_local;
  wire [C_NUM_LUT-1:0]        sel;
  wire [C_NUM_LUT:0]          carry_local;
  
  
  /////////////////////////////////////////////////////////////////////////////
  // 
  /////////////////////////////////////////////////////////////////////////////
  
  generate
    // Assign input to local vectors.
    assign carry_local[0] = CIN;
    
    // Extend input data to fit.
    if ( C_NUM_LUT * C_BITS_PER_LUT > C_DATA_WIDTH ) begin : USE_EXTENDED_DATA
      assign a_local        = {A,       {C_NUM_LUT * C_BITS_PER_LUT - C_DATA_WIDTH{1'b0}}};
      assign b_local        = {B,       {C_NUM_LUT * C_BITS_PER_LUT - C_DATA_WIDTH{1'b0}}};
      assign v_local        = {C_VALUE, {C_NUM_LUT * C_BITS_PER_LUT - C_DATA_WIDTH{1'b0}}};
    end else begin : NO_EXTENDED_DATA
      assign a_local        = A;
      assign b_local        = B;
      assign v_local        = C_VALUE;
    end
    
    // Instantiate one carry and per level.
    for (bit_cnt = 0; bit_cnt < C_NUM_LUT ; bit_cnt = bit_cnt + 1) begin : LUT_LEVEL
      // Create the local select signal
      assign sel[bit_cnt] = ( ( a_local[bit_cnt*C_BITS_PER_LUT +: C_BITS_PER_LUT] == 
                                v_local[bit_cnt*C_BITS_PER_LUT +: C_BITS_PER_LUT] ) & ( S == 1'b0 ) ) |
                            ( ( b_local[bit_cnt*C_BITS_PER_LUT +: C_BITS_PER_LUT] == 
                                v_local[bit_cnt*C_BITS_PER_LUT +: C_BITS_PER_LUT] ) & ( S == 1'b1 ) );
    
      // Instantiate each LUT level.
  axi_interconnect_v1_7_13_carry_and # 
      (
       .C_FAMILY(C_FAMILY)
      ) compare_inst 
      (
       .COUT  (carry_local[bit_cnt+1]),
       .CIN   (carry_local[bit_cnt]),
       .S     (sel[bit_cnt])
      ); 
      
    end // end for bit_cnt
    
    // Assign output from local vector.
    assign COUT = carry_local[C_NUM_LUT];
    
  endgenerate
  
  
endmodule



// -- (c) Copyright 2010 - 2011 Xilinx, Inc. All rights reserved.
// --
// -- This file contains confidential and proprietary information
// -- of Xilinx, Inc. and is protected under U.S. and 
// -- international copyright and other intellectual property
// -- laws.
// --
// -- DISCLAIMER
// -- This disclaimer is not a license and does not grant any
// -- rights to the materials distributed herewith. Except as
// -- otherwise provided in a valid license issued to you by
// -- Xilinx, and to the maximum extent permitted by applicable
// -- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
// -- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
// -- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
// -- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
// -- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
// -- (2) Xilinx shall not be liable (whether in contract or tort,
// -- including negligence, or under any other theory of
// -- liability) for any loss or damage of any kind or nature
// -- related to, arising under or in connection with these
// -- materials, including for any direct, or any indirect,
// -- special, incidental, or consequential loss or damage
// -- (including loss of data, profits, goodwill, or any type of
// -- loss or damage suffered as a result of any action brought
// -- by a third party) even if such damage or loss was
// -- reasonably foreseeable or Xilinx had been advised of the
// -- possibility of the same.
// --
// -- CRITICAL APPLICATIONS
// -- Xilinx products are not designed or intended to be fail-
// -- safe, or for use in any application requiring fail-safe
// -- performance, such as life-support or safety devices or
// -- systems, Class III medical devices, nuclear facilities,
// -- applications related to the deployment of airbags, or any
// -- other applications that could lead to death, personal
// -- injury, or severe property or environmental damage
// -- (individually and collectively, "Critical
// -- Applications"). Customer assumes the sole risk and
// -- liability of any use of Xilinx products in Critical
// -- Applications, subject only to applicable laws and
// -- regulations governing limitations on product liability.
// --
// -- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
// -- PART OF THIS FILE AT ALL TIMES.
//-----------------------------------------------------------------------------
//
// Description: 
//  Optimized COMPARATOR with carry logic.
//
// Verilog-standard:  Verilog 2001
//--------------------------------------------------------------------------
//
// Structure:
//   
//
//--------------------------------------------------------------------------
`timescale 1ps/1ps

(* DowngradeIPIdentifiedWarnings="yes" *) 
module axi_interconnect_v1_7_13_comparator_sel #
  (
   parameter         C_FAMILY                         = "virtex6", 
                       // FPGA Family. Current version: virtex6 or spartan6.
   parameter integer C_DATA_WIDTH                     = 4
                       // Data width for comparator.
   )
  (
   input  wire                    CIN,
   input  wire                    S,
   input  wire [C_DATA_WIDTH-1:0] A,
   input  wire [C_DATA_WIDTH-1:0] B,
   input  wire [C_DATA_WIDTH-1:0] V,
   output wire                    COUT
   );
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Variables for generating parameter controlled instances.
  /////////////////////////////////////////////////////////////////////////////
  
  // Generate variable for bit vector.
  genvar bit_cnt;
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Local params
  /////////////////////////////////////////////////////////////////////////////
  
  // Bits per LUT for this architecture.
  localparam integer C_BITS_PER_LUT   = 1;
  
  // Constants for packing levels.
  localparam integer C_NUM_LUT        = ( C_DATA_WIDTH + C_BITS_PER_LUT - 1 ) / C_BITS_PER_LUT;
  
  // 
  localparam integer C_FIX_DATA_WIDTH = ( C_NUM_LUT * C_BITS_PER_LUT > C_DATA_WIDTH ) ? C_NUM_LUT * C_BITS_PER_LUT :
                                        C_DATA_WIDTH;
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Functions
  /////////////////////////////////////////////////////////////////////////////
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Internal signals
  /////////////////////////////////////////////////////////////////////////////
  
  wire [C_FIX_DATA_WIDTH-1:0] a_local;
  wire [C_FIX_DATA_WIDTH-1:0] b_local;
  wire [C_FIX_DATA_WIDTH-1:0] v_local;
  wire [C_NUM_LUT-1:0]        sel;
  wire [C_NUM_LUT:0]          carry_local;
  
  
  /////////////////////////////////////////////////////////////////////////////
  // 
  /////////////////////////////////////////////////////////////////////////////
  
  generate
    // Assign input to local vectors.
    assign carry_local[0] = CIN;
    
    // Extend input data to fit.
    if ( C_NUM_LUT * C_BITS_PER_LUT > C_DATA_WIDTH ) begin : USE_EXTENDED_DATA
      assign a_local        = {A, {C_NUM_LUT * C_BITS_PER_LUT - C_DATA_WIDTH{1'b0}}};
      assign b_local        = {B, {C_NUM_LUT * C_BITS_PER_LUT - C_DATA_WIDTH{1'b0}}};
      assign v_local        = {V, {C_NUM_LUT * C_BITS_PER_LUT - C_DATA_WIDTH{1'b0}}};
    end else begin : NO_EXTENDED_DATA
      assign a_local        = A;
      assign b_local        = B;
      assign v_local        = V;
    end
  
    // Instantiate one carry and per level.
    for (bit_cnt = 0; bit_cnt < C_NUM_LUT ; bit_cnt = bit_cnt + 1) begin : LUT_LEVEL
      // Create the local select signal
      assign sel[bit_cnt] = ( ( a_local[bit_cnt*C_BITS_PER_LUT +: C_BITS_PER_LUT] == 
                                v_local[bit_cnt*C_BITS_PER_LUT +: C_BITS_PER_LUT] ) & ( S == 1'b0 ) ) |
                            ( ( b_local[bit_cnt*C_BITS_PER_LUT +: C_BITS_PER_LUT] == 
                                v_local[bit_cnt*C_BITS_PER_LUT +: C_BITS_PER_LUT] ) & ( S == 1'b1 ) );
    
      // Instantiate each LUT level.
  axi_interconnect_v1_7_13_carry_and # 
      (
       .C_FAMILY(C_FAMILY)
      ) compare_inst 
      (
       .COUT  (carry_local[bit_cnt+1]),
       .CIN   (carry_local[bit_cnt]),
       .S     (sel[bit_cnt])
      ); 
      
    end // end for bit_cnt
    
    // Assign output from local vector.
    assign COUT = carry_local[C_NUM_LUT];
    
  endgenerate
  
  
endmodule



// -- (c) Copyright 2010 - 2011 Xilinx, Inc. All rights reserved.
// --
// -- This file contains confidential and proprietary information
// -- of Xilinx, Inc. and is protected under U.S. and 
// -- international copyright and other intellectual property
// -- laws.
// --
// -- DISCLAIMER
// -- This disclaimer is not a license and does not grant any
// -- rights to the materials distributed herewith. Except as
// -- otherwise provided in a valid license issued to you by
// -- Xilinx, and to the maximum extent permitted by applicable
// -- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
// -- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
// -- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
// -- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
// -- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
// -- (2) Xilinx shall not be liable (whether in contract or tort,
// -- including negligence, or under any other theory of
// -- liability) for any loss or damage of any kind or nature
// -- related to, arising under or in connection with these
// -- materials, including for any direct, or any indirect,
// -- special, incidental, or consequential loss or damage
// -- (including loss of data, profits, goodwill, or any type of
// -- loss or damage suffered as a result of any action brought
// -- by a third party) even if such damage or loss was
// -- reasonably foreseeable or Xilinx had been advised of the
// -- possibility of the same.
// --
// -- CRITICAL APPLICATIONS
// -- Xilinx products are not designed or intended to be fail-
// -- safe, or for use in any application requiring fail-safe
// -- performance, such as life-support or safety devices or
// -- systems, Class III medical devices, nuclear facilities,
// -- applications related to the deployment of airbags, or any
// -- other applications that could lead to death, personal
// -- injury, or severe property or environmental damage
// -- (individually and collectively, "Critical
// -- Applications"). Customer assumes the sole risk and
// -- liability of any use of Xilinx products in Critical
// -- Applications, subject only to applicable laws and
// -- regulations governing limitations on product liability.
// --
// -- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
// -- PART OF THIS FILE AT ALL TIMES.
//-----------------------------------------------------------------------------
//
// Description: 
//  Optimized COMPARATOR (against constant) with carry logic.
//
// Verilog-standard:  Verilog 2001
//--------------------------------------------------------------------------
//
// Structure:
//   
//
//--------------------------------------------------------------------------
`timescale 1ps/1ps

(* DowngradeIPIdentifiedWarnings="yes" *) 
module axi_interconnect_v1_7_13_comparator_static #
  (
   parameter         C_FAMILY                         = "virtex6", 
                       // FPGA Family. Current version: virtex6 or spartan6.
   parameter         C_VALUE                          = 4'b0,
                       // Static value to compare against.
   parameter integer C_DATA_WIDTH                     = 4
                       // Data width for comparator.
   )
  (
   input  wire                    CIN,
   input  wire [C_DATA_WIDTH-1:0] A,
   output wire                    COUT
   );
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Variables for generating parameter controlled instances.
  /////////////////////////////////////////////////////////////////////////////
  
  // Generate variable for bit vector.
  genvar bit_cnt;
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Local params
  /////////////////////////////////////////////////////////////////////////////
  
  // Bits per LUT for this architecture.
  localparam integer C_BITS_PER_LUT   = 6;
  
  // Constants for packing levels.
  localparam integer C_NUM_LUT        = ( C_DATA_WIDTH + C_BITS_PER_LUT - 1 ) / C_BITS_PER_LUT;
  
  // 
  localparam integer C_FIX_DATA_WIDTH = ( C_NUM_LUT * C_BITS_PER_LUT > C_DATA_WIDTH ) ? C_NUM_LUT * C_BITS_PER_LUT :
                                        C_DATA_WIDTH;
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Functions
  /////////////////////////////////////////////////////////////////////////////
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Internal signals
  /////////////////////////////////////////////////////////////////////////////
  
  wire [C_FIX_DATA_WIDTH-1:0] a_local;
  wire [C_FIX_DATA_WIDTH-1:0] b_local;
  wire [C_NUM_LUT-1:0]        sel;
  wire [C_NUM_LUT:0]          carry_local;
  
  
  /////////////////////////////////////////////////////////////////////////////
  // 
  /////////////////////////////////////////////////////////////////////////////
  
  generate
    // Assign input to local vectors.
    assign carry_local[0] = CIN;
    
    // Extend input data to fit.
    if ( C_NUM_LUT * C_BITS_PER_LUT > C_DATA_WIDTH ) begin : USE_EXTENDED_DATA
      assign a_local        = {A,       {C_NUM_LUT * C_BITS_PER_LUT - C_DATA_WIDTH{1'b0}}};
      assign b_local        = {C_VALUE, {C_NUM_LUT * C_BITS_PER_LUT - C_DATA_WIDTH{1'b0}}};
    end else begin : NO_EXTENDED_DATA
      assign a_local        = A;
      assign b_local        = C_VALUE;
    end
    
    // Instantiate one carry and per level.
    for (bit_cnt = 0; bit_cnt < C_NUM_LUT ; bit_cnt = bit_cnt + 1) begin : LUT_LEVEL
      // Create the local select signal
      assign sel[bit_cnt] = ( a_local[bit_cnt*C_BITS_PER_LUT +: C_BITS_PER_LUT] == 
                              b_local[bit_cnt*C_BITS_PER_LUT +: C_BITS_PER_LUT] );
    
      // Instantiate each LUT level.
  axi_interconnect_v1_7_13_carry_and # 
      (
       .C_FAMILY(C_FAMILY)
      ) compare_inst 
      (
       .COUT  (carry_local[bit_cnt+1]),
       .CIN   (carry_local[bit_cnt]),
       .S     (sel[bit_cnt])
      ); 
      
    end // end for bit_cnt
    
    // Assign output from local vector.
    assign COUT = carry_local[C_NUM_LUT];
    
  endgenerate
  
  
endmodule



// -- (c) Copyright 2010 - 2011 Xilinx, Inc. All rights reserved.
// --
// -- This file contains confidential and proprietary information
// -- of Xilinx, Inc. and is protected under U.S. and 
// -- international copyright and other intellectual property
// -- laws.
// --
// -- DISCLAIMER
// -- This disclaimer is not a license and does not grant any
// -- rights to the materials distributed herewith. Except as
// -- otherwise provided in a valid license issued to you by
// -- Xilinx, and to the maximum extent permitted by applicable
// -- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
// -- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
// -- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
// -- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
// -- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
// -- (2) Xilinx shall not be liable (whether in contract or tort,
// -- including negligence, or under any other theory of
// -- liability) for any loss or damage of any kind or nature
// -- related to, arising under or in connection with these
// -- materials, including for any direct, or any indirect,
// -- special, incidental, or consequential loss or damage
// -- (including loss of data, profits, goodwill, or any type of
// -- loss or damage suffered as a result of any action brought
// -- by a third party) even if such damage or loss was
// -- reasonably foreseeable or Xilinx had been advised of the
// -- possibility of the same.
// --
// -- CRITICAL APPLICATIONS
// -- Xilinx products are not designed or intended to be fail-
// -- safe, or for use in any application requiring fail-safe
// -- performance, such as life-support or safety devices or
// -- systems, Class III medical devices, nuclear facilities,
// -- applications related to the deployment of airbags, or any
// -- other applications that could lead to death, personal
// -- injury, or severe property or environmental damage
// -- (individually and collectively, "Critical
// -- Applications"). Customer assumes the sole risk and
// -- liability of any use of Xilinx products in Critical
// -- Applications, subject only to applicable laws and
// -- regulations governing limitations on product liability.
// --
// -- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
// -- PART OF THIS FILE AT ALL TIMES.
//-----------------------------------------------------------------------------
//
// Description: 
//  Optimized COMPARATOR with carry logic.
//
// Verilog-standard:  Verilog 2001
//--------------------------------------------------------------------------
//
// Structure:
//   
//
//--------------------------------------------------------------------------
`timescale 1ps/1ps

(* DowngradeIPIdentifiedWarnings="yes" *) 
module axi_interconnect_v1_7_13_comparator #
  (
   parameter         C_FAMILY                         = "virtex6", 
                       // FPGA Family. Current version: virtex6 or spartan6.
   parameter integer C_DATA_WIDTH                     = 4
                       // Data width for comparator.
   )
  (
   input  wire                    CIN,
   input  wire [C_DATA_WIDTH-1:0] A,
   input  wire [C_DATA_WIDTH-1:0] B,
   output wire                    COUT
   );
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Variables for generating parameter controlled instances.
  /////////////////////////////////////////////////////////////////////////////
  
  // Generate variable for bit vector.
  genvar bit_cnt;
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Local params
  /////////////////////////////////////////////////////////////////////////////
  
  // Bits per LUT for this architecture.
  localparam integer C_BITS_PER_LUT   = 3;
  
  // Constants for packing levels.
  localparam integer C_NUM_LUT        = ( C_DATA_WIDTH + C_BITS_PER_LUT - 1 ) / C_BITS_PER_LUT;
  
  // 
  localparam integer C_FIX_DATA_WIDTH = ( C_NUM_LUT * C_BITS_PER_LUT > C_DATA_WIDTH ) ? C_NUM_LUT * C_BITS_PER_LUT :
                                        C_DATA_WIDTH;
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Functions
  /////////////////////////////////////////////////////////////////////////////
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Internal signals
  /////////////////////////////////////////////////////////////////////////////
  
  wire [C_FIX_DATA_WIDTH-1:0] a_local;
  wire [C_FIX_DATA_WIDTH-1:0] b_local;
  wire [C_NUM_LUT-1:0]        sel;
  wire [C_NUM_LUT:0]          carry_local;
  
  
  /////////////////////////////////////////////////////////////////////////////
  // 
  /////////////////////////////////////////////////////////////////////////////
  
  generate
    // Assign input to local vectors.
    assign carry_local[0] = CIN;
    
    // Extend input data to fit.
    if ( C_NUM_LUT * C_BITS_PER_LUT > C_DATA_WIDTH ) begin : USE_EXTENDED_DATA
      assign a_local        = {A, {C_NUM_LUT * C_BITS_PER_LUT - C_DATA_WIDTH{1'b0}}};
      assign b_local        = {B, {C_NUM_LUT * C_BITS_PER_LUT - C_DATA_WIDTH{1'b0}}};
    end else begin : NO_EXTENDED_DATA
      assign a_local        = A;
      assign b_local        = B;
    end
  
    // Instantiate one carry and per level.
    for (bit_cnt = 0; bit_cnt < C_NUM_LUT ; bit_cnt = bit_cnt + 1) begin : LUT_LEVEL
      // Create the local select signal
      assign sel[bit_cnt] = ( a_local[bit_cnt*C_BITS_PER_LUT +: C_BITS_PER_LUT] == 
                              b_local[bit_cnt*C_BITS_PER_LUT +: C_BITS_PER_LUT] );
    
      // Instantiate each LUT level.
  axi_interconnect_v1_7_13_carry_and # 
      (
       .C_FAMILY(C_FAMILY)
      ) compare_inst 
      (
       .COUT  (carry_local[bit_cnt+1]),
       .CIN   (carry_local[bit_cnt]),
       .S     (sel[bit_cnt])
      ); 
      
    end // end for bit_cnt
    
    // Assign output from local vector.
    assign COUT = carry_local[C_NUM_LUT];
    
  endgenerate
  
  
endmodule



// -- (c) Copyright 2009 - 2011 Xilinx, Inc. All rights reserved.
// --
// -- This file contains confidential and proprietary information
// -- of Xilinx, Inc. and is protected under U.S. and 
// -- international copyright and other intellectual property
// -- laws.
// --
// -- DISCLAIMER
// -- This disclaimer is not a license and does not grant any
// -- rights to the materials distributed herewith. Except as
// -- otherwise provided in a valid license issued to you by
// -- Xilinx, and to the maximum extent permitted by applicable
// -- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
// -- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
// -- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
// -- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
// -- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
// -- (2) Xilinx shall not be liable (whether in contract or tort,
// -- including negligence, or under any other theory of
// -- liability) for any loss or damage of any kind or nature
// -- related to, arising under or in connection with these
// -- materials, including for any direct, or any indirect,
// -- special, incidental, or consequential loss or damage
// -- (including loss of data, profits, goodwill, or any type of
// -- loss or damage suffered as a result of any action brought
// -- by a third party) even if such damage or loss was
// -- reasonably foreseeable or Xilinx had been advised of the
// -- possibility of the same.
// --
// -- CRITICAL APPLICATIONS
// -- Xilinx products are not designed or intended to be fail-
// -- safe, or for use in any application requiring fail-safe
// -- performance, such as life-support or safety devices or
// -- systems, Class III medical devices, nuclear facilities,
// -- applications related to the deployment of airbags, or any
// -- other applications that could lead to death, personal
// -- injury, or severe property or environmental damage
// -- (individually and collectively, "Critical
// -- Applications"). Customer assumes the sole risk and
// -- liability of any use of Xilinx products in Critical
// -- Applications, subject only to applicable laws and
// -- regulations governing limitations on product liability.
// --
// -- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
// -- PART OF THIS FILE AT ALL TIMES.
//-----------------------------------------------------------------------------
//
// File name: converter_bank.v
//
// Description: 
//   This module is a bank of width and clock converters for a vectored AXI interface.
//   The interface of this module consists of a vectored slave and master interface
//     which are each concatenations of upper-level AXI pathways,
//     plus various vectored parameters.
//   This module instantiates a set of individual up-sizers, down-sizers and
//     clock converters.
//
//-----------------------------------------------------------------------------
//
// Structure:
//    converter_bank
//      axi_upsizer
//      clock_conv
//        fifo_gen
//        clock_sync_accel
//        clock_sync_decel
//      axi_downsizer
//      
//-----------------------------------------------------------------------------
`timescale 1ps/1ps
`default_nettype none

(* DowngradeIPIdentifiedWarnings="yes" *) 
module axi_interconnect_v1_7_13_converter_bank #
  (
   parameter         C_FAMILY                         = "none", 
   parameter integer C_NUM_SLOTS                = 1, 
   parameter         C_AXI_ID_WIDTH                 = 1, 
                       // Effective width of ID ports for each SI and MI slot.
                       // Format: C_NUM_SLOTS{Bit32}; 
                       // Range: 'h00000001 - C_AXI_ID_MAX_WIDTH.
   parameter integer C_AXI_ID_MAX_WIDTH                 = 1, 
                       // Width of ID signals propagated by the Interconnect.
                       // Stride of ID fields within each ID port.
                       // Range: >= 1.
   parameter integer C_AXI_ADDR_WIDTH                 = 32, 
   parameter integer C_AXI_DATA_MAX_WIDTH           = 256, 
                       // Largest value supported for any DATA_WIDTH.
                       // Stride of data fields within each DATA port.
   parameter         C_S_AXI_DATA_WIDTH               = {16{32'h00000020}}, 
                       // SI-side data width of each slot.
                       // Format: C_NUM_SLOTS{Bit32}; 
                       // Range: 'h00000020, 'h00000040, 'h00000080, 'h00000100.
   parameter         C_M_AXI_DATA_WIDTH               = {16{32'h00000020}}, 
                       // MI-side data width of each slot.
                       // Format: C_NUM_SLOTS{Bit32}; 
                       // Range: 'h00000020, 'h00000040, 'h00000080, 'h00000100.
   parameter         C_AXI_PROTOCOL                 = {16{32'h00000000}}, 
                       // Full-AXI4 ('h00000000),
                       // AXI3 ('h00000001) or 
                       // Axi4Lite ('h00000002).
                       // Format: C_NUM_SLOTS{Bit32}.
   parameter         C_S_AXI_ACLK_RATIO               = {16{32'h00000001}}, 
                       // SI-side clock frequency ratio.
                       // Format: C_NUM_SLOTS{Bit32}; Range: >='h00000001.
   parameter         C_M_AXI_ACLK_RATIO               = {16{32'h00000001}}, 
                       // MI-side clock frequency ratio.
                       // Format: C_NUM_SLOTS{Bit32}; Range: >='h00000001.
   parameter         C_AXI_IS_ACLK_ASYNC            = 16'b00000000_00000000, 
                       // Format: C_NUM_SLOTS{Bit1}.
   parameter         C_AXI_SUPPORTS_WRITE           = 16'b11111111_11111111, 
                       // Format: C_NUM_SLOTS{Bit1}.
   parameter         C_AXI_SUPPORTS_READ            = 16'b11111111_11111111, 
                       // Format: C_NUM_SLOTS{Bit1}.
   parameter integer C_AXI_SUPPORTS_USER_SIGNALS      = 0,
                       // 1 = Propagate all USER signals, 0 = Dont propagate.
   parameter integer C_AXI_AWUSER_WIDTH               = 1,
   parameter integer C_AXI_ARUSER_WIDTH               = 1,
   parameter integer C_AXI_WUSER_WIDTH                = 1,
   parameter integer C_AXI_RUSER_WIDTH                = 1,
   parameter integer C_AXI_BUSER_WIDTH                = 1,
   parameter integer C_SYNCHRONIZER_STAGE = 3,
   parameter         C_HEMISPHERE                   = "si"
     // For SI hemisphere, ARESET is in clock domain of the M_AXI interface;
     // For MI hemisphere, ARESET is in clock domain of the S_AXI interface;
   )
  (
   // Global Signals
   input  wire                                              INTERCONNECT_ACLK,
   input  wire                                              INTERCONNECT_ARESETN,
   input  wire                                              LOCAL_ARESETN,
   output wire                                              INTERCONNECT_RESET_OUT_N,
   output wire [C_NUM_SLOTS-1:0]                            S_AXI_RESET_OUT_N,
   output wire [C_NUM_SLOTS-1:0]                            M_AXI_RESET_OUT_N,
   // Slave Interface Global Signals
   input  wire [C_NUM_SLOTS-1:0]                            S_AXI_ACLK,
   // Slave Interface Write Address Ports
   input  wire [C_NUM_SLOTS*C_AXI_ID_MAX_WIDTH-1:0]           S_AXI_AWID,
   input  wire [C_NUM_SLOTS*C_AXI_ADDR_WIDTH-1:0]           S_AXI_AWADDR,
   input  wire [C_NUM_SLOTS*8-1:0]                          S_AXI_AWLEN,
   input  wire [C_NUM_SLOTS*3-1:0]                          S_AXI_AWSIZE,
   input  wire [C_NUM_SLOTS*2-1:0]                          S_AXI_AWBURST,
   input  wire [C_NUM_SLOTS*2-1:0]                          S_AXI_AWLOCK,
   input  wire [C_NUM_SLOTS*4-1:0]                          S_AXI_AWCACHE,
   input  wire [C_NUM_SLOTS*3-1:0]                          S_AXI_AWPROT,
   input  wire [C_NUM_SLOTS*4-1:0]                          S_AXI_AWREGION,
   input  wire [C_NUM_SLOTS*4-1:0]                          S_AXI_AWQOS,
   input  wire [C_NUM_SLOTS*C_AXI_AWUSER_WIDTH-1:0]         S_AXI_AWUSER,
   input  wire [C_NUM_SLOTS-1:0]                            S_AXI_AWVALID,
   output wire [C_NUM_SLOTS-1:0]                            S_AXI_AWREADY,
   // Slave Interface Write Data Ports
   input  wire [C_NUM_SLOTS*C_AXI_DATA_MAX_WIDTH-1:0]     S_AXI_WDATA,
   input  wire [C_NUM_SLOTS*C_AXI_DATA_MAX_WIDTH/8-1:0]   S_AXI_WSTRB,
   input  wire [C_NUM_SLOTS-1:0]                            S_AXI_WLAST,
   input  wire [C_NUM_SLOTS*C_AXI_WUSER_WIDTH-1:0]          S_AXI_WUSER,
   input  wire [C_NUM_SLOTS-1:0]                            S_AXI_WVALID,
   output wire [C_NUM_SLOTS-1:0]                            S_AXI_WREADY,
   // Slave Interface Write Response Ports
   output wire [C_NUM_SLOTS*C_AXI_ID_MAX_WIDTH-1:0]           S_AXI_BID,
   output wire [C_NUM_SLOTS*2-1:0]                          S_AXI_BRESP,
   output wire [C_NUM_SLOTS*C_AXI_BUSER_WIDTH-1:0]          S_AXI_BUSER,
   output wire [C_NUM_SLOTS-1:0]                            S_AXI_BVALID,
   input  wire [C_NUM_SLOTS-1:0]                            S_AXI_BREADY,
   // Slave Interface Read Address Ports
   input  wire [C_NUM_SLOTS*C_AXI_ID_MAX_WIDTH-1:0]           S_AXI_ARID,
   input  wire [C_NUM_SLOTS*C_AXI_ADDR_WIDTH-1:0]           S_AXI_ARADDR,
   input  wire [C_NUM_SLOTS*8-1:0]                          S_AXI_ARLEN,
   input  wire [C_NUM_SLOTS*3-1:0]                          S_AXI_ARSIZE,
   input  wire [C_NUM_SLOTS*2-1:0]                          S_AXI_ARBURST,
   input  wire [C_NUM_SLOTS*2-1:0]                          S_AXI_ARLOCK,
   input  wire [C_NUM_SLOTS*4-1:0]                          S_AXI_ARCACHE,
   input  wire [C_NUM_SLOTS*3-1:0]                          S_AXI_ARPROT,
   input  wire [C_NUM_SLOTS*4-1:0]                          S_AXI_ARREGION,
   input  wire [C_NUM_SLOTS*4-1:0]                          S_AXI_ARQOS,
   input  wire [C_NUM_SLOTS*C_AXI_ARUSER_WIDTH-1:0]         S_AXI_ARUSER,
   input  wire [C_NUM_SLOTS-1:0]                            S_AXI_ARVALID,
   output wire [C_NUM_SLOTS-1:0]                            S_AXI_ARREADY,
   // Slave Interface Read Data Ports
   output wire [C_NUM_SLOTS*C_AXI_ID_MAX_WIDTH-1:0]           S_AXI_RID,
   output wire [C_NUM_SLOTS*C_AXI_DATA_MAX_WIDTH-1:0]     S_AXI_RDATA,
   output wire [C_NUM_SLOTS*2-1:0]                          S_AXI_RRESP,
   output wire [C_NUM_SLOTS-1:0]                            S_AXI_RLAST,
   output wire [C_NUM_SLOTS*C_AXI_RUSER_WIDTH-1:0]          S_AXI_RUSER,
   output wire [C_NUM_SLOTS-1:0]                            S_AXI_RVALID,
   input  wire [C_NUM_SLOTS-1:0]                            S_AXI_RREADY,
   // Master Interface Global Signals
   input  wire [C_NUM_SLOTS-1:0]                            M_AXI_ACLK,
   // Master Interface Write Address Port
   output wire [C_NUM_SLOTS*C_AXI_ID_MAX_WIDTH-1:0]          M_AXI_AWID,
   output wire [C_NUM_SLOTS*C_AXI_ADDR_WIDTH-1:0]          M_AXI_AWADDR,
   output wire [C_NUM_SLOTS*8-1:0]                         M_AXI_AWLEN,
   output wire [C_NUM_SLOTS*3-1:0]                         M_AXI_AWSIZE,
   output wire [C_NUM_SLOTS*2-1:0]                         M_AXI_AWBURST,
   output wire [C_NUM_SLOTS*2-1:0]                         M_AXI_AWLOCK,
   output wire [C_NUM_SLOTS*4-1:0]                         M_AXI_AWCACHE,
   output wire [C_NUM_SLOTS*3-1:0]                         M_AXI_AWPROT,
   output wire [C_NUM_SLOTS*4-1:0]                         M_AXI_AWREGION,
   output wire [C_NUM_SLOTS*4-1:0]                         M_AXI_AWQOS,
   output wire [C_NUM_SLOTS*C_AXI_AWUSER_WIDTH-1:0]        M_AXI_AWUSER,
   output wire [C_NUM_SLOTS-1:0]                           M_AXI_AWVALID,
   input  wire [C_NUM_SLOTS-1:0]                           M_AXI_AWREADY,
   // Master Interface Write Data Ports
   output wire [C_NUM_SLOTS*C_AXI_DATA_MAX_WIDTH-1:0]    M_AXI_WDATA,
   output wire [C_NUM_SLOTS*C_AXI_DATA_MAX_WIDTH/8-1:0]  M_AXI_WSTRB,
   output wire [C_NUM_SLOTS-1:0]                           M_AXI_WLAST,
   output wire [C_NUM_SLOTS*C_AXI_WUSER_WIDTH-1:0]         M_AXI_WUSER,
   output wire [C_NUM_SLOTS-1:0]                           M_AXI_WVALID,
   input  wire [C_NUM_SLOTS-1:0]                           M_AXI_WREADY,
   // Master Interface Write Response Ports
   input  wire [C_NUM_SLOTS*C_AXI_ID_MAX_WIDTH-1:0]          M_AXI_BID,
   input  wire [C_NUM_SLOTS*2-1:0]                         M_AXI_BRESP,
   input  wire [C_NUM_SLOTS*C_AXI_BUSER_WIDTH-1:0]         M_AXI_BUSER,
   input  wire [C_NUM_SLOTS-1:0]                           M_AXI_BVALID,
   output wire [C_NUM_SLOTS-1:0]                           M_AXI_BREADY,
   // Master Interface Read Address Port
   output wire [C_NUM_SLOTS*C_AXI_ID_MAX_WIDTH-1:0]          M_AXI_ARID,
   output wire [C_NUM_SLOTS*C_AXI_ADDR_WIDTH-1:0]          M_AXI_ARADDR,
   output wire [C_NUM_SLOTS*8-1:0]                         M_AXI_ARLEN,
   output wire [C_NUM_SLOTS*3-1:0]                         M_AXI_ARSIZE,
   output wire [C_NUM_SLOTS*2-1:0]                         M_AXI_ARBURST,
   output wire [C_NUM_SLOTS*2-1:0]                         M_AXI_ARLOCK,
   output wire [C_NUM_SLOTS*4-1:0]                         M_AXI_ARCACHE,
   output wire [C_NUM_SLOTS*3-1:0]                         M_AXI_ARPROT,
   output wire [C_NUM_SLOTS*4-1:0]                         M_AXI_ARREGION,
   output wire [C_NUM_SLOTS*4-1:0]                         M_AXI_ARQOS,
   output wire [C_NUM_SLOTS*C_AXI_ARUSER_WIDTH-1:0]        M_AXI_ARUSER,
   output wire [C_NUM_SLOTS-1:0]                           M_AXI_ARVALID,
   input  wire [C_NUM_SLOTS-1:0]                           M_AXI_ARREADY,
   // Master Interface Read Data Ports
   input  wire [C_NUM_SLOTS*C_AXI_ID_MAX_WIDTH-1:0]          M_AXI_RID,
   input  wire [C_NUM_SLOTS*C_AXI_DATA_MAX_WIDTH-1:0]    M_AXI_RDATA,
   input  wire [C_NUM_SLOTS*2-1:0]                         M_AXI_RRESP,
   input  wire [C_NUM_SLOTS-1:0]                           M_AXI_RLAST,
   input  wire [C_NUM_SLOTS*C_AXI_RUSER_WIDTH-1:0]         M_AXI_RUSER,
   input  wire [C_NUM_SLOTS-1:0]                           M_AXI_RVALID,
   output wire [C_NUM_SLOTS-1:0]                           M_AXI_RREADY
   );
   
  localparam P_AXILITE = 32'h2;
  localparam integer P_CONDITIONAL_PACK = 1;
  localparam integer P_NEVER_PACK = 0;
  localparam P_LIGHTWT = 32'h7;
  localparam P_FULLY_REG = 32'h1;
  
  function integer f_cc_data_width (
  // Data width of selected slot at clock-converter.
      input integer slot_f
    );
    begin
      f_cc_data_width = (C_S_AXI_DATA_WIDTH[slot_f*32+:32] < C_M_AXI_DATA_WIDTH[slot_f*32+:32]) ? 
                                 C_M_AXI_DATA_WIDTH[slot_f*32+:32] : C_S_AXI_DATA_WIDTH[slot_f*32+:32];
    end
  endfunction

  wire [C_NUM_SLOTS*C_AXI_DATA_MAX_WIDTH-1:0]     si_us_rdata           ;
  wire [C_NUM_SLOTS*C_AXI_ID_MAX_WIDTH-1:0]     si_us_bid           ;
  wire [C_NUM_SLOTS*C_AXI_ID_MAX_WIDTH-1:0]     si_us_rid           ;
  
  wire [C_NUM_SLOTS*C_AXI_ID_MAX_WIDTH-1:0]           us_cc_awid            ;
  wire [C_NUM_SLOTS*C_AXI_ADDR_WIDTH-1:0]         us_cc_awaddr          ;
  wire [C_NUM_SLOTS*8-1:0]                        us_cc_awlen           ;
  wire [C_NUM_SLOTS*3-1:0]                        us_cc_awsize          ;
  wire [C_NUM_SLOTS*2-1:0]                        us_cc_awburst         ;
  wire [C_NUM_SLOTS*2-1:0]                        us_cc_awlock          ;
  wire [C_NUM_SLOTS*4-1:0]                        us_cc_awcache         ;
  wire [C_NUM_SLOTS*3-1:0]                        us_cc_awprot          ;
  wire [C_NUM_SLOTS*4-1:0]                        us_cc_awregion        ;
  wire [C_NUM_SLOTS*4-1:0]                        us_cc_awqos           ;
  wire [C_NUM_SLOTS*C_AXI_AWUSER_WIDTH-1:0]       us_cc_awuser          ;
  wire [C_NUM_SLOTS-1:0]                          us_cc_awvalid         ;
  wire [C_NUM_SLOTS-1:0]                          us_cc_awready         ;
  wire [C_NUM_SLOTS*C_AXI_DATA_MAX_WIDTH-1:0]     us_cc_wdata           ;
  wire [C_NUM_SLOTS*C_AXI_DATA_MAX_WIDTH/8-1:0]   us_cc_wstrb           ;
  wire [C_NUM_SLOTS-1:0]                          us_cc_wlast           ;
  wire [C_NUM_SLOTS*C_AXI_WUSER_WIDTH-1:0]        us_cc_wuser           ;
  wire [C_NUM_SLOTS-1:0]                          us_cc_wvalid          ;
  wire [C_NUM_SLOTS-1:0]                          us_cc_wready          ;
  wire [C_NUM_SLOTS*C_AXI_ID_MAX_WIDTH-1:0]           us_cc_bid             ;
  wire [C_NUM_SLOTS*2-1:0]                        us_cc_bresp           ;
  wire [C_NUM_SLOTS*C_AXI_BUSER_WIDTH-1:0]        us_cc_buser           ;
  wire [C_NUM_SLOTS-1:0]                          us_cc_bvalid          ;
  wire [C_NUM_SLOTS-1:0]                          us_cc_bready          ;
  wire [C_NUM_SLOTS*C_AXI_ID_MAX_WIDTH-1:0]           us_cc_arid            ;
  wire [C_NUM_SLOTS*C_AXI_ADDR_WIDTH-1:0]         us_cc_araddr          ;
  wire [C_NUM_SLOTS*8-1:0]                        us_cc_arlen           ;
  wire [C_NUM_SLOTS*3-1:0]                        us_cc_arsize          ;
  wire [C_NUM_SLOTS*2-1:0]                        us_cc_arburst         ;
  wire [C_NUM_SLOTS*2-1:0]                        us_cc_arlock          ;
  wire [C_NUM_SLOTS*4-1:0]                        us_cc_arcache         ;
  wire [C_NUM_SLOTS*3-1:0]                        us_cc_arprot          ;
  wire [C_NUM_SLOTS*4-1:0]                        us_cc_arregion        ;
  wire [C_NUM_SLOTS*4-1:0]                        us_cc_arqos           ;
  wire [C_NUM_SLOTS*C_AXI_ARUSER_WIDTH-1:0]       us_cc_aruser          ;
  wire [C_NUM_SLOTS-1:0]                          us_cc_arvalid         ;
  wire [C_NUM_SLOTS-1:0]                          us_cc_arready         ;
  wire [C_NUM_SLOTS*C_AXI_ID_MAX_WIDTH-1:0]           us_cc_rid             ;
  wire [C_NUM_SLOTS*C_AXI_DATA_MAX_WIDTH-1:0]     us_cc_rdata           ;
  wire [C_NUM_SLOTS*2-1:0]                        us_cc_rresp           ;
  wire [C_NUM_SLOTS-1:0]                          us_cc_rlast           ;
  wire [C_NUM_SLOTS*C_AXI_RUSER_WIDTH-1:0]        us_cc_ruser           ;
  wire [C_NUM_SLOTS-1:0]                          us_cc_rvalid          ;
  wire [C_NUM_SLOTS-1:0]                          us_cc_rready          ;
                                                                    
  wire [C_NUM_SLOTS*C_AXI_ID_MAX_WIDTH-1:0]           cc_ds_awid            ;
  wire [C_NUM_SLOTS*C_AXI_ADDR_WIDTH-1:0]         cc_ds_awaddr          ;
  wire [C_NUM_SLOTS*8-1:0]                        cc_ds_awlen           ;
  wire [C_NUM_SLOTS*3-1:0]                        cc_ds_awsize          ;
  wire [C_NUM_SLOTS*2-1:0]                        cc_ds_awburst         ;
  wire [C_NUM_SLOTS*2-1:0]                        cc_ds_awlock          ;
  wire [C_NUM_SLOTS*4-1:0]                        cc_ds_awcache         ;
  wire [C_NUM_SLOTS*3-1:0]                        cc_ds_awprot          ;
  wire [C_NUM_SLOTS*4-1:0]                        cc_ds_awregion        ;
  wire [C_NUM_SLOTS*4-1:0]                        cc_ds_awqos           ;
  wire [C_NUM_SLOTS*C_AXI_AWUSER_WIDTH-1:0]       cc_ds_awuser          ;
  wire [C_NUM_SLOTS-1:0]                          cc_ds_awvalid         ;
  wire [C_NUM_SLOTS-1:0]                          cc_ds_awready         ;
  wire [C_NUM_SLOTS*C_AXI_DATA_MAX_WIDTH-1:0]     cc_ds_wdata           ;
  wire [C_NUM_SLOTS*C_AXI_DATA_MAX_WIDTH/8-1:0]   cc_ds_wstrb           ;
  wire [C_NUM_SLOTS-1:0]                          cc_ds_wlast           ;
  wire [C_NUM_SLOTS*C_AXI_WUSER_WIDTH-1:0]        cc_ds_wuser           ;
  wire [C_NUM_SLOTS-1:0]                          cc_ds_wvalid          ;
  wire [C_NUM_SLOTS-1:0]                          cc_ds_wready          ;
  wire [C_NUM_SLOTS*C_AXI_ID_MAX_WIDTH-1:0]           cc_ds_bid             ;
  wire [C_NUM_SLOTS*2-1:0]                        cc_ds_bresp           ;
  wire [C_NUM_SLOTS*C_AXI_BUSER_WIDTH-1:0]        cc_ds_buser           ;
  wire [C_NUM_SLOTS-1:0]                          cc_ds_bvalid          ;
  wire [C_NUM_SLOTS-1:0]                          cc_ds_bready          ;
  wire [C_NUM_SLOTS*C_AXI_ID_MAX_WIDTH-1:0]           cc_ds_arid            ;
  wire [C_NUM_SLOTS*C_AXI_ADDR_WIDTH-1:0]         cc_ds_araddr          ;
  wire [C_NUM_SLOTS*8-1:0]                        cc_ds_arlen           ;
  wire [C_NUM_SLOTS*3-1:0]                        cc_ds_arsize          ;
  wire [C_NUM_SLOTS*2-1:0]                        cc_ds_arburst         ;
  wire [C_NUM_SLOTS*2-1:0]                        cc_ds_arlock          ;
  wire [C_NUM_SLOTS*4-1:0]                        cc_ds_arcache         ;
  wire [C_NUM_SLOTS*3-1:0]                        cc_ds_arprot          ;
  wire [C_NUM_SLOTS*4-1:0]                        cc_ds_arregion        ;
  wire [C_NUM_SLOTS*4-1:0]                        cc_ds_arqos           ;
  wire [C_NUM_SLOTS*C_AXI_ARUSER_WIDTH-1:0]       cc_ds_aruser          ;
  wire [C_NUM_SLOTS-1:0]                          cc_ds_arvalid         ;
  wire [C_NUM_SLOTS-1:0]                          cc_ds_arready         ;
  wire [C_NUM_SLOTS*C_AXI_ID_MAX_WIDTH-1:0]           cc_ds_rid             ;
  wire [C_NUM_SLOTS*C_AXI_DATA_MAX_WIDTH-1:0]     cc_ds_rdata           ;
  wire [C_NUM_SLOTS*2-1:0]                        cc_ds_rresp           ;
  wire [C_NUM_SLOTS-1:0]                          cc_ds_rlast           ;
  wire [C_NUM_SLOTS*C_AXI_RUSER_WIDTH-1:0]        cc_ds_ruser           ;
  wire [C_NUM_SLOTS-1:0]                          cc_ds_rvalid          ;
  wire [C_NUM_SLOTS-1:0]                          cc_ds_rready          ;
  
  wire [C_NUM_SLOTS*C_AXI_DATA_MAX_WIDTH-1:0]     ds_mi_wdata           ;
  wire [C_NUM_SLOTS*C_AXI_DATA_MAX_WIDTH/8-1:0]   ds_mi_wstrb           ;
  wire [C_NUM_SLOTS*C_AXI_ID_MAX_WIDTH-1:0]       ds_mi_awid           ;
  wire [C_NUM_SLOTS*C_AXI_ID_MAX_WIDTH-1:0]       ds_mi_arid           ;
  
  wire [C_NUM_SLOTS-1:0]                          s_axi_reset_out_n_i;
  wire [C_NUM_SLOTS-1:0]                          m_axi_reset_out_n_i;
  wire [C_NUM_SLOTS-1:0]                          interconnect_reset_out_n_i;  // Only [0] is used
  
  genvar slot;
  
  assign INTERCONNECT_RESET_OUT_N = interconnect_reset_out_n_i[0];
  assign S_AXI_RESET_OUT_N        = s_axi_reset_out_n_i;
  assign M_AXI_RESET_OUT_N        = m_axi_reset_out_n_i;

generate
  for (slot=0;slot<C_NUM_SLOTS;slot=slot+1) begin : gen_conv_slot
    if (C_S_AXI_DATA_WIDTH[slot*32+:32] < C_M_AXI_DATA_WIDTH[slot*32+:32]) begin :  gen_upsizer
  axi_interconnect_v1_7_13_axi_upsizer #
        (
          .C_FAMILY                         (C_FAMILY),
          .C_AXI_ID_WIDTH                   (C_AXI_ID_WIDTH[slot*32+:32]),
          .C_AXI_ADDR_WIDTH                 (C_AXI_ADDR_WIDTH),
          .C_S_AXI_DATA_WIDTH               (C_S_AXI_DATA_WIDTH[slot*32+:32]),
          .C_M_AXI_DATA_WIDTH               (C_M_AXI_DATA_WIDTH[slot*32+:32]),
          .C_AXI_SUPPORTS_USER_SIGNALS      (C_AXI_SUPPORTS_USER_SIGNALS),
          .C_AXI_AWUSER_WIDTH               (C_AXI_AWUSER_WIDTH),
          .C_AXI_ARUSER_WIDTH               (C_AXI_ARUSER_WIDTH),
          .C_AXI_WUSER_WIDTH                (C_AXI_WUSER_WIDTH),
          .C_AXI_RUSER_WIDTH                (C_AXI_RUSER_WIDTH),
          .C_AXI_BUSER_WIDTH                (C_AXI_BUSER_WIDTH),
          .C_AXI_SUPPORTS_WRITE             (C_AXI_SUPPORTS_WRITE[slot]),
          .C_AXI_SUPPORTS_READ              (C_AXI_SUPPORTS_READ[slot]),
          .C_M_AXI_AW_REGISTER              (1),
          .C_M_AXI_AR_REGISTER              (1),
          .C_M_AXI_W_REGISTER               (P_LIGHTWT),
          .C_M_AXI_R_REGISTER               ((C_AXI_PROTOCOL[slot*32+:32] != P_AXILITE)? P_FULLY_REG : P_LIGHTWT),
          .C_PACKING_LEVEL                  (P_CONDITIONAL_PACK),
          .C_SUPPORT_BURSTS                 (C_AXI_PROTOCOL[slot*32+:32] != P_AXILITE),
          .C_SINGLE_THREAD                  (1)
        )
        upsizer_inst 
        (
          .ARESETN                          ((C_HEMISPHERE=="mi")? LOCAL_ARESETN : s_axi_reset_out_n_i[slot]),
          .ACLK                             (S_AXI_ACLK[slot]),
          .S_AXI_AWID                       (S_AXI_AWID[slot*C_AXI_ID_MAX_WIDTH+:C_AXI_ID_WIDTH[slot*32+:32]]),
          .S_AXI_AWADDR                     (S_AXI_AWADDR[slot*C_AXI_ADDR_WIDTH+:C_AXI_ADDR_WIDTH]),
          .S_AXI_AWLEN                      (S_AXI_AWLEN[slot*8+:8]),
          .S_AXI_AWSIZE                     (S_AXI_AWSIZE[slot*3+:3]),
          .S_AXI_AWBURST                    (S_AXI_AWBURST[slot*2+:2]),
          .S_AXI_AWLOCK                     (S_AXI_AWLOCK[slot*2+:2]),
          .S_AXI_AWCACHE                    (S_AXI_AWCACHE[slot*4+:4]),
          .S_AXI_AWPROT                     (S_AXI_AWPROT[slot*3+:3]),
          .S_AXI_AWREGION                   (S_AXI_AWREGION[slot*4+:4]),
          .S_AXI_AWQOS                      (S_AXI_AWQOS[slot*4+:4]),
          .S_AXI_AWUSER                     (S_AXI_AWUSER[slot*C_AXI_AWUSER_WIDTH+:C_AXI_AWUSER_WIDTH]),
          .S_AXI_AWVALID                    (S_AXI_AWVALID[slot*1+:1]),
          .S_AXI_AWREADY                    (S_AXI_AWREADY[slot*1+:1]),
          .S_AXI_WDATA                      (S_AXI_WDATA[slot*C_AXI_DATA_MAX_WIDTH+:C_S_AXI_DATA_WIDTH[slot*32+:32]]),
          .S_AXI_WSTRB                      (S_AXI_WSTRB[slot*C_AXI_DATA_MAX_WIDTH/8+:C_S_AXI_DATA_WIDTH[slot*32+:32]/8]),
          .S_AXI_WLAST                      (S_AXI_WLAST[slot*1+:1]),
          .S_AXI_WUSER                      (S_AXI_WUSER[slot*C_AXI_WUSER_WIDTH+:C_AXI_WUSER_WIDTH]),
          .S_AXI_WVALID                     (S_AXI_WVALID[slot*1+:1]),
          .S_AXI_WREADY                     (S_AXI_WREADY[slot*1+:1]),
          .S_AXI_BID                        (si_us_bid[slot*C_AXI_ID_MAX_WIDTH+:C_AXI_ID_WIDTH[slot*32+:32]]),
          .S_AXI_BRESP                      (S_AXI_BRESP[slot*2+:2]),
          .S_AXI_BUSER                      (S_AXI_BUSER[slot*C_AXI_BUSER_WIDTH+:C_AXI_BUSER_WIDTH]),
          .S_AXI_BVALID                     (S_AXI_BVALID[slot*1+:1]),
          .S_AXI_BREADY                     (S_AXI_BREADY[slot*1+:1]),
          .S_AXI_ARID                       (S_AXI_ARID[slot*C_AXI_ID_MAX_WIDTH+:C_AXI_ID_WIDTH[slot*32+:32]]),
          .S_AXI_ARADDR                     (S_AXI_ARADDR[slot*C_AXI_ADDR_WIDTH+:C_AXI_ADDR_WIDTH]),
          .S_AXI_ARLEN                      (S_AXI_ARLEN[slot*8+:8]),
          .S_AXI_ARSIZE                     (S_AXI_ARSIZE[slot*3+:3]),
          .S_AXI_ARBURST                    (S_AXI_ARBURST[slot*2+:2]),
          .S_AXI_ARLOCK                     (S_AXI_ARLOCK[slot*2+:2]),
          .S_AXI_ARCACHE                    (S_AXI_ARCACHE[slot*4+:4]),
          .S_AXI_ARPROT                     (S_AXI_ARPROT[slot*3+:3]),
          .S_AXI_ARREGION                   (S_AXI_ARREGION[slot*4+:4]),
          .S_AXI_ARQOS                      (S_AXI_ARQOS[slot*4+:4]),
          .S_AXI_ARUSER                     (S_AXI_ARUSER[slot*C_AXI_ARUSER_WIDTH+:C_AXI_ARUSER_WIDTH]),
          .S_AXI_ARVALID                    (S_AXI_ARVALID[slot*1+:1]),
          .S_AXI_ARREADY                    (S_AXI_ARREADY[slot*1+:1]),
          .S_AXI_RID                        (si_us_rid[slot*C_AXI_ID_MAX_WIDTH+:C_AXI_ID_WIDTH[slot*32+:32]]),
          .S_AXI_RDATA                      (si_us_rdata[slot*C_AXI_DATA_MAX_WIDTH+:C_S_AXI_DATA_WIDTH[slot*32+:32]]),
          .S_AXI_RRESP                      (S_AXI_RRESP[slot*2+:2]),
          .S_AXI_RLAST                      (S_AXI_RLAST[slot*1+:1]),
          .S_AXI_RUSER                      (S_AXI_RUSER[slot*C_AXI_RUSER_WIDTH+:C_AXI_RUSER_WIDTH]),
          .S_AXI_RVALID                     (S_AXI_RVALID[slot*1+:1]),
          .S_AXI_RREADY                     (S_AXI_RREADY[slot*1+:1]),
          .M_AXI_AWID                       (us_cc_awid[slot*C_AXI_ID_MAX_WIDTH+:C_AXI_ID_WIDTH[slot*32+:32]]),
          .M_AXI_AWADDR                     (us_cc_awaddr[slot*C_AXI_ADDR_WIDTH+:C_AXI_ADDR_WIDTH]),
          .M_AXI_AWLEN                      (us_cc_awlen[slot*8+:8]),
          .M_AXI_AWSIZE                     (us_cc_awsize[slot*3+:3]),
          .M_AXI_AWBURST                    (us_cc_awburst[slot*2+:2]),
          .M_AXI_AWLOCK                     (us_cc_awlock[slot*2+:2]),
          .M_AXI_AWCACHE                    (us_cc_awcache[slot*4+:4]),
          .M_AXI_AWPROT                     (us_cc_awprot[slot*3+:3]),
          .M_AXI_AWREGION                   (us_cc_awregion[slot*4+:4]),
          .M_AXI_AWQOS                      (us_cc_awqos[slot*4+:4]),
          .M_AXI_AWUSER                     (us_cc_awuser[slot*C_AXI_AWUSER_WIDTH+:C_AXI_AWUSER_WIDTH]),
          .M_AXI_AWVALID                    (us_cc_awvalid[slot*1+:1]),
          .M_AXI_AWREADY                    (us_cc_awready[slot*1+:1]),
          .M_AXI_WDATA                      (us_cc_wdata[slot*C_AXI_DATA_MAX_WIDTH+:C_M_AXI_DATA_WIDTH[slot*32+:32]]),
          .M_AXI_WSTRB                      (us_cc_wstrb[slot*C_AXI_DATA_MAX_WIDTH/8+:C_M_AXI_DATA_WIDTH[slot*32+:32]/8]),
          .M_AXI_WLAST                      (us_cc_wlast[slot*1+:1]),
          .M_AXI_WUSER                      (us_cc_wuser[slot*C_AXI_WUSER_WIDTH+:C_AXI_WUSER_WIDTH]),
          .M_AXI_WVALID                     (us_cc_wvalid[slot*1+:1]),
          .M_AXI_WREADY                     (us_cc_wready[slot*1+:1]),
          .M_AXI_BID                        (us_cc_bid[slot*C_AXI_ID_MAX_WIDTH+:C_AXI_ID_WIDTH[slot*32+:32]]),
          .M_AXI_BRESP                      (us_cc_bresp[slot*2+:2]),
          .M_AXI_BUSER                      (us_cc_buser[slot*C_AXI_BUSER_WIDTH+:C_AXI_BUSER_WIDTH]),
          .M_AXI_BVALID                     (us_cc_bvalid[slot*1+:1]),
          .M_AXI_BREADY                     (us_cc_bready[slot*1+:1]),
          .M_AXI_ARID                       (us_cc_arid[slot*C_AXI_ID_MAX_WIDTH+:C_AXI_ID_WIDTH[slot*32+:32]]),
          .M_AXI_ARADDR                     (us_cc_araddr[slot*C_AXI_ADDR_WIDTH+:C_AXI_ADDR_WIDTH]),
          .M_AXI_ARLEN                      (us_cc_arlen[slot*8+:8]),
          .M_AXI_ARSIZE                     (us_cc_arsize[slot*3+:3]),
          .M_AXI_ARBURST                    (us_cc_arburst[slot*2+:2]),
          .M_AXI_ARLOCK                     (us_cc_arlock[slot*2+:2]),
          .M_AXI_ARCACHE                    (us_cc_arcache[slot*4+:4]),
          .M_AXI_ARPROT                     (us_cc_arprot[slot*3+:3]),
          .M_AXI_ARREGION                   (us_cc_arregion[slot*4+:4]),
          .M_AXI_ARQOS                      (us_cc_arqos[slot*4+:4]),
          .M_AXI_ARUSER                     (us_cc_aruser[slot*C_AXI_ARUSER_WIDTH+:C_AXI_ARUSER_WIDTH]),
          .M_AXI_ARVALID                    (us_cc_arvalid[slot*1+:1]),
          .M_AXI_ARREADY                    (us_cc_arready[slot*1+:1]),
          .M_AXI_RID                        (us_cc_rid[slot*C_AXI_ID_MAX_WIDTH+:C_AXI_ID_WIDTH[slot*32+:32]]),
          .M_AXI_RDATA                      (us_cc_rdata[slot*C_AXI_DATA_MAX_WIDTH+:C_M_AXI_DATA_WIDTH[slot*32+:32]]),
          .M_AXI_RRESP                      (us_cc_rresp[slot*2+:2]),
          .M_AXI_RLAST                      (us_cc_rlast[slot*1+:1]),
          .M_AXI_RUSER                      (us_cc_ruser[slot*C_AXI_RUSER_WIDTH+:C_AXI_RUSER_WIDTH]),
          .M_AXI_RVALID                     (us_cc_rvalid[slot*1+:1]),
          .M_AXI_RREADY                     (us_cc_rready[slot*1+:1])
        );
      assign S_AXI_RDATA[slot*C_AXI_DATA_MAX_WIDTH+:C_AXI_DATA_MAX_WIDTH] = si_us_rdata[slot*C_AXI_DATA_MAX_WIDTH+:C_S_AXI_DATA_WIDTH[slot*32+:32]];
      assign S_AXI_BID[slot*C_AXI_ID_MAX_WIDTH+:C_AXI_ID_MAX_WIDTH] = si_us_bid[slot*C_AXI_ID_MAX_WIDTH+:C_AXI_ID_WIDTH[slot*32+:32]];
      assign S_AXI_RID[slot*C_AXI_ID_MAX_WIDTH+:C_AXI_ID_MAX_WIDTH] = si_us_rid[slot*C_AXI_ID_MAX_WIDTH+:C_AXI_ID_WIDTH[slot*32+:32]];
    end else begin :gen_no_upsizer
      assign us_cc_awid[slot*C_AXI_ID_MAX_WIDTH+:C_AXI_ID_MAX_WIDTH]                             = S_AXI_AWID[slot*C_AXI_ID_MAX_WIDTH+:C_AXI_ID_WIDTH[slot*32+:32]]                           ;
      assign us_cc_awaddr[slot*C_AXI_ADDR_WIDTH+:C_AXI_ADDR_WIDTH]                       = S_AXI_AWADDR[slot*C_AXI_ADDR_WIDTH+:C_AXI_ADDR_WIDTH]                     ;
      assign us_cc_awlen[slot*8+:8]                                                      = S_AXI_AWLEN[slot*8+:8]                                                    ;
      assign us_cc_awsize[slot*3+:3]                                                     = S_AXI_AWSIZE[slot*3+:3]                                                   ;
      assign us_cc_awburst[slot*2+:2]                                                    = S_AXI_AWBURST[slot*2+:2]                                                  ;
      assign us_cc_awlock[slot*2+:2]                                                     = S_AXI_AWLOCK[slot*2+:2]                                                   ;
      assign us_cc_awcache[slot*4+:4]                                                    = S_AXI_AWCACHE[slot*4+:4]                                                  ;
      assign us_cc_awprot[slot*3+:3]                                                     = S_AXI_AWPROT[slot*3+:3]                                                   ;
      assign us_cc_awregion[slot*4+:4]                                                   = S_AXI_AWREGION[slot*4+:4]                                                 ;
      assign us_cc_awqos[slot*4+:4]                                                      = S_AXI_AWQOS[slot*4+:4]                                                    ;
      assign us_cc_awuser[slot*C_AXI_AWUSER_WIDTH+:C_AXI_AWUSER_WIDTH]                   = S_AXI_AWUSER[slot*C_AXI_AWUSER_WIDTH+:C_AXI_AWUSER_WIDTH]                 ;
      assign us_cc_awvalid[slot*1+:1]                                                    = S_AXI_AWVALID[slot*1+:1]                                                  ;

      assign us_cc_wdata[slot*C_AXI_DATA_MAX_WIDTH+:C_S_AXI_DATA_WIDTH[slot*32+:32]]     = S_AXI_WDATA[slot*C_AXI_DATA_MAX_WIDTH+:C_S_AXI_DATA_WIDTH[slot*32+:32]]     ;
      assign us_cc_wstrb[slot*C_AXI_DATA_MAX_WIDTH/8+:C_S_AXI_DATA_WIDTH[slot*32+:32]/8] = S_AXI_WSTRB[slot*C_AXI_DATA_MAX_WIDTH/8+:C_S_AXI_DATA_WIDTH[slot*32+:32]/8] ;
      assign us_cc_wlast[slot*1+:1]                                                      = S_AXI_WLAST[slot*1+:1]                                                    ;
      assign us_cc_wuser[slot*C_AXI_WUSER_WIDTH+:C_AXI_WUSER_WIDTH]                      = S_AXI_WUSER[slot*C_AXI_WUSER_WIDTH+:C_AXI_WUSER_WIDTH]                    ;
      assign us_cc_wvalid[slot*1+:1]                                                     = S_AXI_WVALID[slot*1+:1]                                                   ;
      assign us_cc_bready[slot*1+:1]                                                     = S_AXI_BREADY[slot*1+:1]                                                   ;
      assign us_cc_arid[slot*C_AXI_ID_MAX_WIDTH+:C_AXI_ID_MAX_WIDTH]                             = S_AXI_ARID[slot*C_AXI_ID_MAX_WIDTH+:C_AXI_ID_WIDTH[slot*32+:32]]                           ;
      assign us_cc_araddr[slot*C_AXI_ADDR_WIDTH+:C_AXI_ADDR_WIDTH]                       = S_AXI_ARADDR[slot*C_AXI_ADDR_WIDTH+:C_AXI_ADDR_WIDTH]                     ;
      assign us_cc_arlen[slot*8+:8]                                                      = S_AXI_ARLEN[slot*8+:8]                                                    ;
      assign us_cc_arsize[slot*3+:3]                                                     = S_AXI_ARSIZE[slot*3+:3]                                                   ;
      assign us_cc_arburst[slot*2+:2]                                                    = S_AXI_ARBURST[slot*2+:2]                                                  ;
      assign us_cc_arlock[slot*2+:2]                                                     = S_AXI_ARLOCK[slot*2+:2]                                                   ;
      assign us_cc_arcache[slot*4+:4]                                                    = S_AXI_ARCACHE[slot*4+:4]                                                  ;
      assign us_cc_arprot[slot*3+:3]                                                     = S_AXI_ARPROT[slot*3+:3]                                                   ;
      assign us_cc_arregion[slot*4+:4]                                                   = S_AXI_ARREGION[slot*4+:4]                                                 ;
      assign us_cc_arqos[slot*4+:4]                                                      = S_AXI_ARQOS[slot*4+:4]                                                    ;
      assign us_cc_aruser[slot*C_AXI_ARUSER_WIDTH+:C_AXI_ARUSER_WIDTH]                   = S_AXI_ARUSER[slot*C_AXI_ARUSER_WIDTH+:C_AXI_ARUSER_WIDTH]                 ;
      assign us_cc_arvalid[slot*1+:1]                                                    = S_AXI_ARVALID[slot*1+:1]                                                  ;
      assign us_cc_rready[slot*1+:1]                                                     = S_AXI_RREADY[slot*1+:1]                                                   ;
      
      assign S_AXI_AWREADY[slot*1+:1]                                                    = us_cc_awready[slot*1+:1]                                                  ;
      assign S_AXI_WREADY[slot*1+:1]                                                     = us_cc_wready[slot*1+:1]                                                   ;
      assign S_AXI_BID[slot*C_AXI_ID_MAX_WIDTH+:C_AXI_ID_MAX_WIDTH]                              = us_cc_bid[slot*C_AXI_ID_MAX_WIDTH+:C_AXI_ID_WIDTH[slot*32+:32]]                            ;
      assign S_AXI_BRESP[slot*2+:2]                                                      = us_cc_bresp[slot*2+:2]                                                    ;
      assign S_AXI_BUSER[slot*C_AXI_BUSER_WIDTH+:C_AXI_BUSER_WIDTH]                      = us_cc_buser[slot*C_AXI_BUSER_WIDTH+:C_AXI_BUSER_WIDTH]                    ;
      assign S_AXI_BVALID[slot*1+:1]                                                     = us_cc_bvalid[slot*1+:1]                                                   ;
      assign S_AXI_ARREADY[slot*1+:1]                                                    = us_cc_arready[slot*1+:1]                                                  ;
      assign S_AXI_RID[slot*C_AXI_ID_MAX_WIDTH+:C_AXI_ID_MAX_WIDTH]                              = us_cc_rid[slot*C_AXI_ID_MAX_WIDTH+:C_AXI_ID_WIDTH[slot*32+:32]]                            ;
      assign S_AXI_RDATA[slot*C_AXI_DATA_MAX_WIDTH+:C_AXI_DATA_MAX_WIDTH]     = us_cc_rdata[slot*C_AXI_DATA_MAX_WIDTH+:C_S_AXI_DATA_WIDTH[slot*32+:32]]     ;
      assign S_AXI_RRESP[slot*2+:2]                                                      = us_cc_rresp[slot*2+:2]                                                    ;
      assign S_AXI_RLAST[slot*1+:1]                                                      = us_cc_rlast[slot*1+:1]                                                    ;
      assign S_AXI_RUSER[slot*C_AXI_RUSER_WIDTH+:C_AXI_RUSER_WIDTH]                      = us_cc_ruser[slot*C_AXI_RUSER_WIDTH+:C_AXI_RUSER_WIDTH]                    ;
      assign S_AXI_RVALID[slot*1+:1]                                                     = us_cc_rvalid[slot*1+:1]                                                   ;
    end
    
  axi_interconnect_v1_7_13_axi_clock_converter #
        (
          .C_FAMILY                         (C_FAMILY),
          .C_AXI_ID_WIDTH                   (C_AXI_ID_WIDTH[slot*32+:32]),
          .C_AXI_ADDR_WIDTH                 (C_AXI_ADDR_WIDTH),
          .C_AXI_DATA_WIDTH                 (f_cc_data_width(slot)),
          .C_AXI_IS_ACLK_ASYNC            (C_AXI_IS_ACLK_ASYNC[slot]),
          .C_S_AXI_ACLK_RATIO               (C_S_AXI_ACLK_RATIO[slot*32+:32]),
          .C_M_AXI_ACLK_RATIO               (C_M_AXI_ACLK_RATIO[slot*32+:32]),
          .C_AXI_PROTOCOL                   (C_AXI_PROTOCOL[slot*32+:32]),
          .C_AXI_SUPPORTS_WRITE           (C_AXI_SUPPORTS_WRITE[slot]),
          .C_AXI_SUPPORTS_READ            (C_AXI_SUPPORTS_READ[slot]),
          .C_AXI_SUPPORTS_USER_SIGNALS      (C_AXI_SUPPORTS_USER_SIGNALS),
          .C_AXI_AWUSER_WIDTH               (C_AXI_AWUSER_WIDTH),
          .C_AXI_ARUSER_WIDTH               (C_AXI_ARUSER_WIDTH),
          .C_AXI_WUSER_WIDTH                (C_AXI_WUSER_WIDTH),
          .C_AXI_RUSER_WIDTH                (C_AXI_RUSER_WIDTH),
          .C_AXI_BUSER_WIDTH                (C_AXI_BUSER_WIDTH),
          .C_SYNCHRONIZER_STAGE             (C_SYNCHRONIZER_STAGE)
        )
        clock_conv_inst 
        (
          .INTERCONNECT_ACLK                (INTERCONNECT_ACLK),
          .INTERCONNECT_ARESETN             (INTERCONNECT_ARESETN),
          .LOCAL_ARESETN                    (LOCAL_ARESETN),
          .INTERCONNECT_RESET_OUT_N         (interconnect_reset_out_n_i[slot]),
          .S_AXI_RESET_OUT_N                (s_axi_reset_out_n_i[slot]),
          .M_AXI_RESET_OUT_N                (m_axi_reset_out_n_i[slot]),
          .S_AXI_ACLK                       (S_AXI_ACLK[slot]),
          .S_AXI_AWID                       (us_cc_awid[slot*C_AXI_ID_MAX_WIDTH+:C_AXI_ID_WIDTH[slot*32+:32]]),
          .S_AXI_AWADDR                     (us_cc_awaddr[slot*C_AXI_ADDR_WIDTH+:C_AXI_ADDR_WIDTH]),
          .S_AXI_AWLEN                      (us_cc_awlen[slot*8+:8]),
          .S_AXI_AWSIZE                     (us_cc_awsize[slot*3+:3]),
          .S_AXI_AWBURST                    (us_cc_awburst[slot*2+:2]),
          .S_AXI_AWLOCK                     (us_cc_awlock[slot*2+:2]),
          .S_AXI_AWCACHE                    (us_cc_awcache[slot*4+:4]),
          .S_AXI_AWPROT                     (us_cc_awprot[slot*3+:3]),
          .S_AXI_AWREGION                   (us_cc_awregion[slot*4+:4]),
          .S_AXI_AWQOS                      (us_cc_awqos[slot*4+:4]),
          .S_AXI_AWUSER                     (us_cc_awuser[slot*C_AXI_AWUSER_WIDTH+:C_AXI_AWUSER_WIDTH]),
          .S_AXI_AWVALID                    (us_cc_awvalid[slot*1+:1]),
          .S_AXI_AWREADY                    (us_cc_awready[slot*1+:1]),
          .S_AXI_WDATA                      (us_cc_wdata[slot*C_AXI_DATA_MAX_WIDTH+:f_cc_data_width(slot)]),
          .S_AXI_WSTRB                      (us_cc_wstrb[slot*C_AXI_DATA_MAX_WIDTH/8+:f_cc_data_width(slot)/8]),
          .S_AXI_WLAST                      (us_cc_wlast[slot*1+:1]),
          .S_AXI_WUSER                      (us_cc_wuser[slot*C_AXI_WUSER_WIDTH+:C_AXI_WUSER_WIDTH]),
          .S_AXI_WVALID                     (us_cc_wvalid[slot*1+:1]),
          .S_AXI_WREADY                     (us_cc_wready[slot*1+:1]),
          .S_AXI_BID                        (us_cc_bid[slot*C_AXI_ID_MAX_WIDTH+:C_AXI_ID_WIDTH[slot*32+:32]]),
          .S_AXI_BRESP                      (us_cc_bresp[slot*2+:2]),
          .S_AXI_BUSER                      (us_cc_buser[slot*C_AXI_BUSER_WIDTH+:C_AXI_BUSER_WIDTH]),
          .S_AXI_BVALID                     (us_cc_bvalid[slot*1+:1]),
          .S_AXI_BREADY                     (us_cc_bready[slot*1+:1]),
          .S_AXI_ARID                       (us_cc_arid[slot*C_AXI_ID_MAX_WIDTH+:C_AXI_ID_WIDTH[slot*32+:32]]),
          .S_AXI_ARADDR                     (us_cc_araddr[slot*C_AXI_ADDR_WIDTH+:C_AXI_ADDR_WIDTH]),
          .S_AXI_ARLEN                      (us_cc_arlen[slot*8+:8]),
          .S_AXI_ARSIZE                     (us_cc_arsize[slot*3+:3]),
          .S_AXI_ARBURST                    (us_cc_arburst[slot*2+:2]),
          .S_AXI_ARLOCK                     (us_cc_arlock[slot*2+:2]),
          .S_AXI_ARCACHE                    (us_cc_arcache[slot*4+:4]),
          .S_AXI_ARPROT                     (us_cc_arprot[slot*3+:3]),
          .S_AXI_ARREGION                   (us_cc_arregion[slot*4+:4]),
          .S_AXI_ARQOS                      (us_cc_arqos[slot*4+:4]),
          .S_AXI_ARUSER                     (us_cc_aruser[slot*C_AXI_ARUSER_WIDTH+:C_AXI_ARUSER_WIDTH]),
          .S_AXI_ARVALID                    (us_cc_arvalid[slot*1+:1]),
          .S_AXI_ARREADY                    (us_cc_arready[slot*1+:1]),
          .S_AXI_RID                        (us_cc_rid[slot*C_AXI_ID_MAX_WIDTH+:C_AXI_ID_WIDTH[slot*32+:32]]),
          .S_AXI_RDATA                      (us_cc_rdata[slot*C_AXI_DATA_MAX_WIDTH+:f_cc_data_width(slot)]),
          .S_AXI_RRESP                      (us_cc_rresp[slot*2+:2]),
          .S_AXI_RLAST                      (us_cc_rlast[slot*1+:1]),
          .S_AXI_RUSER                      (us_cc_ruser[slot*C_AXI_RUSER_WIDTH+:C_AXI_RUSER_WIDTH]),
          .S_AXI_RVALID                     (us_cc_rvalid[slot*1+:1]),
          .S_AXI_RREADY                     (us_cc_rready[slot*1+:1]),
          .M_AXI_ACLK                       (M_AXI_ACLK[slot]),
          .M_AXI_AWID                       (cc_ds_awid[slot*C_AXI_ID_MAX_WIDTH+:C_AXI_ID_WIDTH[slot*32+:32]]),
          .M_AXI_AWADDR                     (cc_ds_awaddr[slot*C_AXI_ADDR_WIDTH+:C_AXI_ADDR_WIDTH]),
          .M_AXI_AWLEN                      (cc_ds_awlen[slot*8+:8]),
          .M_AXI_AWSIZE                     (cc_ds_awsize[slot*3+:3]),
          .M_AXI_AWBURST                    (cc_ds_awburst[slot*2+:2]),
          .M_AXI_AWLOCK                     (cc_ds_awlock[slot*2+:2]),
          .M_AXI_AWCACHE                    (cc_ds_awcache[slot*4+:4]),
          .M_AXI_AWPROT                     (cc_ds_awprot[slot*3+:3]),
          .M_AXI_AWREGION                   (cc_ds_awregion[slot*4+:4]),
          .M_AXI_AWQOS                      (cc_ds_awqos[slot*4+:4]),
          .M_AXI_AWUSER                     (cc_ds_awuser[slot*C_AXI_AWUSER_WIDTH+:C_AXI_AWUSER_WIDTH]),
          .M_AXI_AWVALID                    (cc_ds_awvalid[slot*1+:1]),
          .M_AXI_AWREADY                    (cc_ds_awready[slot*1+:1]),
          .M_AXI_WDATA                      (cc_ds_wdata[slot*C_AXI_DATA_MAX_WIDTH+:f_cc_data_width(slot)]),
          .M_AXI_WSTRB                      (cc_ds_wstrb[slot*C_AXI_DATA_MAX_WIDTH/8+:f_cc_data_width(slot)/8]),
          .M_AXI_WLAST                      (cc_ds_wlast[slot*1+:1]),
          .M_AXI_WUSER                      (cc_ds_wuser[slot*C_AXI_WUSER_WIDTH+:C_AXI_WUSER_WIDTH]),
          .M_AXI_WVALID                     (cc_ds_wvalid[slot*1+:1]),
          .M_AXI_WREADY                     (cc_ds_wready[slot*1+:1]),
          .M_AXI_BID                        (cc_ds_bid[slot*C_AXI_ID_MAX_WIDTH+:C_AXI_ID_WIDTH[slot*32+:32]]),
          .M_AXI_BRESP                      (cc_ds_bresp[slot*2+:2]),
          .M_AXI_BUSER                      (cc_ds_buser[slot*C_AXI_BUSER_WIDTH+:C_AXI_BUSER_WIDTH]),
          .M_AXI_BVALID                     (cc_ds_bvalid[slot*1+:1]),
          .M_AXI_BREADY                     (cc_ds_bready[slot*1+:1]),
          .M_AXI_ARID                       (cc_ds_arid[slot*C_AXI_ID_MAX_WIDTH+:C_AXI_ID_WIDTH[slot*32+:32]]),
          .M_AXI_ARADDR                     (cc_ds_araddr[slot*C_AXI_ADDR_WIDTH+:C_AXI_ADDR_WIDTH]),
          .M_AXI_ARLEN                      (cc_ds_arlen[slot*8+:8]),
          .M_AXI_ARSIZE                     (cc_ds_arsize[slot*3+:3]),
          .M_AXI_ARBURST                    (cc_ds_arburst[slot*2+:2]),
          .M_AXI_ARLOCK                     (cc_ds_arlock[slot*2+:2]),
          .M_AXI_ARCACHE                    (cc_ds_arcache[slot*4+:4]),
          .M_AXI_ARPROT                     (cc_ds_arprot[slot*3+:3]),
          .M_AXI_ARREGION                   (cc_ds_arregion[slot*4+:4]),
          .M_AXI_ARQOS                      (cc_ds_arqos[slot*4+:4]),
          .M_AXI_ARUSER                     (cc_ds_aruser[slot*C_AXI_ARUSER_WIDTH+:C_AXI_ARUSER_WIDTH]),
          .M_AXI_ARVALID                    (cc_ds_arvalid[slot*1+:1]),
          .M_AXI_ARREADY                    (cc_ds_arready[slot*1+:1]),
          .M_AXI_RID                        (cc_ds_rid[slot*C_AXI_ID_MAX_WIDTH+:C_AXI_ID_WIDTH[slot*32+:32]]),
          .M_AXI_RDATA                      (cc_ds_rdata[slot*C_AXI_DATA_MAX_WIDTH+:f_cc_data_width(slot)]),
          .M_AXI_RRESP                      (cc_ds_rresp[slot*2+:2]),
          .M_AXI_RLAST                      (cc_ds_rlast[slot*1+:1]),
          .M_AXI_RUSER                      (cc_ds_ruser[slot*C_AXI_RUSER_WIDTH+:C_AXI_RUSER_WIDTH]),
          .M_AXI_RVALID                     (cc_ds_rvalid[slot*1+:1]),
          .M_AXI_RREADY                     (cc_ds_rready[slot*1+:1])
        );
    
    if (C_S_AXI_DATA_WIDTH[slot*32+:32] > C_M_AXI_DATA_WIDTH[slot*32+:32]) begin :  gen_downsizer
  axi_interconnect_v1_7_13_axi_downsizer #
        (
          .C_FAMILY                         (C_FAMILY),
          .C_AXI_ID_WIDTH                   (C_AXI_ID_WIDTH[slot*32+:32]),
          .C_AXI_ADDR_WIDTH                 (C_AXI_ADDR_WIDTH),
          .C_S_AXI_DATA_WIDTH               (C_S_AXI_DATA_WIDTH[slot*32+:32]),
          .C_M_AXI_DATA_WIDTH               (C_M_AXI_DATA_WIDTH[slot*32+:32]),
          .C_AXI_SUPPORTS_USER_SIGNALS      (C_AXI_SUPPORTS_USER_SIGNALS),
          .C_AXI_AWUSER_WIDTH               (C_AXI_AWUSER_WIDTH),
          .C_AXI_ARUSER_WIDTH               (C_AXI_ARUSER_WIDTH),
          .C_AXI_WUSER_WIDTH                (C_AXI_WUSER_WIDTH),
          .C_AXI_RUSER_WIDTH                (C_AXI_RUSER_WIDTH),
          .C_AXI_BUSER_WIDTH                (C_AXI_BUSER_WIDTH),
          .C_AXI_SUPPORTS_WRITE             (C_AXI_SUPPORTS_WRITE[slot]),
          .C_AXI_SUPPORTS_READ              (C_AXI_SUPPORTS_READ[slot]),
          .C_SUPPORT_SPLITTING              (C_AXI_PROTOCOL[slot*32+:32] != P_AXILITE),
          .C_SUPPORT_BURSTS                 (C_AXI_PROTOCOL[slot*32+:32] != P_AXILITE),
          .C_SINGLE_THREAD                  (1)
        )
        downsizer_inst 
        (
          .ARESETN                          ((C_HEMISPHERE=="si") ? LOCAL_ARESETN : m_axi_reset_out_n_i[slot]),
          .ACLK                             (M_AXI_ACLK[slot]),
          .S_AXI_AWID                       (cc_ds_awid[slot*C_AXI_ID_MAX_WIDTH+:C_AXI_ID_WIDTH[slot*32+:32]]),
          .S_AXI_AWADDR                     (cc_ds_awaddr[slot*C_AXI_ADDR_WIDTH+:C_AXI_ADDR_WIDTH]),
          .S_AXI_AWLEN                      (cc_ds_awlen[slot*8+:8]),
          .S_AXI_AWSIZE                     (cc_ds_awsize[slot*3+:3]),
          .S_AXI_AWBURST                    (cc_ds_awburst[slot*2+:2]),
          .S_AXI_AWLOCK                     (cc_ds_awlock[slot*2+:2]),
          .S_AXI_AWCACHE                    (cc_ds_awcache[slot*4+:4]),
          .S_AXI_AWPROT                     (cc_ds_awprot[slot*3+:3]),
          .S_AXI_AWREGION                   (cc_ds_awregion[slot*4+:4]),
          .S_AXI_AWQOS                      (cc_ds_awqos[slot*4+:4]),
          .S_AXI_AWUSER                     (cc_ds_awuser[slot*C_AXI_AWUSER_WIDTH+:C_AXI_AWUSER_WIDTH]),
          .S_AXI_AWVALID                    (cc_ds_awvalid[slot*1+:1]),
          .S_AXI_AWREADY                    (cc_ds_awready[slot*1+:1]),
          .S_AXI_WDATA                      (cc_ds_wdata[slot*C_AXI_DATA_MAX_WIDTH+:C_S_AXI_DATA_WIDTH[slot*32+:32]]),
          .S_AXI_WSTRB                      (cc_ds_wstrb[slot*C_AXI_DATA_MAX_WIDTH/8+:C_S_AXI_DATA_WIDTH[slot*32+:32]/8]),
          .S_AXI_WLAST                      (cc_ds_wlast[slot*1+:1]),
          .S_AXI_WUSER                      (cc_ds_wuser[slot*C_AXI_WUSER_WIDTH+:C_AXI_WUSER_WIDTH]),
          .S_AXI_WVALID                     (cc_ds_wvalid[slot*1+:1]),
          .S_AXI_WREADY                     (cc_ds_wready[slot*1+:1]),
          .S_AXI_BID                        (cc_ds_bid[slot*C_AXI_ID_MAX_WIDTH+:C_AXI_ID_WIDTH[slot*32+:32]]),
          .S_AXI_BRESP                      (cc_ds_bresp[slot*2+:2]),
          .S_AXI_BUSER                      (cc_ds_buser[slot*C_AXI_BUSER_WIDTH+:C_AXI_BUSER_WIDTH]),
          .S_AXI_BVALID                     (cc_ds_bvalid[slot*1+:1]),
          .S_AXI_BREADY                     (cc_ds_bready[slot*1+:1]),
          .S_AXI_ARID                       (cc_ds_arid[slot*C_AXI_ID_MAX_WIDTH+:C_AXI_ID_WIDTH[slot*32+:32]]),
          .S_AXI_ARADDR                     (cc_ds_araddr[slot*C_AXI_ADDR_WIDTH+:C_AXI_ADDR_WIDTH]),
          .S_AXI_ARLEN                      (cc_ds_arlen[slot*8+:8]),
          .S_AXI_ARSIZE                     (cc_ds_arsize[slot*3+:3]),
          .S_AXI_ARBURST                    (cc_ds_arburst[slot*2+:2]),
          .S_AXI_ARLOCK                     (cc_ds_arlock[slot*2+:2]),
          .S_AXI_ARCACHE                    (cc_ds_arcache[slot*4+:4]),
          .S_AXI_ARPROT                     (cc_ds_arprot[slot*3+:3]),
          .S_AXI_ARREGION                   (cc_ds_arregion[slot*4+:4]),
          .S_AXI_ARQOS                      (cc_ds_arqos[slot*4+:4]),
          .S_AXI_ARUSER                     (cc_ds_aruser[slot*C_AXI_ARUSER_WIDTH+:C_AXI_ARUSER_WIDTH]),
          .S_AXI_ARVALID                    (cc_ds_arvalid[slot*1+:1]),
          .S_AXI_ARREADY                    (cc_ds_arready[slot*1+:1]),
          .S_AXI_RID                        (cc_ds_rid[slot*C_AXI_ID_MAX_WIDTH+:C_AXI_ID_WIDTH[slot*32+:32]]),
          .S_AXI_RDATA                      (cc_ds_rdata[slot*C_AXI_DATA_MAX_WIDTH+:C_S_AXI_DATA_WIDTH[slot*32+:32]]),
          .S_AXI_RRESP                      (cc_ds_rresp[slot*2+:2]),
          .S_AXI_RLAST                      (cc_ds_rlast[slot*1+:1]),
          .S_AXI_RUSER                      (cc_ds_ruser[slot*C_AXI_RUSER_WIDTH+:C_AXI_RUSER_WIDTH]),
          .S_AXI_RVALID                     (cc_ds_rvalid[slot*1+:1]),
          .S_AXI_RREADY                     (cc_ds_rready[slot*1+:1]),
          .M_AXI_AWID                       (ds_mi_awid[slot*C_AXI_ID_MAX_WIDTH+:C_AXI_ID_WIDTH[slot*32+:32]]),
          .M_AXI_AWADDR                     (M_AXI_AWADDR[slot*C_AXI_ADDR_WIDTH+:C_AXI_ADDR_WIDTH]),
          .M_AXI_AWLEN                      (M_AXI_AWLEN[slot*8+:8]),
          .M_AXI_AWSIZE                     (M_AXI_AWSIZE[slot*3+:3]),
          .M_AXI_AWBURST                    (M_AXI_AWBURST[slot*2+:2]),
          .M_AXI_AWLOCK                     (M_AXI_AWLOCK[slot*2+:2]),
          .M_AXI_AWCACHE                    (M_AXI_AWCACHE[slot*4+:4]),
          .M_AXI_AWPROT                     (M_AXI_AWPROT[slot*3+:3]),
          .M_AXI_AWREGION                   (M_AXI_AWREGION[slot*4+:4]),
          .M_AXI_AWQOS                      (M_AXI_AWQOS[slot*4+:4]),
          .M_AXI_AWUSER                     (M_AXI_AWUSER[slot*C_AXI_AWUSER_WIDTH+:C_AXI_AWUSER_WIDTH]),
          .M_AXI_AWVALID                    (M_AXI_AWVALID[slot*1+:1]),
          .M_AXI_AWREADY                    (M_AXI_AWREADY[slot*1+:1]),
          .M_AXI_WDATA                      (ds_mi_wdata[slot*C_AXI_DATA_MAX_WIDTH+:C_M_AXI_DATA_WIDTH[slot*32+:32]]),
          .M_AXI_WSTRB                      (ds_mi_wstrb[slot*C_AXI_DATA_MAX_WIDTH/8+:C_M_AXI_DATA_WIDTH[slot*32+:32]/8]),
          .M_AXI_WLAST                      (M_AXI_WLAST[slot*1+:1]),
          .M_AXI_WUSER                      (M_AXI_WUSER[slot*C_AXI_WUSER_WIDTH+:C_AXI_WUSER_WIDTH]),
          .M_AXI_WVALID                     (M_AXI_WVALID[slot*1+:1]),
          .M_AXI_WREADY                     (M_AXI_WREADY[slot*1+:1]),
          .M_AXI_BID                        (M_AXI_BID[slot*C_AXI_ID_MAX_WIDTH+:C_AXI_ID_WIDTH[slot*32+:32]]),
          .M_AXI_BRESP                      (M_AXI_BRESP[slot*2+:2]),
          .M_AXI_BUSER                      (M_AXI_BUSER[slot*C_AXI_BUSER_WIDTH+:C_AXI_BUSER_WIDTH]),
          .M_AXI_BVALID                     (M_AXI_BVALID[slot*1+:1]),
          .M_AXI_BREADY                     (M_AXI_BREADY[slot*1+:1]),
          .M_AXI_ARID                       (ds_mi_arid[slot*C_AXI_ID_MAX_WIDTH+:C_AXI_ID_WIDTH[slot*32+:32]]),
          .M_AXI_ARADDR                     (M_AXI_ARADDR[slot*C_AXI_ADDR_WIDTH+:C_AXI_ADDR_WIDTH]),
          .M_AXI_ARLEN                      (M_AXI_ARLEN[slot*8+:8]),
          .M_AXI_ARSIZE                     (M_AXI_ARSIZE[slot*3+:3]),
          .M_AXI_ARBURST                    (M_AXI_ARBURST[slot*2+:2]),
          .M_AXI_ARLOCK                     (M_AXI_ARLOCK[slot*2+:2]),
          .M_AXI_ARCACHE                    (M_AXI_ARCACHE[slot*4+:4]),
          .M_AXI_ARPROT                     (M_AXI_ARPROT[slot*3+:3]),
          .M_AXI_ARREGION                   (M_AXI_ARREGION[slot*4+:4]),
          .M_AXI_ARQOS                      (M_AXI_ARQOS[slot*4+:4]),
          .M_AXI_ARUSER                     (M_AXI_ARUSER[slot*C_AXI_ARUSER_WIDTH+:C_AXI_ARUSER_WIDTH]),
          .M_AXI_ARVALID                    (M_AXI_ARVALID[slot*1+:1]),
          .M_AXI_ARREADY                    (M_AXI_ARREADY[slot*1+:1]),
          .M_AXI_RID                        (M_AXI_RID[slot*C_AXI_ID_MAX_WIDTH+:C_AXI_ID_WIDTH[slot*32+:32]]),
          .M_AXI_RDATA                      (M_AXI_RDATA[slot*C_AXI_DATA_MAX_WIDTH+:C_M_AXI_DATA_WIDTH[slot*32+:32]]),
          .M_AXI_RRESP                      (M_AXI_RRESP[slot*2+:2]),
          .M_AXI_RLAST                      (M_AXI_RLAST[slot*1+:1]),
          .M_AXI_RUSER                      (M_AXI_RUSER[slot*C_AXI_RUSER_WIDTH+:C_AXI_RUSER_WIDTH]),
          .M_AXI_RVALID                     (M_AXI_RVALID[slot*1+:1]),
          .M_AXI_RREADY                     (M_AXI_RREADY[slot*1+:1])
        );
      assign M_AXI_WDATA[slot*C_AXI_DATA_MAX_WIDTH+:C_AXI_DATA_MAX_WIDTH] = ds_mi_wdata[slot*C_AXI_DATA_MAX_WIDTH+:C_M_AXI_DATA_WIDTH[slot*32+:32]];
      assign M_AXI_WSTRB[slot*C_AXI_DATA_MAX_WIDTH/8+:C_AXI_DATA_MAX_WIDTH/8] = ds_mi_wstrb[slot*C_AXI_DATA_MAX_WIDTH/8+:C_M_AXI_DATA_WIDTH[slot*32+:32]/8];
      assign M_AXI_AWID[slot*C_AXI_ID_MAX_WIDTH+:C_AXI_ID_MAX_WIDTH] = ds_mi_awid[slot*C_AXI_ID_MAX_WIDTH+:C_AXI_ID_WIDTH[slot*32+:32]];
      assign M_AXI_ARID[slot*C_AXI_ID_MAX_WIDTH+:C_AXI_ID_MAX_WIDTH] = ds_mi_arid[slot*C_AXI_ID_MAX_WIDTH+:C_AXI_ID_WIDTH[slot*32+:32]];
    end else begin :gen_no_downsizer
      assign M_AXI_AWID[slot*C_AXI_ID_MAX_WIDTH+:C_AXI_ID_MAX_WIDTH]                             = cc_ds_awid[slot*C_AXI_ID_MAX_WIDTH+:C_AXI_ID_WIDTH[slot*32+:32]]                           ;
      assign M_AXI_AWADDR[slot*C_AXI_ADDR_WIDTH+:C_AXI_ADDR_WIDTH]                       = cc_ds_awaddr[slot*C_AXI_ADDR_WIDTH+:C_AXI_ADDR_WIDTH]                     ;
      assign M_AXI_AWLEN[slot*8+:8]                                                      = cc_ds_awlen[slot*8+:8]                                                    ;
      assign M_AXI_AWSIZE[slot*3+:3]                                                     = cc_ds_awsize[slot*3+:3]                                                   ;
      assign M_AXI_AWBURST[slot*2+:2]                                                    = cc_ds_awburst[slot*2+:2]                                                  ;
      assign M_AXI_AWLOCK[slot*2+:2]                                                     = cc_ds_awlock[slot*2+:2]                                                   ;
      assign M_AXI_AWCACHE[slot*4+:4]                                                    = cc_ds_awcache[slot*4+:4]                                                  ;
      assign M_AXI_AWPROT[slot*3+:3]                                                     = cc_ds_awprot[slot*3+:3]                                                   ;
      assign M_AXI_AWREGION[slot*4+:4]                                                   = cc_ds_awregion[slot*4+:4]                                                 ;
      assign M_AXI_AWQOS[slot*4+:4]                                                      = cc_ds_awqos[slot*4+:4]                                                    ;
      assign M_AXI_AWUSER[slot*C_AXI_AWUSER_WIDTH+:C_AXI_AWUSER_WIDTH]                   = cc_ds_awuser[slot*C_AXI_AWUSER_WIDTH+:C_AXI_AWUSER_WIDTH]                 ;
      assign M_AXI_AWVALID[slot*1+:1]                                                    = cc_ds_awvalid[slot*1+:1]                                                  ;
      assign M_AXI_WDATA[slot*C_AXI_DATA_MAX_WIDTH+:C_AXI_DATA_MAX_WIDTH]                = cc_ds_wdata[slot*C_AXI_DATA_MAX_WIDTH+:C_M_AXI_DATA_WIDTH[slot*32+:32]]     ;
      assign M_AXI_WSTRB[slot*C_AXI_DATA_MAX_WIDTH/8+:C_AXI_DATA_MAX_WIDTH/8]            = cc_ds_wstrb[slot*C_AXI_DATA_MAX_WIDTH/8+:C_M_AXI_DATA_WIDTH[slot*32+:32]/8] ;
      assign M_AXI_WLAST[slot*1+:1]                                                      = cc_ds_wlast[slot*1+:1]                                                    ;
      assign M_AXI_WUSER[slot*C_AXI_WUSER_WIDTH+:C_AXI_WUSER_WIDTH]                      = cc_ds_wuser[slot*C_AXI_WUSER_WIDTH+:C_AXI_WUSER_WIDTH]                    ;
      assign M_AXI_WVALID[slot*1+:1]                                                     = cc_ds_wvalid[slot*1+:1]                                                   ;
      assign M_AXI_BREADY[slot*1+:1]                                                     = cc_ds_bready[slot*1+:1]                                                   ;
      assign M_AXI_ARID[slot*C_AXI_ID_MAX_WIDTH+:C_AXI_ID_MAX_WIDTH]                             = cc_ds_arid[slot*C_AXI_ID_MAX_WIDTH+:C_AXI_ID_WIDTH[slot*32+:32]]                           ;
      assign M_AXI_ARADDR[slot*C_AXI_ADDR_WIDTH+:C_AXI_ADDR_WIDTH]                       = cc_ds_araddr[slot*C_AXI_ADDR_WIDTH+:C_AXI_ADDR_WIDTH]                     ;
      assign M_AXI_ARLEN[slot*8+:8]                                                      = cc_ds_arlen[slot*8+:8]                                                    ;
      assign M_AXI_ARSIZE[slot*3+:3]                                                     = cc_ds_arsize[slot*3+:3]                                                   ;
      assign M_AXI_ARBURST[slot*2+:2]                                                    = cc_ds_arburst[slot*2+:2]                                                  ;
      assign M_AXI_ARLOCK[slot*2+:2]                                                     = cc_ds_arlock[slot*2+:2]                                                   ;
      assign M_AXI_ARCACHE[slot*4+:4]                                                    = cc_ds_arcache[slot*4+:4]                                                  ;
      assign M_AXI_ARPROT[slot*3+:3]                                                     = cc_ds_arprot[slot*3+:3]                                                   ;
      assign M_AXI_ARREGION[slot*4+:4]                                                   = cc_ds_arregion[slot*4+:4]                                                 ;
      assign M_AXI_ARQOS[slot*4+:4]                                                      = cc_ds_arqos[slot*4+:4]                                                    ;
      assign M_AXI_ARUSER[slot*C_AXI_ARUSER_WIDTH+:C_AXI_ARUSER_WIDTH]                   = cc_ds_aruser[slot*C_AXI_ARUSER_WIDTH+:C_AXI_ARUSER_WIDTH]                 ;
      assign M_AXI_ARVALID[slot*1+:1]                                                    = cc_ds_arvalid[slot*1+:1]                                                  ;
      assign M_AXI_RREADY[slot*1+:1]                                                     = cc_ds_rready[slot*1+:1]                                                   ;
      
      assign cc_ds_awready[slot*1+:1]                                                    = M_AXI_AWREADY[slot*1+:1]                                                  ;
      assign cc_ds_wready[slot*1+:1]                                                     = M_AXI_WREADY[slot*1+:1]                                                   ;
      assign cc_ds_bid[slot*C_AXI_ID_MAX_WIDTH+:C_AXI_ID_MAX_WIDTH]                              = M_AXI_BID[slot*C_AXI_ID_MAX_WIDTH+:C_AXI_ID_WIDTH[slot*32+:32]]                            ;
      assign cc_ds_bresp[slot*2+:2]                                                      = M_AXI_BRESP[slot*2+:2]                                                    ;
      assign cc_ds_buser[slot*C_AXI_BUSER_WIDTH+:C_AXI_BUSER_WIDTH]                      = M_AXI_BUSER[slot*C_AXI_BUSER_WIDTH+:C_AXI_BUSER_WIDTH]                    ;
      assign cc_ds_bvalid[slot*1+:1]                                                     = M_AXI_BVALID[slot*1+:1]                                                   ;
      assign cc_ds_arready[slot*1+:1]                                                    = M_AXI_ARREADY[slot*1+:1]                                                  ;
      assign cc_ds_rid[slot*C_AXI_ID_MAX_WIDTH+:C_AXI_ID_MAX_WIDTH]                              = M_AXI_RID[slot*C_AXI_ID_MAX_WIDTH+:C_AXI_ID_WIDTH[slot*32+:32]]                            ;
      assign cc_ds_rdata[slot*C_AXI_DATA_MAX_WIDTH+:C_M_AXI_DATA_WIDTH[slot*32+:32]]     = M_AXI_RDATA[slot*C_AXI_DATA_MAX_WIDTH+:C_M_AXI_DATA_WIDTH[slot*32+:32]]     ;
      assign cc_ds_rresp[slot*2+:2]                                                      = M_AXI_RRESP[slot*2+:2]                                                    ;
      assign cc_ds_rlast[slot*1+:1]                                                      = M_AXI_RLAST[slot*1+:1]                                                    ;
      assign cc_ds_ruser[slot*C_AXI_RUSER_WIDTH+:C_AXI_RUSER_WIDTH]                      = M_AXI_RUSER[slot*C_AXI_RUSER_WIDTH+:C_AXI_RUSER_WIDTH]                    ;
      assign cc_ds_rvalid[slot*1+:1]                                                     = M_AXI_RVALID[slot*1+:1]                                                   ;
    end
  end  // gen_conv_slot
endgenerate

endmodule

`default_nettype wire


// -- (c) Copyright 2009 - 2011 Xilinx, Inc. All rights reserved.
// --
// -- This file contains confidential and proprietary information
// -- of Xilinx, Inc. and is protected under U.S. and 
// -- international copyright and other intellectual property
// -- laws.
// --
// -- DISCLAIMER
// -- This disclaimer is not a license and does not grant any
// -- rights to the materials distributed herewith. Except as
// -- otherwise provided in a valid license issued to you by
// -- Xilinx, and to the maximum extent permitted by applicable
// -- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
// -- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
// -- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
// -- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
// -- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
// -- (2) Xilinx shall not be liable (whether in contract or tort,
// -- including negligence, or under any other theory of
// -- liability) for any loss or damage of any kind or nature
// -- related to, arising under or in connection with these
// -- materials, including for any direct, or any indirect,
// -- special, incidental, or consequential loss or damage
// -- (including loss of data, profits, goodwill, or any type of
// -- loss or damage suffered as a result of any action brought
// -- by a third party) even if such damage or loss was
// -- reasonably foreseeable or Xilinx had been advised of the
// -- possibility of the same.
// --
// -- CRITICAL APPLICATIONS
// -- Xilinx products are not designed or intended to be fail-
// -- safe, or for use in any application requiring fail-safe
// -- performance, such as life-support or safety devices or
// -- systems, Class III medical devices, nuclear facilities,
// -- applications related to the deployment of airbags, or any
// -- other applications that could lead to death, personal
// -- injury, or severe property or environmental damage
// -- (individually and collectively, "Critical
// -- Applications"). Customer assumes the sole risk and
// -- liability of any use of Xilinx products in Critical
// -- Applications, subject only to applicable laws and
// -- regulations governing limitations on product liability.
// --
// -- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
// -- PART OF THIS FILE AT ALL TIMES.
//-----------------------------------------------------------------------------
//
// File name: crossbar_sasd.v
//
// Description: 
//   This module is a M-master to N-slave AXI crossbar switch.
//   Single transaction issuing, single arbiter (both W&R), single data pathways.
//   The interface of this module consists of a vectored slave and master interface
//     in which all slots are sized and synchronized to the native width and clock 
//     of the interconnect, and are all AXI4 protocol.
//   All width, clock and protocol conversions are done outside this block, as are
//     any pipeline registers or data FIFOs.
//   This module contains all arbitration, decoders and channel multiplexing logic.
//     It also contains the diagnostic registers and control interface.
//
//--------------------------------------------------------------------------
//
// Structure:
//    crossbar_sasd
//      addr_arbiter_sasd
//        mux_enc
//      addr_decoder
//        comparator_static
//      splitter
//      mux_enc
//      axic_register_slice
//      decerr_slave
//      
//-----------------------------------------------------------------------------
`timescale 1ps/1ps
`default_nettype none

(* DowngradeIPIdentifiedWarnings="yes" *) 
module axi_interconnect_v1_7_13_crossbar_sasd #
  (
   parameter integer C_MAX_S = 16,
   parameter integer C_MAX_M = 16,
   parameter integer C_NUM_ADDR_RANGES = 16,
   parameter         C_FAMILY                       = "none", 
                       // FPGA Family. Current version: virtex6 or spartan6.
   parameter integer C_NUM_SLAVE_SLOTS              =   1, 
                       // Number of Slave Interface (SI) slots for connecting 
                       // to master IP. Range: 1-C_MAX_S.
   parameter integer C_NUM_MASTER_SLOTS             =   1, 
                       // Number of Master Interface (MI) slots for connecting 
                       // to slave IP. Range: 1-C_MAX_M.
   parameter integer C_AXI_ID_WIDTH                   = 1, 
                       // Width of ID signals propagated by the Interconnect.
                       // Width of ID signals produced on all MI slots.
                       // Range: >= 1.
   parameter [C_MAX_S*32-1:0] C_S_AXI_ID_WIDTH                 = {C_MAX_S{32'h00000000}}, 
                       // Effective width of S_AXI_AWID, S_AXI_BID, S_AXI_ARID 
                       // and S_AXI_RID for each SI slot.
                       // Format: C_NUM_SLAVE_SLOTS{Bit32}; 
                       // Range: 0 - C_AXI_ID_WIDTH.
   parameter integer C_AXI_ADDR_WIDTH                 = 32, 
                       // Width of S_AXI_AWADDR, S_AXI_ARADDR, M_AXI_AWADDR and 
                       // M_AXI_ARADDR for all SI/MI slots.
                       // Range: 32.
   parameter integer C_INTERCONNECT_DATA_WIDTH = 32, 
                       // Data width of the internal interconnect write and read 
                       // data paths.
                       // Range: 32, 64, 128, 256.
   parameter integer C_AXI_DATA_MAX_WIDTH             = 32, 
                       // Largest value supported for any DATA_WIDTH.
   parameter [C_MAX_S*32-1:0] C_S_AXI_PROTOCOL                 = {C_MAX_S{32'h00000000}}, 
                       // Indicates whether connected master is 
                       // Full-AXI4 ('h00000000),
                       // AXI3 ('h00000001) or 
                       // Axi4Lite ('h00000002), for each SI slot.
                       // Format: C_NUM_SLAVE_SLOTS{Bit32}.
   parameter [C_MAX_M*32-1:0] C_M_AXI_PROTOCOL                 = {C_MAX_M{32'h00000000}}, 
                       // Indicates whether connected slave is
                       // Full-AXI4 ('h00000000),
                       // AXI3 ('h00000001) or 
                       // Axi4Lite ('h00000002), for each SI slot.
                       // Format: C_NUM_MASTER_SLOTS{Bit32}.
   parameter [C_MAX_M*C_NUM_ADDR_RANGES*64-1:0] C_M_AXI_BASE_ADDR                 = {C_MAX_M*C_NUM_ADDR_RANGES{64'hFFFFFFFF_FFFFFFFF}}, 
                       // Base address of each range of each MI slot. 
                       // For unused ranges, set base address to 'hFFFFFFFF.
                       // Format: C_NUM_MASTER_SLOTS{C_NUM_ADDR_RANGES{Bit64}}.
   parameter [C_MAX_M*C_NUM_ADDR_RANGES*64-1:0] C_M_AXI_HIGH_ADDR                 = {C_MAX_M*C_NUM_ADDR_RANGES{64'h00000000_00000000}}, 
                       // High address of each range of each MI slot. 
                       // For unused ranges, set high address to 'h00000000.
                       // Format: C_NUM_MASTER_SLOTS{C_NUM_ADDR_RANGES{Bit64}}.
   parameter [C_MAX_S*64-1:0] C_S_AXI_BASE_ID                  = {C_MAX_S{64'h00000000_00000000}},
                       // Base ID of each SI slot. 
                       // Format: C_NUM_SLAVE_SLOTS{Bit64};
                       // Range: 0 to 2**C_AXI_ID_WIDTH-1.
   parameter [C_MAX_S*64-1:0] C_S_AXI_HIGH_ID                  = {C_MAX_S{64'h00000000_00000000}},
                       // High ID of each SI slot. 
                       // Format: C_NUM_SLAVE_SLOTS{Bit64};
                       // Range: 0 to 2**C_AXI_ID_WIDTH-1.
   parameter [C_MAX_S*1-1:0] C_S_AXI_SUPPORTS_WRITE           = {C_MAX_S{1'b0}}, 
                       // Indicates whether each SI supports write transactions.
                       // Format: C_NUM_SLAVE_SLOTS{Bit1}.
   parameter [C_MAX_S*1-1:0] C_S_AXI_SUPPORTS_READ            = {C_MAX_S{1'b0}}, 
                       // Indicates whether each SI supports read transactions.
                       // Format: C_NUM_SLAVE_SLOTS{Bit1}.
   parameter [C_MAX_M*1-1:0] C_M_AXI_SUPPORTS_WRITE           = {C_MAX_M{1'b0}}, 
                       // Indicates whether each MI supports write transactions.
                       // Format: C_NUM_MASTER_SLOTS{Bit1}.
   parameter [C_MAX_M*1-1:0] C_M_AXI_SUPPORTS_READ            = {C_MAX_M{1'b0}}, 
                       // Indicates whether each MI supports read transactions.
                       // Format: C_NUM_MASTER_SLOTS{Bit1}.
   parameter integer C_AXI_SUPPORTS_USER_SIGNALS = 0,
                       // 1 = Propagate all USER signals, 0 = Dont propagate.
   parameter integer C_AXI_AWUSER_WIDTH = 1,
                       // Width of AWUSER signals for all SI slots and MI slots. 
                       // Range: >= 1.
   parameter integer C_AXI_ARUSER_WIDTH = 1,
                       // Width of ARUSER signals for all SI slots and MI slots. 
                       // Range: >= 1.
   parameter integer C_AXI_WUSER_WIDTH = 1,
                       // Width of WUSER signals for all SI slots and MI slots. 
                       // Range: >= 1.
   parameter integer C_AXI_RUSER_WIDTH = 1,
                       // Width of RUSER signals for all SI slots and MI slots. 
                       // Range: >= 1.
   parameter integer C_AXI_BUSER_WIDTH = 1,
                       // Width of BUSER signals for all SI slots and MI slots. 
                       // Range: >= 1.
//   parameter         C_S_AXI_ARB_METHOD = "priority", // Reserved for future
//                       // Arbitration method.
//                       // Format: String; 
//                       // Range: "priority" ("tdm" not yet implemented).
   parameter [C_MAX_S*32-1:0] C_S_AXI_ARB_PRIORITY             = {C_MAX_S{32'h00000000}},
                       // Arbitration priority among each SI slot. 
                       // Higher values indicate higher priority.
                       // Format: C_NUM_SLAVE_SLOTS{Bit32};
                       // Range: 'h0-'hF.
//   parameter [C_MAX_S*32-1:0] C_S_AXI_ARB_TDM_SLOTS            = {C_MAX_S{32'h00000000}}, // Reserved for future
//                       // Maximum number of consecutive TDM arbitration slots 
//                       // allocated among each SI slot.
//                       // Format: C_NUM_SLAVE_SLOTS{Bit32});
//   parameter integer C_S_AXI_ARB_TDM_TOTAL            = 0, // Reserved for future
//                       // Total number of TDM arbitration slots during which all 
//                       // TDM masters must be serviced.
//                       // (Must be >= sum of all C_S_AXI_ARB_TDM_SLOTS.)
   parameter [C_MAX_M*1-1:0] C_M_AXI_SECURE                   = {C_MAX_M{1'b0}},
                       // Indicates whether each MI slot connects to a secure slave 
                       // (allows only TrustZone secure access).
                       // Format: C_NUM_MASTER_SLOTS{Bit1}.
   parameter integer C_INTERCONNECT_R_REGISTER        = 0,
                       // Insert register slice on R channel in the crossbar.
                       // Range: 0-8.
   parameter integer C_USE_CTRL_PORT = 0,
                       // Indicates whether diagnostic information is accessible 
                       // via the S_AXI_CTRL interface.
   parameter integer C_USE_INTERRUPT = 1,
                       // If CTRL interface enabled, indicates whether interrupts 
                       // are generated.
   parameter integer C_RANGE_CHECK                    = 0,
                       // 1 = Always check address ranges (DECERR if no valid MI slot).
                       // 0 = Pass all transactions (no DECERR) when only 1 MI slot/range.
   parameter integer C_ADDR_DECODE                    = 0,
                       // 1 = Implement address decoder.
                       // 0 = Propagate address to single slave.
   parameter integer C_S_AXI_CTRL_ADDR_WIDTH = 32,
                       // ADDR width of CTRL interface.
   parameter integer C_S_AXI_CTRL_DATA_WIDTH = 32,
                       // DATA width of CTRL interface.
   parameter integer C_DEBUG              = 1,
   parameter integer C_MAX_DEBUG_THREADS  = 1
   )
  (
   // Global Signals
   input  wire                                                    INTERCONNECT_ACLK,
   input  wire                                                    ARESETN,
   output wire                                                    IRQ,
   // Slave Interface Write Address Ports
   input  wire [C_NUM_SLAVE_SLOTS*C_AXI_ID_WIDTH-1:0]           S_AXI_AWID,
   input  wire [C_NUM_SLAVE_SLOTS*C_AXI_ADDR_WIDTH-1:0]           S_AXI_AWADDR,
   input  wire [C_NUM_SLAVE_SLOTS*8-1:0]                          S_AXI_AWLEN,
   input  wire [C_NUM_SLAVE_SLOTS*3-1:0]                          S_AXI_AWSIZE,
   input  wire [C_NUM_SLAVE_SLOTS*2-1:0]                          S_AXI_AWBURST,
   input  wire [C_NUM_SLAVE_SLOTS*2-1:0]                          S_AXI_AWLOCK,
   input  wire [C_NUM_SLAVE_SLOTS*4-1:0]                          S_AXI_AWCACHE,
   input  wire [C_NUM_SLAVE_SLOTS*3-1:0]                          S_AXI_AWPROT,
   input  wire [C_NUM_SLAVE_SLOTS*4-1:0]                          S_AXI_AWQOS,
   input  wire [C_NUM_SLAVE_SLOTS*C_AXI_AWUSER_WIDTH-1:0]         S_AXI_AWUSER,
   input  wire [C_NUM_SLAVE_SLOTS-1:0]                            S_AXI_AWVALID,
   output wire [C_NUM_SLAVE_SLOTS-1:0]                            S_AXI_AWREADY,
   // Slave Interface Write Data Ports
   input  wire [C_NUM_SLAVE_SLOTS*C_AXI_DATA_MAX_WIDTH-1:0]     S_AXI_WDATA,
   input  wire [C_NUM_SLAVE_SLOTS*C_AXI_DATA_MAX_WIDTH/8-1:0]   S_AXI_WSTRB,
   input  wire [C_NUM_SLAVE_SLOTS-1:0]                            S_AXI_WLAST,
   input  wire [C_NUM_SLAVE_SLOTS*C_AXI_WUSER_WIDTH-1:0]          S_AXI_WUSER,
   input  wire [C_NUM_SLAVE_SLOTS-1:0]                            S_AXI_WVALID,
   output wire [C_NUM_SLAVE_SLOTS-1:0]                            S_AXI_WREADY,
   // Slave Interface Write Response Ports
   output wire [C_NUM_SLAVE_SLOTS*C_AXI_ID_WIDTH-1:0]           S_AXI_BID,
   output wire [C_NUM_SLAVE_SLOTS*2-1:0]                          S_AXI_BRESP,
   output wire [C_NUM_SLAVE_SLOTS*C_AXI_BUSER_WIDTH-1:0]          S_AXI_BUSER,
   output wire [C_NUM_SLAVE_SLOTS-1:0]                            S_AXI_BVALID,
   input  wire [C_NUM_SLAVE_SLOTS-1:0]                            S_AXI_BREADY,
   // Slave Interface Read Address Ports
   input  wire [C_NUM_SLAVE_SLOTS*C_AXI_ID_WIDTH-1:0]           S_AXI_ARID,
   input  wire [C_NUM_SLAVE_SLOTS*C_AXI_ADDR_WIDTH-1:0]           S_AXI_ARADDR,
   input  wire [C_NUM_SLAVE_SLOTS*8-1:0]                          S_AXI_ARLEN,
   input  wire [C_NUM_SLAVE_SLOTS*3-1:0]                          S_AXI_ARSIZE,
   input  wire [C_NUM_SLAVE_SLOTS*2-1:0]                          S_AXI_ARBURST,
   input  wire [C_NUM_SLAVE_SLOTS*2-1:0]                          S_AXI_ARLOCK,
   input  wire [C_NUM_SLAVE_SLOTS*4-1:0]                          S_AXI_ARCACHE,
   input  wire [C_NUM_SLAVE_SLOTS*3-1:0]                          S_AXI_ARPROT,
   input  wire [C_NUM_SLAVE_SLOTS*4-1:0]                          S_AXI_ARQOS,
   input  wire [C_NUM_SLAVE_SLOTS*C_AXI_ARUSER_WIDTH-1:0]         S_AXI_ARUSER,
   input  wire [C_NUM_SLAVE_SLOTS-1:0]                            S_AXI_ARVALID,
   output wire [C_NUM_SLAVE_SLOTS-1:0]                            S_AXI_ARREADY,
   // Slave Interface Read Data Ports
   output wire [C_NUM_SLAVE_SLOTS*C_AXI_ID_WIDTH-1:0]           S_AXI_RID,
   output wire [C_NUM_SLAVE_SLOTS*C_AXI_DATA_MAX_WIDTH-1:0]     S_AXI_RDATA,
   output wire [C_NUM_SLAVE_SLOTS*2-1:0]                          S_AXI_RRESP,
   output wire [C_NUM_SLAVE_SLOTS-1:0]                            S_AXI_RLAST,
   output wire [C_NUM_SLAVE_SLOTS*C_AXI_RUSER_WIDTH-1:0]          S_AXI_RUSER,
   output wire [C_NUM_SLAVE_SLOTS-1:0]                            S_AXI_RVALID,
   input  wire [C_NUM_SLAVE_SLOTS-1:0]                            S_AXI_RREADY,
   // Master Interface Write Address Port
   output wire [C_NUM_MASTER_SLOTS*C_AXI_ID_WIDTH-1:0]          M_AXI_AWID,
   output wire [C_NUM_MASTER_SLOTS*C_AXI_ADDR_WIDTH-1:0]          M_AXI_AWADDR,
   output wire [C_NUM_MASTER_SLOTS*8-1:0]                         M_AXI_AWLEN,
   output wire [C_NUM_MASTER_SLOTS*3-1:0]                         M_AXI_AWSIZE,
   output wire [C_NUM_MASTER_SLOTS*2-1:0]                         M_AXI_AWBURST,
   output wire [C_NUM_MASTER_SLOTS*2-1:0]                         M_AXI_AWLOCK,
   output wire [C_NUM_MASTER_SLOTS*4-1:0]                         M_AXI_AWCACHE,
   output wire [C_NUM_MASTER_SLOTS*3-1:0]                         M_AXI_AWPROT,
   output wire [C_NUM_MASTER_SLOTS*4-1:0]                         M_AXI_AWREGION,
   output wire [C_NUM_MASTER_SLOTS*4-1:0]                         M_AXI_AWQOS,
   output wire [C_NUM_MASTER_SLOTS*C_AXI_AWUSER_WIDTH-1:0]        M_AXI_AWUSER,
   output wire [C_NUM_MASTER_SLOTS-1:0]                           M_AXI_AWVALID,
   input  wire [C_NUM_MASTER_SLOTS-1:0]                           M_AXI_AWREADY,
   // Master Interface Write Data Ports
   output wire [C_NUM_MASTER_SLOTS*C_AXI_DATA_MAX_WIDTH-1:0]    M_AXI_WDATA,
   output wire [C_NUM_MASTER_SLOTS*C_AXI_DATA_MAX_WIDTH/8-1:0]  M_AXI_WSTRB,
   output wire [C_NUM_MASTER_SLOTS-1:0]                           M_AXI_WLAST,
   output wire [C_NUM_MASTER_SLOTS*C_AXI_WUSER_WIDTH-1:0]         M_AXI_WUSER,
   output wire [C_NUM_MASTER_SLOTS-1:0]                           M_AXI_WVALID,
   input  wire [C_NUM_MASTER_SLOTS-1:0]                           M_AXI_WREADY,
   // Master Interface Write Response Ports
   input  wire [C_NUM_MASTER_SLOTS*C_AXI_ID_WIDTH-1:0]          M_AXI_BID,
   input  wire [C_NUM_MASTER_SLOTS*2-1:0]                         M_AXI_BRESP,
   input  wire [C_NUM_MASTER_SLOTS*C_AXI_BUSER_WIDTH-1:0]         M_AXI_BUSER,
   input  wire [C_NUM_MASTER_SLOTS-1:0]                           M_AXI_BVALID,
   output wire [C_NUM_MASTER_SLOTS-1:0]                           M_AXI_BREADY,
   // Master Interface Read Address Port
   output wire [C_NUM_MASTER_SLOTS*C_AXI_ID_WIDTH-1:0]          M_AXI_ARID,
   output wire [C_NUM_MASTER_SLOTS*C_AXI_ADDR_WIDTH-1:0]          M_AXI_ARADDR,
   output wire [C_NUM_MASTER_SLOTS*8-1:0]                         M_AXI_ARLEN,
   output wire [C_NUM_MASTER_SLOTS*3-1:0]                         M_AXI_ARSIZE,
   output wire [C_NUM_MASTER_SLOTS*2-1:0]                         M_AXI_ARBURST,
   output wire [C_NUM_MASTER_SLOTS*2-1:0]                         M_AXI_ARLOCK,
   output wire [C_NUM_MASTER_SLOTS*4-1:0]                         M_AXI_ARCACHE,
   output wire [C_NUM_MASTER_SLOTS*3-1:0]                         M_AXI_ARPROT,
   output wire [C_NUM_MASTER_SLOTS*4-1:0]                         M_AXI_ARREGION,
   output wire [C_NUM_MASTER_SLOTS*4-1:0]                         M_AXI_ARQOS,
   output wire [C_NUM_MASTER_SLOTS*C_AXI_ARUSER_WIDTH-1:0]        M_AXI_ARUSER,
   output wire [C_NUM_MASTER_SLOTS-1:0]                           M_AXI_ARVALID,
   input  wire [C_NUM_MASTER_SLOTS-1:0]                           M_AXI_ARREADY,
   // Master Interface Read Data Ports
   input  wire [C_NUM_MASTER_SLOTS*C_AXI_ID_WIDTH-1:0]          M_AXI_RID,
   input  wire [C_NUM_MASTER_SLOTS*C_AXI_DATA_MAX_WIDTH-1:0]    M_AXI_RDATA,
   input  wire [C_NUM_MASTER_SLOTS*2-1:0]                         M_AXI_RRESP,
   input  wire [C_NUM_MASTER_SLOTS-1:0]                           M_AXI_RLAST,
   input wire [C_NUM_MASTER_SLOTS*C_AXI_RUSER_WIDTH-1:0]         M_AXI_RUSER,
   input  wire [C_NUM_MASTER_SLOTS-1:0]                           M_AXI_RVALID,
   output wire [C_NUM_MASTER_SLOTS-1:0]                           M_AXI_RREADY,
   // Diagnostic AxiLite Slave Interface
   input wire [(C_S_AXI_CTRL_ADDR_WIDTH-1):0]                     S_AXI_CTRL_AWADDR,
   input wire                                                     S_AXI_CTRL_AWVALID,
   output wire                                                    S_AXI_CTRL_AWREADY,
   input wire [(C_S_AXI_CTRL_DATA_WIDTH-1):0]                     S_AXI_CTRL_WDATA,
   input wire                                                     S_AXI_CTRL_WVALID,
   output wire                                                    S_AXI_CTRL_WREADY,
   output wire [1:0]                                              S_AXI_CTRL_BRESP,
   output wire                                                    S_AXI_CTRL_BVALID,
   input wire                                                     S_AXI_CTRL_BREADY,
   input wire [(C_S_AXI_CTRL_ADDR_WIDTH-1):0]                     S_AXI_CTRL_ARADDR,
   input wire                                                     S_AXI_CTRL_ARVALID,
   output wire                                                    S_AXI_CTRL_ARREADY,
   output wire [(C_S_AXI_CTRL_DATA_WIDTH-1):0]                    S_AXI_CTRL_RDATA,
   output wire [1:0]                                              S_AXI_CTRL_RRESP,
   output wire                                                    S_AXI_CTRL_RVALID,
   input wire                                                     S_AXI_CTRL_RREADY,
   // Diagnostic Probe Ports
   output wire [8-1:0]                                            DEBUG_AW_TRANS_SEQ,
   output wire [C_NUM_SLAVE_SLOTS*8-1:0]                          DEBUG_AW_ERROR,
   output wire [C_NUM_SLAVE_SLOTS*8-1:0]                          DEBUG_AW_TARGET,
   output wire [8-1:0]                                            DEBUG_AW_ARB_GRANT,
   output wire [8-1:0]                                            DEBUG_AR_TRANS_SEQ,
   output wire [C_NUM_SLAVE_SLOTS*8-1:0]                          DEBUG_AR_ERROR,
   output wire [C_NUM_SLAVE_SLOTS*8-1:0]                          DEBUG_AR_TARGET,
   output wire [8-1:0]                                            DEBUG_AR_ARB_GRANT,
   output wire [C_NUM_SLAVE_SLOTS*C_MAX_DEBUG_THREADS*8-1:0]      DEBUG_R_BEAT_CNT,
   output wire [(C_NUM_MASTER_SLOTS+1)*8-1:0]                     DEBUG_W_BEAT_CNT
   );
   
  localparam [31:0] P_AXI4 = 32'h0;
  localparam [31:0] P_AXI3 = 32'h1;
  localparam [31:0] P_AXILITE = 32'h2;
  localparam integer P_NUM_MASTER_SLOTS_DE = C_RANGE_CHECK ? C_NUM_MASTER_SLOTS+1 : C_NUM_MASTER_SLOTS;
  localparam integer P_NUM_MASTER_SLOTS_LOG = (C_NUM_MASTER_SLOTS>1) ? f_ceil_log2(C_NUM_MASTER_SLOTS) : 1;
  localparam integer P_NUM_MASTER_SLOTS_DE_LOG = (P_NUM_MASTER_SLOTS_DE>1) ? f_ceil_log2(P_NUM_MASTER_SLOTS_DE) : 1;
  localparam integer P_NUM_SLAVE_SLOTS_LOG = (C_NUM_SLAVE_SLOTS>1) ? f_ceil_log2(C_NUM_SLAVE_SLOTS) : 1;
  localparam integer P_AXI_AUSER_WIDTH = (C_AXI_AWUSER_WIDTH > C_AXI_ARUSER_WIDTH) ? C_AXI_AWUSER_WIDTH : C_AXI_ARUSER_WIDTH;
  localparam integer P_AMESG_WIDTH = C_AXI_ID_WIDTH + C_AXI_ADDR_WIDTH + 8+3+2+3+2+4+4 + P_AXI_AUSER_WIDTH;
  localparam integer P_BMESG_WIDTH = 2 + C_AXI_BUSER_WIDTH;
  localparam integer P_RMESG_WIDTH = 1+2 + C_INTERCONNECT_DATA_WIDTH + C_AXI_RUSER_WIDTH;
  localparam integer P_WMESG_WIDTH = 1+1 + C_INTERCONNECT_DATA_WIDTH + C_INTERCONNECT_DATA_WIDTH/8 + C_AXI_WUSER_WIDTH;
  localparam [(C_NUM_MASTER_SLOTS+1)-1:0] P_M_AXI_SUPPORTS_READ = {1'b1, C_M_AXI_SUPPORTS_READ[0+:C_NUM_MASTER_SLOTS]};
  localparam [(C_NUM_MASTER_SLOTS+1)-1:0] P_M_AXI_SUPPORTS_WRITE = {1'b1, C_M_AXI_SUPPORTS_WRITE[0+:C_NUM_MASTER_SLOTS]};
  localparam [1:0]   P_AXILITE_VAL = 2'b10;
  localparam integer P_NONSECURE_BIT = 1; 
  localparam [C_NUM_MASTER_SLOTS-1:0] P_M_AXILITE_MASK = f_m_axilite(0);  // Mask of AxiLite MI-slots
  localparam [1:0]   P_FIXED = 2'b00;
  localparam         P_ALL_AXILITE = (C_S_AXI_PROTOCOL[C_NUM_SLAVE_SLOTS*32-1:0]  == {C_NUM_SLAVE_SLOTS{ 32'h00000002}}) && 
                                     (C_M_AXI_PROTOCOL[C_NUM_MASTER_SLOTS*32-1:0] == {C_NUM_MASTER_SLOTS{32'h00000002}});
  localparam integer P_BYPASS = 0;
  localparam integer P_LIGHTWT = 7;
  localparam integer P_FULLY_REG = 1;
  localparam integer P_R_REG_CONFIG = C_INTERCONNECT_R_REGISTER == 8 ?  // "Automatic" reg-slice
        (C_RANGE_CHECK ? (P_ALL_AXILITE ? P_LIGHTWT : P_FULLY_REG) : P_BYPASS) :  // Bypass if no R-channel mux
        C_INTERCONNECT_R_REGISTER;

  //---------------------------------------------------------------------------
  // Functions
  //---------------------------------------------------------------------------
  // Ceiling of log2(x)
  function integer f_ceil_log2
    (
     input integer x
     );
    integer acc;
    begin
      acc=0;
      while ((2**acc) < x)
        acc = acc + 1;
      f_ceil_log2 = acc;
    end
  endfunction

  // Isolate thread bits of input S_ID and add to BASE_ID (RNG00) to form MI-side ID value
  //   only for end-point SI-slots
  function [C_AXI_ID_WIDTH-1:0] f_extend_ID
    (
     input [C_AXI_ID_WIDTH-1:0] s_id,
     input integer slot
     );
    begin
      f_extend_ID = C_S_AXI_BASE_ID[slot*64+:C_AXI_ID_WIDTH] | (s_id & (C_S_AXI_BASE_ID[slot*64+:C_AXI_ID_WIDTH] ^ C_S_AXI_HIGH_ID[slot*64+:C_AXI_ID_WIDTH]));
    end
  endfunction

  // AxiLite protocol flag vector      
  function [C_NUM_MASTER_SLOTS-1:0] f_m_axilite
    (
      input integer null_arg
    );
    integer mi;
    begin
      for (mi=0; mi<C_NUM_MASTER_SLOTS; mi=mi+1) begin
        f_m_axilite[mi] = (C_M_AXI_PROTOCOL[mi*32+:2] == P_AXILITE_VAL);
      end
    end
  endfunction
  
  genvar gen_si_slot;
  genvar gen_mi_slot;
  wire [C_NUM_SLAVE_SLOTS*P_AMESG_WIDTH-1:0]                      si_awmesg          ;
  wire [C_NUM_SLAVE_SLOTS*P_AMESG_WIDTH-1:0]                      si_armesg          ;
  wire [P_AMESG_WIDTH-1:0]                                        aa_amesg         ;
  wire [C_AXI_ID_WIDTH-1:0]                                       mi_aid            ;
  wire [C_AXI_ADDR_WIDTH-1:0]                                     mi_aaddr          ;
  wire [8-1:0]                                                    mi_alen           ;
  wire [3-1:0]                                                    mi_asize          ;
  wire [2-1:0]                                                    mi_alock          ;
  wire [3-1:0]                                                    mi_aprot          ;
  wire [2-1:0]                                                    mi_aburst        ;
  wire [4-1:0]                                                    mi_acache        ;
  wire [4-1:0]                                                    mi_aqos        ;
  wire [P_AXI_AUSER_WIDTH-1:0]                                    mi_auser        ;
  wire [4-1:0]                                                    region        ;
  wire [C_NUM_SLAVE_SLOTS*1-1:0]                                  aa_grant_hot     ;
  wire [P_NUM_SLAVE_SLOTS_LOG-1:0]                                  aa_grant_enc     ;
  wire                                                            aa_grant_rnw ;
  wire                                                            aa_grant_any ;
  wire [C_NUM_MASTER_SLOTS-1:0]                                   target_mi_hot    ;
  wire [P_NUM_MASTER_SLOTS_LOG-1:0]                                   target_mi_enc    ;
  reg  [P_NUM_MASTER_SLOTS_DE-1:0]                               m_atarget_hot    ;
  reg  [P_NUM_MASTER_SLOTS_DE_LOG-1:0]                               m_atarget_enc    ;
  wire [P_NUM_MASTER_SLOTS_DE_LOG-1:0]                               m_atarget_enc_comb    ;
  wire                                                            match;
  wire                                                            any_error         ;
  wire [7:0]                                                      m_aerror_i         ;
  wire [P_NUM_MASTER_SLOTS_DE-1:0]                             mi_awvalid            ;
  wire [P_NUM_MASTER_SLOTS_DE-1:0]                             mi_awready            ;
  wire [P_NUM_MASTER_SLOTS_DE-1:0]                             mi_arvalid            ;
  wire [P_NUM_MASTER_SLOTS_DE-1:0]                             mi_arready            ;
  wire                                                            aa_awvalid         ;
  wire                                                            aa_awready         ;
  wire                                                            aa_arvalid         ;
  wire                                                            aa_arready         ;
  wire                                                            mi_awvalid_en;
  wire                                                            mi_awready_mux;
  wire                                                            mi_arvalid_en;
  wire                                                            mi_arready_mux;
  wire                                                            w_transfer_en;
  wire                                                            w_complete_mux;
  wire                                                            b_transfer_en;
  wire                                                            b_complete_mux;
  wire                                                            r_transfer_en;
  wire                                                            r_complete_mux;
  wire                                                            target_secure;
  wire                                                            target_axilite;
  wire                                                            target_write;
  wire                                                            target_read;
  
  wire [P_BMESG_WIDTH-1:0]                                        si_bmesg           ;
  wire [P_NUM_MASTER_SLOTS_DE*P_BMESG_WIDTH-1:0]                 mi_bmesg           ;
  wire [P_NUM_MASTER_SLOTS_DE*2-1:0]                             mi_bresp           ;
  wire [P_NUM_MASTER_SLOTS_DE*C_AXI_BUSER_WIDTH-1:0]             mi_buser           ;
  wire [2-1:0]                                                    si_bresp           ;
  wire [C_AXI_BUSER_WIDTH-1:0]                                    si_buser           ;
  wire [P_NUM_MASTER_SLOTS_DE-1:0]                             mi_bvalid          ;
  wire [P_NUM_MASTER_SLOTS_DE-1:0]                             mi_bready          ;
  wire                                                            aa_bvalid          ;
  wire                                                            aa_bready         ;
  wire                                                            si_bready         ;
  wire [C_NUM_SLAVE_SLOTS-1:0]                                    si_bvalid;
  
  wire [P_RMESG_WIDTH-1:0]                                        aa_rmesg           ;
  wire [P_RMESG_WIDTH-1:0]                                        sr_rmesg           ;
  wire [P_NUM_MASTER_SLOTS_DE*P_RMESG_WIDTH-1:0]                 mi_rmesg           ;
  wire [P_NUM_MASTER_SLOTS_DE*2-1:0]                             mi_rresp           ;
  wire [P_NUM_MASTER_SLOTS_DE*C_AXI_RUSER_WIDTH-1:0]             mi_ruser           ;
  wire [P_NUM_MASTER_SLOTS_DE*C_AXI_DATA_MAX_WIDTH-1:0]          mi_rdata              ;
  wire [P_NUM_MASTER_SLOTS_DE*1-1:0]                             mi_rlast              ;
  wire [2-1:0]                                                    si_rresp           ;
  wire [C_AXI_RUSER_WIDTH-1:0]                                    si_ruser           ;
  wire [C_AXI_DATA_MAX_WIDTH-1:0]                                 si_rdata              ;
  wire                                                            si_rlast              ;
  wire [P_NUM_MASTER_SLOTS_DE-1:0]                             mi_rvalid          ;
  wire [P_NUM_MASTER_SLOTS_DE-1:0]                             mi_rready          ;
  wire                                                            aa_rvalid          ;
  wire                                                            aa_rready         ;
  wire                                                            sr_rvalid          ;
  wire                                                            si_rready         ;
  wire                                                            sr_rready         ;
  wire [C_NUM_SLAVE_SLOTS-1:0]                                    si_rvalid;
  
  wire [C_NUM_SLAVE_SLOTS*P_WMESG_WIDTH-1:0]                      si_wmesg           ;
  wire [P_WMESG_WIDTH-1:0]                                        mi_wmesg           ;
  wire [C_INTERCONNECT_DATA_WIDTH-1:0]                            mi_wdata              ;
  wire [C_INTERCONNECT_DATA_WIDTH/8-1:0]                          mi_wstrb              ;
  wire [C_AXI_WUSER_WIDTH-1:0]                                    mi_wuser              ;
  wire [1-1:0]                                                    mi_wlast              ;
  wire [P_NUM_MASTER_SLOTS_DE-1:0]                             mi_wvalid          ;
  wire [P_NUM_MASTER_SLOTS_DE-1:0]                             mi_wready          ;
  wire                                                            aa_wvalid          ;
  wire                                                            aa_wready         ;
  wire [C_NUM_SLAVE_SLOTS-1:0]                                    si_wready;
  
  reg  [7:0]                                                      debug_r_beat_cnt_i;
  reg  [7:0]                                                      debug_w_beat_cnt_i;
  reg  [7:0]                                                      debug_aw_trans_seq_i;
  reg  [7:0]                                                      debug_ar_trans_seq_i;

  (* shreg_extract="no", iob="false", equivalent_register_removal = "no" *) reg reset;
  always @(posedge INTERCONNECT_ACLK) begin
    reset <= ~ARESETN;
  end

generate
  if ((C_NUM_MASTER_SLOTS==1) && (C_NUM_SLAVE_SLOTS==1) && (C_ADDR_DECODE==0)) begin : gen_passthru
      
    assign M_AXI_AWID[0+:C_AXI_ID_WIDTH]                = f_extend_ID(S_AXI_AWID[0+:C_AXI_ID_WIDTH], 0);
    assign M_AXI_AWADDR[0+:C_AXI_ADDR_WIDTH]            = S_AXI_AWADDR[0+:C_AXI_ADDR_WIDTH];
    assign M_AXI_AWLEN[0+:8]                            = S_AXI_AWLEN[0+:8];
    assign M_AXI_AWSIZE[0+:3]                           = S_AXI_AWSIZE[0+:3];
    assign M_AXI_AWBURST[0+:2]                          = S_AXI_AWBURST[0+:2];
    assign M_AXI_AWLOCK[0+:2]                           = S_AXI_AWLOCK[0+:2];
    assign M_AXI_AWCACHE[0+:4]                          = S_AXI_AWCACHE[0+:4];
    assign M_AXI_AWPROT[0+:3]                           = S_AXI_AWPROT[0+:3];
    assign M_AXI_AWREGION[0+:4]                         = 4'b0;
    assign M_AXI_AWQOS[0+:4]                            = S_AXI_AWQOS[0+:4];
    assign M_AXI_AWUSER[0+:C_AXI_AWUSER_WIDTH]          = S_AXI_AWUSER[0+:C_AXI_AWUSER_WIDTH];
    assign M_AXI_AWVALID[0+:1]                          = S_AXI_AWVALID[0+:1];
    assign S_AXI_AWREADY[0+:1]                          = M_AXI_AWREADY[0+:1];
    assign M_AXI_WDATA[0+:C_AXI_DATA_MAX_WIDTH]         = S_AXI_WDATA[0+:C_AXI_DATA_MAX_WIDTH];
    assign M_AXI_WSTRB[0+:C_AXI_DATA_MAX_WIDTH/8]       = S_AXI_WSTRB[0+:C_AXI_DATA_MAX_WIDTH/8];
    assign M_AXI_WLAST[0+:1]                            = S_AXI_WLAST[0+:1];
    assign M_AXI_WUSER[0+:C_AXI_WUSER_WIDTH]            = S_AXI_WUSER[0+:C_AXI_WUSER_WIDTH];
    assign M_AXI_WVALID[0+:1]                           = S_AXI_WVALID[0+:1];
    assign S_AXI_WREADY[0+:1]                           = M_AXI_WREADY[0+:1];
    assign S_AXI_BID[0+:C_AXI_ID_WIDTH]                 = M_AXI_BID[0+:C_AXI_ID_WIDTH];
    assign S_AXI_BRESP[0+:2]                            = M_AXI_BRESP[0+:2];
    assign S_AXI_BUSER[0+:C_AXI_BUSER_WIDTH]            = M_AXI_BUSER[0+:C_AXI_BUSER_WIDTH];
    assign S_AXI_BVALID[0+:1]                           = M_AXI_BVALID[0+:1];
    assign M_AXI_BREADY[0+:1]                           = S_AXI_BREADY[0+:1];
    assign M_AXI_ARID[0+:C_AXI_ID_WIDTH]                = f_extend_ID(S_AXI_ARID[0+:C_AXI_ID_WIDTH], 0);
    assign M_AXI_ARADDR[0+:C_AXI_ADDR_WIDTH]            = S_AXI_ARADDR[0+:C_AXI_ADDR_WIDTH];
    assign M_AXI_ARLEN[0+:8]                            = S_AXI_ARLEN[0+:8];
    assign M_AXI_ARSIZE[0+:3]                           = S_AXI_ARSIZE[0+:3];
    assign M_AXI_ARBURST[0+:2]                          = S_AXI_ARBURST[0+:2];
    assign M_AXI_ARLOCK[0+:2]                           = S_AXI_ARLOCK[0+:2];
    assign M_AXI_ARCACHE[0+:4]                          = S_AXI_ARCACHE[0+:4];
    assign M_AXI_ARPROT[0+:3]                           = S_AXI_ARPROT[0+:3];
    assign M_AXI_ARREGION[0+:4]                         = 4'b0;
    assign M_AXI_ARQOS[0+:4]                            = S_AXI_ARQOS[0+:4];
    assign M_AXI_ARUSER[0+:C_AXI_ARUSER_WIDTH]          = S_AXI_ARUSER[0+:C_AXI_ARUSER_WIDTH];
    assign M_AXI_ARVALID[0+:1]                          = S_AXI_ARVALID[0+:1];
    assign S_AXI_ARREADY[0+:1]                          = M_AXI_ARREADY[0+:1];
    assign S_AXI_RID[0+:C_AXI_ID_WIDTH]                 = M_AXI_RID[0+:C_AXI_ID_WIDTH];
    assign S_AXI_RDATA[0+:C_AXI_DATA_MAX_WIDTH]         = M_AXI_RDATA[0+:C_AXI_DATA_MAX_WIDTH];
    assign S_AXI_RRESP[0+:2]                            = M_AXI_RRESP[0+:2];
    assign S_AXI_RLAST[0+:1]                            = M_AXI_RLAST[0+:1];
    assign S_AXI_RUSER[0+:C_AXI_RUSER_WIDTH]            = M_AXI_RUSER[0+:C_AXI_RUSER_WIDTH];
    assign S_AXI_RVALID[0+:1]                           = M_AXI_RVALID[0+:1];
    assign M_AXI_RREADY[0+:1]                           = S_AXI_RREADY[0+:1];
    
    assign DEBUG_AW_TRANS_SEQ     = 0;
    assign DEBUG_AW_ERROR         = 0;
    assign DEBUG_AW_TARGET        = 0;
    assign DEBUG_AW_ARB_GRANT     = 0;
    assign DEBUG_AR_TRANS_SEQ     = 0;
    assign DEBUG_AR_ERROR         = 0;
    assign DEBUG_AR_TARGET        = 0;
    assign DEBUG_AR_ARB_GRANT     = 0;
    assign DEBUG_R_BEAT_CNT       = 0;
    assign DEBUG_W_BEAT_CNT       = 0;
    
  end else begin : gen_crossbar
    
  axi_interconnect_v1_7_13_addr_arbiter_sasd #
      (
       .C_MAX_S                 (C_MAX_S),
       .C_FAMILY                (C_FAMILY),
       .C_NUM_S                 (C_NUM_SLAVE_SLOTS),
       .C_NUM_S_LOG             (P_NUM_SLAVE_SLOTS_LOG),
       .C_AMESG_WIDTH            (P_AMESG_WIDTH),
       .C_GRANT_ENC             (1),
       .C_ARB_PRIORITY          (C_S_AXI_ARB_PRIORITY)
       )
      addr_arbiter_inst
        (
         .ACLK                  (INTERCONNECT_ACLK),
         .ARESET                (reset),
         // Vector of SI-side AW command request inputs
         .S_AWMESG                (si_awmesg),
         .S_ARMESG                (si_armesg),
         .S_AWVALID               (S_AXI_AWVALID),
         .S_AWREADY               (S_AXI_AWREADY),
         .S_ARVALID               (S_AXI_ARVALID),
         .S_ARREADY               (S_AXI_ARREADY),
         .M_GRANT_ENC           (aa_grant_enc),
         .M_GRANT_HOT           (aa_grant_hot),  // SI-slot 1-hot mask of granted command
         .M_GRANT_ANY             (aa_grant_any),
         .M_GRANT_RNW             (aa_grant_rnw),
         .M_AMESG                (aa_amesg),  // Either S_AWMESG or S_ARMESG, as indicated by M_AWVALID and M_ARVALID.
         .M_AWVALID               (aa_awvalid),
         .M_AWREADY               (aa_awready),
         .M_ARVALID               (aa_arvalid),
         .M_ARREADY               (aa_arready)
         );
    assign DEBUG_AW_ARB_GRANT = aa_grant_rnw ? 0 : aa_grant_enc;
    assign DEBUG_AR_ARB_GRANT = aa_grant_rnw ? aa_grant_enc : 0;
         
    if (C_ADDR_DECODE) begin : gen_addr_decoder
  axi_interconnect_v1_7_13_addr_decoder #
        (
          .C_FAMILY          (C_FAMILY),
          .C_NUM_TARGETS     (C_NUM_MASTER_SLOTS),
          .C_NUM_TARGETS_LOG (P_NUM_MASTER_SLOTS_LOG),
          .C_NUM_RANGES      (C_NUM_ADDR_RANGES),
          .C_ADDR_WIDTH      (C_AXI_ADDR_WIDTH),
          .C_TARGET_ENC      (1),
          .C_TARGET_HOT      (1),
          .C_REGION_ENC      (1),
          .C_BASE_ADDR      (C_M_AXI_BASE_ADDR),
          .C_HIGH_ADDR      (C_M_AXI_HIGH_ADDR),
          .C_TARGET_QUAL     ({C_NUM_MASTER_SLOTS{1'b1}}),
          .C_RESOLUTION      (12)
        ) 
        addr_decoder_inst 
        (
          .ADDR             (mi_aaddr),        
          .TARGET_HOT       (target_mi_hot),  
          .TARGET_ENC       (target_mi_enc),  
          .MATCH            (match),       
          .REGION           (region)      
        );
    end else begin : gen_no_addr_decoder
      assign target_mi_hot = 1;
      assign match = 1'b1;
      assign region = 4'b0000;
    end
    
    // AW-channel arbiter command transfer completes upon completion of both M-side AW-channel transfer and B channel completion.
  axi_interconnect_v1_7_13_splitter #  
      (
        .C_NUM_M                (3)
      )
      splitter_aw
      (
         .ACLK                  (INTERCONNECT_ACLK),
         .ARESET                (reset),
         .S_VALID              (aa_awvalid),
         .S_READY              (aa_awready),
         .M_VALID              ({mi_awvalid_en, w_transfer_en, b_transfer_en}),
         .M_READY              ({mi_awready_mux, w_complete_mux, b_complete_mux})
      );
    
    // AR-channel arbiter command transfer completes upon completion of both M-side AR-channel transfer and R channel completion.
  axi_interconnect_v1_7_13_splitter #  
      (
        .C_NUM_M                (2)
      )
      splitter_ar
      (
         .ACLK                  (INTERCONNECT_ACLK),
         .ARESET                (reset),
         .S_VALID              (aa_arvalid),
         .S_READY              (aa_arready),
         .M_VALID              ({mi_arvalid_en, r_transfer_en}),
         .M_READY              ({mi_arready_mux, r_complete_mux})
      );
    
    assign target_secure = |(target_mi_hot & C_M_AXI_SECURE);
    assign target_axilite = |(target_mi_hot & P_M_AXILITE_MASK);
    assign target_write = |(target_mi_hot & C_M_AXI_SUPPORTS_WRITE);
    assign target_read = |(target_mi_hot & C_M_AXI_SUPPORTS_READ);
    
    assign any_error = C_RANGE_CHECK && (m_aerror_i != 0);             // DECERR if error-detection enabled and any error condition.
    assign m_aerror_i[0] = ~match;                                     // Invalid target address
    assign m_aerror_i[1] = target_secure && mi_aprot[P_NONSECURE_BIT]; // TrustZone violation
    assign m_aerror_i[2] = target_axilite && ((mi_alen != 0) || 
      (mi_asize[1:0] == 2'b11) || (mi_asize[2] == 1'b1));              // AxiLite access violation
    assign m_aerror_i[3] = (~aa_grant_rnw && ~target_write) ||
      (aa_grant_rnw && ~target_read);                                  // R/W direction unsupported by target
    assign m_aerror_i[7:4] = 1'b0;                                     // Reserved
    assign DEBUG_AW_ERROR = aa_grant_rnw ? 0 : m_aerror_i;
    assign DEBUG_AR_ERROR = aa_grant_rnw ? m_aerror_i : 0;
    assign m_atarget_enc_comb = any_error ? (P_NUM_MASTER_SLOTS_DE-1) : target_mi_enc;  // Select MI slot or decerr_slave
    assign DEBUG_AW_TARGET = aa_grant_rnw ? 0 : m_atarget_enc_comb;
    assign DEBUG_AR_TARGET = aa_grant_rnw ? m_atarget_enc_comb : 0;
      
    always @(posedge INTERCONNECT_ACLK) begin
      if (reset) begin
        m_atarget_hot <= 0;
      end else begin
        m_atarget_hot <= {P_NUM_MASTER_SLOTS_DE{aa_grant_any}} & (any_error ? {1'b1, {C_NUM_MASTER_SLOTS{1'b0}}} : {1'b0, target_mi_hot});  // Select MI slot or decerr_slave
      end
      m_atarget_enc <= m_atarget_enc_comb;
    end
    
    // Receive AWREADY from targeted MI.
  axi_interconnect_v1_7_13_mux_enc # 
      (
       .C_FAMILY      (C_FAMILY),
       .C_RATIO       (P_NUM_MASTER_SLOTS_DE),
       .C_SEL_WIDTH   (P_NUM_MASTER_SLOTS_DE_LOG),
       .C_DATA_WIDTH  (1)
      ) mi_awready_mux_inst 
      (
       .S   (m_atarget_enc),
       .A   (mi_awready),
       .O   (mi_awready_mux),
       .OE  (mi_awvalid_en)
      ); 
      
    // Receive ARREADY from targeted MI.
  axi_interconnect_v1_7_13_mux_enc # 
      (
       .C_FAMILY      (C_FAMILY),
       .C_RATIO       (P_NUM_MASTER_SLOTS_DE),
       .C_SEL_WIDTH   (P_NUM_MASTER_SLOTS_DE_LOG),
       .C_DATA_WIDTH  (1)
      ) mi_arready_mux_inst 
      (
       .S   (m_atarget_enc),
       .A   (mi_arready),
       .O   (mi_arready_mux),
       .OE  (mi_arvalid_en)
      ); 
      
    assign mi_awvalid = m_atarget_hot & {P_NUM_MASTER_SLOTS_DE{mi_awvalid_en}};  // Assert AWVALID on targeted MI.
    assign mi_arvalid = m_atarget_hot & {P_NUM_MASTER_SLOTS_DE{mi_arvalid_en}};  // Assert ARVALID on targeted MI.
    assign M_AXI_AWVALID = mi_awvalid[0+:C_NUM_MASTER_SLOTS];  // Propagate to MI slots.
    assign M_AXI_ARVALID = mi_arvalid[0+:C_NUM_MASTER_SLOTS];  // Propagate to MI slots.
    assign mi_awready[0+:C_NUM_MASTER_SLOTS] = M_AXI_AWREADY;  // Copy from MI slots.
    assign mi_arready[0+:C_NUM_MASTER_SLOTS] = M_AXI_ARREADY;  // Copy from MI slots.
    
    // Receive WREADY from targeted MI.
  axi_interconnect_v1_7_13_mux_enc # 
      (
       .C_FAMILY      (C_FAMILY),
       .C_RATIO       (P_NUM_MASTER_SLOTS_DE),
       .C_SEL_WIDTH   (P_NUM_MASTER_SLOTS_DE_LOG),
       .C_DATA_WIDTH  (1)
      ) mi_wready_mux_inst 
      (
       .S   (m_atarget_enc),
       .A   (mi_wready),
       .O   (aa_wready),
       .OE  (w_transfer_en)
      ); 
      
    assign mi_wvalid = m_atarget_hot & {P_NUM_MASTER_SLOTS_DE{aa_wvalid}};  // Assert WVALID on targeted MI.
    assign si_wready = aa_grant_hot & {C_NUM_SLAVE_SLOTS{aa_wready}};  // Assert WREADY on granted SI.
    assign S_AXI_WREADY = si_wready;
    assign w_complete_mux = aa_wready & aa_wvalid & mi_wlast;  // W burst complete on on designated SI/MI.
    
    // Receive RREADY from granted SI.
  axi_interconnect_v1_7_13_mux_enc # 
      (
       .C_FAMILY      (C_FAMILY),
       .C_RATIO       (C_NUM_SLAVE_SLOTS),
       .C_SEL_WIDTH   (P_NUM_SLAVE_SLOTS_LOG),
       .C_DATA_WIDTH  (1)
      ) si_rready_mux_inst 
      (
       .S   (aa_grant_enc),
       .A   (S_AXI_RREADY),
       .O   (si_rready),
       .OE  (r_transfer_en)
      ); 
      
    assign sr_rready = si_rready & r_transfer_en;
    assign mi_rready = m_atarget_hot & {P_NUM_MASTER_SLOTS_DE{aa_rready}};  // Assert RREADY on targeted MI.
    assign si_rvalid = aa_grant_hot & {C_NUM_SLAVE_SLOTS{sr_rvalid}};  // Assert RVALID on granted SI.
    assign S_AXI_RVALID = si_rvalid;
    assign r_complete_mux = sr_rready & sr_rvalid & si_rlast;  // R burst complete on on designated SI/MI.
    
    // Receive BREADY from granted SI.
  axi_interconnect_v1_7_13_mux_enc # 
      (
       .C_FAMILY      (C_FAMILY),
       .C_RATIO       (C_NUM_SLAVE_SLOTS),
       .C_SEL_WIDTH   (P_NUM_SLAVE_SLOTS_LOG),
       .C_DATA_WIDTH  (1)
      ) si_bready_mux_inst 
      (
       .S   (aa_grant_enc),
       .A   (S_AXI_BREADY),
       .O   (si_bready),
       .OE  (b_transfer_en)
      ); 
      
    assign aa_bready = si_bready & b_transfer_en;
    assign mi_bready = m_atarget_hot & {P_NUM_MASTER_SLOTS_DE{aa_bready}};  // Assert BREADY on targeted MI.
    assign si_bvalid = aa_grant_hot & {C_NUM_SLAVE_SLOTS{aa_bvalid}};  // Assert BVALID on granted SI.
    assign S_AXI_BVALID = si_bvalid;
    assign b_complete_mux = aa_bready & aa_bvalid;  // B transfer complete on on designated SI/MI.
    
    for (gen_si_slot=0; gen_si_slot<C_NUM_SLAVE_SLOTS; gen_si_slot=gen_si_slot+1) begin : gen_si_amesg
      assign si_armesg[gen_si_slot*P_AMESG_WIDTH +: P_AMESG_WIDTH] = {  // Concatenate from MSB to LSB
        S_AXI_ARUSER[gen_si_slot*C_AXI_ARUSER_WIDTH +: C_AXI_ARUSER_WIDTH],
        S_AXI_ARQOS[gen_si_slot*4+:4],
        S_AXI_ARCACHE[gen_si_slot*4+:4],
        S_AXI_ARBURST[gen_si_slot*2+:2],
        S_AXI_ARPROT[gen_si_slot*3+:3],
        S_AXI_ARLOCK[gen_si_slot*2+:2],
        S_AXI_ARSIZE[gen_si_slot*3+:3],
        S_AXI_ARLEN[gen_si_slot*8+:8],
        S_AXI_ARADDR[gen_si_slot*C_AXI_ADDR_WIDTH +: C_AXI_ADDR_WIDTH],
        f_extend_ID(S_AXI_ARID[gen_si_slot*C_AXI_ID_WIDTH +: C_AXI_ID_WIDTH], gen_si_slot)
        };
      assign si_awmesg[gen_si_slot*P_AMESG_WIDTH +: P_AMESG_WIDTH] = {  // Concatenate from MSB to LSB
        S_AXI_AWUSER[gen_si_slot*C_AXI_AWUSER_WIDTH +: C_AXI_AWUSER_WIDTH],
        S_AXI_AWQOS[gen_si_slot*4+:4],
        S_AXI_AWCACHE[gen_si_slot*4+:4],
        S_AXI_AWBURST[gen_si_slot*2+:2],
        S_AXI_AWPROT[gen_si_slot*3+:3],
        S_AXI_AWLOCK[gen_si_slot*2+:2],
        S_AXI_AWSIZE[gen_si_slot*3+:3],
        S_AXI_AWLEN[gen_si_slot*8+:8],
        S_AXI_AWADDR[gen_si_slot*C_AXI_ADDR_WIDTH +: C_AXI_ADDR_WIDTH],
        f_extend_ID(S_AXI_AWID[gen_si_slot*C_AXI_ID_WIDTH+:C_AXI_ID_WIDTH], gen_si_slot)
        };
    end  // gen_si_amesg
      
    assign mi_aid        = aa_amesg[0 +: C_AXI_ID_WIDTH];
    assign mi_aaddr      = aa_amesg[C_AXI_ID_WIDTH +: C_AXI_ADDR_WIDTH];
    assign mi_alen       = aa_amesg[C_AXI_ID_WIDTH+C_AXI_ADDR_WIDTH +: 8];
    assign mi_asize      = aa_amesg[C_AXI_ID_WIDTH+C_AXI_ADDR_WIDTH+8 +: 3];
    assign mi_alock      = aa_amesg[C_AXI_ID_WIDTH+C_AXI_ADDR_WIDTH+8+3 +: 2];
    assign mi_aprot      = aa_amesg[C_AXI_ID_WIDTH+C_AXI_ADDR_WIDTH+8+3+2 +: 3];
    assign mi_aburst     = aa_amesg[C_AXI_ID_WIDTH+C_AXI_ADDR_WIDTH+8+3+2+3 +: 2];
    assign mi_acache     = aa_amesg[C_AXI_ID_WIDTH+C_AXI_ADDR_WIDTH+8+3+2+3+2 +: 4];
    assign mi_aqos       = aa_amesg[C_AXI_ID_WIDTH+C_AXI_ADDR_WIDTH+8+3+2+3+2+4 +: 4];
    assign mi_auser      = aa_amesg[C_AXI_ID_WIDTH+C_AXI_ADDR_WIDTH+8+3+2+3+2+4+4 +: P_AXI_AUSER_WIDTH];
    
    // Broadcast AW transfer payload to all MI-slots
    assign M_AXI_AWID        = {C_NUM_MASTER_SLOTS{mi_aid}};
    assign M_AXI_AWADDR      = {C_NUM_MASTER_SLOTS{mi_aaddr}};
    assign M_AXI_AWLEN       = {C_NUM_MASTER_SLOTS{mi_alen }};
    assign M_AXI_AWSIZE      = {C_NUM_MASTER_SLOTS{mi_asize}};
    assign M_AXI_AWLOCK      = {C_NUM_MASTER_SLOTS{mi_alock}};
    assign M_AXI_AWPROT      = {C_NUM_MASTER_SLOTS{mi_aprot}};
    assign M_AXI_AWREGION    = {C_NUM_MASTER_SLOTS{region}};
    assign M_AXI_AWBURST     = {C_NUM_MASTER_SLOTS{mi_aburst}};
    assign M_AXI_AWCACHE     = {C_NUM_MASTER_SLOTS{mi_acache}};
    assign M_AXI_AWQOS       = {C_NUM_MASTER_SLOTS{mi_aqos  }};
    assign M_AXI_AWUSER      = {C_NUM_MASTER_SLOTS{mi_auser[0+:C_AXI_AWUSER_WIDTH] }};
    
    // Broadcast AR transfer payload to all MI-slots
    assign M_AXI_ARID        = {C_NUM_MASTER_SLOTS{mi_aid}};
    assign M_AXI_ARADDR      = {C_NUM_MASTER_SLOTS{mi_aaddr}};                        
    assign M_AXI_ARLEN       = {C_NUM_MASTER_SLOTS{mi_alen }};                        
    assign M_AXI_ARSIZE      = {C_NUM_MASTER_SLOTS{mi_asize}};                        
    assign M_AXI_ARLOCK      = {C_NUM_MASTER_SLOTS{mi_alock}};                        
    assign M_AXI_ARPROT      = {C_NUM_MASTER_SLOTS{mi_aprot}};                        
    assign M_AXI_ARREGION    = {C_NUM_MASTER_SLOTS{region}};                          
    assign M_AXI_ARBURST     = {C_NUM_MASTER_SLOTS{mi_aburst}};                       
    assign M_AXI_ARCACHE     = {C_NUM_MASTER_SLOTS{mi_acache}};                       
    assign M_AXI_ARQOS       = {C_NUM_MASTER_SLOTS{mi_aqos  }};                       
    assign M_AXI_ARUSER      = {C_NUM_MASTER_SLOTS{mi_auser[0+:C_AXI_ARUSER_WIDTH] }};
    
    // W-channel MI handshakes
    assign M_AXI_WVALID = mi_wvalid[0+:C_NUM_MASTER_SLOTS];
    assign mi_wready[0+:C_NUM_MASTER_SLOTS] = M_AXI_WREADY;
    // Broadcast W transfer payload to all MI-slots
    assign M_AXI_WLAST = {C_NUM_MASTER_SLOTS{mi_wlast}};
    assign M_AXI_WUSER = {C_NUM_MASTER_SLOTS{mi_wuser}};
    for (gen_mi_slot=0; gen_mi_slot<C_NUM_MASTER_SLOTS; gen_mi_slot=gen_mi_slot+1) begin : gen_mi_wdata
      assign M_AXI_WDATA[gen_mi_slot*C_AXI_DATA_MAX_WIDTH+:C_AXI_DATA_MAX_WIDTH] = mi_wdata;
      assign M_AXI_WSTRB[gen_mi_slot*C_AXI_DATA_MAX_WIDTH/8+:C_AXI_DATA_MAX_WIDTH/8] = mi_wstrb;
    end
    
    // Broadcast R transfer payload to all SI-slots
    assign S_AXI_RLAST = {C_NUM_SLAVE_SLOTS{si_rlast}};
    assign S_AXI_RRESP = {C_NUM_SLAVE_SLOTS{si_rresp}};
    assign S_AXI_RUSER = {C_NUM_SLAVE_SLOTS{si_ruser}};
    for (gen_si_slot=0; gen_si_slot<C_NUM_SLAVE_SLOTS; gen_si_slot=gen_si_slot+1) begin : gen_si_rdata
      assign S_AXI_RDATA[gen_si_slot*C_AXI_DATA_MAX_WIDTH+:C_AXI_DATA_MAX_WIDTH] = si_rdata;
    end
    assign S_AXI_RID = {C_NUM_SLAVE_SLOTS{mi_aid}};
    
    // Broadcast B transfer payload to all SI-slots
    assign S_AXI_BRESP = {C_NUM_SLAVE_SLOTS{si_bresp}};
    assign S_AXI_BUSER = {C_NUM_SLAVE_SLOTS{si_buser}};
    assign S_AXI_BID = {C_NUM_SLAVE_SLOTS{mi_aid}};
    
    // W-channel SI mux
    if (C_NUM_SLAVE_SLOTS>1) begin : gen_wmux
  axi_interconnect_v1_7_13_mux_enc # 
        (
         .C_FAMILY      (C_FAMILY),
         .C_RATIO       (C_NUM_SLAVE_SLOTS),
         .C_SEL_WIDTH   (P_NUM_SLAVE_SLOTS_LOG),
         .C_DATA_WIDTH  (P_WMESG_WIDTH)
        ) si_w_payload_mux_inst 
        (
         .S   (aa_grant_enc),
         .A   (si_wmesg),
         .O   (mi_wmesg),
         .OE  (1'b1)
        ); 
        
      for (gen_si_slot=0; gen_si_slot<C_NUM_SLAVE_SLOTS; gen_si_slot=gen_si_slot+1) begin : gen_wmesg
        assign si_wmesg[gen_si_slot*P_WMESG_WIDTH+:P_WMESG_WIDTH] = {  // Concatenate from MSB to LSB
          S_AXI_WUSER[gen_si_slot*C_AXI_WUSER_WIDTH+:C_AXI_WUSER_WIDTH],
          S_AXI_WSTRB[gen_si_slot*C_AXI_DATA_MAX_WIDTH/8+:C_INTERCONNECT_DATA_WIDTH/8],
          S_AXI_WDATA[gen_si_slot*C_AXI_DATA_MAX_WIDTH+:C_INTERCONNECT_DATA_WIDTH],
          S_AXI_WLAST[gen_si_slot*1+:1],
          S_AXI_WVALID[gen_si_slot*1+:1]
        };
      end  // gen_wmesg
      
      assign aa_wvalid = w_transfer_en & mi_wmesg[0];
      assign mi_wlast = mi_wmesg[1];
      assign mi_wdata = mi_wmesg[2 +: C_INTERCONNECT_DATA_WIDTH];
      assign mi_wstrb = mi_wmesg[2+C_INTERCONNECT_DATA_WIDTH +: C_INTERCONNECT_DATA_WIDTH/8];
      assign mi_wuser = mi_wmesg[2+C_INTERCONNECT_DATA_WIDTH+C_INTERCONNECT_DATA_WIDTH/8 +: C_AXI_WUSER_WIDTH];
    end else begin : gen_no_wmux
      assign aa_wvalid = w_transfer_en & S_AXI_WVALID;
      assign mi_wlast  = S_AXI_WLAST;
      assign mi_wdata  = S_AXI_WDATA[0+:C_INTERCONNECT_DATA_WIDTH];
      assign mi_wstrb  = S_AXI_WSTRB[0+:C_INTERCONNECT_DATA_WIDTH/8];
      assign mi_wuser  = S_AXI_WUSER;
    end  // gen_wmux
    
    // Receive RVALID from targeted MI.
  axi_interconnect_v1_7_13_mux_enc # 
      (
       .C_FAMILY      (C_FAMILY),
       .C_RATIO       (P_NUM_MASTER_SLOTS_DE),
       .C_SEL_WIDTH   (P_NUM_MASTER_SLOTS_DE_LOG),
       .C_DATA_WIDTH  (1)
      ) mi_rvalid_mux_inst 
      (
       .S   (m_atarget_enc),
       .A   (mi_rvalid),
       .O   (aa_rvalid),
       .OE  (r_transfer_en)
      ); 
      
    // MI R-channel payload mux
  axi_interconnect_v1_7_13_mux_enc # 
      (
       .C_FAMILY      (C_FAMILY),
       .C_RATIO       (P_NUM_MASTER_SLOTS_DE),
       .C_SEL_WIDTH   (P_NUM_MASTER_SLOTS_DE_LOG),
       .C_DATA_WIDTH  (P_RMESG_WIDTH)
      ) mi_rmesg_mux_inst 
      (
       .S   (m_atarget_enc),
       .A   (mi_rmesg),
       .O   (aa_rmesg),
       .OE  (1'b1)
      ); 
      
  axi_interconnect_v1_7_13_axic_register_slice #
      (
       .C_FAMILY (C_FAMILY),
       .C_DATA_WIDTH (P_RMESG_WIDTH),
       .C_REG_CONFIG (P_R_REG_CONFIG)
       )
      reg_slice_r
      (
       // System Signals
       .ACLK(INTERCONNECT_ACLK),
       .ARESET(reset),

       // Slave side
       .S_PAYLOAD_DATA(aa_rmesg),
       .S_VALID(aa_rvalid),
       .S_READY(aa_rready),

       // Master side
       .M_PAYLOAD_DATA(sr_rmesg),
       .M_VALID(sr_rvalid),
       .M_READY(sr_rready)
       );

    assign mi_rvalid[0+:C_NUM_MASTER_SLOTS] = M_AXI_RVALID; 
    assign mi_rlast[0+:C_NUM_MASTER_SLOTS] = M_AXI_RLAST; 
    assign mi_rresp[0+:C_NUM_MASTER_SLOTS*2] = M_AXI_RRESP;
    assign mi_ruser[0+:C_NUM_MASTER_SLOTS*C_AXI_RUSER_WIDTH] = M_AXI_RUSER;
    assign mi_rdata[0+:C_NUM_MASTER_SLOTS*C_AXI_DATA_MAX_WIDTH] = M_AXI_RDATA;
    assign M_AXI_RREADY = mi_rready[0+:C_NUM_MASTER_SLOTS];
    
    for (gen_mi_slot=0; gen_mi_slot<P_NUM_MASTER_SLOTS_DE; gen_mi_slot=gen_mi_slot+1) begin : gen_rmesg
      assign mi_rmesg[gen_mi_slot*P_RMESG_WIDTH+:P_RMESG_WIDTH] = {  // Concatenate from MSB to LSB
        mi_ruser[gen_mi_slot*C_AXI_RUSER_WIDTH+:C_AXI_RUSER_WIDTH],
        mi_rdata[gen_mi_slot*C_AXI_DATA_MAX_WIDTH+:C_INTERCONNECT_DATA_WIDTH],
        mi_rresp[gen_mi_slot*2+:2],
        mi_rlast[gen_mi_slot*1+:1]
      };
    end  // gen_rmesg
    
    assign si_rlast = sr_rmesg[0];
    assign si_rresp = sr_rmesg[1 +: 2];
    assign si_rdata = sr_rmesg[1+2 +: C_INTERCONNECT_DATA_WIDTH];
    assign si_ruser = sr_rmesg[1+2+C_INTERCONNECT_DATA_WIDTH +: C_AXI_RUSER_WIDTH];
    
    // Receive BVALID from targeted MI.
  axi_interconnect_v1_7_13_mux_enc # 
      (
       .C_FAMILY      (C_FAMILY),
       .C_RATIO       (P_NUM_MASTER_SLOTS_DE),
       .C_SEL_WIDTH   (P_NUM_MASTER_SLOTS_DE_LOG),
       .C_DATA_WIDTH  (1)
      ) mi_bvalid_mux_inst 
      (
       .S   (m_atarget_enc),
       .A   (mi_bvalid),
       .O   (aa_bvalid),
       .OE  (b_transfer_en)
      ); 
      
    // MI B-channel payload mux
  axi_interconnect_v1_7_13_mux_enc # 
      (
       .C_FAMILY      (C_FAMILY),
       .C_RATIO       (P_NUM_MASTER_SLOTS_DE),
       .C_SEL_WIDTH   (P_NUM_MASTER_SLOTS_DE_LOG),
       .C_DATA_WIDTH  (P_BMESG_WIDTH)
      ) mi_bmesg_mux_inst 
      (
       .S   (m_atarget_enc),
       .A   (mi_bmesg),
       .O   (si_bmesg),
       .OE  (1'b1)
      ); 
      
    assign mi_bvalid[0+:C_NUM_MASTER_SLOTS] = M_AXI_BVALID; 
    assign mi_bresp[0+:C_NUM_MASTER_SLOTS*2] = M_AXI_BRESP;
    assign mi_buser[0+:C_NUM_MASTER_SLOTS*C_AXI_BUSER_WIDTH] = M_AXI_BUSER;
    assign M_AXI_BREADY = mi_bready[0+:C_NUM_MASTER_SLOTS];
    
    for (gen_mi_slot=0; gen_mi_slot<P_NUM_MASTER_SLOTS_DE; gen_mi_slot=gen_mi_slot+1) begin : gen_bmesg
      assign mi_bmesg[gen_mi_slot*P_BMESG_WIDTH+:P_BMESG_WIDTH] = {  // Concatenate from MSB to LSB
        mi_buser[gen_mi_slot*C_AXI_BUSER_WIDTH+:C_AXI_BUSER_WIDTH],
        mi_bresp[gen_mi_slot*2+:2]
      };
    end  // gen_bmesg
    
    assign si_bresp = si_bmesg[0 +: 2];
    assign si_buser = si_bmesg[2 +: C_AXI_BUSER_WIDTH];
    
    if (C_DEBUG) begin : gen_debug_trans_seq
      // DEBUG WRITE TRANSACTION SEQUENCE COUNTER
      always @(posedge INTERCONNECT_ACLK) begin
        if (reset) begin
          debug_aw_trans_seq_i <= 1;
        end else begin
          if (aa_awvalid && aa_awready) begin
            debug_aw_trans_seq_i <= debug_aw_trans_seq_i + 1;
          end
        end
      end
  
      // DEBUG READ TRANSACTION SEQUENCE COUNTER
      always @(posedge INTERCONNECT_ACLK) begin
        if (reset) begin
          debug_ar_trans_seq_i <= 1;
        end else begin
          if (aa_arvalid && aa_arready) begin
            debug_ar_trans_seq_i <= debug_ar_trans_seq_i + 1;
          end
        end
      end
      
      // DEBUG WRITE BEAT COUNTER 
      always @(posedge INTERCONNECT_ACLK) begin
        if (reset) begin
          debug_w_beat_cnt_i <= 0;
        end else if (aa_wready & aa_wvalid) begin
          if (mi_wlast) begin
            debug_w_beat_cnt_i <= 0;
          end else begin
            debug_w_beat_cnt_i <= debug_w_beat_cnt_i + 1;
          end
        end
      end  // Clocked process
    
      // DEBUG READ BEAT COUNTER 
      always @(posedge INTERCONNECT_ACLK) begin
        if (reset) begin
          debug_r_beat_cnt_i <= 0;
        end else if (sr_rready & sr_rvalid) begin
          if (si_rlast) begin
            debug_r_beat_cnt_i <= 0;
          end else begin
            debug_r_beat_cnt_i <= debug_r_beat_cnt_i + 1;
          end
        end
      end  // Clocked process
    
      assign DEBUG_AW_TRANS_SEQ = debug_aw_trans_seq_i;
      assign DEBUG_AR_TRANS_SEQ = debug_ar_trans_seq_i;
      assign DEBUG_W_BEAT_CNT = debug_w_beat_cnt_i;
      assign DEBUG_R_BEAT_CNT = debug_r_beat_cnt_i;
    end else begin : gen_no_debug_trans_seq
      assign DEBUG_AW_TRANS_SEQ = 0;
      assign DEBUG_AR_TRANS_SEQ = 0;
      assign DEBUG_W_BEAT_CNT = 0;
      assign DEBUG_R_BEAT_CNT = 0;
    end  // gen_debug_trans_seq

    if (C_RANGE_CHECK) begin : gen_decerr
      // Highest MI-slot (index C_NUM_MASTER_SLOTS) is the error handler
  axi_interconnect_v1_7_13_decerr_slave #
        (
         .C_AXI_ID_WIDTH                 (1),
         .C_AXI_DATA_WIDTH               (C_INTERCONNECT_DATA_WIDTH),
         .C_AXI_RUSER_WIDTH                (C_AXI_RUSER_WIDTH),
         .C_AXI_BUSER_WIDTH                (C_AXI_BUSER_WIDTH)
        )
        decerr_slave_inst
          (
           .S_AXI_ACLK (INTERCONNECT_ACLK),
           .S_AXI_ARESET (reset),
           .S_AXI_AWID (1'b0),
           .S_AXI_AWVALID (mi_awvalid[C_NUM_MASTER_SLOTS]),
           .S_AXI_AWREADY (mi_awready[C_NUM_MASTER_SLOTS]),
           .S_AXI_WLAST (mi_wlast),
           .S_AXI_WVALID (mi_wvalid[C_NUM_MASTER_SLOTS]),
           .S_AXI_WREADY (mi_wready[C_NUM_MASTER_SLOTS]),
           .S_AXI_BID (),
           .S_AXI_BRESP (mi_bresp[C_NUM_MASTER_SLOTS*2+:2]),
           .S_AXI_BUSER (mi_buser[C_NUM_MASTER_SLOTS*C_AXI_BUSER_WIDTH+:C_AXI_BUSER_WIDTH]),
           .S_AXI_BVALID (mi_bvalid[C_NUM_MASTER_SLOTS]),
           .S_AXI_BREADY (mi_bready[C_NUM_MASTER_SLOTS]),
           .S_AXI_ARID (1'b0),
           .S_AXI_ARLEN (mi_alen),
           .S_AXI_ARVALID (mi_arvalid[C_NUM_MASTER_SLOTS]),
           .S_AXI_ARREADY (mi_arready[C_NUM_MASTER_SLOTS]),
           .S_AXI_RID (),
           .S_AXI_RDATA (mi_rdata[C_NUM_MASTER_SLOTS*C_AXI_DATA_MAX_WIDTH+:C_INTERCONNECT_DATA_WIDTH]),
           .S_AXI_RRESP (mi_rresp[C_NUM_MASTER_SLOTS*2+:2]),
           .S_AXI_RUSER (mi_ruser[C_NUM_MASTER_SLOTS*C_AXI_RUSER_WIDTH+:C_AXI_RUSER_WIDTH]),
           .S_AXI_RLAST (mi_rlast[C_NUM_MASTER_SLOTS]),
           .S_AXI_RVALID (mi_rvalid[C_NUM_MASTER_SLOTS]),
           .S_AXI_RREADY (mi_rready[C_NUM_MASTER_SLOTS])
         );
    end  // gen_decerr

  end  // gen_crossbar
endgenerate

// Control slave port not yet implemented
generate
  if (C_USE_CTRL_PORT) begin : gen_ctrl_port
    assign S_AXI_CTRL_AWREADY = 0;
    assign S_AXI_CTRL_WREADY = 0;
    assign S_AXI_CTRL_BRESP = 0;
    assign S_AXI_CTRL_BVALID = 0;
    assign S_AXI_CTRL_ARREADY = 0;
    assign S_AXI_CTRL_RDATA = 0;
    assign S_AXI_CTRL_RRESP = 0;
    assign S_AXI_CTRL_RVALID = 0;
    assign IRQ = 0;
  end else begin : gen_no_ctrl_port
    assign S_AXI_CTRL_AWREADY = 0;
    assign S_AXI_CTRL_WREADY = 0;
    assign S_AXI_CTRL_BRESP = 0;
    assign S_AXI_CTRL_BVALID = 0;
    assign S_AXI_CTRL_ARREADY = 0;
    assign S_AXI_CTRL_RDATA = 0;
    assign S_AXI_CTRL_RRESP = 0;
    assign S_AXI_CTRL_RVALID = 0;
    assign IRQ = 0;
  end
endgenerate

endmodule

`default_nettype wire


// -- (c) Copyright 2009 - 2011 Xilinx, Inc. All rights reserved.
// --
// -- This file contains confidential and proprietary information
// -- of Xilinx, Inc. and is protected under U.S. and 
// -- international copyright and other intellectual property
// -- laws.
// --
// -- DISCLAIMER
// -- This disclaimer is not a license and does not grant any
// -- rights to the materials distributed herewith. Except as
// -- otherwise provided in a valid license issued to you by
// -- Xilinx, and to the maximum extent permitted by applicable
// -- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
// -- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
// -- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
// -- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
// -- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
// -- (2) Xilinx shall not be liable (whether in contract or tort,
// -- including negligence, or under any other theory of
// -- liability) for any loss or damage of any kind or nature
// -- related to, arising under or in connection with these
// -- materials, including for any direct, or any indirect,
// -- special, incidental, or consequential loss or damage
// -- (including loss of data, profits, goodwill, or any type of
// -- loss or damage suffered as a result of any action brought
// -- by a third party) even if such damage or loss was
// -- reasonably foreseeable or Xilinx had been advised of the
// -- possibility of the same.
// --
// -- CRITICAL APPLICATIONS
// -- Xilinx products are not designed or intended to be fail-
// -- safe, or for use in any application requiring fail-safe
// -- performance, such as life-support or safety devices or
// -- systems, Class III medical devices, nuclear facilities,
// -- applications related to the deployment of airbags, or any
// -- other applications that could lead to death, personal
// -- injury, or severe property or environmental damage
// -- (individually and collectively, "Critical
// -- Applications"). Customer assumes the sole risk and
// -- liability of any use of Xilinx products in Critical
// -- Applications, subject only to applicable laws and
// -- regulations governing limitations on product liability.
// --
// -- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
// -- PART OF THIS FILE AT ALL TIMES.
//-----------------------------------------------------------------------------
//
// File name: crossbar.v
//
// Description: 
//   This module is a M-master to N-slave AXI crossbar switch.
//   The interface of this module consists of a vectored slave and master interface
//     in which all slots are sized and synchronized to the native width and clock 
//     of the interconnect, and are all AXI4 protocol.
//   All width, clock and protocol conversions are done outside this block, as are
//     any pipeline registers or data FIFOs.
//   This module contains all arbitration, decoders and channel multiplexing logic.
//     It also contains the diagnostic registers and control interface.
//
//-----------------------------------------------------------------------------
//
// Structure:
//    crossbar
//      si_transactor
//        addr_decoder
//          comparator_static
//        mux_enc
//        axic_srl_fifo
//        arbiter_resp
//      splitter
//      wdata_router
//        axic_reg_srl_fifo
//      wdata_mux
//        axic_reg_srl_fifo
//        mux_enc
//      addr_decoder
//        comparator_static
//      axic_srl_fifo
//      axi_register_slice
//      addr_arbiter
//        mux_enc
//      decerr_slave
//      
//-----------------------------------------------------------------------------
`timescale 1ps/1ps
`default_nettype none

(* DowngradeIPIdentifiedWarnings="yes" *) 
module axi_interconnect_v1_7_13_crossbar #
  (
   parameter integer C_MAX_S = 16,
   parameter integer C_MAX_M = 16,
   parameter integer C_NUM_ADDR_RANGES = 16,
   parameter         C_FAMILY                       = "none", 
                       // FPGA Family. Current version: virtex6 or spartan6.
   parameter integer C_NUM_SLAVE_SLOTS              =   1, 
                       // Number of Slave Interface (SI) slots for connecting 
                       // to master IP. Range: 1-C_MAX_S.
   parameter integer C_NUM_MASTER_SLOTS             =   1, 
                       // Number of Master Interface (MI) slots for connecting 
                       // to slave IP. Range: 1-C_MAX_M.
   parameter integer C_AXI_ID_WIDTH                   = 1, 
                       // Width of ID signals propagated by the Interconnect.
                       // Width of ID signals produced on all MI slots.
                       // Range: >= 1.
   parameter integer C_AXI_ADDR_WIDTH                 = 32, 
                       // Width of S_AXI_AWADDR, S_AXI_ARADDR, M_AXI_AWADDR and 
                       // M_AXI_ARADDR for all SI/MI slots.
                       // Range: 32.
   parameter integer C_INTERCONNECT_DATA_WIDTH = 32, 
                       // Data width of the internal interconnect write and read 
                       // data paths.
                       // Range: 32, 64, 128, 256.
   parameter integer C_AXI_DATA_MAX_WIDTH             = 32, 
                       // Largest value supported for any DATA_WIDTH.
   parameter [C_MAX_M*32-1:0] C_M_AXI_DATA_WIDTH               = {C_MAX_M{32'h00000020}}, 
                       // Width of M_AXI_WDATA and M_AXI_RDATA for each MI slot.
                       // Format: C_NUM_MASTER_SLOTS{Bit32};
                       // Range: 'h00000020, 'h00000040, 'h00000080, 'h00000100.
                       // Used to determine whether W-channel gets reg-slice.
   parameter [C_MAX_S*32-1:0] C_S_AXI_PROTOCOL                 = {C_MAX_S{32'h00000000}}, 
                       // Indicates whether connected master is 
                       // Full-AXI4 ('h00000000),
                       // AXI3 ('h00000001) or 
                       // Axi4Lite ('h00000002), for each SI slot.
                       // Format: C_NUM_SLAVE_SLOTS{Bit32}.
   parameter [C_MAX_M*32-1:0] C_M_AXI_PROTOCOL                 = {C_MAX_M{32'h00000000}}, 
                       // Indicates whether connected slave is
                       // Full-AXI4 ('h00000000),
                       // AXI3 ('h00000001) or 
                       // Axi4Lite ('h00000002), for each SI slot.
                       // Format: C_NUM_MASTER_SLOTS{Bit32}.
   parameter [C_MAX_M*C_NUM_ADDR_RANGES*64-1:0] C_M_AXI_BASE_ADDR                 = {C_MAX_M*C_NUM_ADDR_RANGES{64'hFFFFFFFF_FFFFFFFF}}, 
                       // Base address of each range of each MI slot. 
                       // For unused ranges, set base address to 'hFFFFFFFF.
                       // Format: C_NUM_MASTER_SLOTS{C_NUM_ADDR_RANGES{Bit64}}.
   parameter [C_MAX_M*C_NUM_ADDR_RANGES*64-1:0] C_M_AXI_HIGH_ADDR                 = {C_MAX_M*C_NUM_ADDR_RANGES{64'h00000000_00000000}}, 
                       // High address of each range of each MI slot. 
                       // For unused ranges, set high address to 'h00000000.
                       // Format: C_NUM_MASTER_SLOTS{C_NUM_ADDR_RANGES{Bit64}}.
   parameter [C_MAX_S*64-1:0] C_S_AXI_BASE_ID                  = {C_MAX_S{64'h00000000_00000000}},
                       // Base ID of each SI slot. 
                       // Format: C_NUM_SLAVE_SLOTS{Bit64};
                       // Range: 0 to 2**C_AXI_ID_WIDTH-1.
   parameter [C_MAX_S*64-1:0] C_S_AXI_HIGH_ID                  = {C_MAX_S{64'h00000000_00000000}},
                       // High ID of each SI slot. 
                       // Format: C_NUM_SLAVE_SLOTS{Bit64};
                       // Range: 0 to 2**C_AXI_ID_WIDTH-1.
   parameter [C_MAX_S*32-1:0] C_S_AXI_THREAD_ID_WIDTH                  = {C_MAX_S{32'h00000000}}, 
   parameter [C_MAX_S*1-1:0] C_S_AXI_IS_INTERCONNECT = {C_MAX_S{1'b0}}, 
                       // Indicates whether connected master is an end-point
                       // master (0) or an interconnect (1), for each SI slot.
                       // Format: C_NUM_SLAVE_SLOTS{Bit1}.
   parameter [C_MAX_S*1-1:0] C_S_AXI_SUPPORTS_WRITE           = {C_MAX_S{1'b0}}, 
                       // Indicates whether each SI supports write transactions.
                       // Format: C_NUM_SLAVE_SLOTS{Bit1}.
   parameter [C_MAX_S*1-1:0] C_S_AXI_SUPPORTS_READ            = {C_MAX_S{1'b0}}, 
                       // Indicates whether each SI supports read transactions.
                       // Format: C_NUM_SLAVE_SLOTS{Bit1}.
   parameter [C_MAX_M*1-1:0] C_M_AXI_SUPPORTS_WRITE           = {C_MAX_M{1'b0}}, 
                       // Indicates whether each MI supports write transactions.
                       // Format: C_NUM_MASTER_SLOTS{Bit1}.
   parameter [C_MAX_M*1-1:0] C_M_AXI_SUPPORTS_READ            = {C_MAX_M{1'b0}}, 
                       // Indicates whether each MI supports read transactions.
                       // Format: C_NUM_MASTER_SLOTS{Bit1}.
   parameter integer C_AXI_SUPPORTS_USER_SIGNALS = 0,
                       // 1 = Propagate all USER signals, 0 = Dont propagate.
   parameter integer C_AXI_AWUSER_WIDTH = 1,
                       // Width of AWUSER signals for all SI slots and MI slots. 
                       // Range: >= 1.
   parameter integer C_AXI_ARUSER_WIDTH = 1,
                       // Width of ARUSER signals for all SI slots and MI slots. 
                       // Range: >= 1.
   parameter integer C_AXI_WUSER_WIDTH = 1,
                       // Width of WUSER signals for all SI slots and MI slots. 
                       // Range: >= 1.
   parameter integer C_AXI_RUSER_WIDTH = 1,
                       // Width of RUSER signals for all SI slots and MI slots. 
                       // Range: >= 1.
   parameter integer C_AXI_BUSER_WIDTH = 1,
                       // Width of BUSER signals for all SI slots and MI slots. 
                       // Range: >= 1.
   parameter [C_MAX_M*32-1:0] C_AXI_CONNECTIVITY               = {C_MAX_M{32'hFFFFFFFF}},
                       // Multi-pathway connectivity from each SI slot (N) to each 
                       // MI slot (M):
                       // 0 = no pathway required; 1 = pathway required.
                       // Format: C_NUM_MASTER_SLOTS{Bit32}; 
                       // Range: C_NUM_SLAVE_SLOTS{Bit1}.
   parameter [C_MAX_S*1-1:0] C_S_AXI_SINGLE_THREAD                 = {C_MAX_S{1'b0}}, 
                       // 0 = Implement separate command queues per ID thread.
                       // 1 = Force corresponding SI slot to be single-threaded.
                       // Format: C_NUM_SLAVE_SLOTS{Bit1}.
   parameter [C_MAX_M*1-1:0] C_M_AXI_SUPPORTS_REORDERING = {C_MAX_M{1'b0}},
                       // Indicates whether the slave connected to each MI slot 
                       // supports response reordering.
                       // Format: C_NUM_MASTER_SLOTS{Bit1}; 
   parameter [C_MAX_S*32-1:0] C_S_AXI_WRITE_ACCEPTANCE = {C_MAX_S{32'h00000020}},
                       // Maximum number of active write transactions that each SI 
                       // slot can accept.
                       // Format: C_NUM_SLAVE_SLOTS{Bit32}; Range: 'h1-'h20.
   parameter [C_MAX_S*32-1:0] C_S_AXI_READ_ACCEPTANCE = {C_MAX_S{32'h00000020}},
                       // Maximum number of active read transactions that each SI 
                       // slot can accept.
                       // Format: C_NUM_SLAVE_SLOTS{Bit32}; Range: 'h1-'h20.
   parameter [C_MAX_M*32-1:0] C_M_AXI_WRITE_ISSUING = {C_MAX_M{32'h00000020}},
                       // Maximum number of data-active write transactions that 
                       // each MI slot can generate at any one time.
                       // Format: C_NUM_MASTER_SLOTS{Bit32}; Range: 'h1-'h20.
                       // Not used in this module; using C_W_ISSUE_WIDTH instead.
   parameter [C_MAX_M*32-1:0] C_M_AXI_READ_ISSUING = {C_MAX_M{32'h00000020}},
                       // Maximum number of active read transactions that 
                       // each MI slot can generate at any one time.
                       // Format: C_NUM_MASTER_SLOTS{Bit32}; Range: 'h1-'h20.
                       // Not used in this module; using C_R_ISSUE_WIDTH instead.
//   parameter         C_S_AXI_ARB_METHOD = "priority", // Reserved for future
//                       // Arbitration method.
//                       // Format: String; 
//                       // Range: "priority" ("tdm" not yet implemented).
   parameter [C_MAX_S*32-1:0] C_S_AXI_ARB_PRIORITY             = {C_MAX_S{32'h00000000}},
                       // Arbitration priority among each SI slot. 
                       // Higher values indicate higher priority.
                       // Format: C_NUM_SLAVE_SLOTS{Bit32};
                       // Range: 'h0-'hF.
//   parameter [C_MAX_S*32-1:0] C_S_AXI_ARB_TDM_SLOTS            = {C_MAX_S{32'h00000000}}, // Reserved for future
//                       // Maximum number of consecutive TDM arbitration slots 
//                       // allocated among each SI slot.
//                       // Format: C_NUM_SLAVE_SLOTS{Bit32});
//   parameter integer C_S_AXI_ARB_TDM_TOTAL            = 0, // Reserved for future
//                       // Total number of TDM arbitration slots during which all 
//                       // TDM masters must be serviced.
//                       // (Must be >= sum of all C_S_AXI_ARB_TDM_SLOTS.)
   parameter [C_MAX_M*1-1:0] C_M_AXI_SECURE                   = {C_MAX_M{1'b0}},
                       // Indicates whether each MI slot connects to a secure slave 
                       // (allows only TrustZone secure access).
                       // Format: C_NUM_MASTER_SLOTS{Bit1}.
   parameter integer C_USE_CTRL_PORT = 0,
                       // Indicates whether diagnostic information is accessible 
                       // via the S_AXI_CTRL interface.
   parameter integer C_USE_INTERRUPT = 1,
                       // If CTRL interface enabled, indicates whether interrupts 
                       // are generated.
   parameter integer C_RANGE_CHECK                    = 0,
                       // 1 = Implement DECERR detection and response handler.
                       // 0 = Pass all transactions without error-checking.
   parameter integer C_ADDR_DECODE                    = 0,
                       // 1 = Implement address decoder.
                       // 0 = Propagate address to single slave.
   parameter integer C_S_AXI_CTRL_ADDR_WIDTH = 32,
                       // ADDR width of CTRL interface.
   parameter integer C_S_AXI_CTRL_DATA_WIDTH = 32,
                       // DATA width of CTRL interface.
   parameter [(C_MAX_M+1)*32-1:0] C_W_ISSUE_WIDTH  = {C_MAX_M+1{32'h00000000}},
   parameter [(C_MAX_M+1)*32-1:0] C_R_ISSUE_WIDTH  = {C_MAX_M+1{32'h00000000}},
   parameter [C_MAX_S*32-1:0] C_W_ACCEPT_WIDTH = {C_MAX_S{32'h00000000}},
   parameter [C_MAX_S*32-1:0] C_R_ACCEPT_WIDTH = {C_MAX_S{32'h00000000}},
   parameter integer C_DEBUG              = 1,
   parameter integer C_MAX_DEBUG_THREADS  = 1
   )
  (
   // Global Signals
   input  wire                                                    INTERCONNECT_ACLK,
   input  wire                                                    ARESETN,
   output wire                                                    IRQ,
   // Slave Interface Write Address Ports
   input  wire [C_NUM_SLAVE_SLOTS*C_AXI_ID_WIDTH-1:0]           S_AXI_AWID,
   input  wire [C_NUM_SLAVE_SLOTS*C_AXI_ADDR_WIDTH-1:0]           S_AXI_AWADDR,
   input  wire [C_NUM_SLAVE_SLOTS*8-1:0]                          S_AXI_AWLEN,
   input  wire [C_NUM_SLAVE_SLOTS*3-1:0]                          S_AXI_AWSIZE,
   input  wire [C_NUM_SLAVE_SLOTS*2-1:0]                          S_AXI_AWBURST,
   input  wire [C_NUM_SLAVE_SLOTS*2-1:0]                          S_AXI_AWLOCK,
   input  wire [C_NUM_SLAVE_SLOTS*4-1:0]                          S_AXI_AWCACHE,
   input  wire [C_NUM_SLAVE_SLOTS*3-1:0]                          S_AXI_AWPROT,
   input  wire [C_NUM_SLAVE_SLOTS*4-1:0]                          S_AXI_AWQOS,
   input  wire [C_NUM_SLAVE_SLOTS*C_AXI_AWUSER_WIDTH-1:0]         S_AXI_AWUSER,
   input  wire [C_NUM_SLAVE_SLOTS-1:0]                            S_AXI_AWVALID,
   output wire [C_NUM_SLAVE_SLOTS-1:0]                            S_AXI_AWREADY,
   // Slave Interface Write Data Ports
   input  wire [C_NUM_SLAVE_SLOTS*C_AXI_DATA_MAX_WIDTH-1:0]     S_AXI_WDATA,
   input  wire [C_NUM_SLAVE_SLOTS*C_AXI_DATA_MAX_WIDTH/8-1:0]   S_AXI_WSTRB,
   input  wire [C_NUM_SLAVE_SLOTS-1:0]                            S_AXI_WLAST,
   input  wire [C_NUM_SLAVE_SLOTS*C_AXI_WUSER_WIDTH-1:0]          S_AXI_WUSER,
   input  wire [C_NUM_SLAVE_SLOTS-1:0]                            S_AXI_WVALID,
   output wire [C_NUM_SLAVE_SLOTS-1:0]                            S_AXI_WREADY,
   // Slave Interface Write Response Ports
   output wire [C_NUM_SLAVE_SLOTS*C_AXI_ID_WIDTH-1:0]           S_AXI_BID,
   output wire [C_NUM_SLAVE_SLOTS*2-1:0]                          S_AXI_BRESP,
   output wire [C_NUM_SLAVE_SLOTS*C_AXI_BUSER_WIDTH-1:0]          S_AXI_BUSER,
   output wire [C_NUM_SLAVE_SLOTS-1:0]                            S_AXI_BVALID,
   input  wire [C_NUM_SLAVE_SLOTS-1:0]                            S_AXI_BREADY,
   // Slave Interface Read Address Ports
   input  wire [C_NUM_SLAVE_SLOTS*C_AXI_ID_WIDTH-1:0]           S_AXI_ARID,
   input  wire [C_NUM_SLAVE_SLOTS*C_AXI_ADDR_WIDTH-1:0]           S_AXI_ARADDR,
   input  wire [C_NUM_SLAVE_SLOTS*8-1:0]                          S_AXI_ARLEN,
   input  wire [C_NUM_SLAVE_SLOTS*3-1:0]                          S_AXI_ARSIZE,
   input  wire [C_NUM_SLAVE_SLOTS*2-1:0]                          S_AXI_ARBURST,
   input  wire [C_NUM_SLAVE_SLOTS*2-1:0]                          S_AXI_ARLOCK,
   input  wire [C_NUM_SLAVE_SLOTS*4-1:0]                          S_AXI_ARCACHE,
   input  wire [C_NUM_SLAVE_SLOTS*3-1:0]                          S_AXI_ARPROT,
   input  wire [C_NUM_SLAVE_SLOTS*4-1:0]                          S_AXI_ARQOS,
   input  wire [C_NUM_SLAVE_SLOTS*C_AXI_ARUSER_WIDTH-1:0]         S_AXI_ARUSER,
   input  wire [C_NUM_SLAVE_SLOTS-1:0]                            S_AXI_ARVALID,
   output wire [C_NUM_SLAVE_SLOTS-1:0]                            S_AXI_ARREADY,
   // Slave Interface Read Data Ports
   output wire [C_NUM_SLAVE_SLOTS*C_AXI_ID_WIDTH-1:0]           S_AXI_RID,
   output wire [C_NUM_SLAVE_SLOTS*C_AXI_DATA_MAX_WIDTH-1:0]     S_AXI_RDATA,
   output wire [C_NUM_SLAVE_SLOTS*2-1:0]                          S_AXI_RRESP,
   output wire [C_NUM_SLAVE_SLOTS-1:0]                            S_AXI_RLAST,
   output wire [C_NUM_SLAVE_SLOTS*C_AXI_RUSER_WIDTH-1:0]          S_AXI_RUSER,
   output wire [C_NUM_SLAVE_SLOTS-1:0]                            S_AXI_RVALID,
   input  wire [C_NUM_SLAVE_SLOTS-1:0]                            S_AXI_RREADY,
   // Master Interface Write Address Port
   output wire [C_NUM_MASTER_SLOTS*C_AXI_ID_WIDTH-1:0]          M_AXI_AWID,
   output wire [C_NUM_MASTER_SLOTS*C_AXI_ADDR_WIDTH-1:0]          M_AXI_AWADDR,
   output wire [C_NUM_MASTER_SLOTS*8-1:0]                         M_AXI_AWLEN,
   output wire [C_NUM_MASTER_SLOTS*3-1:0]                         M_AXI_AWSIZE,
   output wire [C_NUM_MASTER_SLOTS*2-1:0]                         M_AXI_AWBURST,
   output wire [C_NUM_MASTER_SLOTS*2-1:0]                         M_AXI_AWLOCK,
   output wire [C_NUM_MASTER_SLOTS*4-1:0]                         M_AXI_AWCACHE,
   output wire [C_NUM_MASTER_SLOTS*3-1:0]                         M_AXI_AWPROT,
   output wire [C_NUM_MASTER_SLOTS*4-1:0]                         M_AXI_AWREGION,
   output wire [C_NUM_MASTER_SLOTS*4-1:0]                         M_AXI_AWQOS,
   output wire [C_NUM_MASTER_SLOTS*C_AXI_AWUSER_WIDTH-1:0]        M_AXI_AWUSER,
   output wire [C_NUM_MASTER_SLOTS-1:0]                           M_AXI_AWVALID,
   input  wire [C_NUM_MASTER_SLOTS-1:0]                           M_AXI_AWREADY,
   // Master Interface Write Data Ports
   output wire [C_NUM_MASTER_SLOTS*C_AXI_DATA_MAX_WIDTH-1:0]    M_AXI_WDATA,
   output wire [C_NUM_MASTER_SLOTS*C_AXI_DATA_MAX_WIDTH/8-1:0]  M_AXI_WSTRB,
   output wire [C_NUM_MASTER_SLOTS-1:0]                           M_AXI_WLAST,
   output wire [C_NUM_MASTER_SLOTS*C_AXI_WUSER_WIDTH-1:0]         M_AXI_WUSER,
   output wire [C_NUM_MASTER_SLOTS-1:0]                           M_AXI_WVALID,
   input  wire [C_NUM_MASTER_SLOTS-1:0]                           M_AXI_WREADY,
   // Master Interface Write Response Ports
   input  wire [C_NUM_MASTER_SLOTS*C_AXI_ID_WIDTH-1:0]          M_AXI_BID,
   input  wire [C_NUM_MASTER_SLOTS*2-1:0]                         M_AXI_BRESP,
   input  wire [C_NUM_MASTER_SLOTS*C_AXI_BUSER_WIDTH-1:0]         M_AXI_BUSER,
   input  wire [C_NUM_MASTER_SLOTS-1:0]                           M_AXI_BVALID,
   output wire [C_NUM_MASTER_SLOTS-1:0]                           M_AXI_BREADY,
   // Master Interface Read Address Port
   output wire [C_NUM_MASTER_SLOTS*C_AXI_ID_WIDTH-1:0]          M_AXI_ARID,
   output wire [C_NUM_MASTER_SLOTS*C_AXI_ADDR_WIDTH-1:0]          M_AXI_ARADDR,
   output wire [C_NUM_MASTER_SLOTS*8-1:0]                         M_AXI_ARLEN,
   output wire [C_NUM_MASTER_SLOTS*3-1:0]                         M_AXI_ARSIZE,
   output wire [C_NUM_MASTER_SLOTS*2-1:0]                         M_AXI_ARBURST,
   output wire [C_NUM_MASTER_SLOTS*2-1:0]                         M_AXI_ARLOCK,
   output wire [C_NUM_MASTER_SLOTS*4-1:0]                         M_AXI_ARCACHE,
   output wire [C_NUM_MASTER_SLOTS*3-1:0]                         M_AXI_ARPROT,
   output wire [C_NUM_MASTER_SLOTS*4-1:0]                         M_AXI_ARREGION,
   output wire [C_NUM_MASTER_SLOTS*4-1:0]                         M_AXI_ARQOS,
   output wire [C_NUM_MASTER_SLOTS*C_AXI_ARUSER_WIDTH-1:0]        M_AXI_ARUSER,
   output wire [C_NUM_MASTER_SLOTS-1:0]                           M_AXI_ARVALID,
   input  wire [C_NUM_MASTER_SLOTS-1:0]                           M_AXI_ARREADY,
   // Master Interface Read Data Ports
   input  wire [C_NUM_MASTER_SLOTS*C_AXI_ID_WIDTH-1:0]          M_AXI_RID,
   input  wire [C_NUM_MASTER_SLOTS*C_AXI_DATA_MAX_WIDTH-1:0]    M_AXI_RDATA,
   input  wire [C_NUM_MASTER_SLOTS*2-1:0]                         M_AXI_RRESP,
   input  wire [C_NUM_MASTER_SLOTS-1:0]                           M_AXI_RLAST,
   input wire [C_NUM_MASTER_SLOTS*C_AXI_RUSER_WIDTH-1:0]         M_AXI_RUSER,
   input  wire [C_NUM_MASTER_SLOTS-1:0]                           M_AXI_RVALID,
   output wire [C_NUM_MASTER_SLOTS-1:0]                           M_AXI_RREADY,
   // Diagnostic AxiLite Slave Interface
   input wire [(C_S_AXI_CTRL_ADDR_WIDTH-1):0]                     S_AXI_CTRL_AWADDR,
   input wire                                                     S_AXI_CTRL_AWVALID,
   output wire                                                    S_AXI_CTRL_AWREADY,
   input wire [(C_S_AXI_CTRL_DATA_WIDTH-1):0]                     S_AXI_CTRL_WDATA,
   input wire                                                     S_AXI_CTRL_WVALID,
   output wire                                                    S_AXI_CTRL_WREADY,
   output wire [1:0]                                              S_AXI_CTRL_BRESP,
   output wire                                                    S_AXI_CTRL_BVALID,
   input wire                                                     S_AXI_CTRL_BREADY,
   input wire [(C_S_AXI_CTRL_ADDR_WIDTH-1):0]                     S_AXI_CTRL_ARADDR,
   input wire                                                     S_AXI_CTRL_ARVALID,
   output wire                                                    S_AXI_CTRL_ARREADY,
   output wire [(C_S_AXI_CTRL_DATA_WIDTH-1):0]                    S_AXI_CTRL_RDATA,
   output wire [1:0]                                              S_AXI_CTRL_RRESP,
   output wire                                                    S_AXI_CTRL_RVALID,
   input wire                                                     S_AXI_CTRL_RREADY,
   // Diagnostic Probe Ports
   output wire [8-1:0]                                            DEBUG_AW_TRANS_SEQ,
   output wire [C_NUM_SLAVE_SLOTS*C_MAX_DEBUG_THREADS-1:0]        DEBUG_AW_TRANS_QUAL,
   output wire [C_NUM_SLAVE_SLOTS*C_MAX_DEBUG_THREADS*8-1:0]      DEBUG_AW_ACCEPT_CNT,
   output wire [C_NUM_SLAVE_SLOTS*16-1:0]                         DEBUG_AW_ACTIVE_THREAD,
   output wire [C_NUM_SLAVE_SLOTS*C_MAX_DEBUG_THREADS*8-1:0]      DEBUG_AW_ACTIVE_TARGET,
   output wire [C_NUM_SLAVE_SLOTS*C_MAX_DEBUG_THREADS*8-1:0]      DEBUG_AW_ACTIVE_REGION,
   output wire [C_NUM_SLAVE_SLOTS*8-1:0]                          DEBUG_AW_ERROR,
   output wire [C_NUM_SLAVE_SLOTS*8-1:0]                          DEBUG_AW_TARGET,
   output wire [(C_NUM_MASTER_SLOTS+1)*8-1:0]                     DEBUG_AW_ISSUING_CNT,
   output wire [8-1:0]                                            DEBUG_AW_ARB_GRANT,
   output wire [C_NUM_SLAVE_SLOTS*C_MAX_DEBUG_THREADS*8-1:0]      DEBUG_B_TRANS_SEQ,
   output wire [8-1:0]                                            DEBUG_AR_TRANS_SEQ,
   output wire [C_NUM_SLAVE_SLOTS*C_MAX_DEBUG_THREADS-1:0]        DEBUG_AR_TRANS_QUAL,
   output wire [C_NUM_SLAVE_SLOTS*C_MAX_DEBUG_THREADS*8-1:0]      DEBUG_AR_ACCEPT_CNT,
   output wire [C_NUM_SLAVE_SLOTS*16-1:0]                         DEBUG_AR_ACTIVE_THREAD,
   output wire [C_NUM_SLAVE_SLOTS*C_MAX_DEBUG_THREADS*8-1:0]      DEBUG_AR_ACTIVE_TARGET,
   output wire [C_NUM_SLAVE_SLOTS*C_MAX_DEBUG_THREADS*8-1:0]      DEBUG_AR_ACTIVE_REGION,
   output wire [C_NUM_SLAVE_SLOTS*8-1:0]                          DEBUG_AR_ERROR,
   output wire [C_NUM_SLAVE_SLOTS*8-1:0]                          DEBUG_AR_TARGET,
   output wire [(C_NUM_MASTER_SLOTS+1)*8-1:0]                     DEBUG_AR_ISSUING_CNT,
   output wire [8-1:0]                                            DEBUG_AR_ARB_GRANT,
   output wire [C_NUM_SLAVE_SLOTS*C_MAX_DEBUG_THREADS*8-1:0]      DEBUG_R_BEAT_CNT,
   output wire [C_NUM_SLAVE_SLOTS*C_MAX_DEBUG_THREADS*8-1:0]      DEBUG_R_TRANS_SEQ,
   output wire [(C_NUM_MASTER_SLOTS+1)*8-1:0]                     DEBUG_RID_TARGET,
   output wire [(C_NUM_MASTER_SLOTS+1)-1:0]                       DEBUG_RID_ERROR,
   output wire [(C_NUM_MASTER_SLOTS+1)*8-1:0]                     DEBUG_BID_TARGET,
   output wire [(C_NUM_MASTER_SLOTS+1)-1:0]                       DEBUG_BID_ERROR,
   output wire [(C_NUM_MASTER_SLOTS+1)*8-1:0]                     DEBUG_W_BEAT_CNT,
   output wire [(C_NUM_MASTER_SLOTS+1)*8-1:0]                     DEBUG_W_TRANS_SEQ
   );
   
  localparam [31:0] P_AXI4 = 32'h0;
  localparam [31:0] P_AXI3 = 32'h1;
  localparam [31:0] P_AXILITE = 32'h2;
  localparam integer P_WRITE = 0;
  localparam integer P_READ = 1;
  localparam integer P_NUM_MASTER_SLOTS_LOG = f_ceil_log2(C_NUM_MASTER_SLOTS);
  localparam integer P_NUM_SLAVE_SLOTS_LOG = f_ceil_log2((C_NUM_SLAVE_SLOTS>1) ? C_NUM_SLAVE_SLOTS : 2);
  localparam integer P_ST_AWMESG_WIDTH = 2+4+4 + C_AXI_AWUSER_WIDTH;
  localparam integer P_AA_AWMESG_WIDTH = C_AXI_ID_WIDTH + C_AXI_ADDR_WIDTH + 8+3+2+3+4 + P_ST_AWMESG_WIDTH;
  localparam integer P_ST_ARMESG_WIDTH = 2+4+4 + C_AXI_ARUSER_WIDTH;
  localparam integer P_AA_ARMESG_WIDTH = C_AXI_ID_WIDTH + C_AXI_ADDR_WIDTH + 8+3+2+3+4 + P_ST_ARMESG_WIDTH;
  localparam integer P_ST_BMESG_WIDTH = 2 + C_AXI_BUSER_WIDTH;
  localparam integer P_ST_RMESG_WIDTH = 2 + C_AXI_RUSER_WIDTH + C_INTERCONNECT_DATA_WIDTH;
  localparam integer P_WR_WMESG_WIDTH = C_INTERCONNECT_DATA_WIDTH + C_INTERCONNECT_DATA_WIDTH/8 + C_AXI_WUSER_WIDTH;
  localparam [31:0] P_BYPASS  = 32'h00000000;
  localparam [31:0] P_FWD_REV = 32'h00000001;
  localparam [31:0] P_SIMPLE  = 32'h00000007;
  localparam [(C_NUM_MASTER_SLOTS+1)-1:0] P_M_AXI_SUPPORTS_READ = {1'b1, C_M_AXI_SUPPORTS_READ[0+:C_NUM_MASTER_SLOTS]};
  localparam [(C_NUM_MASTER_SLOTS+1)-1:0] P_M_AXI_SUPPORTS_WRITE = {1'b1, C_M_AXI_SUPPORTS_WRITE[0+:C_NUM_MASTER_SLOTS]};
  localparam [(C_NUM_MASTER_SLOTS+1)*32-1:0] P_M_AXI_DATA_WIDTH = {32'h20, C_M_AXI_DATA_WIDTH[0+:C_NUM_MASTER_SLOTS*32]};
  localparam [(C_NUM_MASTER_SLOTS+1)*32-1:0] P_M_AXI_PROTOCOL = {P_AXILITE, C_M_AXI_PROTOCOL[0+:C_NUM_MASTER_SLOTS*32]};
  localparam [(C_MAX_M+1)*32-1:0] P_SI_WRITE_CONNECTIVITY = C_ADDR_DECODE ? f_si_write_connectivity(0) : {(C_MAX_M+1){32'hFFFFFFFF}};
  localparam [(C_MAX_M+1)*32-1:0] P_SI_READ_CONNECTIVITY = C_ADDR_DECODE ? f_si_read_connectivity(0) : {(C_MAX_M+1){32'hFFFFFFFF}};
  localparam [C_MAX_S*32-1:0] P_MI_WRITE_CONNECTIVITY = C_ADDR_DECODE ? f_mi_write_connectivity(0) : {C_MAX_S{32'hFFFFFFFF}};
  localparam [C_MAX_S*32-1:0] P_MI_READ_CONNECTIVITY = C_ADDR_DECODE ? f_mi_read_connectivity(0) : {C_MAX_S{32'hFFFFFFFF}};

  //---------------------------------------------------------------------------
  // Functions
  //---------------------------------------------------------------------------
  // Ceiling of log2(x)
  function integer f_ceil_log2
    (
     input integer x
     );
    integer acc;
    begin
      acc=0;
      while ((2**acc) < x)
        acc = acc + 1;
      f_ceil_log2 = acc;
    end
  endfunction

  // Isolate thread bits of input S_ID and add to BASE_ID (RNG00) to form MI-side ID value
  //   only for end-point SI-slots
  function [C_AXI_ID_WIDTH-1:0] f_extend_ID
    (
     input [C_AXI_ID_WIDTH-1:0] s_id,
     input integer slot
     );
    begin
      f_extend_ID = C_S_AXI_BASE_ID[slot*64+:C_AXI_ID_WIDTH] | (s_id & (C_S_AXI_BASE_ID[slot*64+:C_AXI_ID_WIDTH] ^ C_S_AXI_HIGH_ID[slot*64+:C_AXI_ID_WIDTH]));
    end
  endfunction

  // Connectivity array transposed and masked by MI write capability
  function [C_MAX_S*32-1:0] f_mi_write_connectivity
    (
      input integer null_arg
     );
    integer si_slot;
    integer mi_slot;
    reg  [C_MAX_S*32-1:0]  result;
    begin
      result = {C_MAX_S{32'hFFFFFFFF}};
      for (si_slot=0; si_slot<C_NUM_SLAVE_SLOTS; si_slot=si_slot+1) begin
        for (mi_slot=0; mi_slot<C_NUM_MASTER_SLOTS; mi_slot=mi_slot+1) begin
          result[si_slot*32+mi_slot] = C_AXI_CONNECTIVITY[mi_slot*32+si_slot] & C_M_AXI_SUPPORTS_WRITE[mi_slot];
        end
      end
    f_mi_write_connectivity = result;
    end
  endfunction

  // Connectivity array transposed and masked by MI read capability
  function [C_MAX_S*32-1:0] f_mi_read_connectivity
    (
      input integer null_arg
     );
    integer si_slot;
    integer mi_slot;
    reg  [C_MAX_S*32-1:0]  result;
    begin
      result = {C_MAX_S{32'hFFFFFFFF}};
      for (si_slot=0; si_slot<C_NUM_SLAVE_SLOTS; si_slot=si_slot+1) begin
        for (mi_slot=0; mi_slot<C_NUM_MASTER_SLOTS; mi_slot=mi_slot+1) begin
          result[si_slot*32+mi_slot] = C_AXI_CONNECTIVITY[mi_slot*32+si_slot] & C_M_AXI_SUPPORTS_READ[mi_slot];
        end
      end
    f_mi_read_connectivity = result;
    end
  endfunction

  // Connectivity array masked by SI write capability
  //   augmented with extra row for error handler with full connectivity
  function [(C_MAX_M+1)*32-1:0] f_si_write_connectivity
    (
      input integer null_arg
     );
    integer mi_slot;
    integer si;
    reg  [(C_MAX_M+1)*32-1:0]  result;
    begin
      result = {(C_MAX_M+1){32'hFFFFFFFF}};
      for (mi_slot=0; mi_slot<C_NUM_MASTER_SLOTS; mi_slot=mi_slot+1) begin
        for (si=0; si<C_NUM_SLAVE_SLOTS; si=si+1) begin
          result[mi_slot*32+si] = C_AXI_CONNECTIVITY[mi_slot*32+si] & C_S_AXI_SUPPORTS_WRITE[si];
        end
      end
    f_si_write_connectivity = result;
    end
  endfunction

  // Connectivity array masked by SI read capability
  //   augmented with extra row for error handler with full connectivity
  function [(C_MAX_M+1)*32-1:0] f_si_read_connectivity
    (
      input integer null_arg
     );
    integer mi_slot;
    integer si;
    reg  [(C_MAX_M+1)*32-1:0]  result;
    begin
      result = {(C_MAX_M+1){32'hFFFFFFFF}};
      for (mi_slot=0; mi_slot<C_NUM_MASTER_SLOTS; mi_slot=mi_slot+1) begin
        for (si=0; si<C_NUM_SLAVE_SLOTS; si=si+1) begin
          result[mi_slot*32+si] = C_AXI_CONNECTIVITY[mi_slot*32+si] & C_S_AXI_SUPPORTS_READ[si];
        end
      end
    f_si_read_connectivity = result;
    end
  endfunction

  genvar gen_si_slot;
  genvar gen_mi_slot;
  wire [C_NUM_SLAVE_SLOTS*P_ST_AWMESG_WIDTH-1:0]                  si_st_awmesg          ;
  wire [C_NUM_SLAVE_SLOTS*P_ST_AWMESG_WIDTH-1:0]                  st_tmp_awmesg         ;
  wire [C_NUM_SLAVE_SLOTS*P_AA_AWMESG_WIDTH-1:0]                  tmp_aa_awmesg         ;
  wire [P_AA_AWMESG_WIDTH-1:0]                                    aa_mi_awmesg          ;
  wire [C_NUM_SLAVE_SLOTS*C_AXI_ID_WIDTH-1:0]                     st_aa_awid            ;
  wire [C_NUM_SLAVE_SLOTS*C_AXI_ADDR_WIDTH-1:0]                   st_aa_awaddr          ;
  wire [C_NUM_SLAVE_SLOTS*8-1:0]                                  st_aa_awlen           ;
  wire [C_NUM_SLAVE_SLOTS*3-1:0]                                  st_aa_awsize          ;
  wire [C_NUM_SLAVE_SLOTS*2-1:0]                                  st_aa_awlock          ;
  wire [C_NUM_SLAVE_SLOTS*3-1:0]                                  st_aa_awprot          ;
  wire [C_NUM_SLAVE_SLOTS*4-1:0]                                  st_aa_awregion        ;
  wire [C_NUM_SLAVE_SLOTS*8-1:0]                                  st_aa_awerror         ;
  wire [C_NUM_SLAVE_SLOTS*(C_NUM_MASTER_SLOTS+1)-1:0]             st_aa_awtarget_hot    ;
  wire [C_NUM_SLAVE_SLOTS*(P_NUM_MASTER_SLOTS_LOG+1)-1:0]         st_aa_awtarget_enc    ;
  wire [P_NUM_SLAVE_SLOTS_LOG*1-1:0]                              aa_wm_awgrant_enc     ;
  wire [(C_NUM_MASTER_SLOTS+1)-1:0]                               aa_mi_awtarget_hot    ;
  wire [C_NUM_SLAVE_SLOTS*1-1:0]                                  st_aa_awvalid_qual    ;
  wire [C_NUM_SLAVE_SLOTS*1-1:0]                                  st_ss_awvalid         ;
  wire [C_NUM_SLAVE_SLOTS*1-1:0]                                  st_ss_awready         ;
  wire [C_NUM_SLAVE_SLOTS*1-1:0]                                  ss_wr_awvalid         ;
  wire [C_NUM_SLAVE_SLOTS*1-1:0]                                  ss_wr_awready         ;
  wire [C_NUM_SLAVE_SLOTS*1-1:0]                                  ss_aa_awvalid         ;
  wire [C_NUM_SLAVE_SLOTS*1-1:0]                                  ss_aa_awready         ;
  wire [(C_NUM_MASTER_SLOTS+1)*1-1:0]                             sa_wm_awvalid         ;
  wire [(C_NUM_MASTER_SLOTS+1)*1-1:0]                             sa_wm_awready         ;
  wire [(C_NUM_MASTER_SLOTS+1)*1-1:0]                             mi_awvalid            ;
  wire [(C_NUM_MASTER_SLOTS+1)*1-1:0]                             mi_awready            ;
  wire                                                            aa_sa_awvalid         ;
  wire                                                            aa_sa_awready         ;
  wire                                                            aa_mi_arready         ;
  wire                                                            mi_awvalid_en         ;
  wire                                                            sa_wm_awvalid_en      ;
  wire                                                            sa_wm_awready_mux     ;
  wire [C_NUM_SLAVE_SLOTS*P_ST_ARMESG_WIDTH-1:0]                  si_st_armesg          ;
  wire [C_NUM_SLAVE_SLOTS*P_ST_ARMESG_WIDTH-1:0]                  st_tmp_armesg         ;
  wire [C_NUM_SLAVE_SLOTS*P_AA_ARMESG_WIDTH-1:0]                  tmp_aa_armesg         ;
  wire [P_AA_ARMESG_WIDTH-1:0]                                    aa_mi_armesg          ;
  wire [C_NUM_SLAVE_SLOTS*C_AXI_ID_WIDTH-1:0]                     st_aa_arid            ;
  wire [C_NUM_SLAVE_SLOTS*C_AXI_ADDR_WIDTH-1:0]                   st_aa_araddr          ;
  wire [C_NUM_SLAVE_SLOTS*8-1:0]                                  st_aa_arlen           ;
  wire [C_NUM_SLAVE_SLOTS*3-1:0]                                  st_aa_arsize          ;
  wire [C_NUM_SLAVE_SLOTS*2-1:0]                                  st_aa_arlock          ;
  wire [C_NUM_SLAVE_SLOTS*3-1:0]                                  st_aa_arprot          ;
  wire [C_NUM_SLAVE_SLOTS*4-1:0]                                  st_aa_arregion        ;
  wire [C_NUM_SLAVE_SLOTS*8-1:0]                                  st_aa_arerror         ;
  wire [C_NUM_SLAVE_SLOTS*(C_NUM_MASTER_SLOTS+1)-1:0]             st_aa_artarget_hot    ;
  wire [C_NUM_SLAVE_SLOTS*(P_NUM_MASTER_SLOTS_LOG+1)-1:0]         st_aa_artarget_enc    ;
  wire [(C_NUM_MASTER_SLOTS+1)-1:0]                               aa_mi_artarget_hot    ;
  wire [P_NUM_SLAVE_SLOTS_LOG*1-1:0]                              aa_mi_argrant_enc     ;
  wire [C_NUM_SLAVE_SLOTS*1-1:0]                                  st_aa_arvalid_qual    ;
  wire [C_NUM_SLAVE_SLOTS*1-1:0]                                  st_aa_arvalid         ;
  wire [C_NUM_SLAVE_SLOTS*1-1:0]                                  st_aa_arready         ;
  wire [(C_NUM_MASTER_SLOTS+1)*1-1:0]                             mi_arvalid            ;
  wire [(C_NUM_MASTER_SLOTS+1)*1-1:0]                             mi_arready            ;
  wire                                                            aa_mi_arvalid         ;
  wire                                                            mi_awready_mux        ;
  wire [C_NUM_SLAVE_SLOTS*P_ST_BMESG_WIDTH-1:0]                   st_si_bmesg           ;
  wire [(C_NUM_MASTER_SLOTS+1)*P_ST_BMESG_WIDTH-1:0]              st_mr_bmesg           ;
  wire [(C_NUM_MASTER_SLOTS+1)*C_AXI_ID_WIDTH-1:0]                st_mr_bid             ;
  wire [(C_NUM_MASTER_SLOTS+1)*2-1:0]                             st_mr_bresp           ;
  wire [(C_NUM_MASTER_SLOTS+1)*C_AXI_BUSER_WIDTH-1:0]             st_mr_buser           ;
  wire [(C_NUM_MASTER_SLOTS+1)*1-1:0]                             st_mr_bvalid          ;
  wire [(C_NUM_MASTER_SLOTS+1)*1-1:0]                             st_mr_bready          ;
  wire [C_NUM_SLAVE_SLOTS*(C_NUM_MASTER_SLOTS+1)-1:0]             st_tmp_bready         ;
  wire [C_NUM_SLAVE_SLOTS*(C_NUM_MASTER_SLOTS+1)-1:0]             st_tmp_bid_target     ;
  wire [(C_NUM_MASTER_SLOTS+1)*C_NUM_SLAVE_SLOTS-1:0]             tmp_mr_bid_target     ;
  wire [(C_NUM_MASTER_SLOTS+1)*P_NUM_SLAVE_SLOTS_LOG-1:0]         debug_bid_target_i    ;
  wire [(C_NUM_MASTER_SLOTS+1)*1-1:0]                             bid_match             ;
  wire [(C_NUM_MASTER_SLOTS+1)*C_AXI_ID_WIDTH-1:0]                mi_bid                ;
  wire [(C_NUM_MASTER_SLOTS+1)*2-1:0]                             mi_bresp              ;
  wire [(C_NUM_MASTER_SLOTS+1)*C_AXI_BUSER_WIDTH-1:0]             mi_buser              ;
  wire [(C_NUM_MASTER_SLOTS+1)*1-1:0]                             mi_bvalid             ;
  wire [(C_NUM_MASTER_SLOTS+1)*1-1:0]                             mi_bready             ;
  wire [C_NUM_SLAVE_SLOTS*(C_NUM_MASTER_SLOTS+1)-1:0]             bready_carry          ;
  wire [C_NUM_SLAVE_SLOTS*P_ST_RMESG_WIDTH-1:0]                   st_si_rmesg           ;
  wire [(C_NUM_MASTER_SLOTS+1)*P_ST_RMESG_WIDTH-1:0]              st_mr_rmesg           ;
  wire [(C_NUM_MASTER_SLOTS+1)*C_AXI_ID_WIDTH-1:0]                st_mr_rid             ;
  wire [(C_NUM_MASTER_SLOTS+1)*C_INTERCONNECT_DATA_WIDTH-1:0]     st_mr_rdata           ;
  wire [(C_NUM_MASTER_SLOTS+1)*C_AXI_RUSER_WIDTH-1:0]             st_mr_ruser           ;
  wire [(C_NUM_MASTER_SLOTS+1)*1-1:0]                             st_mr_rlast           ;
  wire [(C_NUM_MASTER_SLOTS+1)*2-1:0]                             st_mr_rresp           ;
  wire [(C_NUM_MASTER_SLOTS+1)*1-1:0]                             st_mr_rvalid          ;
  wire [(C_NUM_MASTER_SLOTS+1)*1-1:0]                             st_mr_rready          ;
  wire [C_NUM_SLAVE_SLOTS*(C_NUM_MASTER_SLOTS+1)-1:0]             st_tmp_rready         ;
  wire [C_NUM_SLAVE_SLOTS*(C_NUM_MASTER_SLOTS+1)-1:0]             st_tmp_rid_target     ;
  wire [(C_NUM_MASTER_SLOTS+1)*C_NUM_SLAVE_SLOTS-1:0]             tmp_mr_rid_target     ;
  wire [(C_NUM_MASTER_SLOTS+1)*P_NUM_SLAVE_SLOTS_LOG-1:0]         debug_rid_target_i    ;
  wire [(C_NUM_MASTER_SLOTS+1)*1-1:0]                             rid_match             ;
  wire [(C_NUM_MASTER_SLOTS+1)*C_AXI_ID_WIDTH-1:0]                mi_rid                ;
  wire [(C_NUM_MASTER_SLOTS+1)*C_AXI_DATA_MAX_WIDTH-1:0]          mi_rdata              ;
  wire [(C_NUM_MASTER_SLOTS+1)*C_AXI_RUSER_WIDTH-1:0]             mi_ruser              ;
  wire [(C_NUM_MASTER_SLOTS+1)*1-1:0]                             mi_rlast              ;
  wire [(C_NUM_MASTER_SLOTS+1)*2-1:0]                             mi_rresp              ;
  wire [(C_NUM_MASTER_SLOTS+1)*1-1:0]                             mi_rvalid             ;
  wire [(C_NUM_MASTER_SLOTS+1)*1-1:0]                             mi_rready             ;
  wire [C_NUM_SLAVE_SLOTS*(C_NUM_MASTER_SLOTS+1)-1:0]             rready_carry          ;
  wire [C_NUM_SLAVE_SLOTS*P_WR_WMESG_WIDTH-1:0]                   si_wr_wmesg           ;
  wire [C_NUM_SLAVE_SLOTS*P_WR_WMESG_WIDTH-1:0]                   wr_wm_wmesg           ;
  wire [C_NUM_SLAVE_SLOTS*1-1:0]                                  wr_wm_wlast           ;
  wire [C_NUM_SLAVE_SLOTS*(C_NUM_MASTER_SLOTS+1)-1:0]             wr_tmp_wvalid         ;
  wire [C_NUM_SLAVE_SLOTS*(C_NUM_MASTER_SLOTS+1)-1:0]             wr_tmp_wready         ;
  wire [(C_NUM_MASTER_SLOTS+1)*C_NUM_SLAVE_SLOTS-1:0]             tmp_wm_wvalid         ;
  wire [(C_NUM_MASTER_SLOTS+1)*C_NUM_SLAVE_SLOTS-1:0]             tmp_wm_wready         ;
  wire [(C_NUM_MASTER_SLOTS+1)*P_WR_WMESG_WIDTH-1:0]              wm_mr_wmesg              ;
  wire [(C_NUM_MASTER_SLOTS+1)*C_INTERCONNECT_DATA_WIDTH-1:0]          wm_mr_wdata              ;
  wire [(C_NUM_MASTER_SLOTS+1)*C_INTERCONNECT_DATA_WIDTH/8-1:0]        wm_mr_wstrb              ;
  wire [(C_NUM_MASTER_SLOTS+1)*C_AXI_WUSER_WIDTH-1:0]             wm_mr_wuser              ;
  wire [(C_NUM_MASTER_SLOTS+1)*1-1:0]                             wm_mr_wlast              ;
  wire [(C_NUM_MASTER_SLOTS+1)*1-1:0]                             wm_mr_wvalid             ;
  wire [(C_NUM_MASTER_SLOTS+1)*1-1:0]                             wm_mr_wready             ;
  wire [(C_NUM_MASTER_SLOTS+1)*C_INTERCONNECT_DATA_WIDTH-1:0]          mi_wdata              ;
  wire [(C_NUM_MASTER_SLOTS+1)*C_INTERCONNECT_DATA_WIDTH/8-1:0]        mi_wstrb              ;
  wire [(C_NUM_MASTER_SLOTS+1)*C_AXI_WUSER_WIDTH-1:0]             mi_wuser              ;
  wire [(C_NUM_MASTER_SLOTS+1)*1-1:0]                             mi_wlast              ;
  wire [(C_NUM_MASTER_SLOTS+1)*1-1:0]                             mi_wvalid             ;
  wire [(C_NUM_MASTER_SLOTS+1)*1-1:0]                             mi_wready             ;
  wire [(C_NUM_MASTER_SLOTS+1)*1-1:0]                             w_cmd_push            ;
  wire [(C_NUM_MASTER_SLOTS+1)*1-1:0]                             w_cmd_pop             ;
  wire [(C_NUM_MASTER_SLOTS+1)*1-1:0]                             r_cmd_push            ;
  wire [(C_NUM_MASTER_SLOTS+1)*1-1:0]                             r_cmd_pop             ;
  wire [(C_NUM_MASTER_SLOTS+1)*1-1:0]                             mi_awmaxissuing      ;
  wire [(C_NUM_MASTER_SLOTS+1)*1-1:0]                             mi_armaxissuing      ;
  reg  [(C_NUM_MASTER_SLOTS+1)*8-1:0]                             w_issuing_cnt        ;
  reg  [(C_NUM_MASTER_SLOTS+1)*8-1:0]                             r_issuing_cnt        ;
  reg  [8-1:0]                                                    debug_aw_trans_seq_i    ;
  reg  [8-1:0]                                                    debug_ar_trans_seq_i    ;
  wire [(C_NUM_MASTER_SLOTS+1)*8-1:0]                             debug_w_trans_seq_i     ;
  reg  [(C_NUM_MASTER_SLOTS+1)*8-1:0]                             debug_w_beat_cnt_i      ;

  (* shreg_extract="no", iob="false", equivalent_register_removal = "no" *) reg reset;
  always @(posedge INTERCONNECT_ACLK) begin
    reset <= ~ARESETN;
  end

generate
  if ((C_NUM_MASTER_SLOTS==1) && (C_NUM_SLAVE_SLOTS==1) && (C_ADDR_DECODE==0)) begin : gen_passthru
      
    assign M_AXI_AWID[0+:C_AXI_ID_WIDTH]                = f_extend_ID(S_AXI_AWID[0+:C_AXI_ID_WIDTH], 0);
    assign M_AXI_AWADDR[0+:C_AXI_ADDR_WIDTH]            = S_AXI_AWADDR[0+:C_AXI_ADDR_WIDTH];
    assign M_AXI_AWLEN[0+:8]                            = S_AXI_AWLEN[0+:8];
    assign M_AXI_AWSIZE[0+:3]                           = S_AXI_AWSIZE[0+:3];
    assign M_AXI_AWBURST[0+:2]                          = S_AXI_AWBURST[0+:2];
    assign M_AXI_AWLOCK[0+:2]                           = S_AXI_AWLOCK[0+:2];
    assign M_AXI_AWCACHE[0+:4]                          = S_AXI_AWCACHE[0+:4];
    assign M_AXI_AWPROT[0+:3]                           = S_AXI_AWPROT[0+:3];
    assign M_AXI_AWREGION[0+:4]                         = 4'b0;
    assign M_AXI_AWQOS[0+:4]                            = S_AXI_AWQOS[0+:4];
    assign M_AXI_AWUSER[0+:C_AXI_AWUSER_WIDTH]          = S_AXI_AWUSER[0+:C_AXI_AWUSER_WIDTH];
    assign M_AXI_AWVALID[0+:1]                          = S_AXI_AWVALID[0+:1];
    assign S_AXI_AWREADY[0+:1]                          = M_AXI_AWREADY[0+:1];
    assign M_AXI_WDATA[0+:C_AXI_DATA_MAX_WIDTH]         = S_AXI_WDATA[0+:C_AXI_DATA_MAX_WIDTH];
    assign M_AXI_WSTRB[0+:C_AXI_DATA_MAX_WIDTH/8]       = S_AXI_WSTRB[0+:C_AXI_DATA_MAX_WIDTH/8];
    assign M_AXI_WLAST[0+:1]                            = S_AXI_WLAST[0+:1];
    assign M_AXI_WUSER[0+:C_AXI_WUSER_WIDTH]            = S_AXI_WUSER[0+:C_AXI_WUSER_WIDTH];
    assign M_AXI_WVALID[0+:1]                           = S_AXI_WVALID[0+:1];
    assign S_AXI_WREADY[0+:1]                           = M_AXI_WREADY[0+:1];
    assign S_AXI_BID[0+:C_AXI_ID_WIDTH]                 = M_AXI_BID[0+:C_AXI_ID_WIDTH];
    assign S_AXI_BRESP[0+:2]                            = M_AXI_BRESP[0+:2];
    assign S_AXI_BUSER[0+:C_AXI_BUSER_WIDTH]            = M_AXI_BUSER[0+:C_AXI_BUSER_WIDTH];
    assign S_AXI_BVALID[0+:1]                           = M_AXI_BVALID[0+:1];
    assign M_AXI_BREADY[0+:1]                           = S_AXI_BREADY[0+:1];
    assign M_AXI_ARID[0+:C_AXI_ID_WIDTH]                = f_extend_ID(S_AXI_ARID[0+:C_AXI_ID_WIDTH], 0);
    assign M_AXI_ARADDR[0+:C_AXI_ADDR_WIDTH]            = S_AXI_ARADDR[0+:C_AXI_ADDR_WIDTH];
    assign M_AXI_ARLEN[0+:8]                            = S_AXI_ARLEN[0+:8];
    assign M_AXI_ARSIZE[0+:3]                           = S_AXI_ARSIZE[0+:3];
    assign M_AXI_ARBURST[0+:2]                          = S_AXI_ARBURST[0+:2];
    assign M_AXI_ARLOCK[0+:2]                           = S_AXI_ARLOCK[0+:2];
    assign M_AXI_ARCACHE[0+:4]                          = S_AXI_ARCACHE[0+:4];
    assign M_AXI_ARPROT[0+:3]                           = S_AXI_ARPROT[0+:3];
    assign M_AXI_ARREGION[0+:4]                         = 4'b0;
    assign M_AXI_ARQOS[0+:4]                            = S_AXI_ARQOS[0+:4];
    assign M_AXI_ARUSER[0+:C_AXI_ARUSER_WIDTH]          = S_AXI_ARUSER[0+:C_AXI_ARUSER_WIDTH];
    assign M_AXI_ARVALID[0+:1]                          = S_AXI_ARVALID[0+:1];
    assign S_AXI_ARREADY[0+:1]                          = M_AXI_ARREADY[0+:1];
    assign S_AXI_RID[0+:C_AXI_ID_WIDTH]                 = M_AXI_RID[0+:C_AXI_ID_WIDTH];
    assign S_AXI_RDATA[0+:C_AXI_DATA_MAX_WIDTH]         = M_AXI_RDATA[0+:C_AXI_DATA_MAX_WIDTH];
    assign S_AXI_RRESP[0+:2]                            = M_AXI_RRESP[0+:2];
    assign S_AXI_RLAST[0+:1]                            = M_AXI_RLAST[0+:1];
    assign S_AXI_RUSER[0+:C_AXI_RUSER_WIDTH]            = M_AXI_RUSER[0+:C_AXI_RUSER_WIDTH];
    assign S_AXI_RVALID[0+:1]                           = M_AXI_RVALID[0+:1];
    assign M_AXI_RREADY[0+:1]                           = S_AXI_RREADY[0+:1];
    
    assign DEBUG_AW_TRANS_SEQ     = 0;
    assign DEBUG_AW_TRANS_QUAL    = 0;
    assign DEBUG_AW_ACCEPT_CNT    = 0;
    assign DEBUG_AW_ACTIVE_THREAD = 0;
    assign DEBUG_AW_ACTIVE_TARGET = 0;
    assign DEBUG_AW_ACTIVE_REGION = 0;
    assign DEBUG_AW_ERROR         = 0;
    assign DEBUG_AW_TARGET        = 0;
    assign DEBUG_AW_ISSUING_CNT   = 0;
    assign DEBUG_AW_ARB_GRANT     = 0;
    assign DEBUG_B_TRANS_SEQ      = 0;
    assign DEBUG_AR_TRANS_SEQ     = 0;
    assign DEBUG_AR_TRANS_QUAL    = 0;
    assign DEBUG_AR_ACCEPT_CNT    = 0;
    assign DEBUG_AR_ACTIVE_THREAD = 0;
    assign DEBUG_AR_ACTIVE_TARGET = 0;
    assign DEBUG_AR_ACTIVE_REGION = 0;
    assign DEBUG_AR_ERROR         = 0;
    assign DEBUG_AR_TARGET        = 0;
    assign DEBUG_AR_ISSUING_CNT   = 0;
    assign DEBUG_AR_ARB_GRANT     = 0;
    assign DEBUG_R_BEAT_CNT       = 0;
    assign DEBUG_R_TRANS_SEQ      = 0;
    assign DEBUG_RID_TARGET       = 0;
    assign DEBUG_RID_ERROR        = 0;
    assign DEBUG_BID_TARGET       = 0;
    assign DEBUG_BID_ERROR        = 0;
    assign DEBUG_W_BEAT_CNT       = 0;
    assign DEBUG_W_TRANS_SEQ      = 0;
    
  end else begin : gen_crossbar
    
    for (gen_si_slot=0; gen_si_slot<C_NUM_SLAVE_SLOTS; gen_si_slot=gen_si_slot+1) begin : gen_slave_slots
      if (C_S_AXI_SUPPORTS_READ[gen_si_slot]) begin : gen_si_read
  axi_interconnect_v1_7_13_si_transactor #  // "ST": SI Transactor (read channel)
          (
           .C_MAX_M                 (C_MAX_M),
           .C_NUM_ADDR_RANGES       (C_NUM_ADDR_RANGES),
           .C_FAMILY                (C_FAMILY),
           .C_SI                    (gen_si_slot),
           .C_DIR                   (P_READ),
           .C_NUM_M                 (C_NUM_MASTER_SLOTS),
           .C_NUM_M_LOG             (P_NUM_MASTER_SLOTS_LOG),
           .C_ACCEPTANCE            (C_S_AXI_READ_ACCEPTANCE[gen_si_slot*32+:6]),
           .C_ACCEPTANCE_LOG        (C_R_ACCEPT_WIDTH[gen_si_slot*32+:6]),
           .C_ID_WIDTH              (C_AXI_ID_WIDTH),
           .C_THREAD_ID_WIDTH       (C_S_AXI_THREAD_ID_WIDTH[gen_si_slot*32+:32]),
           .C_ADDR_WIDTH            (C_AXI_ADDR_WIDTH),
           .C_AMESG_WIDTH           (P_ST_ARMESG_WIDTH),
           .C_RMESG_WIDTH           (P_ST_RMESG_WIDTH),
           .C_BASE_ID               (C_S_AXI_BASE_ID[gen_si_slot*64+:64]),
           .C_HIGH_ID               (C_S_AXI_HIGH_ID[gen_si_slot*64+:64]),
           .C_IS_INTERCONNECT       (C_S_AXI_IS_INTERCONNECT[gen_si_slot]),
           .C_SINGLE_THREAD         (C_S_AXI_SINGLE_THREAD[gen_si_slot]),
           .C_M_PROTOCOL            (C_M_AXI_PROTOCOL),
           .C_BASE_ADDR             (C_M_AXI_BASE_ADDR),
           .C_HIGH_ADDR             (C_M_AXI_HIGH_ADDR),
           .C_TARGET_QUAL           (P_MI_READ_CONNECTIVITY[gen_si_slot*32+:32]),
           .C_M_AXI_SECURE          (C_M_AXI_SECURE),
           .C_RANGE_CHECK           (C_RANGE_CHECK),
           .C_ADDR_DECODE           (C_ADDR_DECODE),
           .C_DEBUG                 (C_DEBUG),
           .C_MAX_DEBUG_THREADS     (C_MAX_DEBUG_THREADS)
           )
          si_transactor_ar
            (
             .ACLK                  (INTERCONNECT_ACLK),
             .ARESET                (reset),
             .S_AID                 (f_extend_ID(S_AXI_ARID[gen_si_slot*C_AXI_ID_WIDTH+:C_AXI_ID_WIDTH], gen_si_slot)),
             .S_AADDR               (S_AXI_ARADDR[gen_si_slot*C_AXI_ADDR_WIDTH+:C_AXI_ADDR_WIDTH]),
             .S_ALEN                (S_AXI_ARLEN[gen_si_slot*8+:8]),
             .S_ASIZE               (S_AXI_ARSIZE[gen_si_slot*3+:3]),
             .S_ABURST              (S_AXI_ARBURST[gen_si_slot*2+:2]),
             .S_ALOCK               (S_AXI_ARLOCK[gen_si_slot*2+:2]),
             .S_APROT               (S_AXI_ARPROT[gen_si_slot*3+:3]),
             .S_AMESG               (si_st_armesg[gen_si_slot*P_ST_ARMESG_WIDTH+:P_ST_ARMESG_WIDTH]),
             .S_AVALID              (S_AXI_ARVALID[gen_si_slot]),
             .S_AREADY              (S_AXI_ARREADY[gen_si_slot]),
             .M_AID                 (st_aa_arid[gen_si_slot*C_AXI_ID_WIDTH+:C_AXI_ID_WIDTH]),
             .M_AADDR               (st_aa_araddr[gen_si_slot*C_AXI_ADDR_WIDTH+:C_AXI_ADDR_WIDTH]),
             .M_ALEN                (st_aa_arlen[gen_si_slot*8+:8]),
             .M_ASIZE               (st_aa_arsize[gen_si_slot*3+:3]),
             .M_ALOCK               (st_aa_arlock[gen_si_slot*2+:2]),
             .M_APROT               (st_aa_arprot[gen_si_slot*3+:3]),
             .M_AREGION             (st_aa_arregion[gen_si_slot*4+:4]),
             .M_AMESG               (st_tmp_armesg[gen_si_slot*P_ST_ARMESG_WIDTH+:P_ST_ARMESG_WIDTH]),
             .M_ATARGET_HOT         (st_aa_artarget_hot[gen_si_slot*(C_NUM_MASTER_SLOTS+1)+:(C_NUM_MASTER_SLOTS+1)]),
             .M_ATARGET_ENC         (st_aa_artarget_enc[gen_si_slot*(P_NUM_MASTER_SLOTS_LOG+1)+:(P_NUM_MASTER_SLOTS_LOG+1)]),
             .M_AERROR              (st_aa_arerror[gen_si_slot*8+:8]),
             .M_AVALID_QUAL         (st_aa_arvalid_qual[gen_si_slot]),
             .M_AVALID              (st_aa_arvalid[gen_si_slot]),
             .M_AREADY              (st_aa_arready[gen_si_slot]),
             .S_RID                 (S_AXI_RID[gen_si_slot*C_AXI_ID_WIDTH+:C_AXI_ID_WIDTH]),
             .S_RMESG               (st_si_rmesg[gen_si_slot*P_ST_RMESG_WIDTH+:P_ST_RMESG_WIDTH]),
             .S_RLAST               (S_AXI_RLAST[gen_si_slot]),
             .S_RVALID              (S_AXI_RVALID[gen_si_slot]),
             .S_RREADY              (S_AXI_RREADY[gen_si_slot]),
             .M_RID                 (st_mr_rid),
             .M_RLAST               (st_mr_rlast),
             .M_RMESG               (st_mr_rmesg),
             .M_RVALID              (st_mr_rvalid),
             .M_RREADY              (st_tmp_rready[gen_si_slot*(C_NUM_MASTER_SLOTS+1)+:(C_NUM_MASTER_SLOTS+1)]),
             .M_RTARGET             (st_tmp_rid_target[gen_si_slot*(C_NUM_MASTER_SLOTS+1)+:(C_NUM_MASTER_SLOTS+1)]),
             .DEBUG_A_TRANS_SEQ     (C_DEBUG ? debug_ar_trans_seq_i : 8'h0),
             .DEBUG_ACCEPT_CNT      (DEBUG_AR_ACCEPT_CNT[gen_si_slot*C_MAX_DEBUG_THREADS*8+:C_MAX_DEBUG_THREADS*8]),
             .DEBUG_ACTIVE_THREAD   (DEBUG_AR_ACTIVE_THREAD[gen_si_slot*16+:16]), 
             .DEBUG_ACTIVE_TARGET   (DEBUG_AR_ACTIVE_TARGET[gen_si_slot*C_MAX_DEBUG_THREADS*8+:C_MAX_DEBUG_THREADS*8]), 
             .DEBUG_ACTIVE_REGION   (DEBUG_AR_ACTIVE_REGION[gen_si_slot*C_MAX_DEBUG_THREADS*8+:C_MAX_DEBUG_THREADS*8]), 
             .DEBUG_R_BEAT_CNT      (DEBUG_R_BEAT_CNT[gen_si_slot*C_MAX_DEBUG_THREADS*8+:C_MAX_DEBUG_THREADS*8]),       
             .DEBUG_R_TRANS_SEQ     (DEBUG_R_TRANS_SEQ[gen_si_slot*C_MAX_DEBUG_THREADS*8+:C_MAX_DEBUG_THREADS*8]),  
             .DEBUG_TRANS_QUAL      (DEBUG_AR_TRANS_QUAL[gen_si_slot*C_MAX_DEBUG_THREADS+:C_MAX_DEBUG_THREADS])
             );
        
        assign si_st_armesg[gen_si_slot*P_ST_ARMESG_WIDTH+:P_ST_ARMESG_WIDTH] = {
          S_AXI_ARUSER[gen_si_slot*C_AXI_ARUSER_WIDTH+:C_AXI_ARUSER_WIDTH],
          S_AXI_ARQOS[gen_si_slot*4+:4],
          S_AXI_ARCACHE[gen_si_slot*4+:4],
          S_AXI_ARBURST[gen_si_slot*2+:2]
          };
        assign tmp_aa_armesg[gen_si_slot*P_AA_ARMESG_WIDTH+:P_AA_ARMESG_WIDTH] = {
          st_tmp_armesg[gen_si_slot*P_ST_ARMESG_WIDTH+:P_ST_ARMESG_WIDTH],
          st_aa_arregion[gen_si_slot*4+:4],
          st_aa_arprot[gen_si_slot*3+:3],
          st_aa_arlock[gen_si_slot*2+:2],
          st_aa_arsize[gen_si_slot*3+:3],
          st_aa_arlen[gen_si_slot*8+:8],
          st_aa_araddr[gen_si_slot*C_AXI_ADDR_WIDTH+:C_AXI_ADDR_WIDTH],
          st_aa_arid[gen_si_slot*C_AXI_ID_WIDTH+:C_AXI_ID_WIDTH]
          };
        assign S_AXI_RRESP[gen_si_slot*2+:2] = st_si_rmesg[gen_si_slot*P_ST_RMESG_WIDTH+:2];
        assign S_AXI_RUSER[gen_si_slot*C_AXI_RUSER_WIDTH+:C_AXI_RUSER_WIDTH] = st_si_rmesg[gen_si_slot*P_ST_RMESG_WIDTH+2 +: C_AXI_RUSER_WIDTH];
        assign S_AXI_RDATA[gen_si_slot*C_AXI_DATA_MAX_WIDTH+:C_AXI_DATA_MAX_WIDTH] = st_si_rmesg[gen_si_slot*P_ST_RMESG_WIDTH+2+C_AXI_RUSER_WIDTH +: C_INTERCONNECT_DATA_WIDTH];
        assign DEBUG_AR_ERROR[gen_si_slot*8+:8] = st_aa_arerror[gen_si_slot*8+:8];
        assign DEBUG_AR_TARGET[gen_si_slot*8+:8] = st_aa_artarget_enc[gen_si_slot*(P_NUM_MASTER_SLOTS_LOG+1)+:(P_NUM_MASTER_SLOTS_LOG+1)];
      end else begin : gen_no_si_read
        assign S_AXI_ARREADY[gen_si_slot] = 1'b0;
        assign st_aa_arvalid[gen_si_slot] = 1'b0;
        assign st_aa_arvalid_qual[gen_si_slot] = 1'b1;
        assign tmp_aa_armesg[gen_si_slot*P_AA_ARMESG_WIDTH+:P_AA_ARMESG_WIDTH] = 0;
        assign S_AXI_RID[gen_si_slot*C_AXI_ID_WIDTH+:C_AXI_ID_WIDTH] = 0;
        assign S_AXI_RRESP[gen_si_slot*2+:2] = 0;
        assign S_AXI_RUSER[gen_si_slot*C_AXI_RUSER_WIDTH+:C_AXI_RUSER_WIDTH] = 0;
        assign S_AXI_RDATA[gen_si_slot*C_AXI_DATA_MAX_WIDTH+:C_AXI_DATA_MAX_WIDTH] = 0;
        assign S_AXI_RVALID[gen_si_slot] = 1'b0;
        assign S_AXI_RLAST[gen_si_slot] = 1'b0;
        assign st_tmp_rready[gen_si_slot*(C_NUM_MASTER_SLOTS+1)+:(C_NUM_MASTER_SLOTS+1)] = 0;
        assign st_aa_artarget_hot[gen_si_slot*(C_NUM_MASTER_SLOTS+1)+:(C_NUM_MASTER_SLOTS+1)] = 0;
        assign DEBUG_AR_TARGET[gen_si_slot*8+:8] = 0;
        assign DEBUG_AR_ERROR[gen_si_slot*8+:8] = 0;        
        assign DEBUG_AR_TRANS_QUAL[gen_si_slot*C_MAX_DEBUG_THREADS+:C_MAX_DEBUG_THREADS] = 0    ;
        assign DEBUG_AR_ACCEPT_CNT[gen_si_slot*C_MAX_DEBUG_THREADS*8+:C_MAX_DEBUG_THREADS*8] = 0 ;
        assign DEBUG_AR_ACTIVE_THREAD[gen_si_slot*16+:16] = 0 ;
        assign DEBUG_AR_ACTIVE_TARGET[gen_si_slot*C_MAX_DEBUG_THREADS*8+:C_MAX_DEBUG_THREADS*8] = 0 ;
        assign DEBUG_AR_ACTIVE_REGION[gen_si_slot*C_MAX_DEBUG_THREADS*8+:C_MAX_DEBUG_THREADS*8] = 0 ;
        assign DEBUG_R_BEAT_CNT [gen_si_slot*C_MAX_DEBUG_THREADS*8+:C_MAX_DEBUG_THREADS*8] = 0 ;
        assign DEBUG_R_TRANS_SEQ[gen_si_slot*C_MAX_DEBUG_THREADS*8+:C_MAX_DEBUG_THREADS*8] = 0 ;
      end  // gen_si_read
        
      if (C_S_AXI_SUPPORTS_WRITE[gen_si_slot]) begin : gen_si_write
  axi_interconnect_v1_7_13_si_transactor #  // "ST": SI Transactor (write channel)
          (
           .C_MAX_M                 (C_MAX_M),
           .C_NUM_ADDR_RANGES       (C_NUM_ADDR_RANGES),
           .C_FAMILY                (C_FAMILY),
           .C_SI                    (gen_si_slot),
           .C_DIR                   (P_WRITE),
           .C_NUM_M                 (C_NUM_MASTER_SLOTS),
           .C_NUM_M_LOG             (P_NUM_MASTER_SLOTS_LOG),
           .C_ACCEPTANCE            (C_S_AXI_WRITE_ACCEPTANCE[gen_si_slot*32+:6]),
           .C_ACCEPTANCE_LOG        (C_W_ACCEPT_WIDTH[gen_si_slot*32+:6]),
           .C_ID_WIDTH              (C_AXI_ID_WIDTH),
           .C_THREAD_ID_WIDTH       (C_S_AXI_THREAD_ID_WIDTH[gen_si_slot*32+:32]),
           .C_ADDR_WIDTH            (C_AXI_ADDR_WIDTH),
           .C_AMESG_WIDTH           (P_ST_AWMESG_WIDTH),
           .C_RMESG_WIDTH           (P_ST_BMESG_WIDTH),
           .C_BASE_ID               (C_S_AXI_BASE_ID[gen_si_slot*64+:64]),
           .C_HIGH_ID               (C_S_AXI_HIGH_ID[gen_si_slot*64+:64]),
           .C_IS_INTERCONNECT       (C_S_AXI_IS_INTERCONNECT[gen_si_slot]),
           .C_SINGLE_THREAD         (C_S_AXI_SINGLE_THREAD[gen_si_slot]),
           .C_M_PROTOCOL            (C_M_AXI_PROTOCOL),
           .C_BASE_ADDR             (C_M_AXI_BASE_ADDR),
           .C_HIGH_ADDR             (C_M_AXI_HIGH_ADDR),
           .C_TARGET_QUAL           (P_MI_WRITE_CONNECTIVITY[gen_si_slot*32+:32]),
           .C_M_AXI_SECURE          (C_M_AXI_SECURE),
           .C_RANGE_CHECK           (C_RANGE_CHECK),
           .C_ADDR_DECODE           (C_ADDR_DECODE),
           .C_DEBUG                 (C_DEBUG),
           .C_MAX_DEBUG_THREADS     (C_MAX_DEBUG_THREADS)
           )
          si_transactor_aw
            (
             .ACLK                  (INTERCONNECT_ACLK),
             .ARESET                (reset),
             .S_AID                 (f_extend_ID(S_AXI_AWID[gen_si_slot*C_AXI_ID_WIDTH+:C_AXI_ID_WIDTH], gen_si_slot)),
             .S_AADDR               (S_AXI_AWADDR[gen_si_slot*C_AXI_ADDR_WIDTH+:C_AXI_ADDR_WIDTH]),
             .S_ALEN                (S_AXI_AWLEN[gen_si_slot*8+:8]),
             .S_ASIZE               (S_AXI_AWSIZE[gen_si_slot*3+:3]),
             .S_ABURST              (S_AXI_AWBURST[gen_si_slot*2+:2]),
             .S_ALOCK               (S_AXI_AWLOCK[gen_si_slot*2+:2]),
             .S_APROT               (S_AXI_AWPROT[gen_si_slot*3+:3]),
             .S_AMESG               (si_st_awmesg[gen_si_slot*P_ST_AWMESG_WIDTH+:P_ST_AWMESG_WIDTH]),
             .S_AVALID              (S_AXI_AWVALID[gen_si_slot]),
             .S_AREADY              (S_AXI_AWREADY[gen_si_slot]),
             .M_AID                 (st_aa_awid[gen_si_slot*C_AXI_ID_WIDTH+:C_AXI_ID_WIDTH]),
             .M_AADDR               (st_aa_awaddr[gen_si_slot*C_AXI_ADDR_WIDTH+:C_AXI_ADDR_WIDTH]),
             .M_ALEN                (st_aa_awlen[gen_si_slot*8+:8]),
             .M_ASIZE               (st_aa_awsize[gen_si_slot*3+:3]),
             .M_ALOCK               (st_aa_awlock[gen_si_slot*2+:2]),
             .M_APROT               (st_aa_awprot[gen_si_slot*3+:3]),
             .M_AREGION             (st_aa_awregion[gen_si_slot*4+:4]),
             .M_AMESG               (st_tmp_awmesg[gen_si_slot*P_ST_AWMESG_WIDTH+:P_ST_AWMESG_WIDTH]),
             .M_ATARGET_HOT         (st_aa_awtarget_hot[gen_si_slot*(C_NUM_MASTER_SLOTS+1)+:(C_NUM_MASTER_SLOTS+1)]),
             .M_ATARGET_ENC         (st_aa_awtarget_enc[gen_si_slot*(P_NUM_MASTER_SLOTS_LOG+1)+:(P_NUM_MASTER_SLOTS_LOG+1)]),
             .M_AERROR              (st_aa_awerror[gen_si_slot*8+:8]),
             .M_AVALID_QUAL         (st_aa_awvalid_qual[gen_si_slot]),
             .M_AVALID              (st_ss_awvalid[gen_si_slot]),
             .M_AREADY              (st_ss_awready[gen_si_slot]),
             .S_RID                 (S_AXI_BID[gen_si_slot*C_AXI_ID_WIDTH+:C_AXI_ID_WIDTH]),
             .S_RMESG               (st_si_bmesg[gen_si_slot*P_ST_BMESG_WIDTH+:P_ST_BMESG_WIDTH]),
             .S_RLAST               (),
             .S_RVALID              (S_AXI_BVALID[gen_si_slot]),
             .S_RREADY              (S_AXI_BREADY[gen_si_slot]),
             .M_RID                 (st_mr_bid),
             .M_RLAST               ({(C_NUM_MASTER_SLOTS+1){1'b1}}),
             .M_RMESG               (st_mr_bmesg),
             .M_RVALID              (st_mr_bvalid),
             .M_RREADY              (st_tmp_bready[gen_si_slot*(C_NUM_MASTER_SLOTS+1)+:(C_NUM_MASTER_SLOTS+1)]),
             .M_RTARGET             (st_tmp_bid_target[gen_si_slot*(C_NUM_MASTER_SLOTS+1)+:(C_NUM_MASTER_SLOTS+1)]),
             .DEBUG_A_TRANS_SEQ     (C_DEBUG ? debug_aw_trans_seq_i : 8'h0),
             .DEBUG_ACCEPT_CNT      (DEBUG_AW_ACCEPT_CNT[gen_si_slot*C_MAX_DEBUG_THREADS*8+:C_MAX_DEBUG_THREADS*8]),
             .DEBUG_ACTIVE_THREAD   (DEBUG_AW_ACTIVE_THREAD[gen_si_slot*16+:16]), 
             .DEBUG_ACTIVE_TARGET   (DEBUG_AW_ACTIVE_TARGET[gen_si_slot*C_MAX_DEBUG_THREADS*8+:C_MAX_DEBUG_THREADS*8]), 
             .DEBUG_ACTIVE_REGION   (DEBUG_AW_ACTIVE_REGION[gen_si_slot*C_MAX_DEBUG_THREADS*8+:C_MAX_DEBUG_THREADS*8]), 
             .DEBUG_R_BEAT_CNT      (),       
             .DEBUG_R_TRANS_SEQ     (DEBUG_B_TRANS_SEQ[gen_si_slot*C_MAX_DEBUG_THREADS*8+:C_MAX_DEBUG_THREADS*8]),  
             .DEBUG_TRANS_QUAL      (DEBUG_AW_TRANS_QUAL[gen_si_slot*C_MAX_DEBUG_THREADS+:C_MAX_DEBUG_THREADS])
             );
        
        // Note: Concatenation of mesg signals is from MSB to LSB; assignments that chop mesg signals appear in opposite order.
        assign si_st_awmesg[gen_si_slot*P_ST_AWMESG_WIDTH+:P_ST_AWMESG_WIDTH] = {
          S_AXI_AWUSER[gen_si_slot*C_AXI_AWUSER_WIDTH+:C_AXI_AWUSER_WIDTH],
          S_AXI_AWQOS[gen_si_slot*4+:4],
          S_AXI_AWCACHE[gen_si_slot*4+:4],
          S_AXI_AWBURST[gen_si_slot*2+:2]
          };
        assign tmp_aa_awmesg[gen_si_slot*P_AA_AWMESG_WIDTH+:P_AA_AWMESG_WIDTH] = {
          st_tmp_awmesg[gen_si_slot*P_ST_AWMESG_WIDTH+:P_ST_AWMESG_WIDTH],
          st_aa_awregion[gen_si_slot*4+:4],
          st_aa_awprot[gen_si_slot*3+:3],
          st_aa_awlock[gen_si_slot*2+:2],
          st_aa_awsize[gen_si_slot*3+:3],
          st_aa_awlen[gen_si_slot*8+:8],
          st_aa_awaddr[gen_si_slot*C_AXI_ADDR_WIDTH+:C_AXI_ADDR_WIDTH],
          st_aa_awid[gen_si_slot*C_AXI_ID_WIDTH+:C_AXI_ID_WIDTH]
          };
        assign S_AXI_BRESP[gen_si_slot*2+:2] = st_si_bmesg[gen_si_slot*P_ST_BMESG_WIDTH+:2];
        assign S_AXI_BUSER[gen_si_slot*C_AXI_BUSER_WIDTH+:C_AXI_BUSER_WIDTH] = st_si_bmesg[gen_si_slot*P_ST_BMESG_WIDTH+2 +: C_AXI_BUSER_WIDTH];
        assign DEBUG_AW_ERROR[gen_si_slot*8+:8] = st_aa_awerror[gen_si_slot*8+:8];
        assign DEBUG_AW_TARGET[gen_si_slot*8+:8] = st_aa_awtarget_enc[gen_si_slot*(P_NUM_MASTER_SLOTS_LOG+1)+:(P_NUM_MASTER_SLOTS_LOG+1)];
                       
        // AW SI-transactor transfer completes upon completion of both W-router address acceptance (command push) and AW arbitration
  axi_interconnect_v1_7_13_splitter #  // "SS": Splitter from SI-Transactor (write channel)
          (
            .C_NUM_M                (2)
          )
          splitter_aw_si
          (
             .ACLK                  (INTERCONNECT_ACLK),
             .ARESET                (reset),
             .S_VALID              (st_ss_awvalid[gen_si_slot]),
             .S_READY              (st_ss_awready[gen_si_slot]),
             .M_VALID              ({ss_wr_awvalid[gen_si_slot], ss_aa_awvalid[gen_si_slot]}),
             .M_READY              ({ss_wr_awready[gen_si_slot], ss_aa_awready[gen_si_slot]})
          );
      
  axi_interconnect_v1_7_13_wdata_router #  // "WR": Write data Router
          (
           .C_FAMILY                   (C_FAMILY),
           .C_NUM_MASTER_SLOTS         (C_NUM_MASTER_SLOTS+1),
           .C_SELECT_WIDTH             (P_NUM_MASTER_SLOTS_LOG+1),
           .C_WMESG_WIDTH               (P_WR_WMESG_WIDTH),
           .C_FIFO_DEPTH_LOG           (C_W_ACCEPT_WIDTH[gen_si_slot*32+:6])
           )
          wdata_router_w
            (
             .ACLK    (INTERCONNECT_ACLK),
             .ARESET  (reset),
             // Write transfer input from the current SI-slot
             .S_WMESG  (si_wr_wmesg[gen_si_slot*P_WR_WMESG_WIDTH+:P_WR_WMESG_WIDTH]),
             .S_WLAST  (S_AXI_WLAST[gen_si_slot]),
             .S_WVALID (S_AXI_WVALID[gen_si_slot]),
             .S_WREADY (S_AXI_WREADY[gen_si_slot]),
             // Vector of write transfer outputs to each MI-slot's W-mux
             .M_WMESG  (wr_wm_wmesg[gen_si_slot*(P_WR_WMESG_WIDTH)+:P_WR_WMESG_WIDTH]),
             .M_WLAST  (wr_wm_wlast[gen_si_slot]),
             .M_WVALID (wr_tmp_wvalid[gen_si_slot*(C_NUM_MASTER_SLOTS+1)+:(C_NUM_MASTER_SLOTS+1)]),
             .M_WREADY (wr_tmp_wready[gen_si_slot*(C_NUM_MASTER_SLOTS+1)+:(C_NUM_MASTER_SLOTS+1)]),
             // AW command push from local SI-slot
             .S_ASELECT (st_aa_awtarget_enc[gen_si_slot*(P_NUM_MASTER_SLOTS_LOG+1)+:(P_NUM_MASTER_SLOTS_LOG+1)]),  // Target MI-slot
             .S_AVALID  (ss_wr_awvalid[gen_si_slot]),
             .S_AREADY  (ss_wr_awready[gen_si_slot])
             );
             
        assign si_wr_wmesg[gen_si_slot*P_WR_WMESG_WIDTH+:P_WR_WMESG_WIDTH] = {
          S_AXI_WUSER[gen_si_slot*C_AXI_WUSER_WIDTH+:C_AXI_WUSER_WIDTH],
          S_AXI_WSTRB[gen_si_slot*C_AXI_DATA_MAX_WIDTH/8+:C_INTERCONNECT_DATA_WIDTH/8],
          S_AXI_WDATA[gen_si_slot*C_AXI_DATA_MAX_WIDTH+:C_INTERCONNECT_DATA_WIDTH]
        };        
      end else begin : gen_no_si_write
        assign S_AXI_AWREADY[gen_si_slot] = 1'b0;
        assign ss_aa_awvalid[gen_si_slot] = 1'b0;
        assign st_aa_awvalid_qual[gen_si_slot] = 1'b1;
        assign tmp_aa_awmesg[gen_si_slot*P_AA_AWMESG_WIDTH+:P_AA_AWMESG_WIDTH] = 0;
        assign S_AXI_BID[gen_si_slot*C_AXI_ID_WIDTH+:C_AXI_ID_WIDTH] = 0;
        assign S_AXI_BRESP[gen_si_slot*2+:2] = 0;
        assign S_AXI_BUSER[gen_si_slot*C_AXI_BUSER_WIDTH+:C_AXI_BUSER_WIDTH] = 0;
        assign S_AXI_BVALID[gen_si_slot] = 1'b0;
        assign st_tmp_bready[gen_si_slot*(C_NUM_MASTER_SLOTS+1)+:(C_NUM_MASTER_SLOTS+1)] = 0;
        assign S_AXI_WREADY[gen_si_slot] = 1'b0;
        assign wr_wm_wmesg[gen_si_slot*(P_WR_WMESG_WIDTH)+:P_WR_WMESG_WIDTH] = 0;
        assign wr_wm_wlast[gen_si_slot] = 1'b0;
        assign wr_tmp_wvalid[gen_si_slot*(C_NUM_MASTER_SLOTS+1)+:(C_NUM_MASTER_SLOTS+1)] = 0;
        assign st_aa_awtarget_hot[gen_si_slot*(C_NUM_MASTER_SLOTS+1)+:(C_NUM_MASTER_SLOTS+1)] = 0;
        assign DEBUG_AW_TARGET[gen_si_slot*8+:8] = 0;
        assign DEBUG_AW_ERROR[gen_si_slot*8+:8] = 0;        
        assign DEBUG_AW_TRANS_QUAL[gen_si_slot*C_MAX_DEBUG_THREADS+:C_MAX_DEBUG_THREADS] = 0    ;
        assign DEBUG_AW_ACCEPT_CNT[gen_si_slot*C_MAX_DEBUG_THREADS*8+:C_MAX_DEBUG_THREADS*8] = 0 ;
        assign DEBUG_AW_ACTIVE_THREAD[gen_si_slot*16+:16] = 0 ;
        assign DEBUG_AW_ACTIVE_TARGET[gen_si_slot*C_MAX_DEBUG_THREADS*8+:C_MAX_DEBUG_THREADS*8] = 0 ;
        assign DEBUG_AW_ACTIVE_REGION[gen_si_slot*C_MAX_DEBUG_THREADS*8+:C_MAX_DEBUG_THREADS*8] = 0 ;
        assign DEBUG_B_TRANS_SEQ[gen_si_slot*C_MAX_DEBUG_THREADS*8+:C_MAX_DEBUG_THREADS*8] = 0 ;
      end  // gen_si_write
    end  // gen_slave_slots
    
    for (gen_mi_slot=0; gen_mi_slot<C_NUM_MASTER_SLOTS+1; gen_mi_slot=gen_mi_slot+1) begin : gen_master_slots
      if (P_M_AXI_SUPPORTS_READ[gen_mi_slot]) begin : gen_mi_read
        if (C_NUM_SLAVE_SLOTS>1) begin : gen_rid_decoder
  axi_interconnect_v1_7_13_addr_decoder #
            (
              .C_FAMILY          (C_FAMILY),
              .C_NUM_TARGETS     (C_NUM_SLAVE_SLOTS),
              .C_NUM_TARGETS_LOG (P_NUM_SLAVE_SLOTS_LOG),
              .C_NUM_RANGES      (1),
              .C_ADDR_WIDTH      (C_AXI_ID_WIDTH),
              .C_TARGET_ENC      (C_DEBUG),
              .C_TARGET_HOT      (1),
              .C_REGION_ENC      (0),
              .C_BASE_ADDR       (C_S_AXI_BASE_ID),
              .C_HIGH_ADDR       (C_S_AXI_HIGH_ID),
              .C_TARGET_QUAL     (P_SI_READ_CONNECTIVITY[gen_mi_slot*32+:32]),
              .C_RESOLUTION      (0)
            ) 
            rid_decoder_inst 
            (
              .ADDR             (st_mr_rid[gen_mi_slot*C_AXI_ID_WIDTH+:C_AXI_ID_WIDTH]),        
              .TARGET_HOT       (tmp_mr_rid_target[gen_mi_slot*C_NUM_SLAVE_SLOTS+:C_NUM_SLAVE_SLOTS]),  
              .TARGET_ENC       (debug_rid_target_i[gen_mi_slot*P_NUM_SLAVE_SLOTS_LOG+:P_NUM_SLAVE_SLOTS_LOG]),  
              .MATCH            (rid_match[gen_mi_slot]),       
              .REGION           ()      
            );
          assign DEBUG_RID_TARGET[gen_mi_slot*8+:8] = debug_rid_target_i[gen_mi_slot*P_NUM_SLAVE_SLOTS_LOG+:P_NUM_SLAVE_SLOTS_LOG];
          assign DEBUG_RID_ERROR[gen_mi_slot] = ~rid_match[gen_mi_slot];
        end else begin : gen_no_rid_decoder
          assign tmp_mr_rid_target[gen_mi_slot] = 1'b1;  // All response transfers route to solo SI-slot.
          assign rid_match[gen_mi_slot] = 1'b1;
          assign DEBUG_RID_TARGET[gen_mi_slot*8+:8] = 0;
          assign DEBUG_RID_ERROR[gen_mi_slot] = 1'b0;
        end
        
        assign st_mr_rmesg[gen_mi_slot*P_ST_RMESG_WIDTH+:P_ST_RMESG_WIDTH] = {
          st_mr_rdata[gen_mi_slot*C_INTERCONNECT_DATA_WIDTH+:C_INTERCONNECT_DATA_WIDTH],
          st_mr_ruser[gen_mi_slot*C_AXI_RUSER_WIDTH+:C_AXI_RUSER_WIDTH], 
          st_mr_rresp[gen_mi_slot*2+:2]
          }; 
      end else begin : gen_no_mi_read
        assign tmp_mr_rid_target[gen_mi_slot*C_NUM_SLAVE_SLOTS+:C_NUM_SLAVE_SLOTS] = 0;
        assign rid_match[gen_mi_slot] = 1'b0;
        assign DEBUG_RID_TARGET[gen_mi_slot*8+:8] = 0;
        assign DEBUG_RID_ERROR[gen_mi_slot] = 1'b0;
        assign st_mr_rmesg[gen_mi_slot*P_ST_RMESG_WIDTH+:P_ST_RMESG_WIDTH] = 0;
      end  // gen_mi_read
      
      if (P_M_AXI_SUPPORTS_WRITE[gen_mi_slot]) begin : gen_mi_write
        if (C_NUM_SLAVE_SLOTS>1) begin : gen_bid_decoder
  axi_interconnect_v1_7_13_addr_decoder #
            (
              .C_FAMILY          (C_FAMILY),
              .C_NUM_TARGETS     (C_NUM_SLAVE_SLOTS),
              .C_NUM_TARGETS_LOG (P_NUM_SLAVE_SLOTS_LOG),
              .C_NUM_RANGES      (1),
              .C_ADDR_WIDTH      (C_AXI_ID_WIDTH),
              .C_TARGET_ENC      (C_DEBUG),
              .C_TARGET_HOT      (1),
              .C_REGION_ENC      (0),
              .C_BASE_ADDR      (C_S_AXI_BASE_ID),
              .C_HIGH_ADDR      (C_S_AXI_HIGH_ID),
              .C_TARGET_QUAL     (P_SI_WRITE_CONNECTIVITY[gen_mi_slot*32+:32]),
              .C_RESOLUTION      (0)
            ) 
            bid_decoder_inst 
            (
              .ADDR             (st_mr_bid[gen_mi_slot*C_AXI_ID_WIDTH+:C_AXI_ID_WIDTH]),        
              .TARGET_HOT       (tmp_mr_bid_target[gen_mi_slot*C_NUM_SLAVE_SLOTS+:C_NUM_SLAVE_SLOTS]),  
              .TARGET_ENC       (debug_bid_target_i[gen_mi_slot*P_NUM_SLAVE_SLOTS_LOG+:P_NUM_SLAVE_SLOTS_LOG]),  
              .MATCH            (bid_match[gen_mi_slot]),       
              .REGION           ()      
            );
          assign DEBUG_BID_TARGET[gen_mi_slot*8+:8] = debug_bid_target_i[gen_mi_slot*P_NUM_SLAVE_SLOTS_LOG+:P_NUM_SLAVE_SLOTS_LOG];
          assign DEBUG_BID_ERROR[gen_mi_slot] = ~bid_match[gen_mi_slot];
        end else begin : gen_no_bid_decoder
          assign tmp_mr_bid_target[gen_mi_slot] = 1'b1;  // All response transfers route to solo SI-slot.
          assign bid_match[gen_mi_slot] = 1'b1;
          assign DEBUG_BID_TARGET[gen_mi_slot*8+:8] = 0;
          assign DEBUG_BID_ERROR[gen_mi_slot] = 1'b0;
        end
      
  axi_interconnect_v1_7_13_wdata_mux #  // "WM": Write data Mux, per MI-slot (incl error-handler)
          (
           .C_FAMILY                   (C_FAMILY),
           .C_NUM_SLAVE_SLOTS         (C_NUM_SLAVE_SLOTS),
           .C_SELECT_WIDTH     (P_NUM_SLAVE_SLOTS_LOG),
           .C_WMESG_WIDTH               (P_WR_WMESG_WIDTH),
           .C_FIFO_DEPTH_LOG           (C_W_ISSUE_WIDTH[gen_mi_slot*32+:6])
           )
          wdata_mux_w
            (
             .ACLK    (INTERCONNECT_ACLK),
             .ARESET  (reset),
             // Vector of write transfer inputs from each SI-slot's W-router
             .S_WMESG  (wr_wm_wmesg),
             .S_WLAST  (wr_wm_wlast),
             .S_WVALID (tmp_wm_wvalid[gen_mi_slot*C_NUM_SLAVE_SLOTS+:C_NUM_SLAVE_SLOTS]),
             .S_WREADY (tmp_wm_wready[gen_mi_slot*C_NUM_SLAVE_SLOTS+:C_NUM_SLAVE_SLOTS]),
             // Write transfer output to the current MI-slot
             .M_WMESG  (wm_mr_wmesg[gen_mi_slot*P_WR_WMESG_WIDTH+:P_WR_WMESG_WIDTH]),
             .M_WLAST  (wm_mr_wlast[gen_mi_slot]),
             .M_WVALID (wm_mr_wvalid[gen_mi_slot]),
             .M_WREADY (wm_mr_wready[gen_mi_slot]),
             // AW command push from AW arbiter output
             .S_ASELECT (aa_wm_awgrant_enc),  // SI-slot selected by arbiter
             .S_AVALID  (sa_wm_awvalid[gen_mi_slot]),
             .S_AREADY  (sa_wm_awready[gen_mi_slot])
             );
             
        if (C_DEBUG) begin : gen_debug_w
          // DEBUG WRITE BEAT COUNTER
          always @(posedge INTERCONNECT_ACLK) begin
            if (reset) begin
              debug_w_beat_cnt_i[gen_mi_slot*8+:8] <= 0;
            end else begin
              if (mi_wvalid[gen_mi_slot] & mi_wready[gen_mi_slot]) begin
                if (mi_wlast[gen_mi_slot]) begin
                  debug_w_beat_cnt_i[gen_mi_slot*8+:8] <= 0;
                end else begin
                  debug_w_beat_cnt_i[gen_mi_slot*8+:8] <= debug_w_beat_cnt_i[gen_mi_slot*8+:8] + 1;
                end
              end
            end
          end  // clocked process
  
          // DEBUG W-CHANNEL TRANSACTION SEQUENCE QUEUE
  axi_interconnect_v1_7_13_axic_srl_fifo #
            (
             .C_FAMILY          (C_FAMILY),
             .C_FIFO_WIDTH      (8),
             .C_FIFO_DEPTH_LOG  (C_W_ISSUE_WIDTH[gen_mi_slot*32+:6]),
             .C_USE_FULL        (0)
             )
            debug_w_seq_fifo
              (
               .ACLK    (INTERCONNECT_ACLK),
               .ARESET  (reset),
               .S_MESG  (debug_aw_trans_seq_i),
               .S_VALID (sa_wm_awvalid[gen_mi_slot]),
               .S_READY (),
               .M_MESG  (debug_w_trans_seq_i[gen_mi_slot*8+:8]),
               .M_VALID (),
               .M_READY (mi_wvalid[gen_mi_slot] & mi_wready[gen_mi_slot] & mi_wlast[gen_mi_slot])
              );
          assign DEBUG_W_BEAT_CNT[gen_mi_slot*8+:8] = debug_w_beat_cnt_i[gen_mi_slot*8+:8];
          assign DEBUG_W_TRANS_SEQ[gen_mi_slot*8+:8] = debug_w_trans_seq_i[gen_mi_slot*8+:8];
        end else begin : gen_no_debug_w
          assign DEBUG_W_BEAT_CNT[gen_mi_slot*8+:8] = 0;
          assign DEBUG_W_TRANS_SEQ[gen_mi_slot*8+:8] = 0;
        end  // gen_debug_w
             
        assign wm_mr_wdata[gen_mi_slot*C_INTERCONNECT_DATA_WIDTH+:C_INTERCONNECT_DATA_WIDTH] = wm_mr_wmesg[gen_mi_slot*P_WR_WMESG_WIDTH +: C_INTERCONNECT_DATA_WIDTH];
        assign wm_mr_wstrb[gen_mi_slot*C_INTERCONNECT_DATA_WIDTH/8+:C_INTERCONNECT_DATA_WIDTH/8] = wm_mr_wmesg[gen_mi_slot*P_WR_WMESG_WIDTH+C_INTERCONNECT_DATA_WIDTH +: C_INTERCONNECT_DATA_WIDTH/8];
        assign wm_mr_wuser[gen_mi_slot*C_AXI_WUSER_WIDTH+:C_AXI_WUSER_WIDTH] = wm_mr_wmesg[gen_mi_slot*P_WR_WMESG_WIDTH+C_INTERCONNECT_DATA_WIDTH+C_INTERCONNECT_DATA_WIDTH/8 +: C_AXI_WUSER_WIDTH];
        assign st_mr_bmesg[gen_mi_slot*P_ST_BMESG_WIDTH+:P_ST_BMESG_WIDTH] = {
          st_mr_buser[gen_mi_slot*C_AXI_BUSER_WIDTH+:C_AXI_BUSER_WIDTH],
          st_mr_bresp[gen_mi_slot*2+:2]
          }; 
      end else begin : gen_no_mi_write
        assign tmp_mr_bid_target[gen_mi_slot*C_NUM_SLAVE_SLOTS+:C_NUM_SLAVE_SLOTS] = 0;
        assign bid_match[gen_mi_slot] = 1'b0;
        assign wm_mr_wvalid[gen_mi_slot] = 0;
        assign wm_mr_wlast[gen_mi_slot] = 0;
        assign wm_mr_wdata[gen_mi_slot*C_INTERCONNECT_DATA_WIDTH+:C_INTERCONNECT_DATA_WIDTH] = 0;
        assign wm_mr_wstrb[gen_mi_slot*C_INTERCONNECT_DATA_WIDTH/8+:C_INTERCONNECT_DATA_WIDTH/8] = 0;
        assign wm_mr_wuser[gen_mi_slot*C_AXI_WUSER_WIDTH+:C_AXI_WUSER_WIDTH] = 0;
        assign st_mr_bmesg[gen_mi_slot*P_ST_BMESG_WIDTH+:P_ST_BMESG_WIDTH] = 0;
        assign tmp_wm_wready[gen_mi_slot*C_NUM_SLAVE_SLOTS+:C_NUM_SLAVE_SLOTS] = 0;
        assign sa_wm_awready[gen_mi_slot] = 0;
        assign DEBUG_BID_TARGET[gen_mi_slot*8+:8] = 0;
        assign DEBUG_BID_ERROR[gen_mi_slot] = 1'b0;
        assign DEBUG_W_BEAT_CNT[gen_mi_slot*8+:8] = 0;
        assign DEBUG_W_TRANS_SEQ[gen_mi_slot*8+:8] = 0;
      end  // gen_mi_write
      
      for (gen_si_slot=0; gen_si_slot<C_NUM_SLAVE_SLOTS; gen_si_slot=gen_si_slot+1) begin : gen_trans_si
        // Transpose handshakes from W-router (SxM) to W-mux (MxS).
        assign tmp_wm_wvalid[gen_mi_slot*C_NUM_SLAVE_SLOTS+gen_si_slot] = wr_tmp_wvalid[gen_si_slot*(C_NUM_MASTER_SLOTS+1)+gen_mi_slot];
        assign wr_tmp_wready[gen_si_slot*(C_NUM_MASTER_SLOTS+1)+gen_mi_slot] = tmp_wm_wready[gen_mi_slot*C_NUM_SLAVE_SLOTS+gen_si_slot];
        // Transpose response enables from ID decoders (MxS) to si_transactors (SxM).
        assign st_tmp_bid_target[gen_si_slot*(C_NUM_MASTER_SLOTS+1)+gen_mi_slot] = tmp_mr_bid_target[gen_mi_slot*C_NUM_SLAVE_SLOTS+gen_si_slot];
        assign st_tmp_rid_target[gen_si_slot*(C_NUM_MASTER_SLOTS+1)+gen_mi_slot] = tmp_mr_rid_target[gen_mi_slot*C_NUM_SLAVE_SLOTS+gen_si_slot];
      end  // gen_trans_si
      
      assign bready_carry[gen_mi_slot] =  st_tmp_bready[gen_mi_slot];
      assign rready_carry[gen_mi_slot] =  st_tmp_rready[gen_mi_slot];
      for (gen_si_slot=1; gen_si_slot<C_NUM_SLAVE_SLOTS; gen_si_slot=gen_si_slot+1) begin : gen_resp_carry_si
        assign bready_carry[gen_si_slot*(C_NUM_MASTER_SLOTS+1)+gen_mi_slot] =  // Generate M_BREADY if ...
          bready_carry[(gen_si_slot-1)*(C_NUM_MASTER_SLOTS+1)+gen_mi_slot] |  // For any SI-slot (OR carry-chain across all SI-slots), ...
          st_tmp_bready[gen_si_slot*(C_NUM_MASTER_SLOTS+1)+gen_mi_slot];  // The write SI transactor indicates BREADY for that MI-slot.
        assign rready_carry[gen_si_slot*(C_NUM_MASTER_SLOTS+1)+gen_mi_slot] =  // Generate M_RREADY if ...
          rready_carry[(gen_si_slot-1)*(C_NUM_MASTER_SLOTS+1)+gen_mi_slot] |  // For any SI-slot (OR carry-chain across all SI-slots), ...
          st_tmp_rready[gen_si_slot*(C_NUM_MASTER_SLOTS+1)+gen_mi_slot];  // The write SI transactor indicates RREADY for that MI-slot.
      end  // gen_resp_carry_si
           
      // ENHANCEMENT?: Conditionally generate if C_*_ISSUING > 0, otherwise issuing is unlimited.
      assign w_cmd_push[gen_mi_slot] = mi_awvalid[gen_mi_slot] && mi_awready[gen_mi_slot] && P_M_AXI_SUPPORTS_WRITE[gen_mi_slot];
      assign r_cmd_push[gen_mi_slot] = mi_arvalid[gen_mi_slot] && mi_arready[gen_mi_slot] && P_M_AXI_SUPPORTS_READ[gen_mi_slot];
      assign w_cmd_pop[gen_mi_slot] = st_mr_bvalid[gen_mi_slot] && st_mr_bready[gen_mi_slot] && P_M_AXI_SUPPORTS_WRITE[gen_mi_slot];
      assign r_cmd_pop[gen_mi_slot] = st_mr_rvalid[gen_mi_slot] && st_mr_rready[gen_mi_slot] && st_mr_rlast[gen_mi_slot] && P_M_AXI_SUPPORTS_READ[gen_mi_slot];
      // Disqualify arbitration of SI-slot if targeted MI-slot has reached its issuing limit.
      assign mi_awmaxissuing[gen_mi_slot] = (P_M_AXI_PROTOCOL[gen_mi_slot*32+:32] == P_AXILITE) ? w_issuing_cnt[gen_mi_slot*8] :
        (w_issuing_cnt[gen_mi_slot*8 +: (C_W_ISSUE_WIDTH[gen_mi_slot*32+:6]+1)] == 
          C_M_AXI_WRITE_ISSUING[gen_mi_slot*32 +: (C_W_ISSUE_WIDTH[gen_mi_slot*32+:6]+1)]) & ~w_cmd_pop[gen_mi_slot];
      assign mi_armaxissuing[gen_mi_slot] = (P_M_AXI_PROTOCOL[gen_mi_slot*32+:32] == P_AXILITE) ? r_issuing_cnt[gen_mi_slot*8] :
        (r_issuing_cnt[gen_mi_slot*8 +: (C_R_ISSUE_WIDTH[gen_mi_slot*32+:6]+1)] == 
          C_M_AXI_READ_ISSUING[gen_mi_slot*32 +: (C_R_ISSUE_WIDTH[gen_mi_slot*32+:6]+1)]) & ~r_cmd_pop[gen_mi_slot];
      
      always @(posedge INTERCONNECT_ACLK) begin
        if (reset) begin
          w_issuing_cnt[gen_mi_slot*8+:8] <= 0;  // Some high-order bits remain constant 0
          r_issuing_cnt[gen_mi_slot*8+:8] <= 0;  // Some high-order bits remain constant 0
        end else begin
          if (w_cmd_push[gen_mi_slot] && ~w_cmd_pop[gen_mi_slot]) begin
            w_issuing_cnt[gen_mi_slot*8+:(C_W_ISSUE_WIDTH[gen_mi_slot*32+:6]+1)] <= w_issuing_cnt[gen_mi_slot*8+:(C_W_ISSUE_WIDTH[gen_mi_slot*32+:6]+1)] + 1;
          end else if (w_cmd_pop[gen_mi_slot] && ~w_cmd_push[gen_mi_slot] && (|w_issuing_cnt[gen_mi_slot*8+:(C_W_ISSUE_WIDTH[gen_mi_slot*32+:6]+1)])) begin
            w_issuing_cnt[gen_mi_slot*8+:(C_W_ISSUE_WIDTH[gen_mi_slot*32+:6]+1)] <= w_issuing_cnt[gen_mi_slot*8+:(C_W_ISSUE_WIDTH[gen_mi_slot*32+:6]+1)] - 1;
          end
          if (r_cmd_push[gen_mi_slot] && ~r_cmd_pop[gen_mi_slot]) begin
            r_issuing_cnt[gen_mi_slot*8+:(C_R_ISSUE_WIDTH[gen_mi_slot*32+:6]+1)] <= r_issuing_cnt[gen_mi_slot*8+:(C_R_ISSUE_WIDTH[gen_mi_slot*32+:6]+1)] + 1;
          end else if (r_cmd_pop[gen_mi_slot] && ~r_cmd_push[gen_mi_slot] && (|r_issuing_cnt[gen_mi_slot*8+:(C_R_ISSUE_WIDTH[gen_mi_slot*32+:6]+1)])) begin
            r_issuing_cnt[gen_mi_slot*8+:(C_R_ISSUE_WIDTH[gen_mi_slot*32+:6]+1)] <= r_issuing_cnt[gen_mi_slot*8+:(C_R_ISSUE_WIDTH[gen_mi_slot*32+:6]+1)] - 1;
          end
        end
      end  // Clocked process
      
      assign DEBUG_AW_ISSUING_CNT[gen_mi_slot*8+:8] = w_issuing_cnt[gen_mi_slot*8+:8];
      assign DEBUG_AR_ISSUING_CNT[gen_mi_slot*8+:8] = r_issuing_cnt[gen_mi_slot*8+:8];

      // Reg-slice must break combinatorial path from M_BID and M_RID inputs to M_BREADY and M_RREADY outputs.
      //   (See m_rready_i and m_resp_en combinatorial assignments in si_transactor.)
      //   Reg-slice incurs +1 latency, but no bubble-cycles.
  axi_interconnect_v1_7_13_axi_register_slice #  // "MR": MI-side R/B-channel Reg-slice, per MI-slot (pass-through if only 1 SI-slot configured)
        (
          .C_FAMILY                         (C_FAMILY),
          .C_AXI_ID_WIDTH                   (C_AXI_ID_WIDTH),
          .C_AXI_ADDR_WIDTH                 (1),
          .C_AXI_DATA_WIDTH                 (C_INTERCONNECT_DATA_WIDTH),
          .C_AXI_SUPPORTS_USER_SIGNALS      (C_AXI_SUPPORTS_USER_SIGNALS),
          .C_AXI_AWUSER_WIDTH               (1),
          .C_AXI_ARUSER_WIDTH               (1),
          .C_AXI_WUSER_WIDTH                (C_AXI_WUSER_WIDTH),
          .C_AXI_RUSER_WIDTH                (C_AXI_RUSER_WIDTH),
          .C_AXI_BUSER_WIDTH                (C_AXI_BUSER_WIDTH),
          .C_REG_CONFIG_AW                  (P_BYPASS),
          .C_REG_CONFIG_AR                  (P_BYPASS),
          .C_REG_CONFIG_W                   ((P_M_AXI_SUPPORTS_WRITE[gen_mi_slot] & (P_M_AXI_PROTOCOL[gen_mi_slot*32+:32]!=P_AXILITE) &
                                              (P_M_AXI_DATA_WIDTH[gen_mi_slot*32+:32] != C_INTERCONNECT_DATA_WIDTH)) ? P_FWD_REV : P_BYPASS),
          .C_REG_CONFIG_R                   (P_M_AXI_SUPPORTS_READ[gen_mi_slot] ? ((P_M_AXI_PROTOCOL[gen_mi_slot*32+:32]==P_AXILITE) ? P_SIMPLE : P_FWD_REV) : P_BYPASS),
          .C_REG_CONFIG_B                   (P_M_AXI_SUPPORTS_WRITE[gen_mi_slot] ? P_SIMPLE : P_BYPASS)
        )
        reg_slice_mi 
        (
          .ARESETN                     (ARESETN),
          .ACLK                       (INTERCONNECT_ACLK),
          .S_AXI_AWID                       ({C_AXI_ID_WIDTH{1'b0}}),
          .S_AXI_AWADDR                     ({1{1'b0}}),
          .S_AXI_AWLEN                      ({8{1'b0}}),
          .S_AXI_AWSIZE                     ({3{1'b0}}),
          .S_AXI_AWBURST                    ({2{1'b0}}),
          .S_AXI_AWLOCK                     ({2{1'b0}}),
          .S_AXI_AWCACHE                    ({4{1'b0}}),
          .S_AXI_AWPROT                     ({3{1'b0}}),
          .S_AXI_AWREGION                   ({4{1'b0}}),
          .S_AXI_AWQOS                      ({4{1'b0}}),
          .S_AXI_AWUSER                     ({1{1'b0}}),
          .S_AXI_AWVALID                    ({1{1'b0}}),
          .S_AXI_AWREADY                    (),
          .S_AXI_WID                        ({C_AXI_ID_WIDTH{1'b0}}),
          .S_AXI_WDATA                      (wm_mr_wdata[gen_mi_slot*C_INTERCONNECT_DATA_WIDTH+:C_INTERCONNECT_DATA_WIDTH]),
          .S_AXI_WSTRB                      (wm_mr_wstrb[gen_mi_slot*C_INTERCONNECT_DATA_WIDTH/8+:C_INTERCONNECT_DATA_WIDTH/8]),
          .S_AXI_WLAST                      (wm_mr_wlast[gen_mi_slot]),
          .S_AXI_WUSER                      (wm_mr_wuser[gen_mi_slot*C_AXI_WUSER_WIDTH+:C_AXI_WUSER_WIDTH]),
          .S_AXI_WVALID                     (wm_mr_wvalid[gen_mi_slot]),
          .S_AXI_WREADY                     (wm_mr_wready[gen_mi_slot]),
          .S_AXI_BID                        (st_mr_bid[gen_mi_slot*C_AXI_ID_WIDTH+:C_AXI_ID_WIDTH]         ),
          .S_AXI_BRESP                      (st_mr_bresp[gen_mi_slot*2+:2]                                 ),
          .S_AXI_BUSER                      (st_mr_buser[gen_mi_slot*C_AXI_BUSER_WIDTH+:C_AXI_BUSER_WIDTH] ),
          .S_AXI_BVALID                     (st_mr_bvalid[gen_mi_slot*1+:1]                                ),
          .S_AXI_BREADY                     (st_mr_bready[gen_mi_slot*1+:1]                                ),
          .S_AXI_ARID                       ({C_AXI_ID_WIDTH{1'b0}}),
          .S_AXI_ARADDR                     ({1{1'b0}}),
          .S_AXI_ARLEN                      ({8{1'b0}}),
          .S_AXI_ARSIZE                     ({3{1'b0}}),
          .S_AXI_ARBURST                    ({2{1'b0}}),
          .S_AXI_ARLOCK                     ({2{1'b0}}),
          .S_AXI_ARCACHE                    ({4{1'b0}}),
          .S_AXI_ARPROT                     ({3{1'b0}}),
          .S_AXI_ARREGION                   ({4{1'b0}}),
          .S_AXI_ARQOS                      ({4{1'b0}}),
          .S_AXI_ARUSER                     ({1{1'b0}}),
          .S_AXI_ARVALID                    ({1{1'b0}}),
          .S_AXI_ARREADY                    (),
          .S_AXI_RID                        (st_mr_rid[gen_mi_slot*C_AXI_ID_WIDTH+:C_AXI_ID_WIDTH]                          ),
          .S_AXI_RDATA                      (st_mr_rdata[gen_mi_slot*C_INTERCONNECT_DATA_WIDTH+:C_INTERCONNECT_DATA_WIDTH]  ),
          .S_AXI_RRESP                      (st_mr_rresp[gen_mi_slot*2+:2]                                                  ),
          .S_AXI_RLAST                      (st_mr_rlast[gen_mi_slot*1+:1]                                                  ),
          .S_AXI_RUSER                      (st_mr_ruser[gen_mi_slot*C_AXI_RUSER_WIDTH+:C_AXI_RUSER_WIDTH]                  ),
          .S_AXI_RVALID                     (st_mr_rvalid[gen_mi_slot*1+:1]                                                 ),
          .S_AXI_RREADY                     (st_mr_rready[gen_mi_slot*1+:1]                                                 ),
          .M_AXI_AWID                       (),
          .M_AXI_AWADDR                     (),
          .M_AXI_AWLEN                      (),
          .M_AXI_AWSIZE                     (),
          .M_AXI_AWBURST                    (),
          .M_AXI_AWLOCK                     (),
          .M_AXI_AWCACHE                    (),
          .M_AXI_AWPROT                     (),
          .M_AXI_AWREGION                   (),
          .M_AXI_AWQOS                      (),
          .M_AXI_AWUSER                     (),
          .M_AXI_AWVALID                    (),
          .M_AXI_AWREADY                    ({1{1'b0}}),
          .M_AXI_WID                        (),
          .M_AXI_WDATA                      (mi_wdata[gen_mi_slot*C_INTERCONNECT_DATA_WIDTH+:C_INTERCONNECT_DATA_WIDTH]),
          .M_AXI_WSTRB                      (mi_wstrb[gen_mi_slot*C_INTERCONNECT_DATA_WIDTH/8+:C_INTERCONNECT_DATA_WIDTH/8]),
          .M_AXI_WLAST                      (mi_wlast[gen_mi_slot]),
          .M_AXI_WUSER                      (mi_wuser[gen_mi_slot*C_AXI_WUSER_WIDTH+:C_AXI_WUSER_WIDTH]),
          .M_AXI_WVALID                     (mi_wvalid[gen_mi_slot]),
          .M_AXI_WREADY                     (mi_wready[gen_mi_slot]),
          .M_AXI_BID                        (mi_bid[gen_mi_slot*C_AXI_ID_WIDTH+:C_AXI_ID_WIDTH]                          ),
          .M_AXI_BRESP                      (mi_bresp[gen_mi_slot*2+:2]                                                  ),
          .M_AXI_BUSER                      (mi_buser[gen_mi_slot*C_AXI_BUSER_WIDTH+:C_AXI_BUSER_WIDTH]                  ),
          .M_AXI_BVALID                     (mi_bvalid[gen_mi_slot*1+:1]                                                 ),
          .M_AXI_BREADY                     (mi_bready[gen_mi_slot*1+:1]                                                 ),
          .M_AXI_ARID                       (),
          .M_AXI_ARADDR                     (),
          .M_AXI_ARLEN                      (),
          .M_AXI_ARSIZE                     (),
          .M_AXI_ARBURST                    (),
          .M_AXI_ARLOCK                     (),
          .M_AXI_ARCACHE                    (),
          .M_AXI_ARPROT                     (),
          .M_AXI_ARREGION                   (),
          .M_AXI_ARQOS                      (),
          .M_AXI_ARUSER                     (),
          .M_AXI_ARVALID                    (),
          .M_AXI_ARREADY                    ({1{1'b0}}),
          .M_AXI_RID                        (mi_rid[gen_mi_slot*C_AXI_ID_WIDTH+:C_AXI_ID_WIDTH]                          ),
          .M_AXI_RDATA                      (mi_rdata[gen_mi_slot*C_AXI_DATA_MAX_WIDTH+:C_INTERCONNECT_DATA_WIDTH]  ),
          .M_AXI_RRESP                      (mi_rresp[gen_mi_slot*2+:2]                                                  ),
          .M_AXI_RLAST                      (mi_rlast[gen_mi_slot*1+:1]                                                  ),
          .M_AXI_RUSER                      (mi_ruser[gen_mi_slot*C_AXI_RUSER_WIDTH+:C_AXI_RUSER_WIDTH]                  ),
          .M_AXI_RVALID                     (mi_rvalid[gen_mi_slot*1+:1]                                                 ),
          .M_AXI_RREADY                     (mi_rready[gen_mi_slot*1+:1]                                                 )
        );
    end  // gen_master_slots (Next gen_mi_slot)
  
    // Highest row of *ready_carry contains accumulated OR across all SI-slots, for each MI-slot.
    assign st_mr_bready = bready_carry[(C_NUM_SLAVE_SLOTS-1)*(C_NUM_MASTER_SLOTS+1) +: C_NUM_MASTER_SLOTS+1]; 
    assign st_mr_rready = rready_carry[(C_NUM_SLAVE_SLOTS-1)*(C_NUM_MASTER_SLOTS+1) +: C_NUM_MASTER_SLOTS+1]; 
    // Assign MI-side B, R and W channel ports (exclude error handler signals).
    assign mi_bid[0+:C_NUM_MASTER_SLOTS*C_AXI_ID_WIDTH] = M_AXI_BID;
    assign mi_bvalid[0+:C_NUM_MASTER_SLOTS] = M_AXI_BVALID; 
    assign mi_bresp[0+:C_NUM_MASTER_SLOTS*2] = M_AXI_BRESP;
    assign mi_buser[0+:C_NUM_MASTER_SLOTS*C_AXI_BUSER_WIDTH] = M_AXI_BUSER;
    assign M_AXI_BREADY = mi_bready[0+:C_NUM_MASTER_SLOTS];
    assign mi_rid[0+:C_NUM_MASTER_SLOTS*C_AXI_ID_WIDTH] = M_AXI_RID;
    assign mi_rlast[0+:C_NUM_MASTER_SLOTS] = M_AXI_RLAST; 
    assign mi_rvalid[0+:C_NUM_MASTER_SLOTS] = M_AXI_RVALID; 
    assign mi_rresp[0+:C_NUM_MASTER_SLOTS*2] = M_AXI_RRESP;
    assign mi_ruser[0+:C_NUM_MASTER_SLOTS*C_AXI_RUSER_WIDTH] = M_AXI_RUSER;
    assign mi_rdata[0+:C_NUM_MASTER_SLOTS*C_AXI_DATA_MAX_WIDTH] = M_AXI_RDATA;
    assign M_AXI_RREADY = mi_rready[0+:C_NUM_MASTER_SLOTS];
    assign M_AXI_WLAST = mi_wlast[0+:C_NUM_MASTER_SLOTS];
    assign M_AXI_WVALID = mi_wvalid[0+:C_NUM_MASTER_SLOTS];
    assign M_AXI_WUSER = mi_wuser[0+:C_NUM_MASTER_SLOTS*C_AXI_WUSER_WIDTH];
    assign mi_wready[0+:C_NUM_MASTER_SLOTS] = M_AXI_WREADY;
    for (gen_mi_slot=0; gen_mi_slot<C_NUM_MASTER_SLOTS; gen_mi_slot=gen_mi_slot+1) begin : gen_mi_w
      assign M_AXI_WDATA[gen_mi_slot*C_AXI_DATA_MAX_WIDTH+:C_AXI_DATA_MAX_WIDTH] = mi_wdata[gen_mi_slot*C_INTERCONNECT_DATA_WIDTH+:C_INTERCONNECT_DATA_WIDTH];
      assign M_AXI_WSTRB[gen_mi_slot*C_AXI_DATA_MAX_WIDTH/8+:C_AXI_DATA_MAX_WIDTH/8] = mi_wstrb[gen_mi_slot*C_INTERCONNECT_DATA_WIDTH/8+:C_INTERCONNECT_DATA_WIDTH/8];
    end

  axi_interconnect_v1_7_13_addr_arbiter #  // "AA": Addr Arbiter (AW channel)
      (
       .C_MAX_S                 (C_MAX_S),
       .C_FAMILY                (C_FAMILY),
       .C_NUM_M                 (C_NUM_MASTER_SLOTS+1),
       .C_NUM_S                 (C_NUM_SLAVE_SLOTS),
       .C_NUM_S_LOG             (P_NUM_SLAVE_SLOTS_LOG),
       .C_MESG_WIDTH            (P_AA_AWMESG_WIDTH),
       .C_ARB_PRIORITY          (C_S_AXI_ARB_PRIORITY)
       )
      addr_arbiter_aw
        (
         .ACLK                  (INTERCONNECT_ACLK),
         .ARESET                (reset),
         // Vector of SI-side AW command request inputs
         .S_MESG                (tmp_aa_awmesg),
         .S_TARGET_HOT          (st_aa_awtarget_hot),
         .S_VALID               (ss_aa_awvalid),
         .S_VALID_QUAL          (st_aa_awvalid_qual),
         .S_READY               (ss_aa_awready),
         // Granted AW command output
         .M_MESG                (aa_mi_awmesg),
         .M_TARGET_HOT          (aa_mi_awtarget_hot),  // MI-slot targeted by granted command
         .M_GRANT_ENC           (aa_wm_awgrant_enc),  // SI-slot index of granted command
         .M_VALID               (aa_sa_awvalid),
         .M_READY               (aa_sa_awready),
         .ISSUING_LIMIT        (mi_awmaxissuing)
        );
         
    assign DEBUG_AW_ARB_GRANT = aa_wm_awgrant_enc;

    // Broadcast AW transfer payload to all MI-slots
    assign M_AXI_AWID        = {C_NUM_MASTER_SLOTS{aa_mi_awmesg[0+:C_AXI_ID_WIDTH]}};
    assign M_AXI_AWADDR      = {C_NUM_MASTER_SLOTS{aa_mi_awmesg[C_AXI_ID_WIDTH+:C_AXI_ADDR_WIDTH]}};
    assign M_AXI_AWLEN       = {C_NUM_MASTER_SLOTS{aa_mi_awmesg[C_AXI_ID_WIDTH+C_AXI_ADDR_WIDTH +:8]}};
    assign M_AXI_AWSIZE      = {C_NUM_MASTER_SLOTS{aa_mi_awmesg[C_AXI_ID_WIDTH+C_AXI_ADDR_WIDTH+8 +:3]}};
    assign M_AXI_AWLOCK      = {C_NUM_MASTER_SLOTS{aa_mi_awmesg[C_AXI_ID_WIDTH+C_AXI_ADDR_WIDTH+8+3 +:2]}};
    assign M_AXI_AWPROT      = {C_NUM_MASTER_SLOTS{aa_mi_awmesg[C_AXI_ID_WIDTH+C_AXI_ADDR_WIDTH+8+3+2 +:3]}};
    assign M_AXI_AWREGION    = {C_NUM_MASTER_SLOTS{aa_mi_awmesg[C_AXI_ID_WIDTH+C_AXI_ADDR_WIDTH+8+3+2+3 +:4]}};
    assign M_AXI_AWBURST     = {C_NUM_MASTER_SLOTS{aa_mi_awmesg[C_AXI_ID_WIDTH+C_AXI_ADDR_WIDTH+8+3+2+3+4 +:2]}};
    assign M_AXI_AWCACHE     = {C_NUM_MASTER_SLOTS{aa_mi_awmesg[C_AXI_ID_WIDTH+C_AXI_ADDR_WIDTH+8+3+2+3+4+2 +:4]}};
    assign M_AXI_AWQOS       = {C_NUM_MASTER_SLOTS{aa_mi_awmesg[C_AXI_ID_WIDTH+C_AXI_ADDR_WIDTH+8+3+2+3+4+2+4 +:4]}};
    assign M_AXI_AWUSER      = {C_NUM_MASTER_SLOTS{aa_mi_awmesg[C_AXI_ID_WIDTH+C_AXI_ADDR_WIDTH+8+3+2+3+4+2+4+4 +:C_AXI_AWUSER_WIDTH]}};
         
  axi_interconnect_v1_7_13_addr_arbiter #  // "AA": Addr Arbiter (AR channel)
      (
       .C_MAX_S                 (C_MAX_S),
       .C_FAMILY                (C_FAMILY),
       .C_NUM_M                 (C_NUM_MASTER_SLOTS+1),
       .C_NUM_S                 (C_NUM_SLAVE_SLOTS),
       .C_NUM_S_LOG             (P_NUM_SLAVE_SLOTS_LOG),
       .C_MESG_WIDTH            (P_AA_ARMESG_WIDTH),
       .C_ARB_PRIORITY          (C_S_AXI_ARB_PRIORITY)
       )
      addr_arbiter_ar
        (
         .ACLK                  (INTERCONNECT_ACLK),
         .ARESET                (reset),
         // Vector of SI-side AR command request inputs
         .S_MESG                (tmp_aa_armesg),
         .S_TARGET_HOT          (st_aa_artarget_hot),
         .S_VALID_QUAL          (st_aa_arvalid_qual),
         .S_VALID               (st_aa_arvalid),
         .S_READY               (st_aa_arready),
         // Granted AR command output
         .M_MESG                (aa_mi_armesg),
         .M_TARGET_HOT          (aa_mi_artarget_hot),  // MI-slot targeted by granted command
         .M_GRANT_ENC           (aa_mi_argrant_enc),
         .M_VALID               (aa_mi_arvalid),  // SI-slot index of granted command
         .M_READY               (aa_mi_arready),
         .ISSUING_LIMIT        (mi_armaxissuing)
        );
    
    assign DEBUG_AR_ARB_GRANT = aa_mi_argrant_enc;
  
    if (C_DEBUG) begin : gen_debug_trans_seq
      // DEBUG WRITE TRANSACTION SEQUENCE COUNTER
      always @(posedge INTERCONNECT_ACLK) begin
        if (reset) begin
          debug_aw_trans_seq_i <= 1;
        end else begin
          if (aa_sa_awvalid && aa_sa_awready) begin
            debug_aw_trans_seq_i <= debug_aw_trans_seq_i + 1;
          end
        end
      end
  
      // DEBUG READ TRANSACTION SEQUENCE COUNTER
      always @(posedge INTERCONNECT_ACLK) begin
        if (reset) begin
          debug_ar_trans_seq_i <= 1;
        end else begin
          if (aa_mi_arvalid && aa_mi_arready) begin
            debug_ar_trans_seq_i <= debug_ar_trans_seq_i + 1;
          end
        end
      end
      
      assign DEBUG_AW_TRANS_SEQ = debug_aw_trans_seq_i;
      assign DEBUG_AR_TRANS_SEQ = debug_ar_trans_seq_i;
    end else begin : gen_no_debug_trans_seq
      assign DEBUG_AW_TRANS_SEQ = 0;
      assign DEBUG_AR_TRANS_SEQ = 0;
    end  // gen_debug_trans_seq

    // Broadcast AR transfer payload to all MI-slots
    assign M_AXI_ARID        = {C_NUM_MASTER_SLOTS{aa_mi_armesg[0+:C_AXI_ID_WIDTH]}};
    assign M_AXI_ARADDR      = {C_NUM_MASTER_SLOTS{aa_mi_armesg[C_AXI_ID_WIDTH+:C_AXI_ADDR_WIDTH]}};
    assign M_AXI_ARLEN       = {C_NUM_MASTER_SLOTS{aa_mi_armesg[C_AXI_ID_WIDTH+C_AXI_ADDR_WIDTH +:8]}};
    assign M_AXI_ARSIZE      = {C_NUM_MASTER_SLOTS{aa_mi_armesg[C_AXI_ID_WIDTH+C_AXI_ADDR_WIDTH+8 +:3]}};
    assign M_AXI_ARLOCK      = {C_NUM_MASTER_SLOTS{aa_mi_armesg[C_AXI_ID_WIDTH+C_AXI_ADDR_WIDTH+8+3 +:2]}};
    assign M_AXI_ARPROT      = {C_NUM_MASTER_SLOTS{aa_mi_armesg[C_AXI_ID_WIDTH+C_AXI_ADDR_WIDTH+8+3+2 +:3]}};
    assign M_AXI_ARREGION    = {C_NUM_MASTER_SLOTS{aa_mi_armesg[C_AXI_ID_WIDTH+C_AXI_ADDR_WIDTH+8+3+2+3 +:4]}};
    assign M_AXI_ARBURST     = {C_NUM_MASTER_SLOTS{aa_mi_armesg[C_AXI_ID_WIDTH+C_AXI_ADDR_WIDTH+8+3+2+3+4 +:2]}};
    assign M_AXI_ARCACHE     = {C_NUM_MASTER_SLOTS{aa_mi_armesg[C_AXI_ID_WIDTH+C_AXI_ADDR_WIDTH+8+3+2+3+4+2 +:4]}};
    assign M_AXI_ARQOS       = {C_NUM_MASTER_SLOTS{aa_mi_armesg[C_AXI_ID_WIDTH+C_AXI_ADDR_WIDTH+8+3+2+3+4+2+4 +:4]}};
    assign M_AXI_ARUSER      = {C_NUM_MASTER_SLOTS{aa_mi_armesg[C_AXI_ID_WIDTH+C_AXI_ADDR_WIDTH+8+3+2+3+4+2+4+4 +:C_AXI_ARUSER_WIDTH]}};
         
    // AW arbiter command transfer completes upon completion of both M-side AW-channel transfer and W-mux address acceptance (command push).
  axi_interconnect_v1_7_13_splitter #  // "SA": Splitter for Write Addr Arbiter
      (
        .C_NUM_M                (2)
      )
      splitter_aw_mi
      (
         .ACLK                  (INTERCONNECT_ACLK),
         .ARESET                (reset),
         .S_VALID              (aa_sa_awvalid),
         .S_READY              (aa_sa_awready),
         .M_VALID              ({mi_awvalid_en, sa_wm_awvalid_en}),
         .M_READY              ({mi_awready_mux, sa_wm_awready_mux})
      );
      
    assign mi_awvalid = aa_mi_awtarget_hot & {C_NUM_MASTER_SLOTS+1{mi_awvalid_en}};
    assign mi_awready_mux = |(aa_mi_awtarget_hot & mi_awready);
    assign M_AXI_AWVALID = mi_awvalid[0+:C_NUM_MASTER_SLOTS];  // Slot C_NUM_MASTER_SLOTS+1 is the error handler
    assign mi_awready[0+:C_NUM_MASTER_SLOTS] = M_AXI_AWREADY;
    assign sa_wm_awvalid = aa_mi_awtarget_hot & {C_NUM_MASTER_SLOTS+1{sa_wm_awvalid_en}};
    assign sa_wm_awready_mux = |(aa_mi_awtarget_hot & sa_wm_awready);
    
    assign mi_arvalid = aa_mi_artarget_hot & {C_NUM_MASTER_SLOTS+1{aa_mi_arvalid}};
    assign aa_mi_arready = |(aa_mi_artarget_hot & mi_arready);
    assign M_AXI_ARVALID = mi_arvalid[0+:C_NUM_MASTER_SLOTS];  // Slot C_NUM_MASTER_SLOTS+1 is the error handler
    assign mi_arready[0+:C_NUM_MASTER_SLOTS] = M_AXI_ARREADY;
    
    // MI-slot # C_NUM_MASTER_SLOTS is the error handler
    if (C_RANGE_CHECK) begin : gen_decerr_slave
  axi_interconnect_v1_7_13_decerr_slave #
        (
         .C_AXI_ID_WIDTH                 (C_AXI_ID_WIDTH),
         .C_AXI_DATA_WIDTH               (C_INTERCONNECT_DATA_WIDTH),
         .C_AXI_RUSER_WIDTH                (C_AXI_RUSER_WIDTH),
         .C_AXI_BUSER_WIDTH                (C_AXI_BUSER_WIDTH)
        )
        decerr_slave_inst
          (
           .S_AXI_ACLK (INTERCONNECT_ACLK),
           .S_AXI_ARESET (reset),
           .S_AXI_AWID (aa_mi_awmesg[0+:C_AXI_ID_WIDTH]),
           .S_AXI_AWVALID (mi_awvalid[C_NUM_MASTER_SLOTS]),
           .S_AXI_AWREADY (mi_awready[C_NUM_MASTER_SLOTS]),
           .S_AXI_WLAST (mi_wlast[C_NUM_MASTER_SLOTS]),
           .S_AXI_WVALID (mi_wvalid[C_NUM_MASTER_SLOTS]),
           .S_AXI_WREADY (mi_wready[C_NUM_MASTER_SLOTS]),
           .S_AXI_BID (mi_bid[C_NUM_MASTER_SLOTS*C_AXI_ID_WIDTH+:C_AXI_ID_WIDTH]),
           .S_AXI_BRESP (mi_bresp[C_NUM_MASTER_SLOTS*2+:2]),
           .S_AXI_BUSER (mi_buser[C_NUM_MASTER_SLOTS*C_AXI_BUSER_WIDTH+:C_AXI_BUSER_WIDTH]),
           .S_AXI_BVALID (mi_bvalid[C_NUM_MASTER_SLOTS]),
           .S_AXI_BREADY (mi_bready[C_NUM_MASTER_SLOTS]),
           .S_AXI_ARID (aa_mi_armesg[0+:C_AXI_ID_WIDTH]),
           .S_AXI_ARLEN (aa_mi_armesg[C_AXI_ID_WIDTH+C_AXI_ADDR_WIDTH +:8]),
           .S_AXI_ARVALID (mi_arvalid[C_NUM_MASTER_SLOTS]),
           .S_AXI_ARREADY (mi_arready[C_NUM_MASTER_SLOTS]),
           .S_AXI_RID (mi_rid[C_NUM_MASTER_SLOTS*C_AXI_ID_WIDTH+:C_AXI_ID_WIDTH]),
           .S_AXI_RDATA (mi_rdata[C_NUM_MASTER_SLOTS*C_AXI_DATA_MAX_WIDTH+:C_INTERCONNECT_DATA_WIDTH]),
           .S_AXI_RRESP (mi_rresp[C_NUM_MASTER_SLOTS*2+:2]),
           .S_AXI_RUSER (mi_ruser[C_NUM_MASTER_SLOTS*C_AXI_RUSER_WIDTH+:C_AXI_RUSER_WIDTH]),
           .S_AXI_RLAST (mi_rlast[C_NUM_MASTER_SLOTS]),
           .S_AXI_RVALID (mi_rvalid[C_NUM_MASTER_SLOTS]),
           .S_AXI_RREADY (mi_rready[C_NUM_MASTER_SLOTS])
         );
    end else begin : gen_no_decerr_slave
      assign mi_awready[C_NUM_MASTER_SLOTS] = 1'b0;
      assign mi_wready[C_NUM_MASTER_SLOTS] = 1'b0;
      assign mi_arready[C_NUM_MASTER_SLOTS] = 1'b0;
      assign mi_awready[C_NUM_MASTER_SLOTS] = 1'b0;
      assign mi_awready[C_NUM_MASTER_SLOTS] = 1'b0;
      assign mi_bid[C_NUM_MASTER_SLOTS*C_AXI_ID_WIDTH+:C_AXI_ID_WIDTH]                    = 0;
      assign mi_bresp[C_NUM_MASTER_SLOTS*2+:2]                                            = 0;
      assign mi_buser[C_NUM_MASTER_SLOTS*C_AXI_BUSER_WIDTH+:C_AXI_BUSER_WIDTH]            = 0;
      assign mi_bvalid[C_NUM_MASTER_SLOTS]                                                = 1'b0;
      assign mi_rid[C_NUM_MASTER_SLOTS*C_AXI_ID_WIDTH+:C_AXI_ID_WIDTH]                    = 0;
      assign mi_rdata[C_NUM_MASTER_SLOTS*C_AXI_DATA_MAX_WIDTH+:C_INTERCONNECT_DATA_WIDTH] = 0; 
      assign mi_rresp[C_NUM_MASTER_SLOTS*2+:2]                                            = 0; 
      assign mi_ruser[C_NUM_MASTER_SLOTS*C_AXI_RUSER_WIDTH+:C_AXI_RUSER_WIDTH]            = 0; 
      assign mi_rlast[C_NUM_MASTER_SLOTS]                                                  = 1'b0;
      assign mi_rvalid[C_NUM_MASTER_SLOTS]                                                 = 1'b0;
    end  // gen_decerr_slave
  end  // gen_crossbar
endgenerate

// Control slave port not yet implemented
generate
  if (C_USE_CTRL_PORT) begin : gen_ctrl_port
    assign S_AXI_CTRL_AWREADY = 0;
    assign S_AXI_CTRL_WREADY = 0;
    assign S_AXI_CTRL_BRESP = 0;
    assign S_AXI_CTRL_BVALID = 0;
    assign S_AXI_CTRL_ARREADY = 0;
    assign S_AXI_CTRL_RDATA = 0;
    assign S_AXI_CTRL_RRESP = 0;
    assign S_AXI_CTRL_RVALID = 0;
    assign IRQ = 0;
  end else begin : gen_no_ctrl_port
    assign S_AXI_CTRL_AWREADY = 0;
    assign S_AXI_CTRL_WREADY = 0;
    assign S_AXI_CTRL_BRESP = 0;
    assign S_AXI_CTRL_BVALID = 0;
    assign S_AXI_CTRL_ARREADY = 0;
    assign S_AXI_CTRL_RDATA = 0;
    assign S_AXI_CTRL_RRESP = 0;
    assign S_AXI_CTRL_RVALID = 0;
    assign IRQ = 0;
  end
endgenerate

endmodule

`default_nettype wire


// -- (c) Copyright 2009 - 2011 Xilinx, Inc. All rights reserved.
// --
// -- This file contains confidential and proprietary information
// -- of Xilinx, Inc. and is protected under U.S. and 
// -- international copyright and other intellectual property
// -- laws.
// --
// -- DISCLAIMER
// -- This disclaimer is not a license and does not grant any
// -- rights to the materials distributed herewith. Except as
// -- otherwise provided in a valid license issued to you by
// -- Xilinx, and to the maximum extent permitted by applicable
// -- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
// -- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
// -- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
// -- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
// -- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
// -- (2) Xilinx shall not be liable (whether in contract or tort,
// -- including negligence, or under any other theory of
// -- liability) for any loss or damage of any kind or nature
// -- related to, arising under or in connection with these
// -- materials, including for any direct, or any indirect,
// -- special, incidental, or consequential loss or damage
// -- (including loss of data, profits, goodwill, or any type of
// -- loss or damage suffered as a result of any action brought
// -- by a third party) even if such damage or loss was
// -- reasonably foreseeable or Xilinx had been advised of the
// -- possibility of the same.
// --
// -- CRITICAL APPLICATIONS
// -- Xilinx products are not designed or intended to be fail-
// -- safe, or for use in any application requiring fail-safe
// -- performance, such as life-support or safety devices or
// -- systems, Class III medical devices, nuclear facilities,
// -- applications related to the deployment of airbags, or any
// -- other applications that could lead to death, personal
// -- injury, or severe property or environmental damage
// -- (individually and collectively, "Critical
// -- Applications"). Customer assumes the sole risk and
// -- liability of any use of Xilinx products in Critical
// -- Applications, subject only to applicable laws and
// -- regulations governing limitations on product liability.
// --
// -- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
// -- PART OF THIS FILE AT ALL TIMES.
//-----------------------------------------------------------------------------
//
// File name: data_fifo_bank.v
//
// Description: 
//   This module is a bank of data-path FIFOs for a vectored AXI interface.
//   The interface of this module consists of a vectored slave and master interface
//     which are each concatenations of upper-level AXI pathways,
//     plus various vectored parameters.
//   This module instantiates a set of individual AXI FIFO buffers.
//
//--------------------------------------------------------------------------
//
// Structure:
//    data_fifo_bank
//      axi_data_fifo
//
//-----------------------------------------------------------------------------
`timescale 1ps/1ps
`default_nettype none

(* DowngradeIPIdentifiedWarnings="yes" *) 
module axi_interconnect_v1_7_13_data_fifo_bank #
  (
   parameter         C_FAMILY                         = "none", 
   parameter integer C_NUM_SLOTS                = 1, 
   parameter         C_AXI_ID_WIDTH                 = 1, 
                       // Effective width of ID ports for each SI and MI slot.
                       // Format: C_NUM_SLOTS{Bit32}; 
                       // Range: 'h00000001 - C_AXI_ID_MAX_WIDTH.
   parameter integer C_AXI_ID_MAX_WIDTH                 = 1, 
                       // Width of ID signals propagated by the Interconnect.
                       // Stride of ID fields within each ID port.
                       // Range: >= 1.
   parameter integer C_AXI_ADDR_WIDTH                 = 32, 
   parameter integer C_AXI_DATA_MAX_WIDTH           = 256, 
                       // Largest value supported for any DATA_WIDTH.
                       // Stride of data fields within each DATA port.
   parameter         C_AXI_DATA_WIDTH               = {16{32'h00000020}}, 
                       // Format: C_NUM_SLOTS{Bit32}; 
                       // Range: 'h00000020, 'h00000040, 'h00000080, 'h00000100.
   parameter         C_AXI_SUPPORTS_WRITE           = 16'b11111111_11111111, 
                       // Format: C_NUM_SLOTS{Bit1}.
   parameter         C_AXI_SUPPORTS_READ            = 16'b11111111_11111111, 
                       // Format: C_NUM_SLOTS{Bit1}.
   parameter integer C_AXI_SUPPORTS_USER_SIGNALS      = 0,
                       // 1 = Propagate all USER signals, 0 = Dont propagate.
   parameter integer C_AXI_AWUSER_WIDTH               = 1,
   parameter integer C_AXI_ARUSER_WIDTH               = 1,
   parameter integer C_AXI_WUSER_WIDTH                = 1,
   parameter integer C_AXI_RUSER_WIDTH                = 1,
   parameter integer C_AXI_BUSER_WIDTH                = 1,
   parameter         C_AXI_WRITE_FIFO_DEPTH         = {16{32'h00000000}},
                       // Format: C_NUM_SLOTS{Bit32}; 
                       // Range: 'h00000000, 'h00000020, 'h00000200.
   parameter         C_AXI_WRITE_FIFO_TYPE          = 16'b11111111_11111111,
                       // 0 = LUT flop/RAM only, 1 = BRAM allowed.
                       // Format: C_NUM_SLOTS{Bit1}.
   parameter         C_AXI_WRITE_FIFO_DELAY         = 16'b00000000_00000000,  // 0 = No, 1 = Yes (FUTURE FEATURE)
                       // Indicates whether AWVALID and WVALID assertion is delayed until:
                       //   a. the corresponding WLAST is stored in the FIFO, or
                       //   b. no WLAST is stored and the FIFO is full.
                       // 0 means AW channel is pass-through and 
                       //   WVALID is asserted whenever FIFO is not empty.
                       // Format: C_NUM_SLOTS{Bit1}.
   parameter         C_AXI_READ_FIFO_DEPTH          = {16{32'h00000000}},
                       // Format: C_NUM_SLOTS{Bit32}; 
   parameter         C_AXI_READ_FIFO_TYPE           = 16'b11111111_11111111,
                       // 0 = LUT flop/RAM only, 1 = BRAM allowed.
                       // Format: C_NUM_SLOTS{Bit1}.
   parameter         C_AXI_READ_FIFO_DELAY          = 16'b00000000_00000000  // 0 = No, 1 = Yes (FUTURE FEATURE)
                       // Indicates whether ARVALID assertion is delayed until the 
                       //   the remaining vacancy of the FIFO is at least the burst length
                       //   as indicated by ARLEN.
                       // 0 means AR channel is pass-through.
                       // Format: C_NUM_SLOTS{Bit1}.
   )
  (
   // Global Signals
   input  wire                                              ACLK,
   input  wire                                              ARESETN,
   // Slave Interface Write Address Ports
   input  wire [C_NUM_SLOTS*C_AXI_ID_MAX_WIDTH-1:0]           S_AXI_AWID,
   input  wire [C_NUM_SLOTS*C_AXI_ADDR_WIDTH-1:0]           S_AXI_AWADDR,
   input  wire [C_NUM_SLOTS*8-1:0]                          S_AXI_AWLEN,
   input  wire [C_NUM_SLOTS*3-1:0]                          S_AXI_AWSIZE,
   input  wire [C_NUM_SLOTS*2-1:0]                          S_AXI_AWBURST,
   input  wire [C_NUM_SLOTS*2-1:0]                          S_AXI_AWLOCK,
   input  wire [C_NUM_SLOTS*4-1:0]                          S_AXI_AWCACHE,
   input  wire [C_NUM_SLOTS*3-1:0]                          S_AXI_AWPROT,
   input  wire [C_NUM_SLOTS*4-1:0]                          S_AXI_AWREGION,
   input  wire [C_NUM_SLOTS*4-1:0]                          S_AXI_AWQOS,
   input  wire [C_NUM_SLOTS*C_AXI_AWUSER_WIDTH-1:0]         S_AXI_AWUSER,
   input  wire [C_NUM_SLOTS-1:0]                            S_AXI_AWVALID,
   output wire [C_NUM_SLOTS-1:0]                            S_AXI_AWREADY,
   // Slave Interface Write Data Ports
   input  wire [C_NUM_SLOTS*C_AXI_DATA_MAX_WIDTH-1:0]     S_AXI_WDATA,
   input  wire [C_NUM_SLOTS*C_AXI_DATA_MAX_WIDTH/8-1:0]   S_AXI_WSTRB,
   input  wire [C_NUM_SLOTS-1:0]                            S_AXI_WLAST,
   input  wire [C_NUM_SLOTS*C_AXI_WUSER_WIDTH-1:0]          S_AXI_WUSER,
   input  wire [C_NUM_SLOTS-1:0]                            S_AXI_WVALID,
   output wire [C_NUM_SLOTS-1:0]                            S_AXI_WREADY,
   // Slave Interface Write Response Ports
   output wire [C_NUM_SLOTS*C_AXI_ID_MAX_WIDTH-1:0]           S_AXI_BID,
   output wire [C_NUM_SLOTS*2-1:0]                          S_AXI_BRESP,
   output wire [C_NUM_SLOTS*C_AXI_BUSER_WIDTH-1:0]          S_AXI_BUSER,
   output wire [C_NUM_SLOTS-1:0]                            S_AXI_BVALID,
   input  wire [C_NUM_SLOTS-1:0]                            S_AXI_BREADY,
   // Slave Interface Read Address Ports
   input  wire [C_NUM_SLOTS*C_AXI_ID_MAX_WIDTH-1:0]           S_AXI_ARID,
   input  wire [C_NUM_SLOTS*C_AXI_ADDR_WIDTH-1:0]           S_AXI_ARADDR,
   input  wire [C_NUM_SLOTS*8-1:0]                          S_AXI_ARLEN,
   input  wire [C_NUM_SLOTS*3-1:0]                          S_AXI_ARSIZE,
   input  wire [C_NUM_SLOTS*2-1:0]                          S_AXI_ARBURST,
   input  wire [C_NUM_SLOTS*2-1:0]                          S_AXI_ARLOCK,
   input  wire [C_NUM_SLOTS*4-1:0]                          S_AXI_ARCACHE,
   input  wire [C_NUM_SLOTS*3-1:0]                          S_AXI_ARPROT,
   input  wire [C_NUM_SLOTS*4-1:0]                          S_AXI_ARREGION,
   input  wire [C_NUM_SLOTS*4-1:0]                          S_AXI_ARQOS,
   input  wire [C_NUM_SLOTS*C_AXI_ARUSER_WIDTH-1:0]         S_AXI_ARUSER,
   input  wire [C_NUM_SLOTS-1:0]                            S_AXI_ARVALID,
   output wire [C_NUM_SLOTS-1:0]                            S_AXI_ARREADY,
   // Slave Interface Read Data Ports
   output wire [C_NUM_SLOTS*C_AXI_ID_MAX_WIDTH-1:0]           S_AXI_RID,
   output wire [C_NUM_SLOTS*C_AXI_DATA_MAX_WIDTH-1:0]     S_AXI_RDATA,
   output wire [C_NUM_SLOTS*2-1:0]                          S_AXI_RRESP,
   output wire [C_NUM_SLOTS-1:0]                            S_AXI_RLAST,
   output wire [C_NUM_SLOTS*C_AXI_RUSER_WIDTH-1:0]          S_AXI_RUSER,
   output wire [C_NUM_SLOTS-1:0]                            S_AXI_RVALID,
   input  wire [C_NUM_SLOTS-1:0]                            S_AXI_RREADY,
   // Master Interface Write Address Port
   output wire [C_NUM_SLOTS*C_AXI_ID_MAX_WIDTH-1:0]          M_AXI_AWID,
   output wire [C_NUM_SLOTS*C_AXI_ADDR_WIDTH-1:0]          M_AXI_AWADDR,
   output wire [C_NUM_SLOTS*8-1:0]                         M_AXI_AWLEN,
   output wire [C_NUM_SLOTS*3-1:0]                         M_AXI_AWSIZE,
   output wire [C_NUM_SLOTS*2-1:0]                         M_AXI_AWBURST,
   output wire [C_NUM_SLOTS*2-1:0]                         M_AXI_AWLOCK,
   output wire [C_NUM_SLOTS*4-1:0]                         M_AXI_AWCACHE,
   output wire [C_NUM_SLOTS*3-1:0]                         M_AXI_AWPROT,
   output wire [C_NUM_SLOTS*4-1:0]                         M_AXI_AWREGION,
   output wire [C_NUM_SLOTS*4-1:0]                         M_AXI_AWQOS,
   output wire [C_NUM_SLOTS*C_AXI_AWUSER_WIDTH-1:0]        M_AXI_AWUSER,
   output wire [C_NUM_SLOTS-1:0]                           M_AXI_AWVALID,
   input  wire [C_NUM_SLOTS-1:0]                           M_AXI_AWREADY,
   // Master Interface Write Data Ports
   output wire [C_NUM_SLOTS*C_AXI_DATA_MAX_WIDTH-1:0]    M_AXI_WDATA,
   output wire [C_NUM_SLOTS*C_AXI_DATA_MAX_WIDTH/8-1:0]  M_AXI_WSTRB,
   output wire [C_NUM_SLOTS-1:0]                           M_AXI_WLAST,
   output wire [C_NUM_SLOTS*C_AXI_WUSER_WIDTH-1:0]         M_AXI_WUSER,
   output wire [C_NUM_SLOTS-1:0]                           M_AXI_WVALID,
   input  wire [C_NUM_SLOTS-1:0]                           M_AXI_WREADY,
   // Master Interface Write Response Ports
   input  wire [C_NUM_SLOTS*C_AXI_ID_MAX_WIDTH-1:0]          M_AXI_BID,
   input  wire [C_NUM_SLOTS*2-1:0]                         M_AXI_BRESP,
   input  wire [C_NUM_SLOTS*C_AXI_BUSER_WIDTH-1:0]         M_AXI_BUSER,
   input  wire [C_NUM_SLOTS-1:0]                           M_AXI_BVALID,
   output wire [C_NUM_SLOTS-1:0]                           M_AXI_BREADY,
   // Master Interface Read Address Port
   output wire [C_NUM_SLOTS*C_AXI_ID_MAX_WIDTH-1:0]          M_AXI_ARID,
   output wire [C_NUM_SLOTS*C_AXI_ADDR_WIDTH-1:0]          M_AXI_ARADDR,
   output wire [C_NUM_SLOTS*8-1:0]                         M_AXI_ARLEN,
   output wire [C_NUM_SLOTS*3-1:0]                         M_AXI_ARSIZE,
   output wire [C_NUM_SLOTS*2-1:0]                         M_AXI_ARBURST,
   output wire [C_NUM_SLOTS*2-1:0]                         M_AXI_ARLOCK,
   output wire [C_NUM_SLOTS*4-1:0]                         M_AXI_ARCACHE,
   output wire [C_NUM_SLOTS*3-1:0]                         M_AXI_ARPROT,
   output wire [C_NUM_SLOTS*4-1:0]                         M_AXI_ARREGION,
   output wire [C_NUM_SLOTS*4-1:0]                         M_AXI_ARQOS,
   output wire [C_NUM_SLOTS*C_AXI_ARUSER_WIDTH-1:0]        M_AXI_ARUSER,
   output wire [C_NUM_SLOTS-1:0]                           M_AXI_ARVALID,
   input  wire [C_NUM_SLOTS-1:0]                           M_AXI_ARREADY,
   // Master Interface Read Data Ports
   input  wire [C_NUM_SLOTS*C_AXI_ID_MAX_WIDTH-1:0]          M_AXI_RID,
   input  wire [C_NUM_SLOTS*C_AXI_DATA_MAX_WIDTH-1:0]    M_AXI_RDATA,
   input  wire [C_NUM_SLOTS*2-1:0]                         M_AXI_RRESP,
   input  wire [C_NUM_SLOTS-1:0]                           M_AXI_RLAST,
   input  wire [C_NUM_SLOTS*C_AXI_RUSER_WIDTH-1:0]         M_AXI_RUSER,
   input  wire [C_NUM_SLOTS-1:0]                           M_AXI_RVALID,
   output wire [C_NUM_SLOTS-1:0]                           M_AXI_RREADY
   );

  wire [C_NUM_SLOTS*C_AXI_DATA_MAX_WIDTH-1:0]     si_df_rdata           ;
  wire [C_NUM_SLOTS*C_AXI_DATA_MAX_WIDTH-1:0]     df_mi_wdata           ;
  wire [C_NUM_SLOTS*C_AXI_DATA_MAX_WIDTH/8-1:0]   df_mi_wstrb           ;
  wire [C_NUM_SLOTS*C_AXI_ID_MAX_WIDTH-1:0]       si_df_bid             ;
  wire [C_NUM_SLOTS*C_AXI_ID_MAX_WIDTH-1:0]       si_df_rid             ;
  wire [C_NUM_SLOTS*C_AXI_ID_MAX_WIDTH-1:0]       df_mi_awid             ;
  wire [C_NUM_SLOTS*C_AXI_ID_MAX_WIDTH-1:0]       df_mi_arid             ;
  
  genvar slot;
  
  generate
    for (slot=0;slot<C_NUM_SLOTS;slot=slot+1) begin : gen_fifo_slot
      
  axi_interconnect_v1_7_13_axi_data_fifo #
        (
          .C_FAMILY                         (C_FAMILY),
          .C_AXI_ID_WIDTH                   (C_AXI_ID_WIDTH[slot*32+:32]),
          .C_AXI_ADDR_WIDTH                 (C_AXI_ADDR_WIDTH),
          .C_AXI_DATA_WIDTH                 (C_AXI_DATA_WIDTH[slot*32+:32]),
          .C_AXI_SUPPORTS_USER_SIGNALS      (C_AXI_SUPPORTS_USER_SIGNALS),
          .C_AXI_AWUSER_WIDTH               (C_AXI_AWUSER_WIDTH),
          .C_AXI_ARUSER_WIDTH               (C_AXI_ARUSER_WIDTH),
          .C_AXI_WUSER_WIDTH                (C_AXI_WUSER_WIDTH),
          .C_AXI_RUSER_WIDTH                (C_AXI_RUSER_WIDTH),
          .C_AXI_BUSER_WIDTH                (C_AXI_BUSER_WIDTH),
          .C_AXI_WRITE_FIFO_DEPTH           (
              C_AXI_SUPPORTS_WRITE[slot] ? C_AXI_WRITE_FIFO_DEPTH[slot*32+:32] : 0),
          .C_AXI_WRITE_FIFO_TYPE            (
              ~C_AXI_WRITE_FIFO_TYPE[slot] ? "lut" :
              C_AXI_WRITE_FIFO_DEPTH[slot*32+:32]>32 ? "bram" : "lut"
              ),
          .C_AXI_WRITE_FIFO_DELAY           (C_AXI_WRITE_FIFO_DELAY[slot]),
          .C_AXI_READ_FIFO_DEPTH           (
              C_AXI_SUPPORTS_READ[slot] ? C_AXI_READ_FIFO_DEPTH[slot*32+:32] : 0),
          .C_AXI_READ_FIFO_TYPE            (
              ~C_AXI_READ_FIFO_TYPE[slot] ? "lut" :
              C_AXI_READ_FIFO_DEPTH[slot*32+:32]>32 ? "bram" : "lut"
              ),
          .C_AXI_READ_FIFO_DELAY           (C_AXI_READ_FIFO_DELAY[slot])
        )
        data_fifo_inst 
        (
          .ACLK                       (ACLK),
          .ARESETN                    (ARESETN),
          .S_AXI_AWID                       (S_AXI_AWID[slot*C_AXI_ID_MAX_WIDTH+:C_AXI_ID_WIDTH[slot*32+:32]]),
          .S_AXI_AWADDR                     (S_AXI_AWADDR[slot*C_AXI_ADDR_WIDTH+:C_AXI_ADDR_WIDTH]),
          .S_AXI_AWLEN                      (S_AXI_AWLEN[slot*8+:8]),
          .S_AXI_AWSIZE                     (S_AXI_AWSIZE[slot*3+:3]),
          .S_AXI_AWBURST                    (S_AXI_AWBURST[slot*2+:2]),
          .S_AXI_AWLOCK                     (S_AXI_AWLOCK[slot*2+:2]),
          .S_AXI_AWCACHE                    (S_AXI_AWCACHE[slot*4+:4]),
          .S_AXI_AWPROT                     (S_AXI_AWPROT[slot*3+:3]),
          .S_AXI_AWREGION                   (S_AXI_AWREGION[slot*4+:4]),
          .S_AXI_AWQOS                      (S_AXI_AWQOS[slot*4+:4]),
          .S_AXI_AWUSER                     (S_AXI_AWUSER[slot*C_AXI_AWUSER_WIDTH+:C_AXI_AWUSER_WIDTH]),
          .S_AXI_AWVALID                    (S_AXI_AWVALID[slot*1+:1]),
          .S_AXI_AWREADY                    (S_AXI_AWREADY[slot*1+:1]),
          .S_AXI_WDATA                      (S_AXI_WDATA[slot*C_AXI_DATA_MAX_WIDTH+:C_AXI_DATA_WIDTH[slot*32+:32]]),
          .S_AXI_WSTRB                      (S_AXI_WSTRB[slot*C_AXI_DATA_MAX_WIDTH/8+:C_AXI_DATA_WIDTH[slot*32+:32]/8]),
          .S_AXI_WLAST                      (S_AXI_WLAST[slot*1+:1]),
          .S_AXI_WUSER                      (S_AXI_WUSER[slot*C_AXI_WUSER_WIDTH+:C_AXI_WUSER_WIDTH]),
          .S_AXI_WVALID                     (S_AXI_WVALID[slot*1+:1]),
          .S_AXI_WREADY                     (S_AXI_WREADY[slot*1+:1]),
          .S_AXI_BID                        (si_df_bid[slot*C_AXI_ID_MAX_WIDTH+:C_AXI_ID_WIDTH[slot*32+:32]]),
          .S_AXI_BRESP                      (S_AXI_BRESP[slot*2+:2]),
          .S_AXI_BUSER                      (S_AXI_BUSER[slot*C_AXI_BUSER_WIDTH+:C_AXI_BUSER_WIDTH]),
          .S_AXI_BVALID                     (S_AXI_BVALID[slot*1+:1]),
          .S_AXI_BREADY                     (S_AXI_BREADY[slot*1+:1]),
          .S_AXI_ARID                       (S_AXI_ARID[slot*C_AXI_ID_MAX_WIDTH+:C_AXI_ID_WIDTH[slot*32+:32]]),
          .S_AXI_ARADDR                     (S_AXI_ARADDR[slot*C_AXI_ADDR_WIDTH+:C_AXI_ADDR_WIDTH]),
          .S_AXI_ARLEN                      (S_AXI_ARLEN[slot*8+:8]),
          .S_AXI_ARSIZE                     (S_AXI_ARSIZE[slot*3+:3]),
          .S_AXI_ARBURST                    (S_AXI_ARBURST[slot*2+:2]),
          .S_AXI_ARLOCK                     (S_AXI_ARLOCK[slot*2+:2]),
          .S_AXI_ARCACHE                    (S_AXI_ARCACHE[slot*4+:4]),
          .S_AXI_ARPROT                     (S_AXI_ARPROT[slot*3+:3]),
          .S_AXI_ARREGION                   (S_AXI_ARREGION[slot*4+:4]),
          .S_AXI_ARQOS                      (S_AXI_ARQOS[slot*4+:4]),
          .S_AXI_ARUSER                     (S_AXI_ARUSER[slot*C_AXI_ARUSER_WIDTH+:C_AXI_ARUSER_WIDTH]),
          .S_AXI_ARVALID                    (S_AXI_ARVALID[slot*1+:1]),
          .S_AXI_ARREADY                    (S_AXI_ARREADY[slot*1+:1]),
          .S_AXI_RID                        (si_df_rid[slot*C_AXI_ID_MAX_WIDTH+:C_AXI_ID_WIDTH[slot*32+:32]]),
          .S_AXI_RDATA                      (si_df_rdata[slot*C_AXI_DATA_MAX_WIDTH+:C_AXI_DATA_WIDTH[slot*32+:32]]),
          .S_AXI_RRESP                      (S_AXI_RRESP[slot*2+:2]),
          .S_AXI_RLAST                      (S_AXI_RLAST[slot*1+:1]),
          .S_AXI_RUSER                      (S_AXI_RUSER[slot*C_AXI_RUSER_WIDTH+:C_AXI_RUSER_WIDTH]),
          .S_AXI_RVALID                     (S_AXI_RVALID[slot*1+:1]),
          .S_AXI_RREADY                     (S_AXI_RREADY[slot*1+:1]),
          .M_AXI_AWID                       (df_mi_awid[slot*C_AXI_ID_MAX_WIDTH+:C_AXI_ID_WIDTH[slot*32+:32]]),
          .M_AXI_AWADDR                     (M_AXI_AWADDR[slot*C_AXI_ADDR_WIDTH+:C_AXI_ADDR_WIDTH]),
          .M_AXI_AWLEN                      (M_AXI_AWLEN[slot*8+:8]),
          .M_AXI_AWSIZE                     (M_AXI_AWSIZE[slot*3+:3]),
          .M_AXI_AWBURST                    (M_AXI_AWBURST[slot*2+:2]),
          .M_AXI_AWLOCK                     (M_AXI_AWLOCK[slot*2+:2]),
          .M_AXI_AWCACHE                    (M_AXI_AWCACHE[slot*4+:4]),
          .M_AXI_AWPROT                     (M_AXI_AWPROT[slot*3+:3]),
          .M_AXI_AWREGION                   (M_AXI_AWREGION[slot*4+:4]),
          .M_AXI_AWQOS                      (M_AXI_AWQOS[slot*4+:4]),
          .M_AXI_AWUSER                     (M_AXI_AWUSER[slot*C_AXI_AWUSER_WIDTH+:C_AXI_AWUSER_WIDTH]),
          .M_AXI_AWVALID                    (M_AXI_AWVALID[slot*1+:1]),
          .M_AXI_AWREADY                    (M_AXI_AWREADY[slot*1+:1]),
          .M_AXI_WDATA                      (df_mi_wdata[slot*C_AXI_DATA_MAX_WIDTH+:C_AXI_DATA_WIDTH[slot*32+:32]]),
          .M_AXI_WSTRB                      (df_mi_wstrb[slot*C_AXI_DATA_MAX_WIDTH/8+:C_AXI_DATA_WIDTH[slot*32+:32]/8]),
          .M_AXI_WLAST                      (M_AXI_WLAST[slot*1+:1]),
          .M_AXI_WUSER                      (M_AXI_WUSER[slot*C_AXI_WUSER_WIDTH+:C_AXI_WUSER_WIDTH]),
          .M_AXI_WVALID                     (M_AXI_WVALID[slot*1+:1]),
          .M_AXI_WREADY                     (M_AXI_WREADY[slot*1+:1]),
          .M_AXI_BID                        (M_AXI_BID[slot*C_AXI_ID_MAX_WIDTH+:C_AXI_ID_WIDTH[slot*32+:32]]),
          .M_AXI_BRESP                      (M_AXI_BRESP[slot*2+:2]),
          .M_AXI_BUSER                      (M_AXI_BUSER[slot*C_AXI_BUSER_WIDTH+:C_AXI_BUSER_WIDTH]),
          .M_AXI_BVALID                     (M_AXI_BVALID[slot*1+:1]),
          .M_AXI_BREADY                     (M_AXI_BREADY[slot*1+:1]),
          .M_AXI_ARID                       (df_mi_arid[slot*C_AXI_ID_MAX_WIDTH+:C_AXI_ID_WIDTH[slot*32+:32]]),
          .M_AXI_ARADDR                     (M_AXI_ARADDR[slot*C_AXI_ADDR_WIDTH+:C_AXI_ADDR_WIDTH]),
          .M_AXI_ARLEN                      (M_AXI_ARLEN[slot*8+:8]),
          .M_AXI_ARSIZE                     (M_AXI_ARSIZE[slot*3+:3]),
          .M_AXI_ARBURST                    (M_AXI_ARBURST[slot*2+:2]),
          .M_AXI_ARLOCK                     (M_AXI_ARLOCK[slot*2+:2]),
          .M_AXI_ARCACHE                    (M_AXI_ARCACHE[slot*4+:4]),
          .M_AXI_ARPROT                     (M_AXI_ARPROT[slot*3+:3]),
          .M_AXI_ARREGION                   (M_AXI_ARREGION[slot*4+:4]),
          .M_AXI_ARQOS                      (M_AXI_ARQOS[slot*4+:4]),
          .M_AXI_ARUSER                     (M_AXI_ARUSER[slot*C_AXI_ARUSER_WIDTH+:C_AXI_ARUSER_WIDTH]),
          .M_AXI_ARVALID                    (M_AXI_ARVALID[slot*1+:1]),
          .M_AXI_ARREADY                    (M_AXI_ARREADY[slot*1+:1]),
          .M_AXI_RID                        (M_AXI_RID[slot*C_AXI_ID_MAX_WIDTH+:C_AXI_ID_WIDTH[slot*32+:32]]),
          .M_AXI_RDATA                      (M_AXI_RDATA[slot*C_AXI_DATA_MAX_WIDTH+:C_AXI_DATA_WIDTH[slot*32+:32]]),
          .M_AXI_RRESP                      (M_AXI_RRESP[slot*2+:2]),
          .M_AXI_RLAST                      (M_AXI_RLAST[slot*1+:1]),
          .M_AXI_RUSER                      (M_AXI_RUSER[slot*C_AXI_RUSER_WIDTH+:C_AXI_RUSER_WIDTH]),
          .M_AXI_RVALID                     (M_AXI_RVALID[slot*1+:1]),
          .M_AXI_RREADY                     (M_AXI_RREADY[slot*1+:1])
        );
      assign S_AXI_RDATA[slot*C_AXI_DATA_MAX_WIDTH+:C_AXI_DATA_MAX_WIDTH] = si_df_rdata[slot*C_AXI_DATA_MAX_WIDTH+:C_AXI_DATA_WIDTH[slot*32+:32]] ;
      assign M_AXI_WDATA[slot*C_AXI_DATA_MAX_WIDTH+:C_AXI_DATA_MAX_WIDTH] = df_mi_wdata[slot*C_AXI_DATA_MAX_WIDTH+:C_AXI_DATA_WIDTH[slot*32+:32]] ;
      assign M_AXI_WSTRB[slot*C_AXI_DATA_MAX_WIDTH/8+:C_AXI_DATA_MAX_WIDTH/8] = df_mi_wstrb[slot*C_AXI_DATA_MAX_WIDTH/8+:C_AXI_DATA_WIDTH[slot*32+:32]/8] ;
      assign S_AXI_BID[slot*C_AXI_ID_MAX_WIDTH+:C_AXI_ID_MAX_WIDTH] = si_df_bid[slot*C_AXI_ID_MAX_WIDTH+:C_AXI_ID_WIDTH[slot*32+:32]];
      assign S_AXI_RID[slot*C_AXI_ID_MAX_WIDTH+:C_AXI_ID_MAX_WIDTH] = si_df_rid[slot*C_AXI_ID_MAX_WIDTH+:C_AXI_ID_WIDTH[slot*32+:32]];
      assign M_AXI_AWID[slot*C_AXI_ID_MAX_WIDTH+:C_AXI_ID_MAX_WIDTH] = df_mi_awid[slot*C_AXI_ID_MAX_WIDTH+:C_AXI_ID_WIDTH[slot*32+:32]];
      assign M_AXI_ARID[slot*C_AXI_ID_MAX_WIDTH+:C_AXI_ID_MAX_WIDTH] = df_mi_arid[slot*C_AXI_ID_MAX_WIDTH+:C_AXI_ID_WIDTH[slot*32+:32]];
      
    end
  endgenerate

endmodule

`default_nettype wire


// -- (c) Copyright 2009 - 2011 Xilinx, Inc. All rights reserved.
// --
// -- This file contains confidential and proprietary information
// -- of Xilinx, Inc. and is protected under U.S. and 
// -- international copyright and other intellectual property
// -- laws.
// --
// -- DISCLAIMER
// -- This disclaimer is not a license and does not grant any
// -- rights to the materials distributed herewith. Except as
// -- otherwise provided in a valid license issued to you by
// -- Xilinx, and to the maximum extent permitted by applicable
// -- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
// -- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
// -- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
// -- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
// -- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
// -- (2) Xilinx shall not be liable (whether in contract or tort,
// -- including negligence, or under any other theory of
// -- liability) for any loss or damage of any kind or nature
// -- related to, arising under or in connection with these
// -- materials, including for any direct, or any indirect,
// -- special, incidental, or consequential loss or damage
// -- (including loss of data, profits, goodwill, or any type of
// -- loss or damage suffered as a result of any action brought
// -- by a third party) even if such damage or loss was
// -- reasonably foreseeable or Xilinx had been advised of the
// -- possibility of the same.
// --
// -- CRITICAL APPLICATIONS
// -- Xilinx products are not designed or intended to be fail-
// -- safe, or for use in any application requiring fail-safe
// -- performance, such as life-support or safety devices or
// -- systems, Class III medical devices, nuclear facilities,
// -- applications related to the deployment of airbags, or any
// -- other applications that could lead to death, personal
// -- injury, or severe property or environmental damage
// -- (individually and collectively, "Critical
// -- Applications"). Customer assumes the sole risk and
// -- liability of any use of Xilinx products in Critical
// -- Applications, subject only to applicable laws and
// -- regulations governing limitations on product liability.
// --
// -- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
// -- PART OF THIS FILE AT ALL TIMES.
//-----------------------------------------------------------------------------
//
// File name: decerr_slave.v
//
// Description: 
//   Phantom slave interface used to complete W, R and B channel transfers when an
//   erroneous transaction is trapped in the crossbar.
//--------------------------------------------------------------------------
//
// Structure:
//    decerr_slave
//    
//-----------------------------------------------------------------------------

`timescale 1ps/1ps
`default_nettype none

(* DowngradeIPIdentifiedWarnings="yes" *) 
module axi_interconnect_v1_7_13_decerr_slave #
  (
   parameter C_AXI_ID_WIDTH           = 1,
   parameter C_AXI_DATA_WIDTH         = 32,
   parameter C_AXI_BUSER_WIDTH           = 1,
   parameter C_AXI_RUSER_WIDTH           = 1
   )
  (
   input wire S_AXI_ACLK,
   input wire S_AXI_ARESET,
   input wire [(C_AXI_ID_WIDTH-1):0] S_AXI_AWID,
   input wire S_AXI_AWVALID,
   output wire S_AXI_AWREADY,
   input wire S_AXI_WLAST,
   input wire S_AXI_WVALID,
   output wire S_AXI_WREADY,
   output wire [(C_AXI_ID_WIDTH-1):0] S_AXI_BID,
   output wire [1:0] S_AXI_BRESP,
   output wire [C_AXI_BUSER_WIDTH-1:0]          S_AXI_BUSER,
   output wire S_AXI_BVALID,
   input wire S_AXI_BREADY,
   input wire [(C_AXI_ID_WIDTH-1):0] S_AXI_ARID,
   input wire [7:0] S_AXI_ARLEN,
   input wire S_AXI_ARVALID,
   output wire S_AXI_ARREADY,
   output wire [(C_AXI_ID_WIDTH-1):0] S_AXI_RID,
   output wire [(C_AXI_DATA_WIDTH-1):0] S_AXI_RDATA,
   output wire [1:0] S_AXI_RRESP,
   output wire [C_AXI_RUSER_WIDTH-1:0]          S_AXI_RUSER,
   output wire S_AXI_RLAST,
   output wire S_AXI_RVALID,
   input wire S_AXI_RREADY
   );
   
  reg s_axi_awready_i;
  reg s_axi_wready_i;
  reg s_axi_bvalid_i;
  reg [(C_AXI_ID_WIDTH-1):0] s_axi_bid_i;
  reg s_axi_arready_i;
  reg s_axi_rvalid_i;
  reg s_axi_rlast_i;
  reg [(C_AXI_ID_WIDTH-1):0] s_axi_rid_i;
  reg [7:0] read_cnt;
  reg [1:0] write_cs;
  reg [0:0] read_cs;
  localparam P_WRITE_IDLE = 2'b00;
  localparam P_WRITE_DATA = 2'b01;
  localparam P_WRITE_RESP = 2'b10;
  localparam P_READ_IDLE = 1'b0;
  localparam P_READ_DATA = 1'b1;
  localparam P_DECERR = 2'b11;
   
  assign S_AXI_BRESP = P_DECERR;
  assign S_AXI_RRESP = P_DECERR;
  assign S_AXI_RDATA = {C_AXI_DATA_WIDTH{1'b0}};
  assign S_AXI_BUSER = {C_AXI_BUSER_WIDTH{1'b0}};
  assign S_AXI_RUSER = {C_AXI_RUSER_WIDTH{1'b0}};
  assign S_AXI_AWREADY = s_axi_awready_i;
  assign S_AXI_WREADY = s_axi_wready_i;
  assign S_AXI_BVALID = s_axi_bvalid_i;
  assign S_AXI_BID = s_axi_bid_i;
  assign S_AXI_ARREADY = s_axi_arready_i;
  assign S_AXI_RVALID = s_axi_rvalid_i;
  assign S_AXI_RLAST = s_axi_rlast_i;
  assign S_AXI_RID = s_axi_rid_i;

  always @(posedge S_AXI_ACLK) begin
    if (S_AXI_ARESET) begin
      write_cs <= P_WRITE_IDLE;
      s_axi_awready_i <= 1'b0;
      s_axi_wready_i <= 1'b0;
      s_axi_bvalid_i <= 1'b0;
      s_axi_bid_i <= 0;
    end else begin
      case (write_cs) 
        P_WRITE_IDLE: 
          begin
            if (S_AXI_AWVALID & s_axi_awready_i) begin
              s_axi_awready_i <= 1'b0;
              s_axi_bid_i <= S_AXI_AWID;
              s_axi_wready_i <= 1'b1;
              write_cs <= P_WRITE_DATA;
            end else begin
              s_axi_awready_i <= 1'b1;
            end
          end
        P_WRITE_DATA:
          begin
            if (S_AXI_WVALID & S_AXI_WLAST) begin
              s_axi_wready_i <= 1'b0;
              s_axi_bvalid_i <= 1'b1;
              write_cs <= P_WRITE_RESP;
            end
          end
        P_WRITE_RESP:
          begin
            if (S_AXI_BREADY) begin
              s_axi_bvalid_i <= 1'b0;
              s_axi_awready_i <= 1'b1;
              write_cs <= P_WRITE_IDLE;
            end
          end
      endcase
    end
  end

  always @(posedge S_AXI_ACLK) begin
    if (S_AXI_ARESET) begin
      read_cs <= P_READ_IDLE;
      s_axi_arready_i <= 1'b0;
      s_axi_rvalid_i <= 1'b0;
      s_axi_rlast_i <= 1'b0;
      s_axi_rid_i <= 0;
      read_cnt <= 0;
    end else begin
      case (read_cs) 
        P_READ_IDLE: 
          begin
            if (S_AXI_ARVALID & s_axi_arready_i) begin
              s_axi_arready_i <= 1'b0;
              s_axi_rid_i <= S_AXI_ARID;
              read_cnt <= S_AXI_ARLEN;
              s_axi_rvalid_i <= 1'b1;
              if (S_AXI_ARLEN == 0) begin
                s_axi_rlast_i <= 1'b1;
              end else begin
                s_axi_rlast_i <= 1'b0;
              end
              read_cs <= P_READ_DATA;
            end else begin
              s_axi_arready_i <= 1'b1;
            end
          end
        P_READ_DATA:
          begin
            if (S_AXI_RREADY) begin
              if (read_cnt == 0) begin
                s_axi_rvalid_i <= 1'b0;
                s_axi_rlast_i <= 1'b0;
                s_axi_arready_i <= 1'b1;
                read_cs <= P_READ_IDLE;
              end else begin
                if (read_cnt == 1) begin
                  s_axi_rlast_i <= 1'b1;
                end
                read_cnt <= read_cnt - 1;
              end
            end
          end
      endcase
    end
  end

endmodule

`default_nettype wire



// -- (c) Copyright 1995 - 2013 Xilinx, Inc. All rights reserved.
// --
// -- This file contains confidential and proprietary information
// -- of Xilinx, Inc. and is protected under U.S. and 
// -- international copyright and other intellectual property
// -- laws.
// --
// -- DISCLAIMER
// -- This disclaimer is not a license and does not grant any
// -- rights to the materials distributed herewith. Except as
// -- otherwise provided in a valid license issued to you by
// -- Xilinx, and to the maximum extent permitted by applicable
// -- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
// -- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
// -- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
// -- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
// -- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
// -- (2) Xilinx shall not be liable (whether in contract or tort,
// -- including negligence, or under any other theory of
// -- liability) for any loss or damage of any kind or nature
// -- related to, arising under or in connection with these
// -- materials, including for any direct, or any indirect,
// -- special, incidental, or consequential loss or damage
// -- (including loss of data, profits, goodwill, or any type of
// -- loss or damage suffered as a result of any action brought
// -- by a third party) even if such damage or loss was
// -- reasonably foreseeable or Xilinx had been advised of the
// -- possibility of the same.
// --
// -- CRITICAL APPLICATIONS
// -- Xilinx products are not designed or intended to be fail-
// -- safe, or for use in any application requiring fail-safe
// -- performance, such as life-support or safety devices or
// -- systems, Class III medical devices, nuclear facilities,
// -- applications related to the deployment of airbags, or any
// -- other applications that could lead to death, personal
// -- injury, or severe property or environmental damage
// -- (individually and collectively, "Critical
// -- Applications"). Customer assumes the sole risk and
// -- liability of any use of Xilinx products in Critical
// -- Applications, subject only to applicable laws and
// -- regulations governing limitations on product liability.
// --
// -- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
// -- PART OF THIS FILE AT ALL TIMES.
//-----------------------------------------------------------------------

// The synthesis directives "translate_off/translate_on" specified below are
// supported by Xilinx, Mentor Graphics and Synplicity synthesis
// tools. Ensure they are correct for your synthesis tool(s).

// You must compile the fifo_generator wrapper file when simulating
// the core. When compiling the wrapper file, be sure to
// reference the XilinxCoreLib Verilog simulation library. For detailed
// instructions, please refer to the "CORE Generator Help".

`timescale 1ps/1ps

(* DowngradeIPIdentifiedWarnings="yes" *) 
module axi_interconnect_v1_7_13_fifo_gen #(
parameter C_FAMILY          = "virtex7",
parameter integer C_COMMON_CLOCK    = 1,
parameter integer C_FIFO_DEPTH_LOG  = 5,
parameter integer C_FIFO_WIDTH      = 64,
parameter C_FIFO_TYPE       = "lut"
)(
  clk,
  rst,
  wr_clk,
  wr_en,
  wr_ready,
  wr_data,
  rd_clk,
  rd_en,
  rd_valid,
  rd_data);

input clk;
input wr_clk;
input rd_clk;
input rst;
input [C_FIFO_WIDTH-1 : 0] wr_data;
input wr_en;
input rd_en;
output [C_FIFO_WIDTH-1 : 0] rd_data;
output wr_ready;
output rd_valid;

wire  full;
wire  empty;
wire  rd_valid = ~empty;
wire  wr_ready = ~full;

localparam C_MEMORY_TYPE =  (C_FIFO_TYPE == "bram")? 1 : 2;

localparam C_IMPLEMENTATION_TYPE = (C_COMMON_CLOCK == 1)? 0 : 2;

localparam C_PRIM_FIFO_TYPE = "512x72" ;

  fifo_generator_v13_1_4 #(
    .C_ADD_NGC_CONSTRAINT(0),
    .C_APPLICATION_TYPE_AXIS(0),
    .C_APPLICATION_TYPE_RACH(0),
    .C_APPLICATION_TYPE_RDCH(0),
    .C_APPLICATION_TYPE_WACH(0),
    .C_APPLICATION_TYPE_WDCH(0),
    .C_APPLICATION_TYPE_WRCH(0),
    .C_AXIS_TDATA_WIDTH(64),
    .C_AXIS_TDEST_WIDTH(4),
    .C_AXIS_TID_WIDTH(8),
    .C_AXIS_TKEEP_WIDTH(4),
    .C_AXIS_TSTRB_WIDTH(4),
    .C_AXIS_TUSER_WIDTH(4),
    .C_AXIS_TYPE(0),
    .C_AXI_ADDR_WIDTH(32),
    .C_AXI_ARUSER_WIDTH(1),
    .C_AXI_AWUSER_WIDTH(1),
    .C_AXI_BUSER_WIDTH(1),
    .C_AXI_DATA_WIDTH(64),
    .C_AXI_ID_WIDTH(4),
    .C_AXI_RUSER_WIDTH(1),
    .C_AXI_TYPE(0),
    .C_AXI_WUSER_WIDTH(1),
    .C_COMMON_CLOCK(C_COMMON_CLOCK),
    .C_COUNT_TYPE(0),
    .C_DATA_COUNT_WIDTH(2),
    .C_DEFAULT_VALUE("BlankString"),
    .C_DIN_WIDTH(C_FIFO_WIDTH),
    .C_DIN_WIDTH_AXIS(1),
    .C_DIN_WIDTH_RACH(32),
    .C_DIN_WIDTH_RDCH(64),
    .C_DIN_WIDTH_WACH(32),
    .C_DIN_WIDTH_WDCH(64),
    .C_DIN_WIDTH_WRCH(2),
    .C_DOUT_RST_VAL("0"),
    .C_DOUT_WIDTH(C_FIFO_WIDTH),
    .C_ENABLE_RLOCS(0),
    .C_ENABLE_RST_SYNC(1),
    .C_ERROR_INJECTION_TYPE(0),
    .C_ERROR_INJECTION_TYPE_AXIS(0),
    .C_ERROR_INJECTION_TYPE_RACH(0),
    .C_ERROR_INJECTION_TYPE_RDCH(0),
    .C_ERROR_INJECTION_TYPE_WACH(0),
    .C_ERROR_INJECTION_TYPE_WDCH(0),
    .C_ERROR_INJECTION_TYPE_WRCH(0),
    .C_FAMILY(C_FAMILY),
    .C_FULL_FLAGS_RST_VAL(1),
    .C_HAS_ALMOST_EMPTY(0),
    .C_HAS_ALMOST_FULL(0),
    .C_HAS_AXIS_TDATA(0),
    .C_HAS_AXIS_TDEST(0),
    .C_HAS_AXIS_TID(0),
    .C_HAS_AXIS_TKEEP(0),
    .C_HAS_AXIS_TLAST(0),
    .C_HAS_AXIS_TREADY(1),
    .C_HAS_AXIS_TSTRB(0),
    .C_HAS_AXIS_TUSER(0),
    .C_HAS_AXI_ARUSER(0),
    .C_HAS_AXI_AWUSER(0),
    .C_HAS_AXI_BUSER(0),
    .C_HAS_AXI_RD_CHANNEL(0),
    .C_HAS_AXI_RUSER(0),
    .C_HAS_AXI_WR_CHANNEL(0),
    .C_HAS_AXI_WUSER(0),
    .C_HAS_BACKUP(0),
    .C_HAS_DATA_COUNT(0),
    .C_HAS_DATA_COUNTS_AXIS(0),
    .C_HAS_DATA_COUNTS_RACH(0),
    .C_HAS_DATA_COUNTS_RDCH(0),
    .C_HAS_DATA_COUNTS_WACH(0),
    .C_HAS_DATA_COUNTS_WDCH(0),
    .C_HAS_DATA_COUNTS_WRCH(0),
    .C_HAS_INT_CLK(0),
    .C_HAS_MASTER_CE(0),
    .C_HAS_MEMINIT_FILE(0),
    .C_HAS_OVERFLOW(0),
    .C_HAS_PROG_FLAGS_AXIS(0),
    .C_HAS_PROG_FLAGS_RACH(0),
    .C_HAS_PROG_FLAGS_RDCH(0),
    .C_HAS_PROG_FLAGS_WACH(0),
    .C_HAS_PROG_FLAGS_WDCH(0),
    .C_HAS_PROG_FLAGS_WRCH(0),
    .C_HAS_RD_DATA_COUNT(0),
    .C_HAS_RD_RST(0),
    .C_HAS_RST(1),
    .C_HAS_SLAVE_CE(0),
    .C_HAS_SRST(0),
    .C_HAS_UNDERFLOW(0),
    .C_HAS_VALID(0),
    .C_HAS_WR_ACK(0),
    .C_HAS_WR_DATA_COUNT(0),
    .C_HAS_WR_RST(0),
    .C_IMPLEMENTATION_TYPE(C_IMPLEMENTATION_TYPE),
    .C_IMPLEMENTATION_TYPE_AXIS(1),
    .C_IMPLEMENTATION_TYPE_RACH(1),
    .C_IMPLEMENTATION_TYPE_RDCH(1),
    .C_IMPLEMENTATION_TYPE_WACH(1),
    .C_IMPLEMENTATION_TYPE_WDCH(1),
    .C_IMPLEMENTATION_TYPE_WRCH(1),
    .C_INIT_WR_PNTR_VAL(0),
    .C_INTERFACE_TYPE(0),
    .C_MEMORY_TYPE(C_MEMORY_TYPE),
    .C_MIF_FILE_NAME("BlankString"),
    .C_MSGON_VAL(1),
    .C_OPTIMIZATION_MODE(0),
    .C_OVERFLOW_LOW(0),
    .C_PRELOAD_LATENCY(0),
    .C_PRELOAD_REGS(1),
    .C_PRIM_FIFO_TYPE("512x72"),
    .C_PROG_EMPTY_THRESH_ASSERT_VAL(2),
    .C_PROG_EMPTY_THRESH_ASSERT_VAL_AXIS(1022),
    .C_PROG_EMPTY_THRESH_ASSERT_VAL_RACH(1022),
    .C_PROG_EMPTY_THRESH_ASSERT_VAL_RDCH(1022),
    .C_PROG_EMPTY_THRESH_ASSERT_VAL_WACH(1022),
    .C_PROG_EMPTY_THRESH_ASSERT_VAL_WDCH(1022),
    .C_PROG_EMPTY_THRESH_ASSERT_VAL_WRCH(1022),
    .C_PROG_EMPTY_THRESH_NEGATE_VAL(3),
    .C_PROG_EMPTY_TYPE(0),
    .C_PROG_EMPTY_TYPE_AXIS(5),
    .C_PROG_EMPTY_TYPE_RACH(5),
    .C_PROG_EMPTY_TYPE_RDCH(5),
    .C_PROG_EMPTY_TYPE_WACH(5),
    .C_PROG_EMPTY_TYPE_WDCH(5),
    .C_PROG_EMPTY_TYPE_WRCH(5),
    .C_PROG_FULL_THRESH_ASSERT_VAL(13),
    .C_PROG_FULL_THRESH_ASSERT_VAL_AXIS(1023),
    .C_PROG_FULL_THRESH_ASSERT_VAL_RACH(1023),
    .C_PROG_FULL_THRESH_ASSERT_VAL_RDCH(1023),
    .C_PROG_FULL_THRESH_ASSERT_VAL_WACH(1023),
    .C_PROG_FULL_THRESH_ASSERT_VAL_WDCH(1023),
    .C_PROG_FULL_THRESH_ASSERT_VAL_WRCH(1023),
    .C_PROG_FULL_THRESH_NEGATE_VAL(12),
    .C_PROG_FULL_TYPE(0),
    .C_PROG_FULL_TYPE_AXIS(5),
    .C_PROG_FULL_TYPE_RACH(5),
    .C_PROG_FULL_TYPE_RDCH(5),
    .C_PROG_FULL_TYPE_WACH(5),
    .C_PROG_FULL_TYPE_WDCH(5),
    .C_PROG_FULL_TYPE_WRCH(5),
    .C_RACH_TYPE(0),
    .C_RDCH_TYPE(0),
    .C_RD_DATA_COUNT_WIDTH(2),
    .C_RD_DEPTH(1<<C_FIFO_DEPTH_LOG),
    .C_RD_FREQ(1),
    .C_RD_PNTR_WIDTH(C_FIFO_DEPTH_LOG),
    .C_REG_SLICE_MODE_AXIS(0),
    .C_REG_SLICE_MODE_RACH(0),
    .C_REG_SLICE_MODE_RDCH(0),
    .C_REG_SLICE_MODE_WACH(0),
    .C_REG_SLICE_MODE_WDCH(0),
    .C_REG_SLICE_MODE_WRCH(0),
    .C_UNDERFLOW_LOW(0),
    .C_USE_COMMON_OVERFLOW(0),
    .C_USE_COMMON_UNDERFLOW(0),
    .C_USE_DEFAULT_SETTINGS(0),
    .C_USE_DOUT_RST(0),
    .C_USE_ECC(0),
    .C_USE_ECC_AXIS(0),
    .C_USE_ECC_RACH(0),
    .C_USE_ECC_RDCH(0),
    .C_USE_ECC_WACH(0),
    .C_USE_ECC_WDCH(0),
    .C_USE_ECC_WRCH(0),
    .C_USE_EMBEDDED_REG(0),
    .C_USE_FIFO16_FLAGS(0),
    .C_USE_FWFT_DATA_COUNT(0),
    .C_VALID_LOW(0),
    .C_WACH_TYPE(0),
    .C_WDCH_TYPE(0),
    .C_WRCH_TYPE(0),
    .C_WR_ACK_LOW(0),
    .C_WR_DATA_COUNT_WIDTH(2),
    .C_WR_DEPTH(1<<C_FIFO_DEPTH_LOG),
    .C_WR_DEPTH_AXIS(1024),
    .C_WR_DEPTH_RACH(16),
    .C_WR_DEPTH_RDCH(1024),
    .C_WR_DEPTH_WACH(16),
    .C_WR_DEPTH_WDCH(1024),
    .C_WR_DEPTH_WRCH(16),
    .C_WR_FREQ(1),
    .C_WR_PNTR_WIDTH(C_FIFO_DEPTH_LOG),
    .C_WR_PNTR_WIDTH_AXIS(10),
    .C_WR_PNTR_WIDTH_RACH(4),
    .C_WR_PNTR_WIDTH_RDCH(10),
    .C_WR_PNTR_WIDTH_WACH(4),
    .C_WR_PNTR_WIDTH_WDCH(10),
    .C_WR_PNTR_WIDTH_WRCH(4),
    .C_WR_RESPONSE_LATENCY(1))
  fifo_gen_inst (
    .rst(rst),
    .wr_clk(wr_clk),
    .rd_clk(rd_clk),
    .din(wr_data),
    .wr_en(wr_en),
    .rd_en(rd_en),
    .dout(rd_data),
    .full(full),
    .empty(empty),
    .backup(),
    .backup_marker(),
    .clk(clk),
    .srst(),
    .wr_rst(),
    .rd_rst(),
    .prog_empty_thresh(),
    .prog_empty_thresh_assert(),
    .prog_empty_thresh_negate(),
    .prog_full_thresh(),
    .prog_full_thresh_assert(),
    .prog_full_thresh_negate(),
    .int_clk(),
    .injectdbiterr(),
    .injectsbiterr(),
    .almost_full(),
    .wr_ack(),
    .overflow(),
    .almost_empty(),
    .valid(),
    .underflow(),
    .data_count(),
    .rd_data_count(),
    .wr_data_count(),
    .prog_full(),
    .prog_empty(),
    .sbiterr(),
    .dbiterr(),
    .m_aclk(),
    .s_aclk(),
    .s_aresetn(),
    .m_aclk_en(),
    .s_aclk_en(),
    .s_axi_awid(),
    .s_axi_awaddr(),
    .s_axi_awlen(),
    .s_axi_awsize(),
    .s_axi_awburst(),
    .s_axi_awlock(),
    .s_axi_awcache(),
    .s_axi_awprot(),
    .s_axi_awqos(),
    .s_axi_awregion(),
    .s_axi_awuser(),
    .s_axi_awvalid(),
    .s_axi_awready(),
    .s_axi_wid(),
    .s_axi_wdata(),
    .s_axi_wstrb(),
    .s_axi_wlast(),
    .s_axi_wuser(),
    .s_axi_wvalid(),
    .s_axi_wready(),
    .s_axi_bid(),
    .s_axi_bresp(),
    .s_axi_buser(),
    .s_axi_bvalid(),
    .s_axi_bready(),
    .m_axi_awid(),
    .m_axi_awaddr(),
    .m_axi_awlen(),
    .m_axi_awsize(),
    .m_axi_awburst(),
    .m_axi_awlock(),
    .m_axi_awcache(),
    .m_axi_awprot(),
    .m_axi_awqos(),
    .m_axi_awregion(),
    .m_axi_awuser(),
    .m_axi_awvalid(),
    .m_axi_awready(),
    .m_axi_wid(),
    .m_axi_wdata(),
    .m_axi_wstrb(),
    .m_axi_wlast(),
    .m_axi_wuser(),
    .m_axi_wvalid(),
    .m_axi_wready(),
    .m_axi_bid(),
    .m_axi_bresp(),
    .m_axi_buser(),
    .m_axi_bvalid(),
    .m_axi_bready(),
    .s_axi_arid(),
    .s_axi_araddr(),
    .s_axi_arlen(),
    .s_axi_arsize(),
    .s_axi_arburst(),
    .s_axi_arlock(),
    .s_axi_arcache(),
    .s_axi_arprot(),
    .s_axi_arqos(),
    .s_axi_arregion(),
    .s_axi_aruser(),
    .s_axi_arvalid(),
    .s_axi_arready(),
    .s_axi_rid(),
    .s_axi_rdata(),
    .s_axi_rresp(),
    .s_axi_rlast(),
    .s_axi_ruser(),
    .s_axi_rvalid(),
    .s_axi_rready(),
    .m_axi_arid(),
    .m_axi_araddr(),
    .m_axi_arlen(),
    .m_axi_arsize(),
    .m_axi_arburst(),
    .m_axi_arlock(),
    .m_axi_arcache(),
    .m_axi_arprot(),
    .m_axi_arqos(),
    .m_axi_arregion(),
    .m_axi_aruser(),
    .m_axi_arvalid(),
    .m_axi_arready(),
    .m_axi_rid(),
    .m_axi_rdata(),
    .m_axi_rresp(),
    .m_axi_rlast(),
    .m_axi_ruser(),
    .m_axi_rvalid(),
    .m_axi_rready(),
    .s_axis_tvalid(),
    .s_axis_tready(),
    .s_axis_tdata(),
    .s_axis_tstrb(),
    .s_axis_tkeep(),
    .s_axis_tlast(),
    .s_axis_tid(),
    .s_axis_tdest(),
    .s_axis_tuser(),
    .m_axis_tvalid(),
    .m_axis_tready(),
    .m_axis_tdata(),
    .m_axis_tstrb(),
    .m_axis_tkeep(),
    .m_axis_tlast(),
    .m_axis_tid(),
    .m_axis_tdest(),
    .m_axis_tuser(),
    .axi_aw_injectsbiterr(),
    .axi_aw_injectdbiterr(),
    .axi_aw_prog_full_thresh(),
    .axi_aw_prog_empty_thresh(),
    .axi_aw_data_count(),
    .axi_aw_wr_data_count(),
    .axi_aw_rd_data_count(),
    .axi_aw_sbiterr(),
    .axi_aw_dbiterr(),
    .axi_aw_overflow(),
    .axi_aw_underflow(),
    .axi_w_injectsbiterr(),
    .axi_w_injectdbiterr(),
    .axi_w_prog_full_thresh(),
    .axi_w_prog_empty_thresh(),
    .axi_w_data_count(),
    .axi_w_wr_data_count(),
    .axi_w_rd_data_count(),
    .axi_w_sbiterr(),
    .axi_w_dbiterr(),
    .axi_w_overflow(),
    .axi_w_underflow(),
    .axi_b_injectsbiterr(),
    .axi_b_injectdbiterr(),
    .axi_b_prog_full_thresh(),
    .axi_b_prog_empty_thresh(),
    .axi_b_data_count(),
    .axi_b_wr_data_count(),
    .axi_b_rd_data_count(),
    .axi_b_sbiterr(),
    .axi_b_dbiterr(),
    .axi_b_overflow(),
    .axi_b_underflow(),
    .axi_ar_injectsbiterr(),
    .axi_ar_injectdbiterr(),
    .axi_ar_prog_full_thresh(),
    .axi_ar_prog_empty_thresh(),
    .axi_ar_data_count(),
    .axi_ar_wr_data_count(),
    .axi_ar_rd_data_count(),
    .axi_ar_sbiterr(),
    .axi_ar_dbiterr(),
    .axi_ar_overflow(),
    .axi_ar_underflow(),
    .axi_r_injectsbiterr(),
    .axi_r_injectdbiterr(),
    .axi_r_prog_full_thresh(),
    .axi_r_prog_empty_thresh(),
    .axi_r_data_count(),
    .axi_r_wr_data_count(),
    .axi_r_rd_data_count(),
    .axi_r_sbiterr(),
    .axi_r_dbiterr(),
    .axi_r_overflow(),
    .axi_r_underflow(),
    .axis_injectsbiterr(),
    .axis_injectdbiterr(),
    .axis_prog_full_thresh(),
    .axis_prog_empty_thresh(),
    .axis_data_count(),
    .axis_wr_data_count(),
    .axis_rd_data_count(),
    .axis_sbiterr(),
    .axis_dbiterr(),
    .axis_overflow(),
    .axis_underflow(),
    .axis_prog_empty(),
    .axis_prog_full(),
    .axi_aw_prog_empty(),
    .axi_ar_prog_empty(),
    .axi_r_prog_empty(),
    .axi_w_prog_empty(),
    .axi_b_prog_empty(),
    .axi_aw_prog_full(),
    .axi_ar_prog_full(),
    .axi_w_prog_full(),
    .axi_r_prog_full(),
    .axi_b_prog_full(),
    .sleep(1'b0),
    .rd_rst_busy(),
    .wr_rst_busy()
    );

endmodule



// -- (c) Copyright 2010 - 2011 Xilinx, Inc. All rights reserved.
// --
// -- This file contains confidential and proprietary information
// -- of Xilinx, Inc. and is protected under U.S. and 
// -- international copyright and other intellectual property
// -- laws.
// --
// -- DISCLAIMER
// -- This disclaimer is not a license and does not grant any
// -- rights to the materials distributed herewith. Except as
// -- otherwise provided in a valid license issued to you by
// -- Xilinx, and to the maximum extent permitted by applicable
// -- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
// -- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
// -- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
// -- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
// -- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
// -- (2) Xilinx shall not be liable (whether in contract or tort,
// -- including negligence, or under any other theory of
// -- liability) for any loss or damage of any kind or nature
// -- related to, arising under or in connection with these
// -- materials, including for any direct, or any indirect,
// -- special, incidental, or consequential loss or damage
// -- (including loss of data, profits, goodwill, or any type of
// -- loss or damage suffered as a result of any action brought
// -- by a third party) even if such damage or loss was
// -- reasonably foreseeable or Xilinx had been advised of the
// -- possibility of the same.
// --
// -- CRITICAL APPLICATIONS
// -- Xilinx products are not designed or intended to be fail-
// -- safe, or for use in any application requiring fail-safe
// -- performance, such as life-support or safety devices or
// -- systems, Class III medical devices, nuclear facilities,
// -- applications related to the deployment of airbags, or any
// -- other applications that could lead to death, personal
// -- injury, or severe property or environmental damage
// -- (individually and collectively, "Critical
// -- Applications"). Customer assumes the sole risk and
// -- liability of any use of Xilinx products in Critical
// -- Applications, subject only to applicable laws and
// -- regulations governing limitations on product liability.
// --
// -- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
// -- PART OF THIS FILE AT ALL TIMES.
//-----------------------------------------------------------------------------
//
// Description: 
//  Optimized Mux using MUXF7/8.
//  Any mux ratio.
//
// Verilog-standard:  Verilog 2001
//--------------------------------------------------------------------------
//
// Structure:
//   mux_enc
//
//--------------------------------------------------------------------------
`timescale 1ps/1ps


(* DowngradeIPIdentifiedWarnings="yes" *) 
module axi_interconnect_v1_7_13_mux_enc #
  (
   parameter         C_FAMILY                       = "rtl",
                       // FPGA Family. Current version: virtex6 or spartan6.
   parameter integer C_RATIO                        = 4,
                       // Mux select ratio. Can be any binary value (>= 1)
   parameter integer C_SEL_WIDTH                    = 2,
                       // Log2-ceiling of C_RATIO (>= 1)
   parameter integer C_DATA_WIDTH                   = 1
                       // Data width for comparator (>= 1)
   )
  (
   input  wire [C_SEL_WIDTH-1:0]                    S,
   input  wire [C_RATIO*C_DATA_WIDTH-1:0]           A,
   output wire [C_DATA_WIDTH-1:0]                   O,
   input  wire                                      OE
   );
  
  wire [C_DATA_WIDTH-1:0] o_i;
  genvar bit_cnt;
  
  function [C_DATA_WIDTH-1:0] f_mux
    (
     input [C_SEL_WIDTH-1:0] s,
     input [C_RATIO*C_DATA_WIDTH-1:0] a
     );
    integer i;
    reg [C_RATIO*C_DATA_WIDTH-1:0] carry;
    begin
      carry[C_DATA_WIDTH-1:0] = {C_DATA_WIDTH{(s==0)?1'b1:1'b0}} & a[C_DATA_WIDTH-1:0];
      for (i=1;i<C_RATIO;i=i+1) begin : gen_carrychain_enc
        carry[i*C_DATA_WIDTH +: C_DATA_WIDTH] = 
          carry[(i-1)*C_DATA_WIDTH +: C_DATA_WIDTH] |
          ({C_DATA_WIDTH{(s==i)?1'b1:1'b0}} & a[i*C_DATA_WIDTH +: C_DATA_WIDTH]);
      end
      f_mux = carry[C_DATA_WIDTH*C_RATIO-1:C_DATA_WIDTH*(C_RATIO-1)];
    end
  endfunction
  
  function [C_DATA_WIDTH-1:0] f_mux4
    (
     input [1:0] s,
     input [4*C_DATA_WIDTH-1:0] a
     );
    integer i;
    reg [4*C_DATA_WIDTH-1:0] carry;
    begin
      carry[C_DATA_WIDTH-1:0] = {C_DATA_WIDTH{(s==0)?1'b1:1'b0}} & a[C_DATA_WIDTH-1:0];
      for (i=1;i<4;i=i+1) begin : gen_carrychain_enc
        carry[i*C_DATA_WIDTH +: C_DATA_WIDTH] = 
          carry[(i-1)*C_DATA_WIDTH +: C_DATA_WIDTH] |
          ({C_DATA_WIDTH{(s==i)?1'b1:1'b0}} & a[i*C_DATA_WIDTH +: C_DATA_WIDTH]);
      end
      f_mux4 = carry[C_DATA_WIDTH*4-1:C_DATA_WIDTH*3];
    end
  endfunction
  
  assign O = o_i & {C_DATA_WIDTH{OE}};  // OE is gated AFTER any MUXF7/8 (can only optimize forward into downstream logic)
  
  generate
    if ( C_RATIO < 2 ) begin : gen_bypass
      assign o_i = A;
    end else if ( C_FAMILY == "rtl" || C_RATIO < 5 ) begin : gen_rtl
      assign o_i = f_mux(S, A);
      
    end else begin : gen_fpga
      wire [C_DATA_WIDTH-1:0] l;
      wire [C_DATA_WIDTH-1:0] h;
      wire [C_DATA_WIDTH-1:0] ll;
      wire [C_DATA_WIDTH-1:0] lh;
      wire [C_DATA_WIDTH-1:0] hl;
      wire [C_DATA_WIDTH-1:0] hh;
      
      case (C_RATIO)
        1, 5, 9, 13: 
          assign hh = A[(C_RATIO-1)*C_DATA_WIDTH +: C_DATA_WIDTH];
        2, 6, 10, 14:
          assign hh = S[0] ? 
            A[(C_RATIO-1)*C_DATA_WIDTH +: C_DATA_WIDTH] :
            A[(C_RATIO-2)*C_DATA_WIDTH +: C_DATA_WIDTH] ;
        3, 7, 11, 15:
          assign hh = S[1] ? 
            A[(C_RATIO-1)*C_DATA_WIDTH +: C_DATA_WIDTH] :
            (S[0] ? 
              A[(C_RATIO-2)*C_DATA_WIDTH +: C_DATA_WIDTH] :
              A[(C_RATIO-3)*C_DATA_WIDTH +: C_DATA_WIDTH] );
        4, 8, 12, 16:
          assign hh = S[1] ? 
            (S[0] ? 
              A[(C_RATIO-1)*C_DATA_WIDTH +: C_DATA_WIDTH] :
              A[(C_RATIO-2)*C_DATA_WIDTH +: C_DATA_WIDTH] ) :
            (S[0] ? 
              A[(C_RATIO-3)*C_DATA_WIDTH +: C_DATA_WIDTH] :
              A[(C_RATIO-4)*C_DATA_WIDTH +: C_DATA_WIDTH] );
        17:
          assign hh = S[1] ? 
            (S[0] ? 
              A[15*C_DATA_WIDTH +: C_DATA_WIDTH] :
              A[14*C_DATA_WIDTH +: C_DATA_WIDTH] ) :
            (S[0] ? 
              A[13*C_DATA_WIDTH +: C_DATA_WIDTH] :
              A[12*C_DATA_WIDTH +: C_DATA_WIDTH] );
        default:
          assign hh = 0; 
      endcase

      case (C_RATIO)
        5, 6, 7, 8: begin
          assign l = f_mux4(S[1:0], A[0 +: 4*C_DATA_WIDTH]);
          for (bit_cnt = 0; bit_cnt < C_DATA_WIDTH ; bit_cnt = bit_cnt + 1) begin : gen_mux_5_8
            MUXF7 mux_s2_inst 
            (
             .I0  (l[bit_cnt]),
             .I1  (hh[bit_cnt]),
             .S   (S[2]),
             .O   (o_i[bit_cnt])
            ); 
          end
        end
          
        9, 10, 11, 12: begin
          assign ll = f_mux4(S[1:0], A[0 +: 4*C_DATA_WIDTH]);
          assign lh = f_mux4(S[1:0], A[4*C_DATA_WIDTH +: 4*C_DATA_WIDTH]);
          for (bit_cnt = 0; bit_cnt < C_DATA_WIDTH ; bit_cnt = bit_cnt + 1) begin : gen_mux_9_12
            MUXF7 muxf_s2_low_inst 
            (
             .I0  (ll[bit_cnt]),
             .I1  (lh[bit_cnt]),
             .S   (S[2]),
             .O   (l[bit_cnt])
            ); 
            MUXF8 muxf_s3_inst 
            (
             .I0  (l[bit_cnt]),
             .I1  (hh[bit_cnt]),
             .S   (S[3]),
             .O   (o_i[bit_cnt])
            ); 
          end
        end
          
        13,14,15,16: begin
          assign ll = f_mux4(S[1:0], A[0 +: 4*C_DATA_WIDTH]);
          assign lh = f_mux4(S[1:0], A[4*C_DATA_WIDTH +: 4*C_DATA_WIDTH]);
          assign hl = f_mux4(S[1:0], A[8*C_DATA_WIDTH +: 4*C_DATA_WIDTH]);
          for (bit_cnt = 0; bit_cnt < C_DATA_WIDTH ; bit_cnt = bit_cnt + 1) begin : gen_mux_13_16
            MUXF7 muxf_s2_low_inst 
            (
             .I0  (ll[bit_cnt]),
             .I1  (lh[bit_cnt]),
             .S   (S[2]),
             .O   (l[bit_cnt])
            ); 
            MUXF7 muxf_s2_hi_inst 
            (
             .I0  (hl[bit_cnt]),
             .I1  (hh[bit_cnt]),
             .S   (S[2]),
             .O   (h[bit_cnt])
            );
          
            MUXF8 muxf_s3_inst 
            (
             .I0  (l[bit_cnt]),
             .I1  (h[bit_cnt]),
             .S   (S[3]),
             .O   (o_i[bit_cnt])
            ); 
          end
        end
          
        17: begin
          assign ll = S[4] ? A[16*C_DATA_WIDTH +: C_DATA_WIDTH] : f_mux4(S[1:0], A[0 +: 4*C_DATA_WIDTH]);  // 5-input mux
          assign lh = f_mux4(S[1:0], A[4*C_DATA_WIDTH +: 4*C_DATA_WIDTH]);
          assign hl = f_mux4(S[1:0], A[8*C_DATA_WIDTH +: 4*C_DATA_WIDTH]);
          for (bit_cnt = 0; bit_cnt < C_DATA_WIDTH ; bit_cnt = bit_cnt + 1) begin : gen_mux_17
            MUXF7 muxf_s2_low_inst 
            (
             .I0  (ll[bit_cnt]),
             .I1  (lh[bit_cnt]),
             .S   (S[2]),
             .O   (l[bit_cnt])
            ); 
            MUXF7 muxf_s2_hi_inst 
            (
             .I0  (hl[bit_cnt]),
             .I1  (hh[bit_cnt]),
             .S   (S[2]),
             .O   (h[bit_cnt])
            ); 
            MUXF8 muxf_s3_inst 
            (
             .I0  (l[bit_cnt]),
             .I1  (h[bit_cnt]),
             .S   (S[3]),
             .O   (o_i[bit_cnt])
            ); 
          end
        end
          
        default:  // If RATIO > 17, use RTL
          assign o_i = f_mux(S, A);
      endcase
    end  // gen_fpga
  endgenerate
endmodule



// -- (c) Copyright 2010 - 2011 Xilinx, Inc. All rights reserved.
// --
// -- This file contains confidential and proprietary information
// -- of Xilinx, Inc. and is protected under U.S. and 
// -- international copyright and other intellectual property
// -- laws.
// --
// -- DISCLAIMER
// -- This disclaimer is not a license and does not grant any
// -- rights to the materials distributed herewith. Except as
// -- otherwise provided in a valid license issued to you by
// -- Xilinx, and to the maximum extent permitted by applicable
// -- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
// -- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
// -- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
// -- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
// -- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
// -- (2) Xilinx shall not be liable (whether in contract or tort,
// -- including negligence, or under any other theory of
// -- liability) for any loss or damage of any kind or nature
// -- related to, arising under or in connection with these
// -- materials, including for any direct, or any indirect,
// -- special, incidental, or consequential loss or damage
// -- (including loss of data, profits, goodwill, or any type of
// -- loss or damage suffered as a result of any action brought
// -- by a third party) even if such damage or loss was
// -- reasonably foreseeable or Xilinx had been advised of the
// -- possibility of the same.
// --
// -- CRITICAL APPLICATIONS
// -- Xilinx products are not designed or intended to be fail-
// -- safe, or for use in any application requiring fail-safe
// -- performance, such as life-support or safety devices or
// -- systems, Class III medical devices, nuclear facilities,
// -- applications related to the deployment of airbags, or any
// -- other applications that could lead to death, personal
// -- injury, or severe property or environmental damage
// -- (individually and collectively, "Critical
// -- Applications"). Customer assumes the sole risk and
// -- liability of any use of Xilinx products in Critical
// -- Applications, subject only to applicable laws and
// -- regulations governing limitations on product liability.
// --
// -- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
// -- PART OF THIS FILE AT ALL TIMES.
//-----------------------------------------------------------------------------
//
// Description: 
//  Optimized Mux from 2:1 upto 16:1.
//
// Verilog-standard:  Verilog 2001
//--------------------------------------------------------------------------
//
// Structure:
//   
//
//--------------------------------------------------------------------------
`timescale 1ps/1ps


(* DowngradeIPIdentifiedWarnings="yes" *) 
module axi_interconnect_v1_7_13_mux #
  (
   parameter         C_FAMILY                         = "rtl",
                       // FPGA Family. Current version: virtex6 or spartan6.
   parameter integer C_SEL_WIDTH                      = 4,
                       // Data width for comparator.
   parameter integer C_DATA_WIDTH                     = 2
                       // Data width for comparator.
   )
  (
   input  wire [C_SEL_WIDTH-1:0]                    S,
   input  wire [(2**C_SEL_WIDTH)*C_DATA_WIDTH-1:0]  A,
   output wire [C_DATA_WIDTH-1:0]                   O
   );
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Variables for generating parameter controlled instances.
  /////////////////////////////////////////////////////////////////////////////
  
  // Generate variable for bit vector.
  genvar bit_cnt;
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Local params
  /////////////////////////////////////////////////////////////////////////////
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Functions
  /////////////////////////////////////////////////////////////////////////////
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Internal signals
  /////////////////////////////////////////////////////////////////////////////
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Instantiate or use RTL code
  /////////////////////////////////////////////////////////////////////////////
  
  generate
    if ( C_FAMILY == "rtl" || C_SEL_WIDTH < 3 ) begin : USE_RTL
      assign O = A[(S)*C_DATA_WIDTH +: C_DATA_WIDTH];
      
    end else begin : USE_FPGA
      
      wire [C_DATA_WIDTH-1:0] C;
      wire [C_DATA_WIDTH-1:0] D;
      
      // Lower half recursively.
  axi_interconnect_v1_7_13_mux # 
      (
       .C_FAMILY      (C_FAMILY),
       .C_SEL_WIDTH   (C_SEL_WIDTH-1),
       .C_DATA_WIDTH  (C_DATA_WIDTH)
      ) mux_c_inst 
      (
       .S   (S[C_SEL_WIDTH-2:0]),
       .A   (A[(2**(C_SEL_WIDTH-1))*C_DATA_WIDTH-1 : 0]),
       .O   (C)
      ); 
      
      // Upper half recursively.
  axi_interconnect_v1_7_13_mux # 
      (
       .C_FAMILY      (C_FAMILY),
       .C_SEL_WIDTH   (C_SEL_WIDTH-1),
       .C_DATA_WIDTH  (C_DATA_WIDTH)
      ) mux_d_inst 
      (
       .S   (S[C_SEL_WIDTH-2:0]),
       .A   (A[(2**C_SEL_WIDTH)*C_DATA_WIDTH-1 : (2**(C_SEL_WIDTH-1))*C_DATA_WIDTH]),
       .O   (D)
      ); 
      
      // Generate instantiated mux components as required.
      for (bit_cnt = 0; bit_cnt < C_DATA_WIDTH ; bit_cnt = bit_cnt + 1) begin : NUM
        if ( C_SEL_WIDTH == 4 ) begin : USE_F8
        
          MUXF8 muxf8_inst 
          (
           .I0  (C[bit_cnt]),
           .I1  (D[bit_cnt]),
           .S   (S[C_SEL_WIDTH-1]),
           .O   (O[bit_cnt])
          ); 
          
        end else if ( C_SEL_WIDTH == 3 ) begin : USE_F7
      
          MUXF7 muxf7_inst 
          (
           .I0  (C[bit_cnt]),
           .I1  (D[bit_cnt]),
           .S   (S[C_SEL_WIDTH-1]),
           .O   (O[bit_cnt])
          ); 
          
        end // C_SEL_WIDTH
      end // end for bit_cnt
    
    end
  endgenerate
  
  
endmodule



// -- (c) Copyright 2008 - 2011 Xilinx, Inc. All rights reserved.
// --
// -- This file contains confidential and proprietary information
// -- of Xilinx, Inc. and is protected under U.S. and 
// -- international copyright and other intellectual property
// -- laws.
// --
// -- DISCLAIMER
// -- This disclaimer is not a license and does not grant any
// -- rights to the materials distributed herewith. Except as
// -- otherwise provided in a valid license issued to you by
// -- Xilinx, and to the maximum extent permitted by applicable
// -- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
// -- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
// -- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
// -- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
// -- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
// -- (2) Xilinx shall not be liable (whether in contract or tort,
// -- including negligence, or under any other theory of
// -- liability) for any loss or damage of any kind or nature
// -- related to, arising under or in connection with these
// -- materials, including for any direct, or any indirect,
// -- special, incidental, or consequential loss or damage
// -- (including loss of data, profits, goodwill, or any type of
// -- loss or damage suffered as a result of any action brought
// -- by a third party) even if such damage or loss was
// -- reasonably foreseeable or Xilinx had been advised of the
// -- possibility of the same.
// --
// -- CRITICAL APPLICATIONS
// -- Xilinx products are not designed or intended to be fail-
// -- safe, or for use in any application requiring fail-safe
// -- performance, such as life-support or safety devices or
// -- systems, Class III medical devices, nuclear facilities,
// -- applications related to the deployment of airbags, or any
// -- other applications that could lead to death, personal
// -- injury, or severe property or environmental damage
// -- (individually and collectively, "Critical
// -- Applications"). Customer assumes the sole risk and
// -- liability of any use of Xilinx products in Critical
// -- Applications, subject only to applicable laws and
// -- regulations governing limitations on product liability.
// --
// -- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
// -- PART OF THIS FILE AT ALL TIMES.
//-----------------------------------------------------------------------------
//
// Description: This is a generic n-deep SRL instantiation
// Verilog-standard:  Verilog 2001
// $Revision: 
// $Date: 
//
//-----------------------------------------------------------------------------
`timescale 1ps/1ps
`default_nettype none

(* DowngradeIPIdentifiedWarnings="yes" *) 
module axi_interconnect_v1_7_13_ndeep_srl #
  (
   parameter         C_FAMILY  = "none", // FPGA Family
   parameter         C_A_WIDTH = 1          // Address Width (>= 1)
   )
  (
   input  wire                 CLK, // Clock
   input  wire [C_A_WIDTH-1:0] A,   // Address
   input  wire                 CE,  // Clock Enable
   input  wire                 D,   // Input Data
   output wire                 Q    // Output Data
   );

  localparam P_SRLASIZE = 5;
  localparam P_NUMSRLS  = (C_A_WIDTH>P_SRLASIZE) ? (2**(C_A_WIDTH-P_SRLASIZE)) : 1;
  
  wire [P_NUMSRLS:0]   d_i;
  wire [P_NUMSRLS-1:0] q_i;
  wire [(C_A_WIDTH>P_SRLASIZE) ? (C_A_WIDTH-1) : (P_SRLASIZE-1) : 0] a_i;
  
  genvar i;
  
  // Instantiate SRLs in carry chain format
  assign d_i[0] = D;
  assign a_i = A;
  
  generate
    for (i=0;i<P_NUMSRLS;i=i+1) begin : gen_srls
      SRLC32E
        srl_inst
          (
           .CLK (CLK),
           .A   (a_i[P_SRLASIZE-1:0]),
           .CE  (CE),
           .D   (d_i[i]),
           .Q   (q_i[i]),
           .Q31 (d_i[i+1])
           );
    end
  endgenerate

  // Instantiate MUX
  generate
    if (C_A_WIDTH>P_SRLASIZE) begin : gen_srl_mux
  axi_interconnect_v1_7_13_nto1_mux #
	(
	 .C_RATIO         (2**(C_A_WIDTH-P_SRLASIZE)),
	 .C_SEL_WIDTH     (C_A_WIDTH-P_SRLASIZE),
	 .C_DATAOUT_WIDTH (1),
	 .C_ONEHOT        (0)
	 )
	srl_q_mux_inst
	  (
	   .SEL_ONEHOT ({2**(C_A_WIDTH-P_SRLASIZE){1'b0}}),
	   .SEL        (a_i[C_A_WIDTH-1:P_SRLASIZE]),
	   .IN         (q_i),
	   .OUT        (Q)
	   );
    end else begin : gen_no_srl_mux
      assign Q = q_i[0];
    end
  endgenerate
  
endmodule

`default_nettype wire


// -- (c) Copyright 2009 - 2011 Xilinx, Inc. All rights reserved.
// --
// -- This file contains confidential and proprietary information
// -- of Xilinx, Inc. and is protected under U.S. and 
// -- international copyright and other intellectual property
// -- laws.
// --
// -- DISCLAIMER
// -- This disclaimer is not a license and does not grant any
// -- rights to the materials distributed herewith. Except as
// -- otherwise provided in a valid license issued to you by
// -- Xilinx, and to the maximum extent permitted by applicable
// -- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
// -- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
// -- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
// -- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
// -- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
// -- (2) Xilinx shall not be liable (whether in contract or tort,
// -- including negligence, or under any other theory of
// -- liability) for any loss or damage of any kind or nature
// -- related to, arising under or in connection with these
// -- materials, including for any direct, or any indirect,
// -- special, incidental, or consequential loss or damage
// -- (including loss of data, profits, goodwill, or any type of
// -- loss or damage suffered as a result of any action brought
// -- by a third party) even if such damage or loss was
// -- reasonably foreseeable or Xilinx had been advised of the
// -- possibility of the same.
// --
// -- CRITICAL APPLICATIONS
// -- Xilinx products are not designed or intended to be fail-
// -- safe, or for use in any application requiring fail-safe
// -- performance, such as life-support or safety devices or
// -- systems, Class III medical devices, nuclear facilities,
// -- applications related to the deployment of airbags, or any
// -- other applications that could lead to death, personal
// -- injury, or severe property or environmental damage
// -- (individually and collectively, "Critical
// -- Applications"). Customer assumes the sole risk and
// -- liability of any use of Xilinx products in Critical
// -- Applications, subject only to applicable laws and
// -- regulations governing limitations on product liability.
// --
// -- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
// -- PART OF THIS FILE AT ALL TIMES.
//-----------------------------------------------------------------------------
//
// File name: nto1_mux.v
//
// Description: N:1 MUX based on either binary-encoded or one-hot select input
//   One-hot mode does not protect against multiple active SEL_ONEHOT inputs.
//   Note: All port signals changed to all-upper-case (w.r.t. prior version).
//
//-----------------------------------------------------------------------------

`timescale 1ps/1ps
`default_nettype none

(* DowngradeIPIdentifiedWarnings="yes" *) 
module axi_interconnect_v1_7_13_nto1_mux #
  (
   parameter integer C_RATIO         =  1,  // Range: >=1
   parameter integer C_SEL_WIDTH     =  1,  // Range: >=1; recommended: ceil_log2(C_RATIO)
   parameter integer C_DATAOUT_WIDTH =  1,  // Range: >=1
   parameter integer C_ONEHOT        =  0   // Values: 0 = binary-encoded (use SEL); 1 = one-hot (use SEL_ONEHOT)
   )
  (
   input  wire [C_RATIO-1:0]                 SEL_ONEHOT,  // One-hot mux select (only used if C_ONEHOT=1)
   input  wire [C_SEL_WIDTH-1:0]             SEL,         // Binary-encoded mux select (only used if C_ONEHOT=0)
   input  wire [C_RATIO*C_DATAOUT_WIDTH-1:0] IN,          // Data input array (num_selections x data_width)
   output wire [C_DATAOUT_WIDTH-1:0]         OUT          // Data output vector
   );

  wire [C_DATAOUT_WIDTH*C_RATIO-1:0] carry;
  genvar i;
  
  generate
    if (C_ONEHOT == 0) begin : gen_encoded
      assign carry[C_DATAOUT_WIDTH-1:0] = {C_DATAOUT_WIDTH{(SEL==0)?1'b1:1'b0}} & IN[C_DATAOUT_WIDTH-1:0];
      for (i=1;i<C_RATIO;i=i+1) begin : gen_carrychain_enc
        assign carry[(i+1)*C_DATAOUT_WIDTH-1:i*C_DATAOUT_WIDTH] = 
               carry[i*C_DATAOUT_WIDTH-1:(i-1)*C_DATAOUT_WIDTH] |
               {C_DATAOUT_WIDTH{(SEL==i)?1'b1:1'b0}} & IN[(i+1)*C_DATAOUT_WIDTH-1:i*C_DATAOUT_WIDTH];
      end
    end else begin : gen_onehot
      assign carry[C_DATAOUT_WIDTH-1:0] = {C_DATAOUT_WIDTH{SEL_ONEHOT[0]}} & IN[C_DATAOUT_WIDTH-1:0];
      for (i=1;i<C_RATIO;i=i+1) begin : gen_carrychain_hot
        assign carry[(i+1)*C_DATAOUT_WIDTH-1:i*C_DATAOUT_WIDTH] = 
               carry[i*C_DATAOUT_WIDTH-1:(i-1)*C_DATAOUT_WIDTH] |
               {C_DATAOUT_WIDTH{SEL_ONEHOT[i]}} & IN[(i+1)*C_DATAOUT_WIDTH-1:i*C_DATAOUT_WIDTH];
      end
    end
  endgenerate
  assign OUT = carry[C_DATAOUT_WIDTH*C_RATIO-1:
                     C_DATAOUT_WIDTH*(C_RATIO-1)];
endmodule

`default_nettype wire


// -- (c) Copyright 2009 - 2011 Xilinx, Inc. All rights reserved.
// --
// -- This file contains confidential and proprietary information
// -- of Xilinx, Inc. and is protected under U.S. and 
// -- international copyright and other intellectual property
// -- laws.
// --
// -- DISCLAIMER
// -- This disclaimer is not a license and does not grant any
// -- rights to the materials distributed herewith. Except as
// -- otherwise provided in a valid license issued to you by
// -- Xilinx, and to the maximum extent permitted by applicable
// -- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
// -- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
// -- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
// -- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
// -- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
// -- (2) Xilinx shall not be liable (whether in contract or tort,
// -- including negligence, or under any other theory of
// -- liability) for any loss or damage of any kind or nature
// -- related to, arising under or in connection with these
// -- materials, including for any direct, or any indirect,
// -- special, incidental, or consequential loss or damage
// -- (including loss of data, profits, goodwill, or any type of
// -- loss or damage suffered as a result of any action brought
// -- by a third party) even if such damage or loss was
// -- reasonably foreseeable or Xilinx had been advised of the
// -- possibility of the same.
// --
// -- CRITICAL APPLICATIONS
// -- Xilinx products are not designed or intended to be fail-
// -- safe, or for use in any application requiring fail-safe
// -- performance, such as life-support or safety devices or
// -- systems, Class III medical devices, nuclear facilities,
// -- applications related to the deployment of airbags, or any
// -- other applications that could lead to death, personal
// -- injury, or severe property or environmental damage
// -- (individually and collectively, "Critical
// -- Applications"). Customer assumes the sole risk and
// -- liability of any use of Xilinx products in Critical
// -- Applications, subject only to applicable laws and
// -- regulations governing limitations on product liability.
// --
// -- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
// -- PART OF THIS FILE AT ALL TIMES.
//-----------------------------------------------------------------------------
//
// File name: protocol_conv_bank.v
//
// Description: 
//   This module is a bank of AXI4-Lite and AXI3 protocol converters for a vectored AXI interface.
//   The interface of this module consists of a vectored slave and master interface
//     which are each concatenations of upper-level AXI pathways,
//     plus various vectored parameters.
//   This module instantiates a set of individual protocol converter modules.
//
//--------------------------------------------------------------------------
//
// Structure:
//    protocol_conv_bank
//      axilite_conv
//      axi3_conv
//        a_axi3_conv
//          axic_fifo
//        w_axi3_conv
//        b_downsizer
//        r_axi3_conv
//      
//-----------------------------------------------------------------------------
`timescale 1ps/1ps
`default_nettype none

(* DowngradeIPIdentifiedWarnings="yes" *) 
module axi_interconnect_v1_7_13_protocol_conv_bank #
  (
   parameter         C_FAMILY                         = "none", 
   parameter integer C_NUM_SLOTS                = 1, 
   parameter integer C_AXI_ID_MAX_WIDTH                 = 1, 
                       // Width of ID signals propagated by the Interconnect.
                       // Stride of ID fields within each ID port.
                       // Range: >= 1.
   parameter integer C_AXI_ADDR_WIDTH                 = 32, 
   parameter integer C_IGNORE_RID                    = 0,
                       // 1 = RID/BID are stored within SASD crossbar.
                       // 0 = RID/BID must be stored by axilite_conv.
   parameter integer C_AXI_DATA_MAX_WIDTH           = 256, 
                       // Largest value supported for any DATA_WIDTH.
                       // Stride of data fields within each DATA port.
   parameter         C_AXI_DATA_WIDTH               = {16{32'h00000020}}, 
                       // Effective width of DATA signals for each MI slot.
                       // Format: C_NUM_SLOTS{Bit32}; 
                       // Range: 'h00000020, 'h00000040, 'h00000080, 'h00000100.
   parameter         C_AXI_PROTOCOL                 = {16{32'h00000000}}, 
                       // Indicates whether connected slave is
                       // Full-AXI4 ('h00000000),
                       // AXI3 ('h00000001) or 
                       // Axi4Lite ('h00000002), for each SI slot.
                       // Format: C_NUM_SLOTS{Bit32}.
   parameter         C_AXI_SUPPORTS_WRITE           = 16'b11111111_11111111, 
                       // Format: C_NUM_SLOTS{Bit1}.
   parameter         C_AXI_SUPPORTS_READ            = 16'b11111111_11111111, 
                       // Format: C_NUM_SLOTS{Bit1}.
   parameter integer C_AXI_SUPPORTS_USER_SIGNALS      = 0,
                       // 1 = Propagate all USER signals, 0 = Dont propagate.
   parameter integer C_AXI_AWUSER_WIDTH               = 1,
   parameter integer C_AXI_ARUSER_WIDTH               = 1,
   parameter integer C_AXI_WUSER_WIDTH                = 1,
   parameter integer C_AXI_RUSER_WIDTH                = 1,
   parameter integer C_AXI_BUSER_WIDTH                = 1,
   parameter integer C_AXI3_BYPASS                    = 0
   )
  (
   // Global Signals
   input  wire [C_NUM_SLOTS-1:0]                            ACLK,
   input  wire [C_NUM_SLOTS-1:0]                            ARESETN,
   // Slave Interface Write Address Ports
   input  wire [C_NUM_SLOTS*C_AXI_ID_MAX_WIDTH-1:0]           S_AXI_AWID,
   input  wire [C_NUM_SLOTS*C_AXI_ADDR_WIDTH-1:0]           S_AXI_AWADDR,
   input  wire [C_NUM_SLOTS*8-1:0]                          S_AXI_AWLEN,
   input  wire [C_NUM_SLOTS*3-1:0]                          S_AXI_AWSIZE,
   input  wire [C_NUM_SLOTS*2-1:0]                          S_AXI_AWBURST,
   input  wire [C_NUM_SLOTS*2-1:0]                          S_AXI_AWLOCK,
   input  wire [C_NUM_SLOTS*4-1:0]                          S_AXI_AWCACHE,
   input  wire [C_NUM_SLOTS*3-1:0]                          S_AXI_AWPROT,
   input  wire [C_NUM_SLOTS*4-1:0]                          S_AXI_AWREGION,
   input  wire [C_NUM_SLOTS*4-1:0]                          S_AXI_AWQOS,
   input  wire [C_NUM_SLOTS*C_AXI_AWUSER_WIDTH-1:0]         S_AXI_AWUSER,
   input  wire [C_NUM_SLOTS-1:0]                            S_AXI_AWVALID,
   output wire [C_NUM_SLOTS-1:0]                            S_AXI_AWREADY,
   // Slave Interface Write Data Ports
   input  wire [C_AXI_ID_MAX_WIDTH-1:0]                     S_AXI_WID,  // Ignored if crossbar is larger than 1x1
   input  wire [C_NUM_SLOTS*C_AXI_DATA_MAX_WIDTH-1:0]       S_AXI_WDATA,
   input  wire [C_NUM_SLOTS*C_AXI_DATA_MAX_WIDTH/8-1:0]     S_AXI_WSTRB,
   input  wire [C_NUM_SLOTS-1:0]                            S_AXI_WLAST,
   input  wire [C_NUM_SLOTS*C_AXI_WUSER_WIDTH-1:0]          S_AXI_WUSER,
   input  wire [C_NUM_SLOTS-1:0]                            S_AXI_WVALID,
   output wire [C_NUM_SLOTS-1:0]                            S_AXI_WREADY,
   // Slave Interface Write Response Ports
   output wire [C_NUM_SLOTS*C_AXI_ID_MAX_WIDTH-1:0]           S_AXI_BID,
   output wire [C_NUM_SLOTS*2-1:0]                          S_AXI_BRESP,
   output wire [C_NUM_SLOTS*C_AXI_BUSER_WIDTH-1:0]          S_AXI_BUSER,
   output wire [C_NUM_SLOTS-1:0]                            S_AXI_BVALID,
   input  wire [C_NUM_SLOTS-1:0]                            S_AXI_BREADY,
   // Slave Interface Read Address Ports
   input  wire [C_NUM_SLOTS*C_AXI_ID_MAX_WIDTH-1:0]           S_AXI_ARID,
   input  wire [C_NUM_SLOTS*C_AXI_ADDR_WIDTH-1:0]           S_AXI_ARADDR,
   input  wire [C_NUM_SLOTS*8-1:0]                          S_AXI_ARLEN,
   input  wire [C_NUM_SLOTS*3-1:0]                          S_AXI_ARSIZE,
   input  wire [C_NUM_SLOTS*2-1:0]                          S_AXI_ARBURST,
   input  wire [C_NUM_SLOTS*2-1:0]                          S_AXI_ARLOCK,
   input  wire [C_NUM_SLOTS*4-1:0]                          S_AXI_ARCACHE,
   input  wire [C_NUM_SLOTS*3-1:0]                          S_AXI_ARPROT,
   input  wire [C_NUM_SLOTS*4-1:0]                          S_AXI_ARREGION,
   input  wire [C_NUM_SLOTS*4-1:0]                          S_AXI_ARQOS,
   input  wire [C_NUM_SLOTS*C_AXI_ARUSER_WIDTH-1:0]         S_AXI_ARUSER,
   input  wire [C_NUM_SLOTS-1:0]                            S_AXI_ARVALID,
   output wire [C_NUM_SLOTS-1:0]                            S_AXI_ARREADY,
   // Slave Interface Read Data Ports
   output wire [C_NUM_SLOTS*C_AXI_ID_MAX_WIDTH-1:0]           S_AXI_RID,
   output wire [C_NUM_SLOTS*C_AXI_DATA_MAX_WIDTH-1:0]     S_AXI_RDATA,
   output wire [C_NUM_SLOTS*2-1:0]                          S_AXI_RRESP,
   output wire [C_NUM_SLOTS-1:0]                            S_AXI_RLAST,
   output wire [C_NUM_SLOTS*C_AXI_RUSER_WIDTH-1:0]          S_AXI_RUSER,
   output wire [C_NUM_SLOTS-1:0]                            S_AXI_RVALID,
   input  wire [C_NUM_SLOTS-1:0]                            S_AXI_RREADY,
   // Master Interface Write Address Port
   output wire [C_NUM_SLOTS*C_AXI_ID_MAX_WIDTH-1:0]          M_AXI_AWID,
   output wire [C_NUM_SLOTS*C_AXI_ADDR_WIDTH-1:0]          M_AXI_AWADDR,
   output wire [C_NUM_SLOTS*8-1:0]                         M_AXI_AWLEN,
   output wire [C_NUM_SLOTS*3-1:0]                         M_AXI_AWSIZE,
   output wire [C_NUM_SLOTS*2-1:0]                         M_AXI_AWBURST,
   output wire [C_NUM_SLOTS*2-1:0]                         M_AXI_AWLOCK,
   output wire [C_NUM_SLOTS*4-1:0]                         M_AXI_AWCACHE,
   output wire [C_NUM_SLOTS*3-1:0]                         M_AXI_AWPROT,
   output wire [C_NUM_SLOTS*4-1:0]                         M_AXI_AWREGION,
   output wire [C_NUM_SLOTS*4-1:0]                         M_AXI_AWQOS,
   output wire [C_NUM_SLOTS*C_AXI_AWUSER_WIDTH-1:0]        M_AXI_AWUSER,
   output wire [C_NUM_SLOTS-1:0]                           M_AXI_AWVALID,
   input  wire [C_NUM_SLOTS-1:0]                           M_AXI_AWREADY,
   // Master Interface Write Data Ports
   output wire [C_NUM_SLOTS*C_AXI_ID_MAX_WIDTH-1:0]          M_AXI_WID,
   output wire [C_NUM_SLOTS*C_AXI_DATA_MAX_WIDTH-1:0]    M_AXI_WDATA,
   output wire [C_NUM_SLOTS*C_AXI_DATA_MAX_WIDTH/8-1:0]  M_AXI_WSTRB,
   output wire [C_NUM_SLOTS-1:0]                           M_AXI_WLAST,
   output wire [C_NUM_SLOTS*C_AXI_WUSER_WIDTH-1:0]         M_AXI_WUSER,
   output wire [C_NUM_SLOTS-1:0]                           M_AXI_WVALID,
   input  wire [C_NUM_SLOTS-1:0]                           M_AXI_WREADY,
   // Master Interface Write Response Ports
   input  wire [C_NUM_SLOTS*C_AXI_ID_MAX_WIDTH-1:0]          M_AXI_BID,
   input  wire [C_NUM_SLOTS*2-1:0]                         M_AXI_BRESP,
   input  wire [C_NUM_SLOTS*C_AXI_BUSER_WIDTH-1:0]         M_AXI_BUSER,
   input  wire [C_NUM_SLOTS-1:0]                           M_AXI_BVALID,
   output wire [C_NUM_SLOTS-1:0]                           M_AXI_BREADY,
   // Master Interface Read Address Port
   output wire [C_NUM_SLOTS*C_AXI_ID_MAX_WIDTH-1:0]          M_AXI_ARID,
   output wire [C_NUM_SLOTS*C_AXI_ADDR_WIDTH-1:0]          M_AXI_ARADDR,
   output wire [C_NUM_SLOTS*8-1:0]                         M_AXI_ARLEN,
   output wire [C_NUM_SLOTS*3-1:0]                         M_AXI_ARSIZE,
   output wire [C_NUM_SLOTS*2-1:0]                         M_AXI_ARBURST,
   output wire [C_NUM_SLOTS*2-1:0]                         M_AXI_ARLOCK,
   output wire [C_NUM_SLOTS*4-1:0]                         M_AXI_ARCACHE,
   output wire [C_NUM_SLOTS*3-1:0]                         M_AXI_ARPROT,
   output wire [C_NUM_SLOTS*4-1:0]                         M_AXI_ARREGION,
   output wire [C_NUM_SLOTS*4-1:0]                         M_AXI_ARQOS,
   output wire [C_NUM_SLOTS*C_AXI_ARUSER_WIDTH-1:0]        M_AXI_ARUSER,
   output wire [C_NUM_SLOTS-1:0]                           M_AXI_ARVALID,
   input  wire [C_NUM_SLOTS-1:0]                           M_AXI_ARREADY,
   // Master Interface Read Data Ports
   input  wire [C_NUM_SLOTS*C_AXI_ID_MAX_WIDTH-1:0]          M_AXI_RID,
   input  wire [C_NUM_SLOTS*C_AXI_DATA_MAX_WIDTH-1:0]    M_AXI_RDATA,
   input  wire [C_NUM_SLOTS*2-1:0]                         M_AXI_RRESP,
   input  wire [C_NUM_SLOTS-1:0]                           M_AXI_RLAST,
   input  wire [C_NUM_SLOTS*C_AXI_RUSER_WIDTH-1:0]         M_AXI_RUSER,
   input  wire [C_NUM_SLOTS-1:0]                           M_AXI_RVALID,
   output wire [C_NUM_SLOTS-1:0]                           M_AXI_RREADY
   );

  localparam P_AXI3 = 32'h1;
  localparam P_AXILITE = 32'h2;

  wire [C_NUM_SLOTS*C_AXI_DATA_MAX_WIDTH-1:0]     s_rdata           ;
  wire [C_NUM_SLOTS*C_AXI_DATA_MAX_WIDTH-1:0]     m_wdata           ;
  wire [C_NUM_SLOTS*C_AXI_DATA_MAX_WIDTH/8-1:0]   m_wstrb           ;
  
genvar slot;
  
generate
  for (slot=0;slot<C_NUM_SLOTS;slot=slot+1) begin : gen_protocol_slot
    if ((C_AXI_PROTOCOL[slot*32+:32] == P_AXILITE) || (C_AXI_PROTOCOL[slot*32+:32] == P_AXI3)) begin : gen_prot_conv
  axi_interconnect_v1_7_13_axi_protocol_converter #(
        .C_FAMILY                         (C_FAMILY),
        .C_AXI_PROTOCOL                   (C_AXI_PROTOCOL[slot*32+:32]),
        .C_AXI_ID_WIDTH                   (C_AXI_ID_MAX_WIDTH),
        .C_AXI_ADDR_WIDTH                 (C_AXI_ADDR_WIDTH),
        .C_AXI_DATA_WIDTH                 (C_AXI_DATA_WIDTH[slot*32+:32]),
        .C_AXI_SUPPORTS_WRITE             (C_AXI_SUPPORTS_WRITE[slot]),
        .C_AXI_SUPPORTS_READ              (C_AXI_SUPPORTS_READ[slot]),
        .C_AXI_SUPPORTS_USER_SIGNALS      (C_AXI_SUPPORTS_USER_SIGNALS),
        .C_AXI_AWUSER_WIDTH               (C_AXI_AWUSER_WIDTH),
        .C_AXI_ARUSER_WIDTH               (C_AXI_ARUSER_WIDTH),
        .C_AXI_WUSER_WIDTH                (C_AXI_WUSER_WIDTH),
        .C_AXI_RUSER_WIDTH                (C_AXI_RUSER_WIDTH),
        .C_AXI_BUSER_WIDTH                (C_AXI_BUSER_WIDTH),
        .C_AXI3_BYPASS                    (C_AXI3_BYPASS)
      ) conv_inst (
        .ARESETN                          (ARESETN[slot]),
        .ACLK                             (ACLK[slot]),
        .S_AXI_AWID                       (S_AXI_AWID[slot*C_AXI_ID_MAX_WIDTH+:C_AXI_ID_MAX_WIDTH]),
        .S_AXI_AWADDR                     (S_AXI_AWADDR[slot*C_AXI_ADDR_WIDTH+:C_AXI_ADDR_WIDTH]),
        .S_AXI_AWLEN                      (S_AXI_AWLEN[slot*8+:8]),
        .S_AXI_AWSIZE                     (S_AXI_AWSIZE[slot*3+:3]),
        .S_AXI_AWBURST                    (S_AXI_AWBURST[slot*2+:2]),
        .S_AXI_AWLOCK                     (S_AXI_AWLOCK[slot*2+:2]),
        .S_AXI_AWCACHE                    (S_AXI_AWCACHE[slot*4+:4]),
        .S_AXI_AWPROT                     (S_AXI_AWPROT[slot*3+:3]),
        .S_AXI_AWREGION                   (S_AXI_AWREGION[slot*4+:4]),
        .S_AXI_AWQOS                      (S_AXI_AWQOS[slot*4+:4]),
        .S_AXI_AWUSER                     (S_AXI_AWUSER[slot*C_AXI_AWUSER_WIDTH+:C_AXI_AWUSER_WIDTH]),
        .S_AXI_AWVALID                    (S_AXI_AWVALID[slot*1+:1]),
        .S_AXI_AWREADY                    (S_AXI_AWREADY[slot*1+:1]),
        .S_AXI_WID                        (S_AXI_WID),
        .S_AXI_WDATA                      (S_AXI_WDATA[slot*C_AXI_DATA_MAX_WIDTH+:C_AXI_DATA_WIDTH[slot*32+:32]]),
        .S_AXI_WSTRB                      (S_AXI_WSTRB[slot*C_AXI_DATA_MAX_WIDTH/8+:C_AXI_DATA_WIDTH[slot*32+:32]/8]),
        .S_AXI_WLAST                      (S_AXI_WLAST[slot*1+:1]),
        .S_AXI_WUSER                      (S_AXI_WUSER[slot*C_AXI_WUSER_WIDTH+:C_AXI_WUSER_WIDTH]),
        .S_AXI_WVALID                     (S_AXI_WVALID[slot*1+:1]),
        .S_AXI_WREADY                     (S_AXI_WREADY[slot*1+:1]),
        .S_AXI_BID                        (S_AXI_BID[slot*C_AXI_ID_MAX_WIDTH+:C_AXI_ID_MAX_WIDTH]),
        .S_AXI_BRESP                      (S_AXI_BRESP[slot*2+:2]),
        .S_AXI_BUSER                      (S_AXI_BUSER[slot*C_AXI_BUSER_WIDTH+:C_AXI_BUSER_WIDTH]),
        .S_AXI_BVALID                     (S_AXI_BVALID[slot*1+:1]),
        .S_AXI_BREADY                     (S_AXI_BREADY[slot*1+:1]),
        .S_AXI_ARID                       (S_AXI_ARID[slot*C_AXI_ID_MAX_WIDTH+:C_AXI_ID_MAX_WIDTH]),
        .S_AXI_ARADDR                     (S_AXI_ARADDR[slot*C_AXI_ADDR_WIDTH+:C_AXI_ADDR_WIDTH]),
        .S_AXI_ARLEN                      (S_AXI_ARLEN[slot*8+:8]),
        .S_AXI_ARSIZE                     (S_AXI_ARSIZE[slot*3+:3]),
        .S_AXI_ARBURST                    (S_AXI_ARBURST[slot*2+:2]),
        .S_AXI_ARLOCK                     (S_AXI_ARLOCK[slot*2+:2]),
        .S_AXI_ARCACHE                    (S_AXI_ARCACHE[slot*4+:4]),
        .S_AXI_ARPROT                     (S_AXI_ARPROT[slot*3+:3]),
        .S_AXI_ARREGION                   (S_AXI_ARREGION[slot*4+:4]),
        .S_AXI_ARQOS                      (S_AXI_ARQOS[slot*4+:4]),
        .S_AXI_ARUSER                     (S_AXI_ARUSER[slot*C_AXI_ARUSER_WIDTH+:C_AXI_ARUSER_WIDTH]),
        .S_AXI_ARVALID                    (S_AXI_ARVALID[slot*1+:1]),
        .S_AXI_ARREADY                    (S_AXI_ARREADY[slot*1+:1]),
        .S_AXI_RID                        (S_AXI_RID[slot*C_AXI_ID_MAX_WIDTH+:C_AXI_ID_MAX_WIDTH]),
        .S_AXI_RDATA                      (s_rdata[slot*C_AXI_DATA_MAX_WIDTH+:C_AXI_DATA_WIDTH[slot*32+:32]]),
        .S_AXI_RRESP                      (S_AXI_RRESP[slot*2+:2]),
        .S_AXI_RLAST                      (S_AXI_RLAST[slot*1+:1]),
        .S_AXI_RUSER                      (S_AXI_RUSER[slot*C_AXI_RUSER_WIDTH+:C_AXI_RUSER_WIDTH]),
        .S_AXI_RVALID                     (S_AXI_RVALID[slot*1+:1]),
        .S_AXI_RREADY                     (S_AXI_RREADY[slot*1+:1]),
        .M_AXI_AWID                       (M_AXI_AWID[slot*C_AXI_ID_MAX_WIDTH+:C_AXI_ID_MAX_WIDTH]),
        .M_AXI_AWADDR                     (M_AXI_AWADDR[slot*C_AXI_ADDR_WIDTH+:C_AXI_ADDR_WIDTH]),
        .M_AXI_AWLEN                      (M_AXI_AWLEN[slot*8+:8]),
        .M_AXI_AWSIZE                     (M_AXI_AWSIZE[slot*3+:3]),
        .M_AXI_AWBURST                    (M_AXI_AWBURST[slot*2+:2]),
        .M_AXI_AWLOCK                     (M_AXI_AWLOCK[slot*2+:2]),
        .M_AXI_AWCACHE                    (M_AXI_AWCACHE[slot*4+:4]),
        .M_AXI_AWPROT                     (M_AXI_AWPROT[slot*3+:3]),
        .M_AXI_AWREGION                   (M_AXI_AWREGION[slot*4+:4]),
        .M_AXI_AWQOS                      (M_AXI_AWQOS[slot*4+:4]),
        .M_AXI_AWUSER                     (M_AXI_AWUSER[slot*C_AXI_AWUSER_WIDTH+:C_AXI_AWUSER_WIDTH]),
        .M_AXI_AWVALID                    (M_AXI_AWVALID[slot*1+:1]),
        .M_AXI_AWREADY                    (M_AXI_AWREADY[slot*1+:1]),
        .M_AXI_WID                        (M_AXI_WID[slot*C_AXI_ID_MAX_WIDTH+:C_AXI_ID_MAX_WIDTH]),
        .M_AXI_WDATA                      (m_wdata[slot*C_AXI_DATA_MAX_WIDTH+:C_AXI_DATA_WIDTH[slot*32+:32]]),
        .M_AXI_WSTRB                      (m_wstrb[slot*C_AXI_DATA_MAX_WIDTH/8+:C_AXI_DATA_WIDTH[slot*32+:32]/8]),
        .M_AXI_WLAST                      (M_AXI_WLAST[slot*1+:1]),
        .M_AXI_WUSER                      (M_AXI_WUSER[slot*C_AXI_WUSER_WIDTH+:C_AXI_WUSER_WIDTH]),
        .M_AXI_WVALID                     (M_AXI_WVALID[slot*1+:1]),
        .M_AXI_WREADY                     (M_AXI_WREADY[slot*1+:1]),
        .M_AXI_BID                        (M_AXI_BID[slot*C_AXI_ID_MAX_WIDTH+:C_AXI_ID_MAX_WIDTH]),
        .M_AXI_BRESP                      (M_AXI_BRESP[slot*2+:2]),
        .M_AXI_BUSER                      (M_AXI_BUSER[slot*C_AXI_BUSER_WIDTH+:C_AXI_BUSER_WIDTH]),
        .M_AXI_BVALID                     (M_AXI_BVALID[slot*1+:1]),
        .M_AXI_BREADY                     (M_AXI_BREADY[slot*1+:1]),
        .M_AXI_ARID                       (M_AXI_ARID[slot*C_AXI_ID_MAX_WIDTH+:C_AXI_ID_MAX_WIDTH]),
        .M_AXI_ARADDR                     (M_AXI_ARADDR[slot*C_AXI_ADDR_WIDTH+:C_AXI_ADDR_WIDTH]),
        .M_AXI_ARLEN                      (M_AXI_ARLEN[slot*8+:8]),
        .M_AXI_ARSIZE                     (M_AXI_ARSIZE[slot*3+:3]),
        .M_AXI_ARBURST                    (M_AXI_ARBURST[slot*2+:2]),
        .M_AXI_ARLOCK                     (M_AXI_ARLOCK[slot*2+:2]),
        .M_AXI_ARCACHE                    (M_AXI_ARCACHE[slot*4+:4]),
        .M_AXI_ARPROT                     (M_AXI_ARPROT[slot*3+:3]),
        .M_AXI_ARREGION                   (M_AXI_ARREGION[slot*4+:4]),
        .M_AXI_ARQOS                      (M_AXI_ARQOS[slot*4+:4]),
        .M_AXI_ARUSER                     (M_AXI_ARUSER[slot*C_AXI_ARUSER_WIDTH+:C_AXI_ARUSER_WIDTH]),
        .M_AXI_ARVALID                    (M_AXI_ARVALID[slot*1+:1]),
        .M_AXI_ARREADY                    (M_AXI_ARREADY[slot*1+:1]),
        .M_AXI_RID                        (M_AXI_RID[slot*C_AXI_ID_MAX_WIDTH+:C_AXI_ID_MAX_WIDTH]),
        .M_AXI_RDATA                      (M_AXI_RDATA[slot*C_AXI_DATA_MAX_WIDTH+:C_AXI_DATA_WIDTH[slot*32+:32]]),
        .M_AXI_RRESP                      (M_AXI_RRESP[slot*2+:2]),
        .M_AXI_RLAST                      (M_AXI_RLAST[slot*1+:1]),
        .M_AXI_RUSER                      (M_AXI_RUSER[slot*C_AXI_RUSER_WIDTH+:C_AXI_RUSER_WIDTH]),
        .M_AXI_RVALID                     (M_AXI_RVALID[slot*1+:1]),
        .M_AXI_RREADY                     (M_AXI_RREADY[slot*1+:1])
      );
      assign S_AXI_RDATA[slot*C_AXI_DATA_MAX_WIDTH+:C_AXI_DATA_MAX_WIDTH] = s_rdata[slot*C_AXI_DATA_MAX_WIDTH+:C_AXI_DATA_WIDTH[slot*32+:32]] ;
      assign M_AXI_WDATA[slot*C_AXI_DATA_MAX_WIDTH+:C_AXI_DATA_MAX_WIDTH] = m_wdata[slot*C_AXI_DATA_MAX_WIDTH+:C_AXI_DATA_WIDTH[slot*32+:32]] ;
      assign M_AXI_WSTRB[slot*C_AXI_DATA_MAX_WIDTH/8+:C_AXI_DATA_MAX_WIDTH/8] = m_wstrb[slot*C_AXI_DATA_MAX_WIDTH/8+:C_AXI_DATA_WIDTH[slot*32+:32]/8] ;
    end else begin :gen_no_conv
      assign M_AXI_AWID[slot*C_AXI_ID_MAX_WIDTH+:C_AXI_ID_MAX_WIDTH]                   = S_AXI_AWID[slot*C_AXI_ID_MAX_WIDTH+:C_AXI_ID_MAX_WIDTH]                   ;
      assign M_AXI_AWADDR[slot*C_AXI_ADDR_WIDTH+:C_AXI_ADDR_WIDTH]                     = S_AXI_AWADDR[slot*C_AXI_ADDR_WIDTH+:C_AXI_ADDR_WIDTH]                     ;
      assign M_AXI_AWLEN[slot*8+:8]                                                    = S_AXI_AWLEN[slot*8+:8]                                                    ;
      assign M_AXI_AWSIZE[slot*3+:3]                                                   = S_AXI_AWSIZE[slot*3+:3]                                                   ;
      assign M_AXI_AWBURST[slot*2+:2]                                                  = S_AXI_AWBURST[slot*2+:2]                                                  ;
      assign M_AXI_AWLOCK[slot*2+:2]                                                   = S_AXI_AWLOCK[slot*2+:2]                                                   ;
      assign M_AXI_AWCACHE[slot*4+:4]                                                  = S_AXI_AWCACHE[slot*4+:4]                                                  ;
      assign M_AXI_AWPROT[slot*3+:3]                                                   = S_AXI_AWPROT[slot*3+:3]                                                   ;
      assign M_AXI_AWREGION[slot*4+:4]                                                 = S_AXI_AWREGION[slot*4+:4]                                                 ;
      assign M_AXI_AWQOS[slot*4+:4]                                                    = S_AXI_AWQOS[slot*4+:4]                                                    ;
      assign M_AXI_AWUSER[slot*C_AXI_AWUSER_WIDTH+:C_AXI_AWUSER_WIDTH]                 = S_AXI_AWUSER[slot*C_AXI_AWUSER_WIDTH+:C_AXI_AWUSER_WIDTH]                 ;
      assign M_AXI_AWVALID[slot*1+:1]                                                  = S_AXI_AWVALID[slot*1+:1]                                                  ;
      assign S_AXI_AWREADY[slot*1+:1]                                                  = M_AXI_AWREADY[slot*1+:1]                                                  ;
      assign M_AXI_WID[slot*C_AXI_ID_MAX_WIDTH+:C_AXI_ID_MAX_WIDTH]                    = {C_AXI_ID_MAX_WIDTH{1'b0}} ;
      assign M_AXI_WDATA[slot*C_AXI_DATA_MAX_WIDTH+:C_AXI_DATA_MAX_WIDTH]              = S_AXI_WDATA[slot*C_AXI_DATA_MAX_WIDTH+:C_AXI_DATA_WIDTH[slot*32+:32]]     ;
      assign M_AXI_WSTRB[slot*C_AXI_DATA_MAX_WIDTH/8+:C_AXI_DATA_MAX_WIDTH/8]          = S_AXI_WSTRB[slot*C_AXI_DATA_MAX_WIDTH/8+:C_AXI_DATA_WIDTH[slot*32+:32]/8] ;
      assign M_AXI_WLAST[slot*1+:1]                                                    = S_AXI_WLAST[slot*1+:1]                                                    ;
      assign M_AXI_WUSER[slot*C_AXI_WUSER_WIDTH+:C_AXI_WUSER_WIDTH]                    = S_AXI_WUSER[slot*C_AXI_WUSER_WIDTH+:C_AXI_WUSER_WIDTH]                    ;
      assign M_AXI_WVALID[slot*1+:1]                                                   = S_AXI_WVALID[slot*1+:1]                                                   ;
      assign S_AXI_WREADY[slot*1+:1]                                                   = M_AXI_WREADY[slot*1+:1]                                                   ;
      assign S_AXI_BID[slot*C_AXI_ID_MAX_WIDTH+:C_AXI_ID_MAX_WIDTH]                    = M_AXI_BID[slot*C_AXI_ID_MAX_WIDTH+:C_AXI_ID_MAX_WIDTH]                            ;
      assign S_AXI_BRESP[slot*2+:2]                                                    = M_AXI_BRESP[slot*2+:2]                                                    ;
      assign S_AXI_BUSER[slot*C_AXI_BUSER_WIDTH+:C_AXI_BUSER_WIDTH]                    = M_AXI_BUSER[slot*C_AXI_BUSER_WIDTH+:C_AXI_BUSER_WIDTH]                    ;
      assign S_AXI_BVALID[slot*1+:1]                                                   = M_AXI_BVALID[slot*1+:1]                                                   ;
      assign M_AXI_BREADY[slot*1+:1]                                                   = S_AXI_BREADY[slot*1+:1]                                                   ;
      assign M_AXI_ARID[slot*C_AXI_ID_MAX_WIDTH+:C_AXI_ID_MAX_WIDTH]                   = S_AXI_ARID[slot*C_AXI_ID_MAX_WIDTH+:C_AXI_ID_MAX_WIDTH]                           ;
      assign M_AXI_ARADDR[slot*C_AXI_ADDR_WIDTH+:C_AXI_ADDR_WIDTH]                     = S_AXI_ARADDR[slot*C_AXI_ADDR_WIDTH+:C_AXI_ADDR_WIDTH]                     ;
      assign M_AXI_ARLEN[slot*8+:8]                                                    = S_AXI_ARLEN[slot*8+:8]                                                    ;
      assign M_AXI_ARSIZE[slot*3+:3]                                                   = S_AXI_ARSIZE[slot*3+:3]                                                   ;
      assign M_AXI_ARBURST[slot*2+:2]                                                  = S_AXI_ARBURST[slot*2+:2]                                                  ;
      assign M_AXI_ARLOCK[slot*2+:2]                                                   = S_AXI_ARLOCK[slot*2+:2]                                                   ;
      assign M_AXI_ARCACHE[slot*4+:4]                                                  = S_AXI_ARCACHE[slot*4+:4]                                                  ;
      assign M_AXI_ARPROT[slot*3+:3]                                                   = S_AXI_ARPROT[slot*3+:3]                                                   ;
      assign M_AXI_ARREGION[slot*4+:4]                                                 = S_AXI_ARREGION[slot*4+:4]                                                 ;
      assign M_AXI_ARQOS[slot*4+:4]                                                    = S_AXI_ARQOS[slot*4+:4]                                                    ;
      assign M_AXI_ARUSER[slot*C_AXI_ARUSER_WIDTH+:C_AXI_ARUSER_WIDTH]                 = S_AXI_ARUSER[slot*C_AXI_ARUSER_WIDTH+:C_AXI_ARUSER_WIDTH]                 ;
      assign M_AXI_ARVALID[slot*1+:1]                                                  = S_AXI_ARVALID[slot*1+:1]                                                  ;
      assign S_AXI_ARREADY[slot*1+:1]                                                  = M_AXI_ARREADY[slot*1+:1]                                                  ;
      assign S_AXI_RID[slot*C_AXI_ID_MAX_WIDTH+:C_AXI_ID_MAX_WIDTH]                    = M_AXI_RID[slot*C_AXI_ID_MAX_WIDTH+:C_AXI_ID_MAX_WIDTH]                            ;
      assign S_AXI_RDATA[slot*C_AXI_DATA_MAX_WIDTH+:C_AXI_DATA_MAX_WIDTH]              = M_AXI_RDATA[slot*C_AXI_DATA_MAX_WIDTH+:C_AXI_DATA_WIDTH[slot*32+:32]]     ;
      assign S_AXI_RRESP[slot*2+:2]                                                    = M_AXI_RRESP[slot*2+:2]                                                    ;
      assign S_AXI_RLAST[slot*1+:1]                                                    = M_AXI_RLAST[slot*1+:1]                                                    ;
      assign S_AXI_RUSER[slot*C_AXI_RUSER_WIDTH+:C_AXI_RUSER_WIDTH]                    = M_AXI_RUSER[slot*C_AXI_RUSER_WIDTH+:C_AXI_RUSER_WIDTH]                    ;
      assign S_AXI_RVALID[slot*1+:1]                                                   = M_AXI_RVALID[slot*1+:1]                                                   ;
      assign M_AXI_RREADY[slot*1+:1]                                                   = S_AXI_RREADY[slot*1+:1]                                                   ;
    end
  end
endgenerate

endmodule

`default_nettype wire


// -- (c) Copyright 2010 - 2011 Xilinx, Inc. All rights reserved.
// --
// -- This file contains confidential and proprietary information
// -- of Xilinx, Inc. and is protected under U.S. and 
// -- international copyright and other intellectual property
// -- laws.
// --
// -- DISCLAIMER
// -- This disclaimer is not a license and does not grant any
// -- rights to the materials distributed herewith. Except as
// -- otherwise provided in a valid license issued to you by
// -- Xilinx, and to the maximum extent permitted by applicable
// -- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
// -- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
// -- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
// -- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
// -- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
// -- (2) Xilinx shall not be liable (whether in contract or tort,
// -- including negligence, or under any other theory of
// -- liability) for any loss or damage of any kind or nature
// -- related to, arising under or in connection with these
// -- materials, including for any direct, or any indirect,
// -- special, incidental, or consequential loss or damage
// -- (including loss of data, profits, goodwill, or any type of
// -- loss or damage suffered as a result of any action brought
// -- by a third party) even if such damage or loss was
// -- reasonably foreseeable or Xilinx had been advised of the
// -- possibility of the same.
// --
// -- CRITICAL APPLICATIONS
// -- Xilinx products are not designed or intended to be fail-
// -- safe, or for use in any application requiring fail-safe
// -- performance, such as life-support or safety devices or
// -- systems, Class III medical devices, nuclear facilities,
// -- applications related to the deployment of airbags, or any
// -- other applications that could lead to death, personal
// -- injury, or severe property or environmental damage
// -- (individually and collectively, "Critical
// -- Applications"). Customer assumes the sole risk and
// -- liability of any use of Xilinx products in Critical
// -- Applications, subject only to applicable laws and
// -- regulations governing limitations on product liability.
// --
// -- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
// -- PART OF THIS FILE AT ALL TIMES.
//-----------------------------------------------------------------------------
//
// Description: Read Data Response AXI3 Slave Converter
// Forwards and re-assembles split transactions.
//
// Verilog-standard:  Verilog 2001
//--------------------------------------------------------------------------
//
// Structure:
//   r_axi3_conv
//
//--------------------------------------------------------------------------
`timescale 1ps/1ps

(* DowngradeIPIdentifiedWarnings="yes" *) 
module axi_interconnect_v1_7_13_r_axi3_conv #
  (
   parameter C_FAMILY                            = "none",
   parameter integer C_AXI_ID_WIDTH              = 1,
   parameter integer C_AXI_ADDR_WIDTH            = 32,
   parameter integer C_AXI_DATA_WIDTH            = 32,
   parameter integer C_AXI_SUPPORTS_USER_SIGNALS = 0,
   parameter integer C_AXI_RUSER_WIDTH           = 1,
   parameter integer C_SUPPORT_SPLITTING              = 1,
                       // Implement transaction splitting logic.
                       // Disabled whan all connected masters are AXI3 and have same or narrower data width.
   parameter integer C_SUPPORT_BURSTS                 = 1
                       // Disabled when all connected masters are AxiLite,
                       //   allowing logic to be simplified.
   )
  (
   // System Signals
   input wire ACLK,
   input wire ARESET,

   // Command Interface
   input  wire                              cmd_valid,
   input  wire                              cmd_split,
   output wire                              cmd_ready,
   
   // Slave Interface Read Data Ports
   output wire [C_AXI_ID_WIDTH-1:0]    S_AXI_RID,
   output wire [C_AXI_DATA_WIDTH-1:0]  S_AXI_RDATA,
   output wire [2-1:0]                 S_AXI_RRESP,
   output wire                         S_AXI_RLAST,
   output wire [C_AXI_RUSER_WIDTH-1:0] S_AXI_RUSER,
   output wire                         S_AXI_RVALID,
   input  wire                         S_AXI_RREADY,
   
   // Master Interface Read Data Ports
   input  wire [C_AXI_ID_WIDTH-1:0]    M_AXI_RID,
   input  wire [C_AXI_DATA_WIDTH-1:0]  M_AXI_RDATA,
   input  wire [2-1:0]                 M_AXI_RRESP,
   input  wire                         M_AXI_RLAST,
   input  wire [C_AXI_RUSER_WIDTH-1:0] M_AXI_RUSER,
   input  wire                         M_AXI_RVALID,
   output wire                         M_AXI_RREADY
   );

   
  /////////////////////////////////////////////////////////////////////////////
  // Variables for generating parameter controlled instances.
  /////////////////////////////////////////////////////////////////////////////
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Local params
  /////////////////////////////////////////////////////////////////////////////
  
  // Constants for packing levels.
  localparam [2-1:0] C_RESP_OKAY        = 2'b00;
  localparam [2-1:0] C_RESP_EXOKAY      = 2'b01;
  localparam [2-1:0] C_RESP_SLVERROR    = 2'b10;
  localparam [2-1:0] C_RESP_DECERR      = 2'b11;
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Functions
  /////////////////////////////////////////////////////////////////////////////
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Internal signals
  /////////////////////////////////////////////////////////////////////////////
  
  // Throttling help signals.
  wire                            cmd_ready_i;
  wire                            pop_si_data;
  wire                            si_stalling;
  
  // Internal MI-side control signals.
  wire                            M_AXI_RREADY_I;
   
  // Internal signals for SI-side.
  wire [C_AXI_ID_WIDTH-1:0]       S_AXI_RID_I;
  wire [C_AXI_DATA_WIDTH-1:0]     S_AXI_RDATA_I;
  wire [2-1:0]                    S_AXI_RRESP_I;
  wire                            S_AXI_RLAST_I;
  wire [C_AXI_RUSER_WIDTH-1:0]    S_AXI_RUSER_I;
  wire                            S_AXI_RVALID_I;
  wire                            S_AXI_RREADY_I;
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Handle interface handshaking:
  //
  // Forward data from MI-Side to SI-Side while a command is available. When
  // the transaction has completed the command is popped from the Command FIFO.
  // 
  // 
  /////////////////////////////////////////////////////////////////////////////
  
  // Pop word from SI-side.
  assign M_AXI_RREADY_I = ~si_stalling & cmd_valid;
  assign M_AXI_RREADY   = M_AXI_RREADY_I;
  
  // Indicate when there is data available @ SI-side.
  assign S_AXI_RVALID_I = M_AXI_RVALID & cmd_valid;
  
  // Get SI-side data.
  assign pop_si_data    = S_AXI_RVALID_I & S_AXI_RREADY_I;
  
  // Signal that the command is done (so that it can be poped from command queue).
  assign cmd_ready_i    = cmd_valid & pop_si_data & M_AXI_RLAST;
  assign cmd_ready      = cmd_ready_i;
  
  // Detect when MI-side is stalling.
  assign si_stalling    = S_AXI_RVALID_I & ~S_AXI_RREADY_I;
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Simple AXI signal forwarding:
  // 
  // USER, ID, DATA and RRESP passes through untouched.
  // 
  // LAST has to be filtered to remove any intermediate LAST (due to split 
  // trasactions). LAST is only removed for the first parts of a split 
  // transaction. When splitting is unsupported is the LAST filtering completely
  // completely removed.
  // 
  /////////////////////////////////////////////////////////////////////////////
  
  // Calculate last, i.e. mask from split transactions.
  assign S_AXI_RLAST_I  = M_AXI_RLAST & 
                          ( ~cmd_split | ( C_SUPPORT_SPLITTING == 0 ) );
  
  // Data is passed through.
  assign S_AXI_RID_I    = M_AXI_RID;
  assign S_AXI_RUSER_I  = M_AXI_RUSER;
  assign S_AXI_RDATA_I  = M_AXI_RDATA;
  assign S_AXI_RRESP_I  = M_AXI_RRESP;
      
  
  /////////////////////////////////////////////////////////////////////////////
  // SI-side output handling
  // 
  /////////////////////////////////////////////////////////////////////////////
// TODO: registered?  
  assign S_AXI_RREADY_I = S_AXI_RREADY;
  assign S_AXI_RVALID   = S_AXI_RVALID_I;
  assign S_AXI_RID      = S_AXI_RID_I;
  assign S_AXI_RDATA    = S_AXI_RDATA_I;
  assign S_AXI_RRESP    = S_AXI_RRESP_I;
  assign S_AXI_RLAST    = S_AXI_RLAST_I;
  assign S_AXI_RUSER    = S_AXI_RUSER_I;
  
  
endmodule



// -- (c) Copyright 2010 - 2011 Xilinx, Inc. All rights reserved.
// --
// -- This file contains confidential and proprietary information
// -- of Xilinx, Inc. and is protected under U.S. and 
// -- international copyright and other intellectual property
// -- laws.
// --
// -- DISCLAIMER
// -- This disclaimer is not a license and does not grant any
// -- rights to the materials distributed herewith. Except as
// -- otherwise provided in a valid license issued to you by
// -- Xilinx, and to the maximum extent permitted by applicable
// -- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
// -- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
// -- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
// -- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
// -- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
// -- (2) Xilinx shall not be liable (whether in contract or tort,
// -- including negligence, or under any other theory of
// -- liability) for any loss or damage of any kind or nature
// -- related to, arising under or in connection with these
// -- materials, including for any direct, or any indirect,
// -- special, incidental, or consequential loss or damage
// -- (including loss of data, profits, goodwill, or any type of
// -- loss or damage suffered as a result of any action brought
// -- by a third party) even if such damage or loss was
// -- reasonably foreseeable or Xilinx had been advised of the
// -- possibility of the same.
// --
// -- CRITICAL APPLICATIONS
// -- Xilinx products are not designed or intended to be fail-
// -- safe, or for use in any application requiring fail-safe
// -- performance, such as life-support or safety devices or
// -- systems, Class III medical devices, nuclear facilities,
// -- applications related to the deployment of airbags, or any
// -- other applications that could lead to death, personal
// -- injury, or severe property or environmental damage
// -- (individually and collectively, "Critical
// -- Applications"). Customer assumes the sole risk and
// -- liability of any use of Xilinx products in Critical
// -- Applications, subject only to applicable laws and
// -- regulations governing limitations on product liability.
// --
// -- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
// -- PART OF THIS FILE AT ALL TIMES.
//-----------------------------------------------------------------------------
//
// Description: Read Data Response Down-Sizer
// 
// 
// Verilog-standard:  Verilog 2001
//--------------------------------------------------------------------------
//
// Structure:
//   r_downsizer
//
//--------------------------------------------------------------------------
`timescale 1ps/1ps

(* DowngradeIPIdentifiedWarnings="yes" *) 
module axi_interconnect_v1_7_13_r_downsizer #
  (
   parameter         C_FAMILY                         = "none", 
                       // FPGA Family. Current version: virtex6 or spartan6.
   parameter integer C_AXI_ID_WIDTH                   = 4, 
                       // Width of all ID signals on SI and MI side of converter.
                       // Range: >= 1.
   parameter         C_S_AXI_DATA_WIDTH               = 32'h00000020,
                       // Width of S_AXI_WDATA and S_AXI_RDATA.
                       // Format: Bit32;
                       // Range: 'h00000040, 'h00000080, 'h00000100.
   parameter         C_M_AXI_DATA_WIDTH               = 32'h00000020, 
                       // Width of M_AXI_WDATA and M_AXI_RDATA. 
                       // Assume always smaller than C_S_AXI_DATA_WIDTH.
                       // Format: Bit32; 
                       // Range: 'h00000020, 'h00000040, 'h00000080.
   parameter integer C_AXI_SUPPORTS_USER_SIGNALS      = 0,
                       // 1 = Propagate all USER signals, 0 = Dont propagate.
   parameter integer C_AXI_RUSER_WIDTH                = 1,
                       // Width of RUSER signals. 
                       // Range: >= 1.
   parameter integer C_SUPPORT_SPLITTING              = 1,
                       // Implement transaction splitting logic.
   parameter integer C_SUPPORT_BURSTS                 = 1,
                       // Disabled when all connected slaves and masters are AxiLite,
                       //   allowing logic to be simplified.
   parameter integer C_SINGLE_THREAD                  = 1,
                       // Allow multiple outstanding transactions only if the IDs are the same.
   parameter integer C_S_AXI_BYTES_LOG                = 3,
                       // Log2 of number of 32bit word on SI-side.
   parameter integer C_M_AXI_BYTES_LOG                = 2,
                       // Log2 of number of 32bit word on MI-side.
   parameter integer C_RATIO_LOG                      = 1
                       // Log2 of Up-Sizing ratio for data.
   )
  (
   // Global Signals
   input  wire                                                    ARESET,
   input  wire                                                    ACLK,

   // Command Interface
   input  wire                              cmd_valid,
   input  wire                              cmd_split,
   input  wire                              cmd_mirror,
   input  wire                              cmd_fix,
   input  wire [C_S_AXI_BYTES_LOG-1:0]      cmd_first_word, 
   input  wire [C_S_AXI_BYTES_LOG-1:0]      cmd_offset,
   input  wire [C_S_AXI_BYTES_LOG-1:0]      cmd_mask,
   input  wire [C_M_AXI_BYTES_LOG:0]        cmd_step,
   input  wire [3-1:0]                      cmd_size,
   input  wire [8-1:0]                      cmd_length,
   output wire                              cmd_ready,
   
   // Slave Interface Read Data Ports
   output wire [C_AXI_ID_WIDTH-1:0]           S_AXI_RID,
   output wire [C_S_AXI_DATA_WIDTH-1:0]     S_AXI_RDATA,
   output wire [2-1:0]                          S_AXI_RRESP,
   output wire                                                    S_AXI_RLAST,
   output wire [C_AXI_RUSER_WIDTH-1:0]          S_AXI_RUSER,
   output wire                                                    S_AXI_RVALID,
   input  wire                                                    S_AXI_RREADY,

   // Master Interface Read Data Ports
   input  wire [C_AXI_ID_WIDTH-1:0]          M_AXI_RID,
   input  wire [C_M_AXI_DATA_WIDTH-1:0]    M_AXI_RDATA,
   input  wire [2-1:0]                         M_AXI_RRESP,
   input  wire                                                   M_AXI_RLAST,
   input  wire [C_AXI_RUSER_WIDTH-1:0]         M_AXI_RUSER,
   input  wire                                                   M_AXI_RVALID,
   output wire                                                   M_AXI_RREADY
   );

   
  /////////////////////////////////////////////////////////////////////////////
  // Variables for generating parameter controlled instances.
  /////////////////////////////////////////////////////////////////////////////
  
  // Generate variable for MI-side word lanes on SI-side.
  genvar word_cnt;
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Local params
  /////////////////////////////////////////////////////////////////////////////
  
  // Constants for packing levels.
  localparam [2-1:0] C_RESP_OKAY        = 2'b00;
  localparam [2-1:0] C_RESP_EXOKAY      = 2'b01;
  localparam [2-1:0] C_RESP_SLVERROR    = 2'b10;
  localparam [2-1:0] C_RESP_DECERR      = 2'b11;
  
  // .
  localparam [24-1:0] C_DOUBLE_LEN       = 24'b0000_0000_0000_0000_1111_1111;
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Functions
  /////////////////////////////////////////////////////////////////////////////
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Internal signals
  /////////////////////////////////////////////////////////////////////////////
  
  // Sub-word handling.
  reg                             first_word;
  reg  [C_S_AXI_BYTES_LOG-1:0]    current_word_1;
  reg  [C_S_AXI_BYTES_LOG-1:0]    current_word;
  wire [C_S_AXI_BYTES_LOG-1:0]    current_word_adjusted;
  wire [C_RATIO_LOG-1:0]          current_index;
  wire                            last_beat;
  wire                            last_word;
  wire                            new_si_word;
  reg  [C_S_AXI_BYTES_LOG-1:0]    size_mask;
  
  // Sub-word handling for the next cycle.
  wire [C_S_AXI_BYTES_LOG-1:0]    next_word;
  
  // Burst length handling.
  reg                             first_mi_word;
  reg  [8-1:0]                    length_counter_1;
  reg  [8-1:0]                    length_counter;
  wire [8-1:0]                    next_length_counter;
  
  // Loading of new rresp data.
  wire                            load_rresp;
  reg                             need_to_update_rresp;
  reg  [2-1:0]                    S_AXI_RRESP_ACC;
  
  // Detect start of MI word.
  wire                            first_si_in_mi;
  
  // Handle USER.
  wire                            first_mi_in_si;
  
  // Throttling help signals.
  wire                            word_completed;
  wire                            cmd_ready_i;
  wire                            pop_si_data;
  wire                            pop_mi_data;
  wire                            si_stalling;
  
  // Internal MI-side control signals.
  wire                            M_AXI_RREADY_I;
  reg  [C_AXI_RUSER_WIDTH-1:0]    M_AXI_RUSER_I;
   
  // Internal SI-side control signals.
  reg  [C_S_AXI_DATA_WIDTH-1:0]   S_AXI_RDATA_II;
  
  // Internal signals for SI-side.
  wire [C_AXI_ID_WIDTH-1:0]       S_AXI_RID_I;
  reg  [C_S_AXI_DATA_WIDTH-1:0]   S_AXI_RDATA_I;
  reg  [2-1:0]                    S_AXI_RRESP_I;
  wire                            S_AXI_RLAST_I;
  reg  [C_AXI_RUSER_WIDTH-1:0]    S_AXI_RUSER_I;
  wire                            S_AXI_RVALID_I;
  wire                            S_AXI_RREADY_I;
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Handle interface handshaking:
  //
  // 
  /////////////////////////////////////////////////////////////////////////////
  
  // Generate address bits used for SI-side transaction size.
  always @ *
  begin
    case (cmd_size)
      3'b000: size_mask = C_DOUBLE_LEN[8 +: C_S_AXI_BYTES_LOG];
      3'b001: size_mask = C_DOUBLE_LEN[7 +: C_S_AXI_BYTES_LOG];
      3'b010: size_mask = C_DOUBLE_LEN[6 +: C_S_AXI_BYTES_LOG];
      3'b011: size_mask = C_DOUBLE_LEN[5 +: C_S_AXI_BYTES_LOG];
      3'b100: size_mask = C_DOUBLE_LEN[4 +: C_S_AXI_BYTES_LOG];
      3'b101: size_mask = C_DOUBLE_LEN[3 +: C_S_AXI_BYTES_LOG];
      3'b110: size_mask = C_DOUBLE_LEN[2 +: C_S_AXI_BYTES_LOG];
      3'b111: size_mask = C_DOUBLE_LEN[1 +: C_S_AXI_BYTES_LOG];  // Illegal setting.
    endcase
  end
  
  // Detect when MI-side word is completely assembled.
  assign word_completed = ( cmd_fix ) |
                          ( cmd_mirror ) |
                          ( ~cmd_fix & ( ( next_word & size_mask ) == {C_S_AXI_BYTES_LOG{1'b0}} ) ) | 
                          ( ~cmd_fix & last_word ) | 
                          ( C_SUPPORT_BURSTS == 0 );
  
  // Pop word from SI-side.
  assign M_AXI_RREADY_I = ~si_stalling & cmd_valid;
  assign M_AXI_RREADY   = M_AXI_RREADY_I;
  
  // Indicate when there is data available @ SI-side.
  assign S_AXI_RVALID_I = M_AXI_RVALID & word_completed & cmd_valid;
  
  // Get MI-side data.
  assign pop_mi_data    = M_AXI_RVALID & M_AXI_RREADY_I;
  
  // Get SI-side data.
  assign pop_si_data    = S_AXI_RVALID_I & S_AXI_RREADY_I;
  
  // Signal that the command is done (so that it can be poped from command queue).
  assign cmd_ready_i    = cmd_valid & pop_si_data & last_word;
  assign cmd_ready      = cmd_ready_i;
  
  // Detect when MI-side is stalling.
  assign si_stalling    = S_AXI_RVALID_I & ~S_AXI_RREADY_I;
                          
  
  /////////////////////////////////////////////////////////////////////////////
  // 
  /////////////////////////////////////////////////////////////////////////////
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Keep track of data extraction:
  // 
  // Current address is taken form the command buffer for the first data beat
  // to handle unaligned Read transactions. After this is the extraction 
  // address usually calculated from this point.
  // FIX transactions uses the same word address for all data beats. 
  // 
  // Next word address is generated as current word plus the current step 
  // size, with masking to facilitate sub-sized wraping. The Mask is all ones
  // for normal wraping, and less when sub-sized wraping is used.
  // 
  // The calculated word addresses (current and next) is offseted by the 
  // current Offset. For sub-sized transaction the Offset points to the least 
  // significant address of the included data beats. (The least significant 
  // word is not necessarily the first data to be extracted, consider WRAP).
  // Offset is only used for sub-sized WRAP transcation that are Complete.
  // 
  // First word is active during the first MI-side data beat.
  // 
  // First MI is set during the first MI-side data beat.
  //
  // The transaction length is taken from the command buffer combinatorialy
  // during the First MI cycle. For each generated MI word it is decreased 
  // until Last Beat is reached.
  // 
  // Last word is determined depending as the last MI-side word generated for 
  // the command (generated from the AW translation).
  // If burst aren't supported all MI-side words are concidered to be the last.
  //
  /////////////////////////////////////////////////////////////////////////////
  
  // Select if the offset comes from command queue directly or 
  // from a counter while when extracting multiple MI words per SI word
  always @ *
  begin
    if ( first_word | cmd_fix )
      current_word = cmd_first_word;
    else
      current_word = current_word_1;
  end
  
  // Calculate next word.
  assign next_word              = ( current_word + cmd_step ) & cmd_mask;
  
  // Calculate the word address with offset.
  assign current_word_adjusted  = current_word + cmd_offset;
  
  // Get the ratio bits (MI-side words vs SI-side words).
  assign current_index          = current_word_adjusted[C_S_AXI_BYTES_LOG-C_RATIO_LOG +: C_RATIO_LOG];
  
  // Prepare next word address.
  always @ (posedge ACLK) begin
    if (ARESET) begin
      first_word      <= 1'b1;
      current_word_1  <= 'b0;
    end else begin
      if ( pop_mi_data ) begin
        if ( M_AXI_RLAST ) begin
          // Prepare for next access.
          first_word <=  1'b1;
        end else begin
          first_word <=  1'b0;
        end
      
        current_word_1 <= next_word;
      end
    end
  end
  
  // Select command length or counted length.
  always @ *
  begin
    if ( first_mi_word )
      length_counter = cmd_length;
    else
      length_counter = length_counter_1;
  end
  
  // Calculate next length counter value.
  assign next_length_counter = length_counter - 1'b1;
  
  // Keep track of burst length.
  always @ (posedge ACLK) begin
    if (ARESET) begin
      first_mi_word    <= 1'b1;
      length_counter_1 <= 8'b0;
    end else begin
      if ( pop_mi_data ) begin
        if ( M_AXI_RLAST ) begin
          first_mi_word    <= 1'b1;
        end else begin
          first_mi_word    <= 1'b0;
        end
      
        length_counter_1 <= next_length_counter;
      end
    end
  end
  
  // Detect last beat in a burst.
  assign last_beat    = ( length_counter == 8'b0 );
  
  // Determine if this last word that shall be extracted from this SI-side word.
  assign last_word    = ( last_beat ) |
                        ( C_SUPPORT_BURSTS == 0 );
  
  // Detect new SI-side data word.
  assign new_si_word  = ( current_word == {C_S_AXI_BYTES_LOG{1'b0}} );
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Simple AXI signal forwarding:
  // 
  // WID passes through untouched.
  // 
  // LAST has to be filtered to remove any intermediate LAST (due to split 
  // trasactions).
  // 
  /////////////////////////////////////////////////////////////////////////////
  
  // ID and USER is copied from the MI word to all SI word transactions.
  assign S_AXI_RID_I    = M_AXI_RID;
  
  // Handle last flag, i.e. set for SI-side last word.
  assign S_AXI_RLAST_I  = M_AXI_RLAST & ~cmd_split;
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Handle the accumulation of RRESP.
  // 
  // The accumulated RRESP register is updated for each MI-side response that 
  // is used in an SI-side word, i.e. the worst status for all included data
  // so far.
  // 
  /////////////////////////////////////////////////////////////////////////////
  
  // Detect first SI-side word per MI-side word.
  assign first_si_in_mi = cmd_mirror | 
                          first_mi_word |
                          ( ~cmd_mirror & ( ( current_word & size_mask ) == {C_S_AXI_BYTES_LOG{1'b0}} ) ) | 
                          ( C_SUPPORT_BURSTS == 0 );
  
  // Force load accumulated RRESPs to first value or continously for non split.
  assign load_rresp     = first_si_in_mi;
  
  // Update if more critical.
  always @ *
  begin
    case (S_AXI_RRESP_ACC)
      C_RESP_EXOKAY:    need_to_update_rresp = ( M_AXI_RRESP == C_RESP_OKAY     |
                                                 M_AXI_RRESP == C_RESP_SLVERROR |
                                                 M_AXI_RRESP == C_RESP_DECERR );
      C_RESP_OKAY:      need_to_update_rresp = ( M_AXI_RRESP == C_RESP_SLVERROR |
                                                 M_AXI_RRESP == C_RESP_DECERR );
      C_RESP_SLVERROR:  need_to_update_rresp = ( M_AXI_RRESP == C_RESP_DECERR );
      C_RESP_DECERR:    need_to_update_rresp = 1'b0;
    endcase
  end
  
  // Select accumultated or direct depending on setting.
  always @ *
  begin
    if ( load_rresp || need_to_update_rresp ) begin
      S_AXI_RRESP_I = M_AXI_RRESP;
    end else begin
      S_AXI_RRESP_I = S_AXI_RRESP_ACC;
    end
  end
  
  // Accumulate MI-side RRESP.
  always @ (posedge ACLK) begin
    if (ARESET) begin
      S_AXI_RRESP_ACC <= C_RESP_OKAY;
    end else begin
      if ( pop_mi_data ) begin
        S_AXI_RRESP_ACC <= S_AXI_RRESP_I;
      end
    end
  end
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Handle USER bits:
  // 
  // The USER bits are always propagated from the least significant Down-Sized 
  // MI-side beat to the SI-side data beat. That means:
  // * FIX transactions propagate all USER data (1:1 SI- vs MI-side beat ratio).
  // * INCR transactions uses the first MI-side beat that goes into a SI-side
  //   data word.
  // * WRAP always propagates the USER bits from the most zero aligned MI-side 
  //   data word. 
  //
  /////////////////////////////////////////////////////////////////////////////
  
  // Detect first MI-side word per SI-side word.
  assign first_mi_in_si = cmd_fix     |
                          cmd_mirror  |
                          first_word  |
                          new_si_word |
                          ( C_SUPPORT_BURSTS == 0 );
  
  // Select USER bits combinatorially when expanding or fix.
  always @ *
  begin
    if ( C_AXI_SUPPORTS_USER_SIGNALS ) begin
      if ( first_mi_in_si ) begin
        S_AXI_RUSER_I = M_AXI_RUSER;
      end else begin
        S_AXI_RUSER_I = M_AXI_RUSER_I;
      end
    end else begin
      S_AXI_RUSER_I = {C_AXI_RUSER_WIDTH{1'b0}};
    end
  end
  
  // Capture user bits.
  always @ (posedge ACLK) begin
    if (ARESET) begin
      M_AXI_RUSER_I <= {C_AXI_RUSER_WIDTH{1'b0}};
    end else begin
      if ( first_mi_in_si & pop_mi_data ) begin
        M_AXI_RUSER_I <= M_AXI_RUSER;
      end
    end
  end
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Demultiplex data to form complete data word.
  // 
  /////////////////////////////////////////////////////////////////////////////
  
  // Registers and combinatorial data MI-word size mux.
  generate
    for (word_cnt = 0; word_cnt < (2 ** C_RATIO_LOG) ; word_cnt = word_cnt + 1) begin : WORD_LANE
        
      // Generate extended write data and strobe.
      always @ (posedge ACLK) begin
        if (ARESET) begin
          S_AXI_RDATA_II[word_cnt*C_M_AXI_DATA_WIDTH   +: C_M_AXI_DATA_WIDTH]   <= {C_M_AXI_DATA_WIDTH{1'b0}};
        end else begin
          if ( pop_si_data ) begin
            S_AXI_RDATA_II[word_cnt*C_M_AXI_DATA_WIDTH   +: C_M_AXI_DATA_WIDTH]   <= {C_M_AXI_DATA_WIDTH{1'b0}};
          end else if ( current_index == word_cnt & pop_mi_data ) begin
            S_AXI_RDATA_II[word_cnt*C_M_AXI_DATA_WIDTH   +: C_M_AXI_DATA_WIDTH]   <= M_AXI_RDATA;
          end
        end
      end
      
      // Select packed or extended data.
      always @ *
      begin
        // Multiplex data.
        if ( ( current_index == word_cnt ) | cmd_mirror ) begin
          S_AXI_RDATA_I[word_cnt*C_M_AXI_DATA_WIDTH +: C_M_AXI_DATA_WIDTH] = M_AXI_RDATA;
        end else begin
          S_AXI_RDATA_I[word_cnt*C_M_AXI_DATA_WIDTH +: C_M_AXI_DATA_WIDTH] = 
                        S_AXI_RDATA_II[word_cnt*C_M_AXI_DATA_WIDTH +: C_M_AXI_DATA_WIDTH];
        end
      end
      
    end // end for word_cnt
  endgenerate
      
  
  /////////////////////////////////////////////////////////////////////////////
  // SI-side output handling
  /////////////////////////////////////////////////////////////////////////////
  assign S_AXI_RREADY_I = S_AXI_RREADY;
  assign S_AXI_RVALID   = S_AXI_RVALID_I;
  assign S_AXI_RID      = S_AXI_RID_I;
  assign S_AXI_RDATA    = S_AXI_RDATA_I;
  assign S_AXI_RRESP    = S_AXI_RRESP_I;
  assign S_AXI_RLAST    = S_AXI_RLAST_I;
  assign S_AXI_RUSER    = S_AXI_RUSER_I;
  
  
endmodule



// -- (c) Copyright 2009 - 2011 Xilinx, Inc. All rights reserved.
// --
// -- This file contains confidential and proprietary information
// -- of Xilinx, Inc. and is protected under U.S. and 
// -- international copyright and other intellectual property
// -- laws.
// --
// -- DISCLAIMER
// -- This disclaimer is not a license and does not grant any
// -- rights to the materials distributed herewith. Except as
// -- otherwise provided in a valid license issued to you by
// -- Xilinx, and to the maximum extent permitted by applicable
// -- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
// -- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
// -- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
// -- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
// -- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
// -- (2) Xilinx shall not be liable (whether in contract or tort,
// -- including negligence, or under any other theory of
// -- liability) for any loss or damage of any kind or nature
// -- related to, arising under or in connection with these
// -- materials, including for any direct, or any indirect,
// -- special, incidental, or consequential loss or damage
// -- (including loss of data, profits, goodwill, or any type of
// -- loss or damage suffered as a result of any action brought
// -- by a third party) even if such damage or loss was
// -- reasonably foreseeable or Xilinx had been advised of the
// -- possibility of the same.
// --
// -- CRITICAL APPLICATIONS
// -- Xilinx products are not designed or intended to be fail-
// -- safe, or for use in any application requiring fail-safe
// -- performance, such as life-support or safety devices or
// -- systems, Class III medical devices, nuclear facilities,
// -- applications related to the deployment of airbags, or any
// -- other applications that could lead to death, personal
// -- injury, or severe property or environmental damage
// -- (individually and collectively, "Critical
// -- Applications"). Customer assumes the sole risk and
// -- liability of any use of Xilinx products in Critical
// -- Applications, subject only to applicable laws and
// -- regulations governing limitations on product liability.
// --
// -- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
// -- PART OF THIS FILE AT ALL TIMES.
//-----------------------------------------------------------------------------
//
// File name: register_slice_bank.v
//
// Description: 
//   This module is a bank of register slices for a vectored AXI interface.
//   The interface of this module consists of a vectored slave and master interface
//     which are each concatenations of upper-level AXI pathways,
//     plus various vectored parameters.
//   This module instantiates a set of individual 2-deep AXI register-slices.
//
//--------------------------------------------------------------------------
//
// Structure:
//    register_slice_bank
//      axi_register_slice
//      
//-----------------------------------------------------------------------------
`timescale 1ps/1ps
`default_nettype none

(* DowngradeIPIdentifiedWarnings="yes" *) 
module axi_interconnect_v1_7_13_register_slice_bank #
  (
   parameter         C_FAMILY                         = "none", 
   parameter integer C_NUM_SLOTS                = 1, 
   parameter         C_AXI_ID_WIDTH                 = 1, 
                       // Effective width of ID ports for each SI and MI slot.
                       // Format: C_NUM_SLOTS{Bit32}; 
                       // Range: 'h00000001 - C_AXI_ID_MAX_WIDTH.
   parameter integer C_AXI_ID_MAX_WIDTH                 = 1, 
                       // Width of ID signals propagated by the Interconnect.
                       // Stride of ID fields within each ID port.
                       // Range: >= 1.
   parameter integer C_AXI_ADDR_WIDTH                 = 32, 
   parameter integer C_AXI_DATA_MAX_WIDTH           = 256, 
                       // Largest value supported for any DATA_WIDTH.
                       // Stride of data fields within each DATA port.
   parameter [511:0] C_AXI_DATA_WIDTH               = {16{32'h00000020}}, 
                       // Effective width of DATA signals for each SI and MI slot.
                       // Format: C_NUM_SLOTS{Bit32}; 
                       // Range: 'h00000020, 'h00000040, 'h00000080, 'h00000100.
   parameter [511:0] C_AXI_PROTOCOL                 = {16{32'h00000000}}, 
                       // Indicates whether connected device is 
                       // Full-AXI4 ('h00000000),
                       // AXI3 ('h00000001) or 
                       // Axi4Lite ('h00000002), for each slot.
                       // Format: C_NUM_SLOTS{Bit32}.
   parameter         C_AXI_SUPPORTS_WRITE           = 16'b11111111_11111111, 
                       // Format: C_NUM_SLOTS{Bit1}.
   parameter         C_AXI_SUPPORTS_READ            = 16'b11111111_11111111, 
                       // Format: C_NUM_SLOTS{Bit1}.
   parameter integer C_AXI_SUPPORTS_USER_SIGNALS      = 0,
                       // 1 = Propagate all USER signals, 0 = Dont propagate.
   parameter integer C_AXI_AWUSER_WIDTH               = 1,
   parameter integer C_AXI_ARUSER_WIDTH               = 1,
   parameter integer C_AXI_WUSER_WIDTH                = 1,
   parameter integer C_AXI_RUSER_WIDTH                = 1,
   parameter integer C_AXI_BUSER_WIDTH                = 1,
   parameter [511:0] C_AXI_AW_REGISTER              = {16{32'h00000000}},
                       // Format: C_NUM_SLOTS{Bit32}.
   parameter [511:0] C_AXI_AR_REGISTER              = {16{32'h00000000}},
                       // Format: C_NUM_SLOTS{Bit32}.
   parameter [511:0] C_AXI_W_REGISTER               = {16{32'h00000000}},
                       // Format: C_NUM_SLOTS{Bit32}.
   parameter [511:0] C_AXI_R_REGISTER               = {16{32'h00000000}},
                       // Format: C_NUM_SLOTS{Bit32}.
   parameter [511:0] C_AXI_B_REGISTER               = {16{32'h00000000}}
                       // Format: C_NUM_SLOTS{Bit32}.
   )
  (
   // Global Signals
   input  wire [C_NUM_SLOTS-1:0]                            ACLK,
   input  wire [C_NUM_SLOTS-1:0]                            ARESETN,
   // Slave Interface Write Address Ports
   input  wire [C_NUM_SLOTS*C_AXI_ID_MAX_WIDTH-1:0]           S_AXI_AWID,
   input  wire [C_NUM_SLOTS*C_AXI_ADDR_WIDTH-1:0]           S_AXI_AWADDR,
   input  wire [C_NUM_SLOTS*8-1:0]                          S_AXI_AWLEN,
   input  wire [C_NUM_SLOTS*3-1:0]                          S_AXI_AWSIZE,
   input  wire [C_NUM_SLOTS*2-1:0]                          S_AXI_AWBURST,
   input  wire [C_NUM_SLOTS*2-1:0]                          S_AXI_AWLOCK,
   input  wire [C_NUM_SLOTS*4-1:0]                          S_AXI_AWCACHE,
   input  wire [C_NUM_SLOTS*3-1:0]                          S_AXI_AWPROT,
   input  wire [C_NUM_SLOTS*4-1:0]                          S_AXI_AWREGION,
   input  wire [C_NUM_SLOTS*4-1:0]                          S_AXI_AWQOS,
   input  wire [C_NUM_SLOTS*C_AXI_AWUSER_WIDTH-1:0]         S_AXI_AWUSER,
   input  wire [C_NUM_SLOTS-1:0]                            S_AXI_AWVALID,
   output wire [C_NUM_SLOTS-1:0]                            S_AXI_AWREADY,
   // Slave Interface Write Data Ports
   input  wire [C_NUM_SLOTS*C_AXI_ID_MAX_WIDTH-1:0]           S_AXI_WID,
   input  wire [C_NUM_SLOTS*C_AXI_DATA_MAX_WIDTH-1:0]     S_AXI_WDATA,
   input  wire [C_NUM_SLOTS*C_AXI_DATA_MAX_WIDTH/8-1:0]   S_AXI_WSTRB,
   input  wire [C_NUM_SLOTS-1:0]                            S_AXI_WLAST,
   input  wire [C_NUM_SLOTS*C_AXI_WUSER_WIDTH-1:0]          S_AXI_WUSER,
   input  wire [C_NUM_SLOTS-1:0]                            S_AXI_WVALID,
   output wire [C_NUM_SLOTS-1:0]                            S_AXI_WREADY,
   // Slave Interface Write Response Ports
   output wire [C_NUM_SLOTS*C_AXI_ID_MAX_WIDTH-1:0]           S_AXI_BID,
   output wire [C_NUM_SLOTS*2-1:0]                          S_AXI_BRESP,
   output wire [C_NUM_SLOTS*C_AXI_BUSER_WIDTH-1:0]          S_AXI_BUSER,
   output wire [C_NUM_SLOTS-1:0]                            S_AXI_BVALID,
   input  wire [C_NUM_SLOTS-1:0]                            S_AXI_BREADY,
   // Slave Interface Read Address Ports
   input  wire [C_NUM_SLOTS*C_AXI_ID_MAX_WIDTH-1:0]           S_AXI_ARID,
   input  wire [C_NUM_SLOTS*C_AXI_ADDR_WIDTH-1:0]           S_AXI_ARADDR,
   input  wire [C_NUM_SLOTS*8-1:0]                          S_AXI_ARLEN,
   input  wire [C_NUM_SLOTS*3-1:0]                          S_AXI_ARSIZE,
   input  wire [C_NUM_SLOTS*2-1:0]                          S_AXI_ARBURST,
   input  wire [C_NUM_SLOTS*2-1:0]                          S_AXI_ARLOCK,
   input  wire [C_NUM_SLOTS*4-1:0]                          S_AXI_ARCACHE,
   input  wire [C_NUM_SLOTS*3-1:0]                          S_AXI_ARPROT,
   input  wire [C_NUM_SLOTS*4-1:0]                          S_AXI_ARREGION,
   input  wire [C_NUM_SLOTS*4-1:0]                          S_AXI_ARQOS,
   input  wire [C_NUM_SLOTS*C_AXI_ARUSER_WIDTH-1:0]         S_AXI_ARUSER,
   input  wire [C_NUM_SLOTS-1:0]                            S_AXI_ARVALID,
   output wire [C_NUM_SLOTS-1:0]                            S_AXI_ARREADY,
   // Slave Interface Read Data Ports
   output wire [C_NUM_SLOTS*C_AXI_ID_MAX_WIDTH-1:0]           S_AXI_RID,
   output wire [C_NUM_SLOTS*C_AXI_DATA_MAX_WIDTH-1:0]     S_AXI_RDATA,
   output wire [C_NUM_SLOTS*2-1:0]                          S_AXI_RRESP,
   output wire [C_NUM_SLOTS-1:0]                            S_AXI_RLAST,
   output wire [C_NUM_SLOTS*C_AXI_RUSER_WIDTH-1:0]          S_AXI_RUSER,
   output wire [C_NUM_SLOTS-1:0]                            S_AXI_RVALID,
   input  wire [C_NUM_SLOTS-1:0]                            S_AXI_RREADY,
   // Master Interface Write Address Port
   output wire [C_NUM_SLOTS*C_AXI_ID_MAX_WIDTH-1:0]          M_AXI_AWID,
   output wire [C_NUM_SLOTS*C_AXI_ADDR_WIDTH-1:0]          M_AXI_AWADDR,
   output wire [C_NUM_SLOTS*8-1:0]                         M_AXI_AWLEN,
   output wire [C_NUM_SLOTS*3-1:0]                         M_AXI_AWSIZE,
   output wire [C_NUM_SLOTS*2-1:0]                         M_AXI_AWBURST,
   output wire [C_NUM_SLOTS*2-1:0]                         M_AXI_AWLOCK,
   output wire [C_NUM_SLOTS*4-1:0]                         M_AXI_AWCACHE,
   output wire [C_NUM_SLOTS*3-1:0]                         M_AXI_AWPROT,
   output wire [C_NUM_SLOTS*4-1:0]                         M_AXI_AWREGION,
   output wire [C_NUM_SLOTS*4-1:0]                         M_AXI_AWQOS,
   output wire [C_NUM_SLOTS*C_AXI_AWUSER_WIDTH-1:0]        M_AXI_AWUSER,
   output wire [C_NUM_SLOTS-1:0]                           M_AXI_AWVALID,
   input  wire [C_NUM_SLOTS-1:0]                           M_AXI_AWREADY,
   // Master Interface Write Data Ports
   output wire [C_NUM_SLOTS*C_AXI_ID_MAX_WIDTH-1:0]          M_AXI_WID,
   output wire [C_NUM_SLOTS*C_AXI_DATA_MAX_WIDTH-1:0]    M_AXI_WDATA,
   output wire [C_NUM_SLOTS*C_AXI_DATA_MAX_WIDTH/8-1:0]  M_AXI_WSTRB,
   output wire [C_NUM_SLOTS-1:0]                           M_AXI_WLAST,
   output wire [C_NUM_SLOTS*C_AXI_WUSER_WIDTH-1:0]         M_AXI_WUSER,
   output wire [C_NUM_SLOTS-1:0]                           M_AXI_WVALID,
   input  wire [C_NUM_SLOTS-1:0]                           M_AXI_WREADY,
   // Master Interface Write Response Ports
   input  wire [C_NUM_SLOTS*C_AXI_ID_MAX_WIDTH-1:0]          M_AXI_BID,
   input  wire [C_NUM_SLOTS*2-1:0]                         M_AXI_BRESP,
   input  wire [C_NUM_SLOTS*C_AXI_BUSER_WIDTH-1:0]         M_AXI_BUSER,
   input  wire [C_NUM_SLOTS-1:0]                           M_AXI_BVALID,
   output wire [C_NUM_SLOTS-1:0]                           M_AXI_BREADY,
   // Master Interface Read Address Port
   output wire [C_NUM_SLOTS*C_AXI_ID_MAX_WIDTH-1:0]          M_AXI_ARID,
   output wire [C_NUM_SLOTS*C_AXI_ADDR_WIDTH-1:0]          M_AXI_ARADDR,
   output wire [C_NUM_SLOTS*8-1:0]                         M_AXI_ARLEN,
   output wire [C_NUM_SLOTS*3-1:0]                         M_AXI_ARSIZE,
   output wire [C_NUM_SLOTS*2-1:0]                         M_AXI_ARBURST,
   output wire [C_NUM_SLOTS*2-1:0]                         M_AXI_ARLOCK,
   output wire [C_NUM_SLOTS*4-1:0]                         M_AXI_ARCACHE,
   output wire [C_NUM_SLOTS*3-1:0]                         M_AXI_ARPROT,
   output wire [C_NUM_SLOTS*4-1:0]                         M_AXI_ARREGION,
   output wire [C_NUM_SLOTS*4-1:0]                         M_AXI_ARQOS,
   output wire [C_NUM_SLOTS*C_AXI_ARUSER_WIDTH-1:0]        M_AXI_ARUSER,
   output wire [C_NUM_SLOTS-1:0]                           M_AXI_ARVALID,
   input  wire [C_NUM_SLOTS-1:0]                           M_AXI_ARREADY,
   // Master Interface Read Data Ports
   input  wire [C_NUM_SLOTS*C_AXI_ID_MAX_WIDTH-1:0]          M_AXI_RID,
   input  wire [C_NUM_SLOTS*C_AXI_DATA_MAX_WIDTH-1:0]    M_AXI_RDATA,
   input  wire [C_NUM_SLOTS*2-1:0]                         M_AXI_RRESP,
   input  wire [C_NUM_SLOTS-1:0]                           M_AXI_RLAST,
   input  wire [C_NUM_SLOTS*C_AXI_RUSER_WIDTH-1:0]         M_AXI_RUSER,
   input  wire [C_NUM_SLOTS-1:0]                           M_AXI_RVALID,
   output wire [C_NUM_SLOTS-1:0]                           M_AXI_RREADY
   );

  wire [C_NUM_SLOTS*C_AXI_DATA_MAX_WIDTH-1:0]     si_rs_rdata           ;
  wire [C_NUM_SLOTS*C_AXI_DATA_MAX_WIDTH-1:0]     rs_mi_wdata           ;
  wire [C_NUM_SLOTS*C_AXI_DATA_MAX_WIDTH/8-1:0]   rs_mi_wstrb           ;
  wire [C_NUM_SLOTS*C_AXI_ID_MAX_WIDTH-1:0]       si_rs_bid             ;
  wire [C_NUM_SLOTS*C_AXI_ID_MAX_WIDTH-1:0]       si_rs_rid             ;
  wire [C_NUM_SLOTS*C_AXI_ID_MAX_WIDTH-1:0]       rs_mi_awid             ;
  wire [C_NUM_SLOTS*C_AXI_ID_MAX_WIDTH-1:0]       rs_mi_wid             ;
  wire [C_NUM_SLOTS*C_AXI_ID_MAX_WIDTH-1:0]       rs_mi_arid             ;
  
  genvar slot;
  
  localparam P_BYPASS = 32'h0;
  localparam P_FWD_REV = 32'h1;
  localparam P_LIGHTWT = 32'h7;
  localparam P_AUTO    = 32'h8;
  localparam P_AXILITE = 32'h2;

generate
  for (slot=0;slot<C_NUM_SLOTS;slot=slot+1) begin : gen_reg_slot
  axi_interconnect_v1_7_13_axi_register_slice #
      (
        .C_FAMILY                         (C_FAMILY),
        .C_AXI_ID_WIDTH                   (C_AXI_ID_WIDTH[slot*32+:32]),
        .C_AXI_ADDR_WIDTH                 (C_AXI_ADDR_WIDTH),
        .C_AXI_DATA_WIDTH                 (C_AXI_DATA_WIDTH[slot*32+:32]),
        .C_AXI_SUPPORTS_USER_SIGNALS      (C_AXI_SUPPORTS_USER_SIGNALS),
        .C_AXI_AWUSER_WIDTH               (C_AXI_AWUSER_WIDTH),
        .C_AXI_ARUSER_WIDTH               (C_AXI_ARUSER_WIDTH),
        .C_AXI_WUSER_WIDTH                (C_AXI_WUSER_WIDTH),
        .C_AXI_RUSER_WIDTH                (C_AXI_RUSER_WIDTH),
        .C_AXI_BUSER_WIDTH                (C_AXI_BUSER_WIDTH),
        .C_REG_CONFIG_AW                  ((~C_AXI_SUPPORTS_WRITE[slot]) ? P_BYPASS :
                                          (C_AXI_AW_REGISTER[slot*32+:32] != P_AUTO) ? C_AXI_AW_REGISTER[slot*32+:32] :
                                          P_LIGHTWT),
        .C_REG_CONFIG_AR                  ((~C_AXI_SUPPORTS_READ[slot]) ? P_BYPASS :
                                          (C_AXI_AR_REGISTER[slot*32+:32] != P_AUTO) ? C_AXI_AR_REGISTER[slot*32+:32] :
                                          P_LIGHTWT),
        .C_REG_CONFIG_B                   ((~C_AXI_SUPPORTS_WRITE[slot]) ? P_BYPASS :
                                          (C_AXI_B_REGISTER[slot*32+:32] != P_AUTO) ? C_AXI_B_REGISTER[slot*32+:32] :
                                          P_LIGHTWT),
        .C_REG_CONFIG_W                   ((~C_AXI_SUPPORTS_WRITE[slot]) ? P_BYPASS :
                                          (C_AXI_W_REGISTER[slot*32+:32] != P_AUTO) ? C_AXI_W_REGISTER[slot*32+:32] :
                                          (C_AXI_PROTOCOL[slot*32+:32] == P_AXILITE) ? P_LIGHTWT : P_FWD_REV),
        .C_REG_CONFIG_R                   ((~C_AXI_SUPPORTS_READ[slot]) ? P_BYPASS :
                                          (C_AXI_R_REGISTER[slot*32+:32] != P_AUTO) ? C_AXI_R_REGISTER[slot*32+:32] :
                                          (C_AXI_PROTOCOL[slot*32+:32] == P_AXILITE) ? P_LIGHTWT : P_FWD_REV)
      )
      register_slice_inst 
      (
        .ARESETN                    (ARESETN[slot]),
        .ACLK                       (ACLK[slot]),
        .S_AXI_AWID                       (S_AXI_AWID[slot*C_AXI_ID_MAX_WIDTH+:C_AXI_ID_WIDTH[slot*32+:32]]),
        .S_AXI_AWADDR                     (S_AXI_AWADDR[slot*C_AXI_ADDR_WIDTH+:C_AXI_ADDR_WIDTH]),
        .S_AXI_AWLEN                      (S_AXI_AWLEN[slot*8+:8]),
        .S_AXI_AWSIZE                     (S_AXI_AWSIZE[slot*3+:3]),
        .S_AXI_AWBURST                    (S_AXI_AWBURST[slot*2+:2]),
        .S_AXI_AWLOCK                     (S_AXI_AWLOCK[slot*2+:2]),
        .S_AXI_AWCACHE                    (S_AXI_AWCACHE[slot*4+:4]),
        .S_AXI_AWPROT                     (S_AXI_AWPROT[slot*3+:3]),
        .S_AXI_AWREGION                   (S_AXI_AWREGION[slot*4+:4]),
        .S_AXI_AWQOS                      (S_AXI_AWQOS[slot*4+:4]),
        .S_AXI_AWUSER                     (S_AXI_AWUSER[slot*C_AXI_AWUSER_WIDTH+:C_AXI_AWUSER_WIDTH]),
        .S_AXI_AWVALID                    (S_AXI_AWVALID[slot*1+:1]),
        .S_AXI_AWREADY                    (S_AXI_AWREADY[slot*1+:1]),
        .S_AXI_WID                        (S_AXI_WID[slot*C_AXI_ID_MAX_WIDTH+:C_AXI_ID_WIDTH[slot*32+:32]]),
        .S_AXI_WDATA                      (S_AXI_WDATA[slot*C_AXI_DATA_MAX_WIDTH+:C_AXI_DATA_WIDTH[slot*32+:32]]),
        .S_AXI_WSTRB                      (S_AXI_WSTRB[slot*C_AXI_DATA_MAX_WIDTH/8+:C_AXI_DATA_WIDTH[slot*32+:32]/8]),
        .S_AXI_WLAST                      (S_AXI_WLAST[slot*1+:1]),
        .S_AXI_WUSER                      (S_AXI_WUSER[slot*C_AXI_WUSER_WIDTH+:C_AXI_WUSER_WIDTH]),
        .S_AXI_WVALID                     (S_AXI_WVALID[slot*1+:1]),
        .S_AXI_WREADY                     (S_AXI_WREADY[slot*1+:1]),
        .S_AXI_BID                        (si_rs_bid[slot*C_AXI_ID_MAX_WIDTH+:C_AXI_ID_WIDTH[slot*32+:32]]),
        .S_AXI_BRESP                      (S_AXI_BRESP[slot*2+:2]),
        .S_AXI_BUSER                      (S_AXI_BUSER[slot*C_AXI_BUSER_WIDTH+:C_AXI_BUSER_WIDTH]),
        .S_AXI_BVALID                     (S_AXI_BVALID[slot*1+:1]),
        .S_AXI_BREADY                     (S_AXI_BREADY[slot*1+:1]),
        .S_AXI_ARID                       (S_AXI_ARID[slot*C_AXI_ID_MAX_WIDTH+:C_AXI_ID_WIDTH[slot*32+:32]]),
        .S_AXI_ARADDR                     (S_AXI_ARADDR[slot*C_AXI_ADDR_WIDTH+:C_AXI_ADDR_WIDTH]),
        .S_AXI_ARLEN                      (S_AXI_ARLEN[slot*8+:8]),
        .S_AXI_ARSIZE                     (S_AXI_ARSIZE[slot*3+:3]),
        .S_AXI_ARBURST                    (S_AXI_ARBURST[slot*2+:2]),
        .S_AXI_ARLOCK                     (S_AXI_ARLOCK[slot*2+:2]),
        .S_AXI_ARCACHE                    (S_AXI_ARCACHE[slot*4+:4]),
        .S_AXI_ARPROT                     (S_AXI_ARPROT[slot*3+:3]),
        .S_AXI_ARREGION                   (S_AXI_ARREGION[slot*4+:4]),
        .S_AXI_ARQOS                      (S_AXI_ARQOS[slot*4+:4]),
        .S_AXI_ARUSER                     (S_AXI_ARUSER[slot*C_AXI_ARUSER_WIDTH+:C_AXI_ARUSER_WIDTH]),
        .S_AXI_ARVALID                    (S_AXI_ARVALID[slot*1+:1]),
        .S_AXI_ARREADY                    (S_AXI_ARREADY[slot*1+:1]),
        .S_AXI_RID                        (si_rs_rid[slot*C_AXI_ID_MAX_WIDTH+:C_AXI_ID_WIDTH[slot*32+:32]]),
        .S_AXI_RDATA                      (si_rs_rdata[slot*C_AXI_DATA_MAX_WIDTH+:C_AXI_DATA_WIDTH[slot*32+:32]]),
        .S_AXI_RRESP                      (S_AXI_RRESP[slot*2+:2]),
        .S_AXI_RLAST                      (S_AXI_RLAST[slot*1+:1]),
        .S_AXI_RUSER                      (S_AXI_RUSER[slot*C_AXI_RUSER_WIDTH+:C_AXI_RUSER_WIDTH]),
        .S_AXI_RVALID                     (S_AXI_RVALID[slot*1+:1]),
        .S_AXI_RREADY                     (S_AXI_RREADY[slot*1+:1]),
        .M_AXI_AWID                       (rs_mi_awid[slot*C_AXI_ID_MAX_WIDTH+:C_AXI_ID_WIDTH[slot*32+:32]]),
        .M_AXI_AWADDR                     (M_AXI_AWADDR[slot*C_AXI_ADDR_WIDTH+:C_AXI_ADDR_WIDTH]),
        .M_AXI_AWLEN                      (M_AXI_AWLEN[slot*8+:8]),
        .M_AXI_AWSIZE                     (M_AXI_AWSIZE[slot*3+:3]),
        .M_AXI_AWBURST                    (M_AXI_AWBURST[slot*2+:2]),
        .M_AXI_AWLOCK                     (M_AXI_AWLOCK[slot*2+:2]),
        .M_AXI_AWCACHE                    (M_AXI_AWCACHE[slot*4+:4]),
        .M_AXI_AWPROT                     (M_AXI_AWPROT[slot*3+:3]),
        .M_AXI_AWREGION                   (M_AXI_AWREGION[slot*4+:4]),
        .M_AXI_AWQOS                      (M_AXI_AWQOS[slot*4+:4]),
        .M_AXI_AWUSER                     (M_AXI_AWUSER[slot*C_AXI_AWUSER_WIDTH+:C_AXI_AWUSER_WIDTH]),
        .M_AXI_AWVALID                    (M_AXI_AWVALID[slot*1+:1]),
        .M_AXI_AWREADY                    (M_AXI_AWREADY[slot*1+:1]),
        .M_AXI_WID                        (rs_mi_wid[slot*C_AXI_ID_MAX_WIDTH+:C_AXI_ID_WIDTH[slot*32+:32]]),
        .M_AXI_WDATA                      (rs_mi_wdata[slot*C_AXI_DATA_MAX_WIDTH+:C_AXI_DATA_WIDTH[slot*32+:32]]),
        .M_AXI_WSTRB                      (rs_mi_wstrb[slot*C_AXI_DATA_MAX_WIDTH/8+:C_AXI_DATA_WIDTH[slot*32+:32]/8]),
        .M_AXI_WLAST                      (M_AXI_WLAST[slot*1+:1]),
        .M_AXI_WUSER                      (M_AXI_WUSER[slot*C_AXI_WUSER_WIDTH+:C_AXI_WUSER_WIDTH]),
        .M_AXI_WVALID                     (M_AXI_WVALID[slot*1+:1]),
        .M_AXI_WREADY                     (M_AXI_WREADY[slot*1+:1]),
        .M_AXI_BID                        (M_AXI_BID[slot*C_AXI_ID_MAX_WIDTH+:C_AXI_ID_WIDTH[slot*32+:32]]),
        .M_AXI_BRESP                      (M_AXI_BRESP[slot*2+:2]),
        .M_AXI_BUSER                      (M_AXI_BUSER[slot*C_AXI_BUSER_WIDTH+:C_AXI_BUSER_WIDTH]),
        .M_AXI_BVALID                     (M_AXI_BVALID[slot*1+:1]),
        .M_AXI_BREADY                     (M_AXI_BREADY[slot*1+:1]),
        .M_AXI_ARID                       (rs_mi_arid[slot*C_AXI_ID_MAX_WIDTH+:C_AXI_ID_WIDTH[slot*32+:32]]),
        .M_AXI_ARADDR                     (M_AXI_ARADDR[slot*C_AXI_ADDR_WIDTH+:C_AXI_ADDR_WIDTH]),
        .M_AXI_ARLEN                      (M_AXI_ARLEN[slot*8+:8]),
        .M_AXI_ARSIZE                     (M_AXI_ARSIZE[slot*3+:3]),
        .M_AXI_ARBURST                    (M_AXI_ARBURST[slot*2+:2]),
        .M_AXI_ARLOCK                     (M_AXI_ARLOCK[slot*2+:2]),
        .M_AXI_ARCACHE                    (M_AXI_ARCACHE[slot*4+:4]),
        .M_AXI_ARPROT                     (M_AXI_ARPROT[slot*3+:3]),
        .M_AXI_ARREGION                   (M_AXI_ARREGION[slot*4+:4]),
        .M_AXI_ARQOS                      (M_AXI_ARQOS[slot*4+:4]),
        .M_AXI_ARUSER                     (M_AXI_ARUSER[slot*C_AXI_ARUSER_WIDTH+:C_AXI_ARUSER_WIDTH]),
        .M_AXI_ARVALID                    (M_AXI_ARVALID[slot*1+:1]),
        .M_AXI_ARREADY                    (M_AXI_ARREADY[slot*1+:1]),
        .M_AXI_RID                        (M_AXI_RID[slot*C_AXI_ID_MAX_WIDTH+:C_AXI_ID_WIDTH[slot*32+:32]]),
        .M_AXI_RDATA                      (M_AXI_RDATA[slot*C_AXI_DATA_MAX_WIDTH+:C_AXI_DATA_WIDTH[slot*32+:32]]),
        .M_AXI_RRESP                      (M_AXI_RRESP[slot*2+:2]),
        .M_AXI_RLAST                      (M_AXI_RLAST[slot*1+:1]),
        .M_AXI_RUSER                      (M_AXI_RUSER[slot*C_AXI_RUSER_WIDTH+:C_AXI_RUSER_WIDTH]),
        .M_AXI_RVALID                     (M_AXI_RVALID[slot*1+:1]),
        .M_AXI_RREADY                     (M_AXI_RREADY[slot*1+:1])
      );
    assign S_AXI_RDATA[slot*C_AXI_DATA_MAX_WIDTH+:C_AXI_DATA_MAX_WIDTH] = si_rs_rdata[slot*C_AXI_DATA_MAX_WIDTH+:C_AXI_DATA_WIDTH[slot*32+:32]] ;
    assign M_AXI_WDATA[slot*C_AXI_DATA_MAX_WIDTH+:C_AXI_DATA_MAX_WIDTH] = rs_mi_wdata[slot*C_AXI_DATA_MAX_WIDTH+:C_AXI_DATA_WIDTH[slot*32+:32]] ;
    assign M_AXI_WSTRB[slot*C_AXI_DATA_MAX_WIDTH/8+:C_AXI_DATA_MAX_WIDTH/8] = rs_mi_wstrb[slot*C_AXI_DATA_MAX_WIDTH/8+:C_AXI_DATA_WIDTH[slot*32+:32]/8] ;
    assign S_AXI_BID[slot*C_AXI_ID_MAX_WIDTH+:C_AXI_ID_MAX_WIDTH] = si_rs_bid[slot*C_AXI_ID_MAX_WIDTH+:C_AXI_ID_WIDTH[slot*32+:32]];
    assign S_AXI_RID[slot*C_AXI_ID_MAX_WIDTH+:C_AXI_ID_MAX_WIDTH] = si_rs_rid[slot*C_AXI_ID_MAX_WIDTH+:C_AXI_ID_WIDTH[slot*32+:32]];
    assign M_AXI_AWID[slot*C_AXI_ID_MAX_WIDTH+:C_AXI_ID_MAX_WIDTH] = rs_mi_awid[slot*C_AXI_ID_MAX_WIDTH+:C_AXI_ID_WIDTH[slot*32+:32]];
    assign M_AXI_WID[slot*C_AXI_ID_MAX_WIDTH+:C_AXI_ID_MAX_WIDTH] = rs_mi_wid[slot*C_AXI_ID_MAX_WIDTH+:C_AXI_ID_WIDTH[slot*32+:32]];
    assign M_AXI_ARID[slot*C_AXI_ID_MAX_WIDTH+:C_AXI_ID_MAX_WIDTH] = rs_mi_arid[slot*C_AXI_ID_MAX_WIDTH+:C_AXI_ID_WIDTH[slot*32+:32]];
  end
endgenerate

endmodule

`default_nettype wire


// -- (c) Copyright 2010 - 2011 Xilinx, Inc. All rights reserved.
// --
// -- This file contains confidential and proprietary information
// -- of Xilinx, Inc. and is protected under U.S. and 
// -- international copyright and other intellectual property
// -- laws.
// --
// -- DISCLAIMER
// -- This disclaimer is not a license and does not grant any
// -- rights to the materials distributed herewith. Except as
// -- otherwise provided in a valid license issued to you by
// -- Xilinx, and to the maximum extent permitted by applicable
// -- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
// -- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
// -- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
// -- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
// -- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
// -- (2) Xilinx shall not be liable (whether in contract or tort,
// -- including negligence, or under any other theory of
// -- liability) for any loss or damage of any kind or nature
// -- related to, arising under or in connection with these
// -- materials, including for any direct, or any indirect,
// -- special, incidental, or consequential loss or damage
// -- (including loss of data, profits, goodwill, or any type of
// -- loss or damage suffered as a result of any action brought
// -- by a third party) even if such damage or loss was
// -- reasonably foreseeable or Xilinx had been advised of the
// -- possibility of the same.
// --
// -- CRITICAL APPLICATIONS
// -- Xilinx products are not designed or intended to be fail-
// -- safe, or for use in any application requiring fail-safe
// -- performance, such as life-support or safety devices or
// -- systems, Class III medical devices, nuclear facilities,
// -- applications related to the deployment of airbags, or any
// -- other applications that could lead to death, personal
// -- injury, or severe property or environmental damage
// -- (individually and collectively, "Critical
// -- Applications"). Customer assumes the sole risk and
// -- liability of any use of Xilinx products in Critical
// -- Applications, subject only to applicable laws and
// -- regulations governing limitations on product liability.
// --
// -- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
// -- PART OF THIS FILE AT ALL TIMES.
//-----------------------------------------------------------------------------
//
// Description: Read Data Response Up-Sizer
// Extract SI-side Data from packed and unpacked MI-side data.
//
// Verilog-standard:  Verilog 2001
//--------------------------------------------------------------------------
//
// Structure:
//   r_upsizer
//
//--------------------------------------------------------------------------
`timescale 1ps/1ps


(* DowngradeIPIdentifiedWarnings="yes" *) 
module axi_interconnect_v1_7_13_r_upsizer #
  (
   parameter         C_FAMILY                         = "rtl", 
                       // FPGA Family. Current version: virtex6 or spartan6.
   parameter integer C_AXI_ID_WIDTH                   = 4, 
                       // Width of all ID signals on SI and MI side of converter.
                       // Range: >= 1.
   parameter         C_S_AXI_DATA_WIDTH               = 32'h00000020, 
                       // Width of S_AXI_WDATA and S_AXI_RDATA.
                       // Format: Bit32; 
                       // Range: 'h00000020, 'h00000040, 'h00000080, 'h00000100.
   parameter         C_M_AXI_DATA_WIDTH               = 32'h00000040, 
                       // Width of M_AXI_WDATA and M_AXI_RDATA.
                       // Assume greater than or equal to C_S_AXI_DATA_WIDTH.
                       // Format: Bit32;
                       // Range: 'h00000020, 'h00000040, 'h00000080, 'h00000100.
   parameter integer C_S_AXI_REGISTER                 = 0,
                       // Clock output data.
                       // Range: 0, 1
   parameter integer C_AXI_SUPPORTS_USER_SIGNALS      = 0,
                       // 1 = Propagate all USER signals, 0 = Dont propagate.
   parameter integer C_AXI_RUSER_WIDTH                = 1,
                       // Width of RUSER signals. 
                       // Range: >= 1.
   parameter integer C_PACKING_LEVEL                    = 1,
                       // 0 = Never pack (expander only); packing logic is omitted.
                       // 1 = Pack only when CACHE[1] (Modifiable) is high.
                       // 2 = Always pack, regardless of sub-size transaction or Modifiable bit.
                       //     (Required when used as helper-core by mem-con.)
   parameter integer C_SUPPORT_BURSTS                 = 1,
                       // Disabled when all connected masters and slaves are AxiLite,
                       //   allowing logic to be simplified.
   parameter integer C_S_AXI_BYTES_LOG                = 3,
                       // Log2 of number of 32bit word on SI-side.
   parameter integer C_M_AXI_BYTES_LOG                = 3,
                       // Log2 of number of 32bit word on MI-side.
   parameter integer C_RATIO                          = 2,
                       // Up-Sizing ratio for data.
   parameter integer C_RATIO_LOG                      = 1
                       // Log2 of Up-Sizing ratio for data.
   )
  (
   // Global Signals
   input  wire                                                    ARESET,
   input  wire                                                    ACLK,

   // Command Interface
   input  wire                              cmd_valid,
   input  wire                              cmd_fix,
   input  wire                              cmd_modified,
   input  wire                              cmd_complete_wrap,
   input  wire                              cmd_packed_wrap,
   input  wire [C_M_AXI_BYTES_LOG-1:0]      cmd_first_word, 
   input  wire [C_M_AXI_BYTES_LOG-1:0]      cmd_next_word,
   input  wire [C_M_AXI_BYTES_LOG-1:0]      cmd_last_word,
   input  wire [C_M_AXI_BYTES_LOG-1:0]      cmd_offset,
   input  wire [C_M_AXI_BYTES_LOG-1:0]      cmd_mask,
   input  wire [C_S_AXI_BYTES_LOG:0]        cmd_step,
   input  wire [8-1:0]                      cmd_length,
   output wire                              cmd_ready,
   
   // Slave Interface Read Data Ports
   output wire [C_AXI_ID_WIDTH-1:0]           S_AXI_RID,
   output wire [C_S_AXI_DATA_WIDTH-1:0]    S_AXI_RDATA,
   output wire [2-1:0]                          S_AXI_RRESP,
   output wire                                                    S_AXI_RLAST,
   output wire [C_AXI_RUSER_WIDTH-1:0]          S_AXI_RUSER,
   output wire                                                    S_AXI_RVALID,
   input  wire                                                    S_AXI_RREADY,

   // Master Interface Read Data Ports
   input  wire [C_AXI_ID_WIDTH-1:0]          M_AXI_RID,
   input  wire [C_M_AXI_DATA_WIDTH-1:0]    M_AXI_RDATA,
   input  wire [2-1:0]                         M_AXI_RRESP,
   input  wire                                                   M_AXI_RLAST,
   input  wire [C_AXI_RUSER_WIDTH-1:0]         M_AXI_RUSER,
   input  wire                                                   M_AXI_RVALID,
   output wire                                                   M_AXI_RREADY
   );
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Variables for generating parameter controlled instances.
  /////////////////////////////////////////////////////////////////////////////
  
  genvar bit_cnt;
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Local params
  /////////////////////////////////////////////////////////////////////////////
  
  // Constants for packing levels.
  localparam integer C_NEVER_PACK        = 0;
  localparam integer C_DEFAULT_PACK      = 1;
  localparam integer C_ALWAYS_PACK       = 2;
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Functions
  /////////////////////////////////////////////////////////////////////////////
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Internal signals
  /////////////////////////////////////////////////////////////////////////////
  
  // Sub-word handling.
  wire                            sel_first_word;
  reg                             first_word;
  reg  [C_M_AXI_BYTES_LOG-1:0]    current_word_1;
  reg  [C_M_AXI_BYTES_LOG-1:0]    current_word_cmb;
  wire [C_M_AXI_BYTES_LOG-1:0]    current_word;
  wire [C_M_AXI_BYTES_LOG-1:0]    current_word_adjusted;
  wire                            last_beat;
  wire                            last_word;
  wire [C_M_AXI_BYTES_LOG-1:0]    cmd_step_i;
  
  // Sub-word handling for the next cycle.
  wire [C_M_AXI_BYTES_LOG-1:0]    pre_next_word_i;
  wire [C_M_AXI_BYTES_LOG-1:0]    pre_next_word;
  reg  [C_M_AXI_BYTES_LOG-1:0]    pre_next_word_1;
  wire [C_M_AXI_BYTES_LOG-1:0]    next_word_i;
  wire [C_M_AXI_BYTES_LOG-1:0]    next_word;
  
  // Burst length handling.
  wire                            first_mi_word;
  wire [8-1:0]                    length_counter_1;
  reg  [8-1:0]                    length_counter;
  wire [8-1:0]                    next_length_counter;
  
  // Handle wrap buffering.
  wire                            store_in_wrap_buffer;
  reg                             use_wrap_buffer;
  reg                             wrap_buffer_available;
  reg [C_AXI_ID_WIDTH-1:0]        rid_wrap_buffer;
  reg [2-1:0]                     rresp_wrap_buffer;
  reg [C_AXI_RUSER_WIDTH-1:0]     ruser_wrap_buffer;
  
  // Throttling help signals.
  wire                            next_word_wrap;
  wire                            word_complete_next_wrap;
  wire                            word_complete_next_wrap_ready;
  wire                            word_complete_next_wrap_pop;
  wire                            word_complete_last_word;
  wire                            word_complete_rest;
  wire                            word_complete_rest_ready;
  wire                            word_complete_rest_pop;
  wire                            word_completed;
  wire                            cmd_ready_i;
  wire                            pop_si_data;
  wire                            pop_mi_data;
  wire                            si_stalling;
  
  // Internal signals for MI-side.
  reg  [C_M_AXI_DATA_WIDTH-1:0]   M_AXI_RDATA_I;
  wire                            M_AXI_RLAST_I;
  wire                            M_AXI_RVALID_I;
  wire                            M_AXI_RREADY_I;
  
  // Internal signals for SI-side.
  wire [C_AXI_ID_WIDTH-1:0]       S_AXI_RID_I;
  wire [C_S_AXI_DATA_WIDTH-1:0]   S_AXI_RDATA_I;
  wire [2-1:0]                    S_AXI_RRESP_I;
  wire                            S_AXI_RLAST_I;
  wire [C_AXI_RUSER_WIDTH-1:0]    S_AXI_RUSER_I;
  wire                            S_AXI_RVALID_I;
  wire                            S_AXI_RREADY_I;
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Handle interface handshaking:
  //
  // Determine if a MI side word has been completely used. For FIX transactions
  // the MI-side word is used to extract a single data word. This is also true
  // for for an upsizer in Expander mode (Never Pack). Unmodified burst also 
  // only use the MI word to extract a single SI-side word (although with 
  // different offsets).
  // Otherwise is the MI-side word considered to be used when last SI-side beat
  // has been extracted or when the last (most significant) SI-side word has 
  // been extracted from ti MI word.
  //
  // Data on the SI-side is available when data is being taken from MI-side or
  // from wrap buffer.
  //
  // The command is popped from the command queue once the last beat on the 
  // SI-side has been ackowledged.
  //
  /////////////////////////////////////////////////////////////////////////////
  
  generate
    if ( C_RATIO_LOG > 1 ) begin : USE_LARGE_UPSIZING
      assign cmd_step_i = {{C_RATIO_LOG-1{1'b0}}, cmd_step};
    end else begin : NO_LARGE_UPSIZING
      assign cmd_step_i = cmd_step;
    end
  endgenerate
  
  generate
    if ( C_FAMILY == "rtl" || ( C_SUPPORT_BURSTS == 0 ) || 
       ( C_PACKING_LEVEL == C_NEVER_PACK ) ) begin : USE_RTL_WORD_COMPLETED
      // Detect when MI-side word is completely used.
      assign word_completed = cmd_valid & 
                              ( ( cmd_fix ) |
                                ( ~cmd_fix & ~cmd_complete_wrap & next_word == {C_M_AXI_BYTES_LOG{1'b0}} ) | 
                                ( ~cmd_fix & last_word & ~use_wrap_buffer ) | 
                                ( ~cmd_modified & ( C_PACKING_LEVEL == C_DEFAULT_PACK ) ) |
                                ( C_PACKING_LEVEL == C_NEVER_PACK ) |
                                ( C_SUPPORT_BURSTS == 0 ) );
      
      // RTL equivalent of optimized partial extressions (address wrap for next word).
      assign word_complete_next_wrap       = ( ~cmd_fix & ~cmd_complete_wrap & next_word == {C_M_AXI_BYTES_LOG{1'b0}} ) | 
                                            ( C_PACKING_LEVEL == C_NEVER_PACK ) |
                                            ( C_SUPPORT_BURSTS == 0 );
      assign word_complete_next_wrap_ready = word_complete_next_wrap & M_AXI_RVALID_I & ~si_stalling;
      assign word_complete_next_wrap_pop   = word_complete_next_wrap_ready & M_AXI_RVALID_I;
      
      // RTL equivalent of optimized partial extressions (last word and the remaining).
      assign word_complete_last_word  = last_word & (~cmd_fix & ~use_wrap_buffer);
      assign word_complete_rest       = word_complete_last_word | cmd_fix | 
                                        ( ~cmd_modified & ( C_PACKING_LEVEL == C_DEFAULT_PACK ) );
      assign word_complete_rest_ready = word_complete_rest & M_AXI_RVALID_I & ~si_stalling;
      assign word_complete_rest_pop   = word_complete_rest_ready & M_AXI_RVALID_I;
      
    end else begin : USE_FPGA_WORD_COMPLETED
    
      wire sel_word_complete_next_wrap;
      wire sel_word_completed;
      wire sel_m_axi_rready;
      wire sel_word_complete_last_word;
      wire sel_word_complete_rest;
      
      // Optimize next word address wrap branch of expression.
      //
  axi_interconnect_v1_7_13_comparator_sel_static #
        (
         .C_FAMILY(C_FAMILY),
         .C_VALUE({C_M_AXI_BYTES_LOG{1'b0}}),
         .C_DATA_WIDTH(C_M_AXI_BYTES_LOG)
         ) next_word_wrap_inst
        (
         .CIN(1'b1),
         .S(sel_first_word),
         .A(pre_next_word_1),
         .B(cmd_next_word),
         .COUT(next_word_wrap)
         );
         
      assign sel_word_complete_next_wrap = ~cmd_fix & ~cmd_complete_wrap;
      
  axi_interconnect_v1_7_13_carry_and #
        (
         .C_FAMILY(C_FAMILY)
         ) word_complete_next_wrap_inst
        (
         .CIN(next_word_wrap),
         .S(sel_word_complete_next_wrap),
         .COUT(word_complete_next_wrap)
         );
         
      assign sel_m_axi_rready = cmd_valid & S_AXI_RREADY_I;
      
  axi_interconnect_v1_7_13_carry_and #
        (
         .C_FAMILY(C_FAMILY)
         ) word_complete_next_wrap_ready_inst
        (
         .CIN(word_complete_next_wrap),
         .S(sel_m_axi_rready),
         .COUT(word_complete_next_wrap_ready)
         );
      
  axi_interconnect_v1_7_13_carry_and #
        (
         .C_FAMILY(C_FAMILY)
         ) word_complete_next_wrap_pop_inst
        (
         .CIN(word_complete_next_wrap_ready),
         .S(M_AXI_RVALID_I),
         .COUT(word_complete_next_wrap_pop)
         );
      
      // Optimize last word and "rest" branch of expression.
      //
      assign sel_word_complete_last_word = ~cmd_fix & ~use_wrap_buffer;
      
  axi_interconnect_v1_7_13_carry_and #
        (
         .C_FAMILY(C_FAMILY)
         ) word_complete_last_word_inst
        (
         .CIN(last_word),
         .S(sel_word_complete_last_word),
         .COUT(word_complete_last_word)
         );
      
      assign sel_word_complete_rest = cmd_fix | ( ~cmd_modified & ( C_PACKING_LEVEL == C_DEFAULT_PACK ) );
      
  axi_interconnect_v1_7_13_carry_or #
        (
         .C_FAMILY(C_FAMILY)
         ) word_complete_rest_inst
        (
         .CIN(word_complete_last_word),
         .S(sel_word_complete_rest),
         .COUT(word_complete_rest)
         );
         
  axi_interconnect_v1_7_13_carry_and #
        (
         .C_FAMILY(C_FAMILY)
         ) word_complete_rest_ready_inst
        (
         .CIN(word_complete_rest),
         .S(sel_m_axi_rready),
         .COUT(word_complete_rest_ready)
         );
      
  axi_interconnect_v1_7_13_carry_and #
        (
         .C_FAMILY(C_FAMILY)
         ) word_complete_rest_pop_inst
        (
         .CIN(word_complete_rest_ready),
         .S(M_AXI_RVALID_I),
         .COUT(word_complete_rest_pop)
         );
      
      // Combine the two branches to generate the full signal.
      assign word_completed = word_complete_next_wrap | word_complete_rest;
      
    end
  endgenerate
  
  // Only propagate Valid when there is command information available.
  assign M_AXI_RVALID_I = M_AXI_RVALID & cmd_valid;
  
  generate
    if ( C_FAMILY == "rtl" ) begin : USE_RTL_CTRL
      // Pop word from MI-side.
      assign M_AXI_RREADY_I = word_completed & S_AXI_RREADY_I;
      
      // Get MI-side data.
      assign pop_mi_data    = M_AXI_RVALID_I & M_AXI_RREADY_I;
      
      // Signal that the command is done (so that it can be poped from command queue).
      assign cmd_ready_i    = cmd_valid & S_AXI_RLAST_I & pop_si_data;
      
    end else begin : USE_FPGA_CTRL
      wire sel_cmd_ready;
      
      assign M_AXI_RREADY_I = word_complete_next_wrap_ready | word_complete_rest_ready;
      
      assign pop_mi_data    = word_complete_next_wrap_pop | word_complete_rest_pop;
      
      assign sel_cmd_ready  = cmd_valid & pop_si_data;
    
  axi_interconnect_v1_7_13_carry_latch_and #
        (
         .C_FAMILY(C_FAMILY)
         ) cmd_ready_inst
        (
         .CIN(S_AXI_RLAST_I),
         .I(sel_cmd_ready),
         .O(cmd_ready_i)
         );
      
    end
  endgenerate
  
  // Indicate when there is data available @ SI-side.
  assign S_AXI_RVALID_I = ( M_AXI_RVALID_I | use_wrap_buffer );
  
  // Get SI-side data.
  assign pop_si_data    = S_AXI_RVALID_I & S_AXI_RREADY_I;
  
  // Assign external signals.
  assign M_AXI_RREADY   = M_AXI_RREADY_I;
  assign cmd_ready      = cmd_ready_i;
  
  // Detect when SI-side is stalling.
  assign si_stalling    = S_AXI_RVALID_I & ~S_AXI_RREADY_I;
                          
  
  /////////////////////////////////////////////////////////////////////////////
  // Keep track of data extraction:
  // 
  // Current address is taken form the command buffer for the first data beat
  // to handle unaligned Read transactions. After this is the extraction 
  // address usually calculated from this point.
  // FIX transactions uses the same word address for all data beats. 
  // 
  // Next word address is generated as current word plus the current step 
  // size, with masking to facilitate sub-sized wraping. The Mask is all ones
  // for normal wraping, and less when sub-sized wraping is used.
  // 
  // The calculated word addresses (current and next) is offseted by the 
  // current Offset. For sub-sized transaction the Offset points to the least 
  // significant address of the included data beats. (The least significant 
  // word is not necessarily the first data to be extracted, consider WRAP).
  // Offset is only used for sub-sized WRAP transcation that are Complete.
  // 
  // First word is active during the first SI-side data beat.
  // 
  // First MI is set while the entire first MI-side word is processed.
  //
  // The transaction length is taken from the command buffer combinatorialy
  // during the First MI cycle. For each used MI word it is decreased until 
  // Last beat is reached.
  // 
  // Last word is determined depending on the current command, i.e. modified 
  // burst has to scale since multiple words could be packed into one MI-side
  // word.
  // Last word is 1:1 for:
  // FIX, when burst support is disabled or unmodified for Normal Pack.
  // Last word is scaled for all other transactions.
  //
  /////////////////////////////////////////////////////////////////////////////
  
  // Select if the offset comes from command queue directly or 
  // from a counter while when extracting multiple SI words per MI word
  assign sel_first_word = first_word | cmd_fix;
  assign current_word   = sel_first_word ? cmd_first_word : 
                                           current_word_1;
  
  generate
    if ( C_FAMILY == "rtl" ) begin : USE_RTL_NEXT_WORD
      
      // Calculate next word.
      assign pre_next_word_i  = ( next_word_i + cmd_step_i );
      
      // Calculate next word.
      assign next_word_i      = sel_first_word ? cmd_next_word : 
                                                 pre_next_word_1;
      
    end else begin : USE_FPGA_NEXT_WORD
      wire [C_M_AXI_BYTES_LOG-1:0]  next_sel;
      wire [C_M_AXI_BYTES_LOG:0]    next_carry_local;

      // Assign input to local vectors.
      assign next_carry_local[0]      = 1'b0;
    
      // Instantiate one carry and per level.
      for (bit_cnt = 0; bit_cnt < C_M_AXI_BYTES_LOG ; bit_cnt = bit_cnt + 1) begin : LUT_LEVEL
        
        LUT6_2 # (
         .INIT(64'h5A5A_5A66_F0F0_F0CC) 
        ) LUT6_2_inst (
        .O6(next_sel[bit_cnt]),         // 6/5-LUT output (1-bit)
        .O5(next_word_i[bit_cnt]),      // 5-LUT output (1-bit)
        .I0(cmd_step_i[bit_cnt]),       // LUT input (1-bit)
        .I1(pre_next_word_1[bit_cnt]),  // LUT input (1-bit)
        .I2(cmd_next_word[bit_cnt]),    // LUT input (1-bit)
        .I3(first_word),                // LUT input (1-bit)
        .I4(cmd_fix),                   // LUT input (1-bit)
        .I5(1'b1)                       // LUT input (1-bit)
        );
        
        MUXCY next_carry_inst 
        (
         .O (next_carry_local[bit_cnt+1]), 
         .CI (next_carry_local[bit_cnt]), 
         .DI (cmd_step_i[bit_cnt]), 
         .S (next_sel[bit_cnt])
        ); 
        
        XORCY next_xorcy_inst 
        (
         .O(pre_next_word_i[bit_cnt]),
         .CI(next_carry_local[bit_cnt]),
         .LI(next_sel[bit_cnt])
        );
        
      end // end for bit_cnt
      
    end
  endgenerate
  
  // Calculate next word.
  assign next_word              = next_word_i     & cmd_mask;
  assign pre_next_word          = pre_next_word_i & cmd_mask;
  
  // Calculate the word address with offset.
  assign current_word_adjusted  = current_word | cmd_offset;
  
  // Prepare next word address.
  always @ (posedge ACLK) begin
    if (ARESET) begin
      first_word      <= 1'b1;
      current_word_1  <= 'b0;
      pre_next_word_1 <= {C_M_AXI_BYTES_LOG{1'b0}};
    end else begin
      if ( pop_si_data ) begin
        if ( last_word ) begin
          // Prepare for next access.
          first_word      <=  1'b1;
        end else begin
          first_word      <=  1'b0;
        end
      
        current_word_1  <= next_word;
        pre_next_word_1 <= pre_next_word;
      end
    end
  end
  
  // Select command length or counted length.
  always @ *
  begin
    if ( first_mi_word )
      length_counter = cmd_length;
    else
      length_counter = length_counter_1;
  end
  
  // Calculate next length counter value.
  assign next_length_counter = length_counter - 1'b1;
  
  generate
    if ( C_FAMILY == "rtl" ) begin : USE_RTL_LENGTH
      reg  [8-1:0]                    length_counter_q;
      reg                             first_mi_word_q;
    
      always @ (posedge ACLK) begin
        if (ARESET) begin
          first_mi_word_q  <= 1'b1;
          length_counter_q <= 8'b0;
        end else begin
          if ( pop_mi_data ) begin
            if ( M_AXI_RLAST ) begin
              first_mi_word_q  <= 1'b1;
            end else begin
              first_mi_word_q  <= 1'b0;
            end
          
            length_counter_q <= next_length_counter;
          end
        end
      end
      
      assign first_mi_word    = first_mi_word_q;
      assign length_counter_1 = length_counter_q;
      
    end else begin : USE_FPGA_LENGTH
      wire [8-1:0]  length_counter_i;
      wire [8-1:0]  length_sel;
      wire [8-1:0]  length_di;
      wire [8:0]    length_local_carry;
      
      // Assign input to local vectors.
      assign length_local_carry[0] = 1'b0;
    
      for (bit_cnt = 0; bit_cnt < 8 ; bit_cnt = bit_cnt + 1) begin : BIT_LANE

        LUT6_2 # (
         .INIT(64'h333C_555A_FFF0_FFF0) 
        ) LUT6_2_inst (
        .O6(length_sel[bit_cnt]),           // 6/5-LUT output (1-bit)
        .O5(length_di[bit_cnt]),            // 5-LUT output (1-bit)
        .I0(length_counter_1[bit_cnt]),     // LUT input (1-bit)
        .I1(cmd_length[bit_cnt]),           // LUT input (1-bit)
        .I2(word_complete_next_wrap_pop),  // LUT input (1-bit)
        .I3(word_complete_rest_pop),        // LUT input (1-bit)
        .I4(first_mi_word),                 // LUT input (1-bit)
        .I5(1'b1)                           // LUT input (1-bit)
        );
        
        MUXCY and_inst 
        (
         .O (length_local_carry[bit_cnt+1]), 
         .CI (length_local_carry[bit_cnt]), 
         .DI (length_di[bit_cnt]), 
         .S (length_sel[bit_cnt])
        ); 
        
        XORCY xorcy_inst 
        (
         .O(length_counter_i[bit_cnt]),
         .CI(length_local_carry[bit_cnt]),
         .LI(length_sel[bit_cnt])
        );
        
        FDRE #(
         .INIT(1'b0)                    // Initial value of register (1'b0 or 1'b1)
         ) FDRE_inst (
         .Q(length_counter_1[bit_cnt]), // Data output
         .C(ACLK),                      // Clock input
         .CE(1'b1),                     // Clock enable input
         .R(ARESET),                    // Synchronous reset input
         .D(length_counter_i[bit_cnt])  // Data input
         );
      end // end for bit_cnt
      
      wire first_mi_word_i;
      
      LUT6 # (
       .INIT(64'hAAAC_AAAC_AAAC_AAAC) 
      ) LUT6_cnt_inst (
      .O(first_mi_word_i),                // 6-LUT output (1-bit)
      .I0(M_AXI_RLAST),                   // LUT input (1-bit)
      .I1(first_mi_word),                 // LUT input (1-bit)
      .I2(word_complete_next_wrap_pop),  // LUT input (1-bit)
      .I3(word_complete_rest_pop),        // LUT input (1-bit)
      .I4(1'b1),                          // LUT input (1-bit)
      .I5(1'b1)                           // LUT input (1-bit)
      );
          
      FDSE #(
       .INIT(1'b1)                    // Initial value of register (1'b0 or 1'b1)
       ) FDRE_inst (
       .Q(first_mi_word),             // Data output
       .C(ACLK),                      // Clock input
       .CE(1'b1),                     // Clock enable input
       .S(ARESET),                    // Synchronous reset input
       .D(first_mi_word_i)            // Data input
       );
      
    end
  endgenerate
  
  generate
    if ( C_FAMILY == "rtl" || C_SUPPORT_BURSTS == 0 ) begin : USE_RTL_LAST_WORD
      // Detect last beat in a burst.
      assign last_beat = ( length_counter == 8'b0 );
      
      // Determine if this last word that shall be extracted from this MI-side word.
      assign last_word = ( last_beat & ( current_word == cmd_last_word ) & ~wrap_buffer_available & ( current_word == cmd_last_word ) ) |
                         ( use_wrap_buffer & ( current_word == cmd_last_word ) ) |
                         ( last_beat & ( current_word == cmd_last_word ) & ( C_PACKING_LEVEL == C_NEVER_PACK ) ) |
                         ( C_SUPPORT_BURSTS == 0 );
  
    end else begin : USE_FPGA_LAST_WORD
    
      wire sel_last_word;
      wire last_beat_ii;
      
      
  axi_interconnect_v1_7_13_comparator_sel_static #
        (
         .C_FAMILY(C_FAMILY),
         .C_VALUE(8'b0),
         .C_DATA_WIDTH(8)
         ) last_beat_inst
        (
         .CIN(1'b1),
         .S(first_mi_word),
         .A(length_counter_1),
         .B(cmd_length),
         .COUT(last_beat)
         );
      
      if ( C_PACKING_LEVEL != C_NEVER_PACK  ) begin : USE_FPGA_PACK
        // 
        //
        wire sel_last_beat;
        wire last_beat_i;
        
        assign sel_last_beat = ~wrap_buffer_available;
        
  axi_interconnect_v1_7_13_carry_and #
          (
           .C_FAMILY(C_FAMILY)
           ) last_beat_inst_1
          (
           .CIN(last_beat),
           .S(sel_last_beat),
           .COUT(last_beat_i)
           );
  
  axi_interconnect_v1_7_13_carry_or #
          (
           .C_FAMILY(C_FAMILY)
           ) last_beat_wrap_inst
          (
           .CIN(last_beat_i),
           .S(use_wrap_buffer),
           .COUT(last_beat_ii)
           );
  
      end else begin : NO_PACK
        assign last_beat_ii = last_beat;
           
      end
        
  axi_interconnect_v1_7_13_comparator_sel #
        (
         .C_FAMILY(C_FAMILY),
         .C_DATA_WIDTH(C_M_AXI_BYTES_LOG)
         ) last_beat_curr_word_inst
        (
         .CIN(last_beat_ii),
         .S(sel_first_word),
         .A(current_word_1),
         .B(cmd_first_word),
         .V(cmd_last_word),
         .COUT(last_word)
         );
      
    end
  endgenerate
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Handle wrap buffer:
  // 
  // The wrap buffer is used to move data around in an unaligned WRAP 
  // transaction. The requested read address has been rounded down, meaning 
  // that parts of the first MI-side data beat has to be delayed for later use.
  // The extraction starts at the origian unaligned address, the remaining data
  // is stored in the wrap buffer to be extracted after the last MI-side data 
  // beat has been fully processed.
  // For example: an 32bit to 64bit read upsizing @ 0x4 will request a MI-side
  // read WRAP transaction 0x0. The 0x4 data word is used at once and the 0x0 
  // word is delayed to be used after all data in the last MI-side beat has 
  // arrived.
  // 
  /////////////////////////////////////////////////////////////////////////////
  
  // Save data to be able to perform buffer wraping.
  assign store_in_wrap_buffer = M_AXI_RVALID_I & cmd_packed_wrap & first_mi_word & ~use_wrap_buffer;
  
  // Mark that there are data available for wrap buffering.
  always @ (posedge ACLK) begin
    if (ARESET) begin
      wrap_buffer_available <= 1'b0;
    end else begin
      if ( store_in_wrap_buffer & word_completed & pop_si_data  ) begin
        wrap_buffer_available <= 1'b1;
      end else if ( last_beat & word_completed & pop_si_data  ) begin
        wrap_buffer_available <= 1'b0;
      end
    end
  end
  
  // Start using the wrap buffer.
  always @ (posedge ACLK) begin
    if (ARESET) begin
      use_wrap_buffer <= 1'b0;
    end else begin
      if ( wrap_buffer_available & last_beat & word_completed & pop_si_data ) begin
        use_wrap_buffer <= 1'b1;
      end else if ( cmd_ready_i ) begin
        use_wrap_buffer <= 1'b0;
      end
    end
  end
  
  // Store data in wrap buffer.
  always @ (posedge ACLK) begin
    if (ARESET) begin
      M_AXI_RDATA_I     <= {C_M_AXI_DATA_WIDTH{1'b0}};
      rid_wrap_buffer   <= {C_AXI_ID_WIDTH{1'b0}};
      rresp_wrap_buffer <= 2'b0;
      ruser_wrap_buffer <= {C_AXI_ID_WIDTH{1'b0}};
    end else begin
      if ( store_in_wrap_buffer ) begin
        M_AXI_RDATA_I     <= M_AXI_RDATA;
        rid_wrap_buffer   <= M_AXI_RID;
        rresp_wrap_buffer <= M_AXI_RRESP;
        ruser_wrap_buffer <= M_AXI_RUSER;
      end
    end
  end
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Select the SI-side word to read.
  //
  // Everything must be multiplexed since the next transfer can be arriving 
  // with a different set of signals while the wrap buffer is still being 
  // processed for the current transaction.
  // 
  // Non modifiable word has a 1:1 ratio, i.e. only one SI-side word is 
  // generated per MI-side word.
  // Data is taken either directly from the incomming MI-side data or the 
  // wrap buffer (for packed WRAP).
  //
  // Last need special handling since it is the last SI-side word generated 
  // from the MI-side word.
  //
  /////////////////////////////////////////////////////////////////////////////
  
  // ID, RESP and USER has to be multiplexed.
  assign S_AXI_RID_I    = ( use_wrap_buffer & ( C_SUPPORT_BURSTS == 1 ) ) ? 
                          rid_wrap_buffer :
                          M_AXI_RID;
  assign S_AXI_RRESP_I  = ( use_wrap_buffer & ( C_SUPPORT_BURSTS == 1 ) ) ? 
                          rresp_wrap_buffer :
                          M_AXI_RRESP;
  assign S_AXI_RUSER_I  = ( C_AXI_SUPPORTS_USER_SIGNALS ) ? 
                            ( use_wrap_buffer & ( C_SUPPORT_BURSTS == 1 ) ) ? 
                            ruser_wrap_buffer :
                            M_AXI_RUSER :
                          {C_AXI_RUSER_WIDTH{1'b0}};
                          
  // Data has to be multiplexed.
  generate
    if ( C_RATIO == 1 ) begin : SINGLE_WORD
      assign S_AXI_RDATA_I  = ( use_wrap_buffer & ( C_SUPPORT_BURSTS == 1 ) ) ? 
                              M_AXI_RDATA_I :
                              M_AXI_RDATA;
    end else begin : MULTIPLE_WORD
      // Get the ratio bits (MI-side words vs SI-side words).
      wire [C_RATIO_LOG-1:0]          current_index;
      assign current_index  = current_word_adjusted[C_M_AXI_BYTES_LOG-C_RATIO_LOG +: C_RATIO_LOG];
      
      assign S_AXI_RDATA_I  = ( use_wrap_buffer & ( C_SUPPORT_BURSTS == 1 ) ) ? 
                              M_AXI_RDATA_I[current_index * C_S_AXI_DATA_WIDTH +: C_S_AXI_DATA_WIDTH] :
                              M_AXI_RDATA[current_index * C_S_AXI_DATA_WIDTH +: C_S_AXI_DATA_WIDTH];
    end
  endgenerate
  
  // Generate the true last flag including "keep" while using wrap buffer.
  assign M_AXI_RLAST_I  = ( M_AXI_RLAST | use_wrap_buffer );
  
  // Handle last flag, i.e. set for SI-side last word.
  assign S_AXI_RLAST_I  = last_word;
  
  
  /////////////////////////////////////////////////////////////////////////////
  // SI-side output handling
  /////////////////////////////////////////////////////////////////////////////
  
  generate
    if ( C_S_AXI_REGISTER ) begin : USE_REGISTER
      reg  [C_AXI_ID_WIDTH-1:0]       S_AXI_RID_q;
      reg  [C_S_AXI_DATA_WIDTH-1:0]   S_AXI_RDATA_q;
      reg  [2-1:0]                    S_AXI_RRESP_q;
      reg                             S_AXI_RLAST_q;
      reg  [C_AXI_RUSER_WIDTH-1:0]    S_AXI_RUSER_q;
      reg                             S_AXI_RVALID_q;
      reg                             S_AXI_RREADY_q;
    
      // Register SI-side Data.
      always @ (posedge ACLK) begin
        if (ARESET) begin
          S_AXI_RID_q       <= {C_AXI_ID_WIDTH{1'b0}};
          S_AXI_RDATA_q     <= {C_S_AXI_DATA_WIDTH{1'b0}};
          S_AXI_RRESP_q     <= 2'b0;
          S_AXI_RLAST_q     <= 1'b0;
          S_AXI_RUSER_q     <= {C_AXI_RUSER_WIDTH{1'b0}};
          S_AXI_RVALID_q    <= 1'b0;
        end else begin
          if ( S_AXI_RREADY_I ) begin
            S_AXI_RID_q       <= S_AXI_RID_I;
            S_AXI_RDATA_q     <= S_AXI_RDATA_I;
            S_AXI_RRESP_q     <= S_AXI_RRESP_I;
            S_AXI_RLAST_q     <= S_AXI_RLAST_I;
            S_AXI_RUSER_q     <= S_AXI_RUSER_I;
            S_AXI_RVALID_q    <= S_AXI_RVALID_I;
          end
          
        end
      end
      
      assign S_AXI_RID      = S_AXI_RID_q;
      assign S_AXI_RDATA    = S_AXI_RDATA_q;
      assign S_AXI_RRESP    = S_AXI_RRESP_q;
      assign S_AXI_RLAST    = S_AXI_RLAST_q;
      assign S_AXI_RUSER    = S_AXI_RUSER_q;
      assign S_AXI_RVALID   = S_AXI_RVALID_q;
      assign S_AXI_RREADY_I = ( S_AXI_RVALID_q & S_AXI_RREADY) | ~S_AXI_RVALID_q;
      
    end else begin : NO_REGISTER
    
      // Combinatorial SI-side Data.
      assign S_AXI_RREADY_I = S_AXI_RREADY;
      assign S_AXI_RVALID   = S_AXI_RVALID_I;
      assign S_AXI_RID      = S_AXI_RID_I;
      assign S_AXI_RDATA    = S_AXI_RDATA_I;
      assign S_AXI_RRESP    = S_AXI_RRESP_I;
      assign S_AXI_RLAST    = S_AXI_RLAST_I;
      assign S_AXI_RUSER    = S_AXI_RUSER_I;
  
    end
  endgenerate
  
  
endmodule



// -- (c) Copyright 2009 - 2011 Xilinx, Inc. All rights reserved.
// --
// -- This file contains confidential and proprietary information
// -- of Xilinx, Inc. and is protected under U.S. and 
// -- international copyright and other intellectual property
// -- laws.
// --
// -- DISCLAIMER
// -- This disclaimer is not a license and does not grant any
// -- rights to the materials distributed herewith. Except as
// -- otherwise provided in a valid license issued to you by
// -- Xilinx, and to the maximum extent permitted by applicable
// -- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
// -- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
// -- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
// -- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
// -- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
// -- (2) Xilinx shall not be liable (whether in contract or tort,
// -- including negligence, or under any other theory of
// -- liability) for any loss or damage of any kind or nature
// -- related to, arising under or in connection with these
// -- materials, including for any direct, or any indirect,
// -- special, incidental, or consequential loss or damage
// -- (including loss of data, profits, goodwill, or any type of
// -- loss or damage suffered as a result of any action brought
// -- by a third party) even if such damage or loss was
// -- reasonably foreseeable or Xilinx had been advised of the
// -- possibility of the same.
// --
// -- CRITICAL APPLICATIONS
// -- Xilinx products are not designed or intended to be fail-
// -- safe, or for use in any application requiring fail-safe
// -- performance, such as life-support or safety devices or
// -- systems, Class III medical devices, nuclear facilities,
// -- applications related to the deployment of airbags, or any
// -- other applications that could lead to death, personal
// -- injury, or severe property or environmental damage
// -- (individually and collectively, "Critical
// -- Applications"). Customer assumes the sole risk and
// -- liability of any use of Xilinx products in Critical
// -- Applications, subject only to applicable laws and
// -- regulations governing limitations on product liability.
// --
// -- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
// -- PART OF THIS FILE AT ALL TIMES.
//-----------------------------------------------------------------------------
//
// File name: si_transactor.v
//
// Description: 
//   This module manages multi-threaded transactions for one SI-slot.
//   The module interface consists of a 1-slave to 1-master address channel, plus a
//     (M+1)-master (from M MI-slots plus error handler) to 1-slave response channel.
//   The module maintains transaction thread control registers that count the
//     number of outstanding transations for each thread and the target MI-slot.
//   On the address channel, the module decodes addresses to select among MI-slots 
//     accessible to the SI-slot where it is instantiated.
//     It then qualifies whether each received transaction
//     should be propagated as a request to the address channel arbiter.
//     Transactions are blocked while there is any outstanding transaction to a 
//     different slave (MI-slot) for the requested ID thread (for deadlock avoidance).
//   On the response channel, the module mulitplexes transfers from each of the 
//     MI-slots whenever a transfer targets the ID of an active thread,
//     arbitrating between MI-slots if multiple threads respond concurrently.
//
//--------------------------------------------------------------------------
//
// Structure:
//    si_transactor
//      addr_decoder
//        comparator_static
//      mux_enc
//      axic_srl_fifo
//      arbiter_resp
//      
//-----------------------------------------------------------------------------
`timescale 1ps/1ps
`default_nettype none

(* DowngradeIPIdentifiedWarnings="yes" *) 
module axi_interconnect_v1_7_13_si_transactor #
  (
   parameter integer C_MAX_M = 16,
   parameter integer C_NUM_ADDR_RANGES = 16,
   parameter         C_FAMILY                       = "none", 
   parameter integer C_SI             =   0, // SI-slot number of current instance.
   parameter integer C_DIR             =   0, // Direction: 0 = Write; 1 = Read.
   parameter integer C_NUM_M             =   2, 
   parameter integer C_NUM_M_LOG             =   1, 
   parameter integer C_ACCEPTANCE             =   1,  // Acceptance limit of this SI-slot.
   parameter integer C_ACCEPTANCE_LOG             =   0,  // Width of acceptance counter for this SI-slot.
   parameter integer C_ID_WIDTH                   = 1, 
   parameter integer C_ADDR_WIDTH                 = 32, 
   parameter integer C_AMESG_WIDTH = 1,  // Used for AW or AR channel payload, depending on instantiation.
   parameter integer C_RMESG_WIDTH = 1,  // Used for B or R channel payload, depending on instantiation.
   parameter integer C_THREAD_ID_WIDTH                  = 0,
   parameter [63:0]  C_BASE_ID                  = 64'hFFFFFFFF_FFFFFFFF,
                       // Base ID of this SI slot. 
                       // Format: Bit64;
                       // Range: 0 to 2**C_S_AXI_ID_WIDTH-1.
   parameter [63:0]  C_HIGH_ID                  = 64'h00000000_00000000,
                       // High ID of this SI slot. 
                       // Format: Bit64;
                       // Range: C_BASE_ID to 2**C_S_AXI_ID_WIDTH-1.
   parameter [C_MAX_M*C_NUM_ADDR_RANGES*64-1:0] C_BASE_ADDR                 = {C_MAX_M*C_NUM_ADDR_RANGES{64'hFFFFFFFF_FFFFFFFF}}, 
                       // Base address of each range of each MI slot. 
                       // For unused ranges, set base address to 'hFFFFFFFF.
                       // Format: C_NUM_MASTER_SLOTS{C_NUM_ADDR_RANGES{Bit64}}.
   parameter [C_MAX_M*C_NUM_ADDR_RANGES*64-1:0] C_HIGH_ADDR                 = {C_MAX_M*C_NUM_ADDR_RANGES{64'h00000000_00000000}}, 
                       // High address of each range of each MI slot. 
                       // For unused ranges, set high address to 'h00000000.
                       // Format: C_NUM_MASTER_SLOTS{C_NUM_ADDR_RANGES{Bit64}}.
   parameter           C_IS_INTERCONNECT = 1'b0, 
                       // Indicates whether master connected to this SI slot is an end-point
                       // master (0) or an interconnect (1).
   parameter [31:0]    C_TARGET_QUAL                 = 32'hFFFFFFFF,
                       // Indicates whether each MI target has connectivity.
                       // Format: C_NUM_M{Bit1}.
   parameter [C_MAX_M*1-1:0] C_M_AXI_SECURE                   = {C_MAX_M{1'b0}},
                       // Indicates whether each MI slot connects to a secure slave 
                       // (allows only TrustZone secure access).
                       // Format: C_NUM_MASTER_SLOTS{Bit1}.
   parameter integer C_SINGLE_THREAD             =   0, // Not yet supported
   parameter [C_MAX_M*32-1:0] C_M_PROTOCOL                 = {C_MAX_M{32'h00000000}}, 
                       // Indicates whether connected slave is
                       // Full-AXI4 ('h00000000),
                       // AXI3 ('h00000001) or 
                       // Axi4Lite ('h00000002), for each SI slot.
                       // Format: C_NUM_MASTER_SLOTS{Bit32}.
   parameter integer C_RANGE_CHECK                    = 0,
                       // 1 = Implement DECERR detection.
                       // 0 = Pass all transactions without error-checking.
   parameter integer C_ADDR_DECODE           =0,
                       // Generate address decoder
   parameter integer C_DEBUG                = 1,
   parameter integer C_MAX_DEBUG_THREADS    = 1
   )
  (
   // Global Signals
   input  wire                                                    ACLK,
   input  wire                                                    ARESET,
   // Slave Address Channel Interface Ports
   input  wire [C_ID_WIDTH-1:0]           S_AID,
   input  wire [C_ADDR_WIDTH-1:0]          S_AADDR,
   input  wire [8-1:0]                    S_ALEN,
   input  wire [3-1:0]                    S_ASIZE,
   input  wire [2-1:0]                    S_ABURST,
   input  wire [2-1:0]                    S_ALOCK,
   input  wire [3-1:0]                    S_APROT,
   input  wire [C_AMESG_WIDTH-1:0]         S_AMESG,
   input  wire                             S_AVALID,
   output wire                             S_AREADY,
   // Master Address Channel Interface Ports
   output wire [C_ID_WIDTH-1:0]          M_AID,
   output wire [C_ADDR_WIDTH-1:0]          M_AADDR,
   output  wire [8-1:0]                    M_ALEN,
   output  wire [3-1:0]                    M_ASIZE,
   output  wire [2-1:0]                    M_ALOCK,
   output  wire [3-1:0]                    M_APROT,
   output wire [4-1:0]                         M_AREGION,
   output wire [C_AMESG_WIDTH-1:0]                         M_AMESG,
   output wire [(C_NUM_M+1)-1:0]                         M_ATARGET_HOT,
   output wire [(C_NUM_M_LOG+1)-1:0]                         M_ATARGET_ENC,
   output wire [7:0]                         M_AERROR,
   output wire                            M_AVALID_QUAL,
   output wire                            M_AVALID,
   input  wire                            M_AREADY,
   // Slave Response Channel Interface Ports
   output  wire [C_ID_WIDTH-1:0]           S_RID,
   output  wire [C_RMESG_WIDTH-1:0]         S_RMESG,
   output  wire                             S_RLAST,
   output  wire                             S_RVALID,
   input wire                             S_RREADY,
   // Master Response Channel Interface Ports
   input wire [(C_NUM_M+1)*C_ID_WIDTH-1:0]          M_RID,
   input wire [(C_NUM_M+1)*C_RMESG_WIDTH-1:0]             M_RMESG,
   input wire [(C_NUM_M+1)-1:0]                           M_RLAST,
   input wire [(C_NUM_M+1)-1:0]                           M_RVALID,
   output  wire [(C_NUM_M+1)-1:0]                           M_RREADY,
   input wire [(C_NUM_M+1)-1:0]           M_RTARGET,  // Does response ID from each MI-slot target this SI slot?
   
   // Diagnostic Ports
   input wire [8-1:0]                        DEBUG_A_TRANS_SEQ,
   output wire [C_MAX_DEBUG_THREADS*8-1:0]   DEBUG_ACCEPT_CNT,
   output wire [16-1:0]                      DEBUG_ACTIVE_THREAD,
   output wire [C_MAX_DEBUG_THREADS*8-1:0]   DEBUG_ACTIVE_TARGET,
   output wire [C_MAX_DEBUG_THREADS*8-1:0]   DEBUG_ACTIVE_REGION,
   output wire [C_MAX_DEBUG_THREADS*8-1:0]   DEBUG_R_BEAT_CNT,
   output wire [C_MAX_DEBUG_THREADS*8-1:0]   DEBUG_R_TRANS_SEQ,
   output wire [C_MAX_DEBUG_THREADS-1:0]     DEBUG_TRANS_QUAL
   );

  localparam integer P_WRITE = 0;
  localparam integer P_READ = 1;
  localparam integer P_RMUX_MESG_WIDTH = C_ID_WIDTH + C_RMESG_WIDTH + 1;
  localparam [1:0]   P_AXILITE_VAL = 2'b10;
  localparam integer P_NONSECURE_BIT = 1; 
  localparam integer P_NUM_M_LOG_M1 = C_NUM_M_LOG ? C_NUM_M_LOG : 1;
  localparam [C_NUM_M-1:0] P_M_AXILITE = f_m_axilite(0);  // Mask of AxiLite MI-slots
  localparam [1:0]   P_FIXED = 2'b00;
  localparam integer P_NUM_M_DE_LOG = f_ceil_log2(C_NUM_M+1);
  localparam integer P_ID_MAX_WIDTH = 16;
  localparam integer P_THREAD_ID_WIDTH_M1 = (C_THREAD_ID_WIDTH > 0) ? C_THREAD_ID_WIDTH : 1; 
  localparam integer P_NUM_ID_VAL = 1 << C_THREAD_ID_WIDTH;
  localparam integer P_NUM_THREADS = (P_NUM_ID_VAL < C_ACCEPTANCE) ? P_NUM_ID_VAL : C_ACCEPTANCE;
  
  // Ceiling of log2(x)
  function integer f_ceil_log2
    (
     input integer x
     );
    integer acc;
    begin
      acc=0;
      while ((2**acc) < x)
        acc = acc + 1;
      f_ceil_log2 = acc;
    end
  endfunction

  // AxiLite protocol flag vector      
  function [C_NUM_M-1:0] f_m_axilite
    (
      input integer null_arg
    );
    integer mi;
    begin
      for (mi=0; mi<C_NUM_M; mi=mi+1) begin
        f_m_axilite[mi] = (C_M_PROTOCOL[mi*32+:2] == P_AXILITE_VAL);
      end
    end
  endfunction
  
  wire [C_NUM_M-1:0] target_mi_hot;
  wire [P_NUM_M_LOG_M1-1:0] target_mi_enc;
  wire [(C_NUM_M+1)-1:0] m_atarget_hot_i;
  wire [(P_NUM_M_DE_LOG)-1:0] m_atarget_enc_i;
  wire match;
  wire [3:0] region;
  wire [3:0] m_aregion_i;
  wire m_avalid_i;
  wire s_aready_i;
  wire any_error;
  wire s_rvalid_i;
  wire [C_ID_WIDTH-1:0] s_rid_i;
  wire s_rlast_i;
  wire [P_RMUX_MESG_WIDTH-1:0] si_rmux_mesg;
  wire [(C_NUM_M+1)*P_RMUX_MESG_WIDTH-1:0] mi_rmux_mesg;
  wire [(C_NUM_M+1)-1:0] m_rvalid_qual;
  wire [(C_NUM_M+1)-1:0] m_rready_arb;
  wire [(C_NUM_M+1)-1:0] m_rready_i;
  wire target_secure;
  wire target_axilite;
  wire m_avalid_qual_i;
  wire target_prohibit_narrow;
  wire [7:0] m_aerror_i;
  
  genvar gen_mi;
  genvar gen_thread;
    
  generate
    if (C_ADDR_DECODE) begin : gen_addr_decoder
  axi_interconnect_v1_7_13_addr_decoder #
        (
          .C_MAX_M                 (C_MAX_M),
          .C_FAMILY          (C_FAMILY),
          .C_NUM_TARGETS     (C_NUM_M),
          .C_NUM_TARGETS_LOG (P_NUM_M_LOG_M1),
          .C_NUM_RANGES      (C_NUM_ADDR_RANGES),
          .C_ADDR_WIDTH      (C_ADDR_WIDTH),
          .C_TARGET_ENC      (1),
          .C_TARGET_HOT      (1),
          .C_REGION_ENC      (1),
          .C_BASE_ADDR      (C_BASE_ADDR),
          .C_HIGH_ADDR      (C_HIGH_ADDR),
          .C_TARGET_QUAL     (C_TARGET_QUAL),
          .C_RESOLUTION      (12)
        ) 
        addr_decoder_inst 
        (
          .ADDR             (S_AADDR),        
          .TARGET_HOT       (target_mi_hot),  
          .TARGET_ENC       (target_mi_enc),  
          .MATCH            (match),       
          .REGION           (region)      
        );
    end else begin : gen_no_addr_decoder
      assign target_mi_hot = 1;
      assign target_mi_enc = 0;
      assign match = 1'b1;
      assign region = 4'b0000;
    end
  endgenerate
  
  assign target_secure = |(target_mi_hot & C_M_AXI_SECURE);
  assign target_axilite = |(target_mi_hot & P_M_AXILITE);

  assign any_error = C_RANGE_CHECK && (m_aerror_i != 0);            // DECERR if error-detection enabled and any error condition.
  assign m_aerror_i[0] = ~match;                                    // Invalid target address
  assign m_aerror_i[1] = target_secure && S_APROT[P_NONSECURE_BIT]; // TrustZone violation
  assign m_aerror_i[2] = target_axilite && ((S_ALEN != 0) || 
    (S_ASIZE[1:0] == 2'b11) || (S_ASIZE[2] == 1'b1));               // AxiLite access violation
  assign m_aerror_i[7:3] = 1'b0;                                    // Reserved
  assign M_ATARGET_HOT = m_atarget_hot_i;
  assign m_atarget_hot_i = (any_error ? {1'b1, {C_NUM_M{1'b0}}} : {1'b0, target_mi_hot});
  assign m_atarget_enc_i = (any_error ? C_NUM_M : target_mi_enc);
    
  assign M_AVALID = m_avalid_i;
  assign m_avalid_i = S_AVALID;
  assign M_AVALID_QUAL = m_avalid_qual_i; 
  assign S_AREADY = s_aready_i;
  assign s_aready_i = M_AREADY;
  assign M_AERROR = m_aerror_i;
  assign M_ATARGET_ENC = m_atarget_enc_i;
  assign m_aregion_i = any_error ? 4'b0000 : region;
  assign M_AREGION = m_aregion_i;
  assign M_AID = S_AID;
  assign M_AADDR = S_AADDR;
  assign M_ALEN = S_ALEN;
  assign M_ASIZE = S_ASIZE;
  assign M_ALOCK = S_ALOCK;
  assign M_APROT = S_APROT;
  assign M_AMESG = S_AMESG;
  
  assign S_RVALID = s_rvalid_i;
  assign M_RREADY = m_rready_i;
  assign s_rid_i = si_rmux_mesg[0+:C_ID_WIDTH];
  assign S_RMESG = si_rmux_mesg[C_ID_WIDTH+:C_RMESG_WIDTH];
  assign s_rlast_i = si_rmux_mesg[C_ID_WIDTH+C_RMESG_WIDTH+:1];
  assign S_RID = s_rid_i;
  assign S_RLAST = s_rlast_i;
  assign m_rvalid_qual = M_RVALID & M_RTARGET;
  assign m_rready_i = m_rready_arb & M_RTARGET;

  generate
    for (gen_mi=0; gen_mi<(C_NUM_M+1); gen_mi=gen_mi+1) begin : gen_rmesg_mi
      // Note: Concatenation of mesg signals is from MSB to LSB; assignments that chop mesg signals appear in opposite order.
      assign mi_rmux_mesg[gen_mi*P_RMUX_MESG_WIDTH+:P_RMUX_MESG_WIDTH] = {
               M_RLAST[gen_mi],
               M_RMESG[gen_mi*C_RMESG_WIDTH+:C_RMESG_WIDTH],
               M_RID[gen_mi*C_ID_WIDTH+:C_ID_WIDTH]
               };
    end  // gen_rmesg_mi

    if (C_ACCEPTANCE == 1) begin : gen_single_issue
      wire  cmd_push;
      wire  cmd_pop;
      reg  [(C_NUM_M+1)-1:0] active_target_hot;
      reg  [P_NUM_M_DE_LOG-1:0] active_target_enc;
      reg  accept_cnt;
      reg  [8-1:0] debug_r_beat_cnt_i;
      wire [8-1:0] debug_r_trans_seq_i;

      assign cmd_push = M_AREADY;
      assign cmd_pop = s_rvalid_i && S_RREADY && s_rlast_i;  // Pop command queue if end of read burst
      assign m_avalid_qual_i = ~accept_cnt | cmd_pop;  // Ready for arbitration if no outstanding transaction or transaction being completed

      always @(posedge ACLK) begin 
        if (ARESET) begin
          accept_cnt <= 1'b0;
          active_target_enc <= 0;
          active_target_hot <= 0;
        end else begin
          if (cmd_push) begin
            active_target_enc <= m_atarget_enc_i;
            active_target_hot <= m_atarget_hot_i;
            accept_cnt <= 1'b1;
          end else if (cmd_pop) begin
            accept_cnt <= 1'b0;
          end
        end 
      end  // Clocked process
        
      assign m_rready_arb = active_target_hot & {(C_NUM_M+1){S_RREADY}};
      assign s_rvalid_i = |(active_target_hot & m_rvalid_qual);
                 
  axi_interconnect_v1_7_13_mux_enc # 
        (
         .C_FAMILY      (C_FAMILY),
         .C_RATIO       (C_NUM_M+1),
         .C_SEL_WIDTH   (P_NUM_M_DE_LOG),
         .C_DATA_WIDTH  (P_RMUX_MESG_WIDTH)
        ) mux_resp_single_issue
        (
         .S   (active_target_enc),
         .A   (mi_rmux_mesg),
         .O   (si_rmux_mesg),
         .OE  (1'b1)
        ); 
        
      if (C_DEBUG) begin : gen_debug_r_single_issue
        // DEBUG READ BEAT COUNTER (only meaningful for R-channel)
        always @(posedge ACLK) begin
          if (ARESET) begin
            debug_r_beat_cnt_i <= 0;
          end else if (C_DIR == P_READ) begin
            if (s_rvalid_i && S_RREADY) begin
              if (s_rlast_i) begin
                debug_r_beat_cnt_i <= 0;
              end else begin
                debug_r_beat_cnt_i <= debug_r_beat_cnt_i + 1;
              end
            end
          end else begin
            debug_r_beat_cnt_i <= 0;            
          end
        end  // Clocked process
        
        // DEBUG R-CHANNEL TRANSACTION SEQUENCE FIFO
  axi_interconnect_v1_7_13_axic_srl_fifo #
          (
           .C_FAMILY          (C_FAMILY),
           .C_FIFO_WIDTH      (8),
           .C_FIFO_DEPTH_LOG  (C_ACCEPTANCE_LOG+1),
           .C_USE_FULL        (0)
           )
          debug_r_seq_fifo_single_issue
            (
             .ACLK    (ACLK),
             .ARESET  (ARESET),
             .S_MESG  (DEBUG_A_TRANS_SEQ),
             .S_VALID (cmd_push),
             .S_READY (),
             .M_MESG  (debug_r_trans_seq_i),
             .M_VALID (),
             .M_READY (cmd_pop)
            );
            
        assign DEBUG_TRANS_QUAL = m_avalid_qual_i;
        assign DEBUG_ACCEPT_CNT = accept_cnt;
        assign DEBUG_ACTIVE_THREAD = 0;
        assign DEBUG_ACTIVE_TARGET = active_target_enc;
        assign DEBUG_ACTIVE_REGION = 0;
        assign DEBUG_R_BEAT_CNT = debug_r_beat_cnt_i;
        assign DEBUG_R_TRANS_SEQ = debug_r_trans_seq_i;
      end else begin : gen_no_debug_r_single_issue
        assign DEBUG_TRANS_QUAL = 0;
        assign DEBUG_ACCEPT_CNT = 0;
        assign DEBUG_ACTIVE_THREAD = 0;
        assign DEBUG_ACTIVE_TARGET = 0;
        assign DEBUG_ACTIVE_REGION = 0;
        assign DEBUG_R_BEAT_CNT = 0;
        assign DEBUG_R_TRANS_SEQ = 0;
      end  // gen_debug_r
      
    end else if (C_SINGLE_THREAD || (P_NUM_ID_VAL==1)) begin : gen_single_thread
      wire  s_avalid_en;
      wire  cmd_push;
      wire  cmd_pop;
      reg  [P_ID_MAX_WIDTH-1:0] active_id;
      reg  [(C_NUM_M+1)-1:0] active_target_hot;
      reg  [P_NUM_M_DE_LOG-1:0] active_target_enc;
      reg  [4-1:0] active_region;
      reg  [(C_ACCEPTANCE_LOG+1)-1:0] accept_cnt;
      reg  [8-1:0] debug_r_beat_cnt_i;
      wire [8-1:0] debug_r_trans_seq_i;
      wire accept_limit ;

      // Implement single-region-per-ID cyclic dependency avoidance method.
      assign s_avalid_en =  // This transaction is qualified to request arbitration if ...
        (accept_cnt == 0) ||  // Either there are no outstanding transactions, or ...
        (((P_NUM_ID_VAL==1) || (S_AID[P_THREAD_ID_WIDTH_M1-1:0] == active_id[P_THREAD_ID_WIDTH_M1-1:0])) &&  // the current transaction ID matches the previous, and ...
        (active_target_enc == m_atarget_enc_i) &&  // all outstanding transactions are to the same target MI ...
        (active_region == m_aregion_i));  // and to the same REGION.
      
      assign cmd_push = M_AREADY;
      assign cmd_pop = s_rvalid_i && S_RREADY && s_rlast_i;  // Pop command queue if end of read burst
      assign accept_limit = (accept_cnt == C_ACCEPTANCE) & ~cmd_pop;  // Allow next push if a transaction is currently being completed
      assign m_avalid_qual_i = s_avalid_en & ~accept_limit; 
      
      always @(posedge ACLK) begin 
        if (ARESET) begin
          accept_cnt <= 0;
          active_id <= 0;
          active_target_enc <= 0;
          active_target_hot <= 0;
          active_region <= 0;
        end else begin
          if (cmd_push) begin
            active_id <= S_AID[P_THREAD_ID_WIDTH_M1-1:0];
            active_target_enc <= m_atarget_enc_i;
            active_target_hot <= m_atarget_hot_i;
            active_region <= m_aregion_i;
            if (~cmd_pop) begin
              accept_cnt <= accept_cnt + 1;
            end
          end else begin
            if (cmd_pop & (accept_cnt != 0)) begin
              accept_cnt <= accept_cnt - 1;
            end
          end
        end 
      end  // Clocked process
        
      assign m_rready_arb = active_target_hot & {(C_NUM_M+1){S_RREADY}};
      assign s_rvalid_i = |(active_target_hot & m_rvalid_qual);
                 
  axi_interconnect_v1_7_13_mux_enc # 
        (
         .C_FAMILY      (C_FAMILY),
         .C_RATIO       (C_NUM_M+1),
         .C_SEL_WIDTH   (P_NUM_M_DE_LOG),
         .C_DATA_WIDTH  (P_RMUX_MESG_WIDTH)
        ) mux_resp_single_thread
        (
         .S   (active_target_enc),
         .A   (mi_rmux_mesg),
         .O   (si_rmux_mesg),
         .OE  (1'b1)
        ); 
        
      if (C_DEBUG) begin : gen_debug_r_single_thread
        // DEBUG READ BEAT COUNTER (only meaningful for R-channel)
        always @(posedge ACLK) begin
          if (ARESET) begin
            debug_r_beat_cnt_i <= 0;
          end else if (C_DIR == P_READ) begin
            if (s_rvalid_i && S_RREADY) begin
              if (s_rlast_i) begin
                debug_r_beat_cnt_i <= 0;
              end else begin
                debug_r_beat_cnt_i <= debug_r_beat_cnt_i + 1;
              end
            end
          end else begin
            debug_r_beat_cnt_i <= 0;            
          end
        end  // Clocked process
        
        // DEBUG R-CHANNEL TRANSACTION SEQUENCE FIFO
  axi_interconnect_v1_7_13_axic_srl_fifo #
          (
           .C_FAMILY          (C_FAMILY),
           .C_FIFO_WIDTH      (8),
           .C_FIFO_DEPTH_LOG  (C_ACCEPTANCE_LOG+1),
           .C_USE_FULL        (0)
           )
          debug_r_seq_fifo_single_thread
            (
             .ACLK    (ACLK),
             .ARESET  (ARESET),
             .S_MESG  (DEBUG_A_TRANS_SEQ),
             .S_VALID (cmd_push),
             .S_READY (),
             .M_MESG  (debug_r_trans_seq_i),
             .M_VALID (),
             .M_READY (cmd_pop)
            );
            
        assign DEBUG_TRANS_QUAL = m_avalid_qual_i;
        assign DEBUG_ACCEPT_CNT = accept_cnt;
        assign DEBUG_ACTIVE_THREAD = active_id;
        assign DEBUG_ACTIVE_TARGET = active_target_enc;
        assign DEBUG_ACTIVE_REGION = active_region;
        assign DEBUG_R_BEAT_CNT = debug_r_beat_cnt_i;
        assign DEBUG_R_TRANS_SEQ = debug_r_trans_seq_i;
      end else begin : gen_no_debug_r_single_thread
        assign DEBUG_TRANS_QUAL = 0;
        assign DEBUG_ACCEPT_CNT = 0;
        assign DEBUG_ACTIVE_THREAD = 0;
        assign DEBUG_ACTIVE_TARGET = 0;
        assign DEBUG_ACTIVE_REGION = 0;
        assign DEBUG_R_BEAT_CNT = 0;
        assign DEBUG_R_TRANS_SEQ = 0;
      end  // gen_debug_r
      
    end else begin : gen_multi_thread
      wire [(P_NUM_M_DE_LOG)-1:0] resp_select;
      reg  [(C_ACCEPTANCE_LOG+1)-1:0] accept_cnt;
      wire [P_NUM_THREADS-1:0] s_avalid_en;
      wire [P_NUM_THREADS-1:0] thread_valid;
      wire [P_NUM_THREADS-1:0] aid_match;
      wire [P_NUM_THREADS-1:0] rid_match;
      wire [P_NUM_THREADS-1:0] cmd_push;
      wire [P_NUM_THREADS-1:0] cmd_pop;
      wire [P_NUM_THREADS:0]   accum_push;
      reg  [P_NUM_THREADS*P_ID_MAX_WIDTH-1:0] active_id;
      reg  [P_NUM_THREADS*8-1:0] active_target;
      reg  [P_NUM_THREADS*8-1:0] active_region;
      reg  [P_NUM_THREADS*8-1:0] active_cnt;
      reg  [P_NUM_THREADS*8-1:0] debug_r_beat_cnt_i;
      wire [P_NUM_THREADS*8-1:0] debug_r_trans_seq_i;
      wire any_aid_match;
      wire any_rid_match;
      wire accept_limit;
      wire any_push;
      wire any_pop;
        
  axi_interconnect_v1_7_13_arbiter_resp #  // Multi-thread response arbiter
        (
         .C_FAMILY                (C_FAMILY),
         .C_NUM_S                 (C_NUM_M+1),
         .C_NUM_S_LOG             (P_NUM_M_DE_LOG),
         .C_GRANT_ENC            (1),
         .C_GRANT_HOT            (0)
         )
        arbiter_resp_inst
          (
           .ACLK                  (ACLK),
           .ARESET                (ARESET),
           .S_VALID               (m_rvalid_qual),
           .S_READY               (m_rready_arb),
           .M_GRANT_HOT           (),
           .M_GRANT_ENC           (resp_select),
           .M_VALID               (s_rvalid_i),
           .M_READY               (S_RREADY)
           );
                 
  axi_interconnect_v1_7_13_mux_enc # 
        (
         .C_FAMILY      (C_FAMILY),
         .C_RATIO       (C_NUM_M+1),
         .C_SEL_WIDTH   (P_NUM_M_DE_LOG),
         .C_DATA_WIDTH  (P_RMUX_MESG_WIDTH)
        ) mux_resp_multi_thread
        (
         .S   (resp_select),
         .A   (mi_rmux_mesg),
         .O   (si_rmux_mesg),
         .OE  (1'b1)
        ); 
        
      assign any_push = M_AREADY;
      assign any_pop = s_rvalid_i & S_RREADY & s_rlast_i;
      assign accept_limit = (accept_cnt == C_ACCEPTANCE) & ~any_pop;  // Allow next push if a transaction is currently being completed
        assign m_avalid_qual_i = (&s_avalid_en) & ~accept_limit;  // The current request is qualified for arbitration when it is qualified against all outstanding transaction threads.
        assign any_aid_match = |aid_match;
        assign any_rid_match = |rid_match;
        assign accum_push[0] = 1'b0;
        
        always @(posedge ACLK) begin
          if (ARESET) begin
            accept_cnt <= 0; 
          end else begin
            if (any_push & ~any_pop) begin
              accept_cnt <= accept_cnt + 1;
          end else if (any_pop & ~any_push & (accept_cnt != 0)) begin
              accept_cnt <= accept_cnt - 1;
            end
          end 
        end  // Clocked process
          
        for (gen_thread=0; gen_thread<P_NUM_THREADS; gen_thread=gen_thread+1) begin : gen_thread_loop
          assign thread_valid[gen_thread] = (active_cnt[gen_thread*8 +: C_ACCEPTANCE_LOG+1] != 0);
          assign aid_match[gen_thread] =  // The currect thread is active for the requested transaction if
            thread_valid[gen_thread] &&  // this thread slot is not vacant, and
          ((S_AID[P_THREAD_ID_WIDTH_M1-1:0]) == active_id[gen_thread*P_ID_MAX_WIDTH+:P_THREAD_ID_WIDTH_M1]);  // the requested ID matches the active ID for this thread.
          assign s_avalid_en[gen_thread] =  // The current request is qualified against this thread slot if
            (~aid_match[gen_thread]) ||  // This thread slot is not active for the requested ID, or
            ((m_atarget_enc_i == active_target[gen_thread*8+:P_NUM_M_DE_LOG]) &&  // this outstanding transaction was to the same target and
            (m_aregion_i == active_region[gen_thread*8+:4]));  // to the same region.
          
          // cmd_push points to the position of either the active thread for the requested ID or the lowest vacant thread slot.
          assign accum_push[gen_thread+1] = accum_push[gen_thread] | ~thread_valid[gen_thread];
          assign cmd_push[gen_thread] = any_push & (aid_match[gen_thread] | ((~any_aid_match) & ~thread_valid[gen_thread] & ~accum_push[gen_thread]));
          
          // cmd_pop points to the position of the active thread that matches the current RID.
        assign rid_match[gen_thread] = thread_valid[gen_thread] & ((s_rid_i[P_THREAD_ID_WIDTH_M1-1:0]) == active_id[gen_thread*P_ID_MAX_WIDTH+:P_THREAD_ID_WIDTH_M1]);
          assign cmd_pop[gen_thread] = any_pop & rid_match[gen_thread];
        
          always @(posedge ACLK) begin
            if (ARESET) begin
              active_id[gen_thread*P_ID_MAX_WIDTH+:P_ID_MAX_WIDTH] <= 0;
              active_target[gen_thread*8+:8] <= 0;
              active_region[gen_thread*8+:8] <= 0;
              active_cnt[gen_thread*8+:8] <= 0; 
            end else begin
              if (cmd_push[gen_thread]) begin
              active_id[gen_thread*P_ID_MAX_WIDTH+:P_THREAD_ID_WIDTH_M1] <= S_AID[P_THREAD_ID_WIDTH_M1-1:0];
                active_target[gen_thread*8+:P_NUM_M_DE_LOG] <= m_atarget_enc_i;
                active_region[gen_thread*8+:4] <= m_aregion_i;
                if (~cmd_pop[gen_thread]) begin
                  active_cnt[gen_thread*8+:C_ACCEPTANCE_LOG+1] <= active_cnt[gen_thread*8+:C_ACCEPTANCE_LOG+1] + 1;
                end
              end else if (cmd_pop[gen_thread]) begin
                  active_cnt[gen_thread*8+:C_ACCEPTANCE_LOG+1] <= active_cnt[gen_thread*8+:C_ACCEPTANCE_LOG+1] - 1;
              end
            end 
          end  // Clocked process
            
        if (C_DEBUG) begin : gen_debug_r_multi_thread
            // DEBUG READ BEAT COUNTER (only meaningful for R-channel)
            always @(posedge ACLK) begin
              if (ARESET) begin
                debug_r_beat_cnt_i[gen_thread*8+:8] <= 0;
              end else if (C_DIR == P_READ) begin
                if (s_rvalid_i & S_RREADY & rid_match[gen_thread]) begin
                  if (s_rlast_i) begin
                    debug_r_beat_cnt_i[gen_thread*8+:8] <= 0;
                  end else begin
                    debug_r_beat_cnt_i[gen_thread*8+:8] <= debug_r_beat_cnt_i[gen_thread*8+:8] + 1;
                  end
                end
              end else begin
                debug_r_beat_cnt_i[gen_thread*8+:8] <= 0;            
              end
            end  // Clocked process
            
            // DEBUG R-CHANNEL TRANSACTION SEQUENCE FIFO
  axi_interconnect_v1_7_13_axic_srl_fifo #
              (
               .C_FAMILY          (C_FAMILY),
               .C_FIFO_WIDTH      (8),
               .C_FIFO_DEPTH_LOG  (C_ACCEPTANCE_LOG+1),
               .C_USE_FULL        (0)
               )
            debug_r_seq_fifo_multi_thread
                (
                 .ACLK    (ACLK),
                 .ARESET  (ARESET),
                 .S_MESG  (DEBUG_A_TRANS_SEQ),
                 .S_VALID (cmd_push[gen_thread]),
                 .S_READY (),
                 .M_MESG  (debug_r_trans_seq_i[gen_thread*8+:8]),
                 .M_VALID (),
                 .M_READY (cmd_pop[gen_thread])
                );
        end  // gen_debug_r_multi_thread
      end  // Next gen_thread_loop
            
        if (C_DEBUG) begin : gen_debug_r_multi_thread
            assign DEBUG_TRANS_QUAL = m_avalid_qual_i;
            assign DEBUG_ACCEPT_CNT = active_cnt;
            assign DEBUG_ACTIVE_THREAD = active_id;
            assign DEBUG_ACTIVE_TARGET = active_target;
            assign DEBUG_ACTIVE_REGION = active_region;
            assign DEBUG_R_BEAT_CNT = debug_r_beat_cnt_i;
            assign DEBUG_R_TRANS_SEQ = debug_r_trans_seq_i;
        end else begin : gen_no_debug_r_multi_thread
            assign DEBUG_TRANS_QUAL = 0;
            assign DEBUG_ACCEPT_CNT = 0;
            assign DEBUG_ACTIVE_THREAD = 0;
            assign DEBUG_ACTIVE_TARGET = 0;
            assign DEBUG_ACTIVE_REGION = 0;
            assign DEBUG_R_BEAT_CNT = 0;
            assign DEBUG_R_TRANS_SEQ = 0;
        end  // gen_debug_r_multi_thread
    end  // thread control
        
//      if (C_IS_INTERCONNECT) begin : gen_no_thread_control  // C_IS_INTERCONNECT automation not supported 
//        reg   [8-1:0] debug_r_beat_cnt_i;
//        wire  [8-1:0] debug_r_trans_seq_i;
//        assign m_avalid_qual_i = 1'b1;
//        
//        if (C_DEBUG) begin : gen_debug_r_nothread
//          // DEBUG READ BEAT COUNTER (only meaningful for R-channel)
//          always @(posedge ACLK) begin
//            if (ARESET) begin
//              debug_r_beat_cnt_i <= 0;
//            end else if (C_DIR == P_READ) begin
//              if (s_rvalid_i && S_RREADY) begin
//                if (s_rlast_i) begin
//                  debug_r_beat_cnt_i <= 0;
//                end else begin
//                  debug_r_beat_cnt_i <= debug_r_beat_cnt_i + 1;
//                end
//              end
//            end else begin
//              debug_r_beat_cnt_i <= 0;            
//            end
//          end  // Clocked process
//          
//          // DEBUG R-CHANNEL TRANSACTION SEQUENCE FIFO
//          axic_srl_fifo #
//            (
//             .C_FAMILY          (C_FAMILY),
//             .C_FIFO_WIDTH      (8),
//             .C_FIFO_DEPTH_LOG  (C_ACCEPTANCE_LOG+1),
//             .C_USE_FULL        (0)
//             )
//            debug_r_seq_fifo_nothread
//              (
//               .ACLK    (ACLK),
//               .ARESET  (ARESET),
//               .S_MESG  (DEBUG_A_TRANS_SEQ),
//               .S_VALID (S_AVALID & M_AREADY),
//               .S_READY (),
//               .M_MESG  (debug_r_trans_seq_i),
//               .M_VALID (),
//               .M_READY (s_rvalid_i && S_RREADY && s_rlast_i)
//              );
//               
//          assign DEBUG_TRANS_QUAL = 1;
//          assign DEBUG_ACCEPT_CNT = 0;
//          assign DEBUG_ACTIVE_THREAD = 0;
//          assign DEBUG_ACTIVE_TARGET = 0;
//          assign DEBUG_ACTIVE_REGION = 0;
//          assign DEBUG_R_BEAT_CNT = debug_r_beat_cnt_i;
//          assign DEBUG_R_TRANS_SEQ = debug_r_trans_seq_i;
//        end else begin : gen_no_debug_r_nothread
//          assign DEBUG_TRANS_QUAL = 0;
//          assign DEBUG_ACCEPT_CNT = 0;
//          assign DEBUG_ACTIVE_THREAD = 0;
//          assign DEBUG_ACTIVE_TARGET = 0;
//          assign DEBUG_ACTIVE_REGION = 0;
//          assign DEBUG_R_BEAT_CNT = 0;
//          assign DEBUG_R_TRANS_SEQ = 0;
//        end  // gen_debug_r_nothread
//      end  // gen_no_thread_control
    
  endgenerate
endmodule

`default_nettype wire


// -- (c) Copyright 2010 - 2011 Xilinx, Inc. All rights reserved.
// --
// -- This file contains confidential and proprietary information
// -- of Xilinx, Inc. and is protected under U.S. and 
// -- international copyright and other intellectual property
// -- laws.
// --
// -- DISCLAIMER
// -- This disclaimer is not a license and does not grant any
// -- rights to the materials distributed herewith. Except as
// -- otherwise provided in a valid license issued to you by
// -- Xilinx, and to the maximum extent permitted by applicable
// -- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
// -- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
// -- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
// -- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
// -- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
// -- (2) Xilinx shall not be liable (whether in contract or tort,
// -- including negligence, or under any other theory of
// -- liability) for any loss or damage of any kind or nature
// -- related to, arising under or in connection with these
// -- materials, including for any direct, or any indirect,
// -- special, incidental, or consequential loss or damage
// -- (including loss of data, profits, goodwill, or any type of
// -- loss or damage suffered as a result of any action brought
// -- by a third party) even if such damage or loss was
// -- reasonably foreseeable or Xilinx had been advised of the
// -- possibility of the same.
// --
// -- CRITICAL APPLICATIONS
// -- Xilinx products are not designed or intended to be fail-
// -- safe, or for use in any application requiring fail-safe
// -- performance, such as life-support or safety devices or
// -- systems, Class III medical devices, nuclear facilities,
// -- applications related to the deployment of airbags, or any
// -- other applications that could lead to death, personal
// -- injury, or severe property or environmental damage
// -- (individually and collectively, "Critical
// -- Applications"). Customer assumes the sole risk and
// -- liability of any use of Xilinx products in Critical
// -- Applications, subject only to applicable laws and
// -- regulations governing limitations on product liability.
// --
// -- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
// -- PART OF THIS FILE AT ALL TIMES.
//-----------------------------------------------------------------------------
//
// Description: AXI Splitter
// Each transfer received on the AXI handshake slave port is replicated onto 
//   each of the master ports, and is completed back to the slave (S_READY) 
//   once all master ports have completed.
//   
// M_VALID is asserted combinatorially from S_VALID assertion.
// Each M_VALID is masked off beginning the cycle after each M_READY is
//   received (if S_READY remains low) until the cycle after both S_VALID
//   and S_READY are asserted.
// S_READY is asserted combinatorially when the last (or all) of the M_READY
//   inputs have been received.
// If all M_READYs are asserted when S_VALID is asserted, back-to-back
//   handshakes can occur without bubble cycles.
//
// Verilog-standard:  Verilog 2001
//--------------------------------------------------------------------------
//
// Structure:
//   splitter
//
//--------------------------------------------------------------------------
`timescale 1ps/1ps

(* DowngradeIPIdentifiedWarnings="yes" *) 
module axi_interconnect_v1_7_13_splitter #
  (
   parameter integer C_NUM_M = 2  // Number of master ports = [2:16]
   )
  (
   // Global Signals
   input  wire                             ACLK,
   input  wire                             ARESET,
   // Slave  Port
   input  wire                             S_VALID,
   output wire                             S_READY,
   // Master Ports
   output wire [C_NUM_M-1:0]               M_VALID,
   input  wire [C_NUM_M-1:0]               M_READY
   );

   reg  [C_NUM_M-1:0] m_ready_d;
   wire               s_ready_i;
   wire [C_NUM_M-1:0] m_valid_i;

   always @(posedge ACLK) begin
      if (ARESET | s_ready_i) m_ready_d <= {C_NUM_M{1'b0}};
      else                    m_ready_d <= m_ready_d | (m_valid_i & M_READY);
   end

   assign s_ready_i = &(m_ready_d | M_READY);
   assign m_valid_i = {C_NUM_M{S_VALID}} & ~m_ready_d;
   assign M_VALID = m_valid_i;
   assign S_READY = s_ready_i;

endmodule


// -- (c) Copyright 2010 - 2011 Xilinx, Inc. All rights reserved.
// --
// -- This file contains confidential and proprietary information
// -- of Xilinx, Inc. and is protected under U.S. and 
// -- international copyright and other intellectual property
// -- laws.
// --
// -- DISCLAIMER
// -- This disclaimer is not a license and does not grant any
// -- rights to the materials distributed herewith. Except as
// -- otherwise provided in a valid license issued to you by
// -- Xilinx, and to the maximum extent permitted by applicable
// -- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
// -- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
// -- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
// -- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
// -- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
// -- (2) Xilinx shall not be liable (whether in contract or tort,
// -- including negligence, or under any other theory of
// -- liability) for any loss or damage of any kind or nature
// -- related to, arising under or in connection with these
// -- materials, including for any direct, or any indirect,
// -- special, incidental, or consequential loss or damage
// -- (including loss of data, profits, goodwill, or any type of
// -- loss or damage suffered as a result of any action brought
// -- by a third party) even if such damage or loss was
// -- reasonably foreseeable or Xilinx had been advised of the
// -- possibility of the same.
// --
// -- CRITICAL APPLICATIONS
// -- Xilinx products are not designed or intended to be fail-
// -- safe, or for use in any application requiring fail-safe
// -- performance, such as life-support or safety devices or
// -- systems, Class III medical devices, nuclear facilities,
// -- applications related to the deployment of airbags, or any
// -- other applications that could lead to death, personal
// -- injury, or severe property or environmental damage
// -- (individually and collectively, "Critical
// -- Applications"). Customer assumes the sole risk and
// -- liability of any use of Xilinx products in Critical
// -- Applications, subject only to applicable laws and
// -- regulations governing limitations on product liability.
// --
// -- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
// -- PART OF THIS FILE AT ALL TIMES.
//-----------------------------------------------------------------------------
//
// Description: Write Data AXI3 Slave Converter
// Forward and split transactions as required.
//
// Verilog-standard:  Verilog 2001
//--------------------------------------------------------------------------
//
// Structure:
//   w_axi3_conv
//
//--------------------------------------------------------------------------
`timescale 1ps/1ps

(* DowngradeIPIdentifiedWarnings="yes" *) 
module axi_interconnect_v1_7_13_w_axi3_conv #
  (
   parameter C_FAMILY                            = "none",
   parameter integer C_AXI_ID_WIDTH              = 1,
   parameter integer C_AXI_ADDR_WIDTH            = 32,
   parameter integer C_AXI_DATA_WIDTH            = 32,
   parameter integer C_AXI_SUPPORTS_USER_SIGNALS = 0,
   parameter integer C_AXI_WUSER_WIDTH           = 1,
   parameter integer C_SUPPORT_SPLITTING              = 1,
                       // Implement transaction splitting logic.
                       // Disabled whan all connected masters are AXI3 and have same or narrower data width.
   parameter integer C_SUPPORT_BURSTS                 = 1
                       // Disabled when all connected masters are AxiLite,
                       //   allowing logic to be simplified.
   )
  (
   // System Signals
   input wire ACLK,
   input wire ARESET,

   // Command Interface
   input  wire                              cmd_valid,
   input  wire [C_AXI_ID_WIDTH-1:0]         cmd_id,
   input  wire [4-1:0]                      cmd_length,
   output wire                              cmd_ready,
   
   // Slave Interface Write Data Ports
   input  wire [C_AXI_DATA_WIDTH-1:0]   S_AXI_WDATA,
   input  wire [C_AXI_DATA_WIDTH/8-1:0] S_AXI_WSTRB,
   input  wire                          S_AXI_WLAST,
   input  wire [C_AXI_WUSER_WIDTH-1:0]  S_AXI_WUSER,
   input  wire                          S_AXI_WVALID,
   output wire                          S_AXI_WREADY,
   
   // Master Interface Write Data Ports
   output wire [C_AXI_ID_WIDTH-1:0]     M_AXI_WID,
   output wire [C_AXI_DATA_WIDTH-1:0]   M_AXI_WDATA,
   output wire [C_AXI_DATA_WIDTH/8-1:0] M_AXI_WSTRB,
   output wire                          M_AXI_WLAST,
   output wire [C_AXI_WUSER_WIDTH-1:0]  M_AXI_WUSER,
   output wire                          M_AXI_WVALID,
   input  wire                          M_AXI_WREADY
   );

   
  /////////////////////////////////////////////////////////////////////////////
  // Variables for generating parameter controlled instances.
  /////////////////////////////////////////////////////////////////////////////
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Local params
  /////////////////////////////////////////////////////////////////////////////
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Functions
  /////////////////////////////////////////////////////////////////////////////
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Internal signals
  /////////////////////////////////////////////////////////////////////////////

  // Burst length handling.
  reg                             first_mi_word;
  reg  [8-1:0]                    length_counter_1;
  reg  [8-1:0]                    length_counter;
  wire [8-1:0]                    next_length_counter;
  wire                            last_beat;
  wire                            last_word;
  
  // Throttling help signals.
  wire                            cmd_ready_i;
  wire                            pop_mi_data;
  wire                            mi_stalling;
  
  // Internal SI side control signals.
  wire                            S_AXI_WREADY_I;
  
  // Internal signals for MI-side.
  wire [C_AXI_ID_WIDTH-1:0]       M_AXI_WID_I;
  wire [C_AXI_DATA_WIDTH-1:0]     M_AXI_WDATA_I;
  wire [C_AXI_DATA_WIDTH/8-1:0]   M_AXI_WSTRB_I;
  wire                            M_AXI_WLAST_I;
  wire [C_AXI_WUSER_WIDTH-1:0]    M_AXI_WUSER_I;
  wire                            M_AXI_WVALID_I;
  wire                            M_AXI_WREADY_I;
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Handle interface handshaking:
  // 
  // Forward data from SI-Side to MI-Side while a command is available. When
  // the transaction has completed the command is popped from the Command FIFO.
  // 
  /////////////////////////////////////////////////////////////////////////////
                          
  // Pop word from SI-side.
  assign S_AXI_WREADY_I = S_AXI_WVALID & cmd_valid & ~mi_stalling;
  assign S_AXI_WREADY   = S_AXI_WREADY_I;
  
  // Indicate when there is data available @ MI-side.
  assign M_AXI_WVALID_I = S_AXI_WVALID & cmd_valid;
  
  // Get MI-side data.
  assign pop_mi_data    = M_AXI_WVALID_I & M_AXI_WREADY_I;
  
  // Signal that the command is done (so that it can be poped from command queue).
  assign cmd_ready_i    = cmd_valid & pop_mi_data & last_word;
  assign cmd_ready      = cmd_ready_i;
  
  // Detect when MI-side is stalling.
  assign mi_stalling    = M_AXI_WVALID_I & ~M_AXI_WREADY_I;
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Keep track of data forwarding:
  // 
  // On the first cycle of the transaction is the length taken from the Command
  // FIFO. The length is decreased until 0 is reached which indicates last data 
  // word.
  //
  // If bursts are unsupported will all data words be the last word, each one
  // from a separate transaction.
  // 
  /////////////////////////////////////////////////////////////////////////////
  
  // Select command length or counted length.
  always @ *
  begin
    if ( first_mi_word )
      length_counter = cmd_length;
    else
      length_counter = length_counter_1;
  end
  
  // Calculate next length counter value.
  assign next_length_counter = length_counter - 1'b1;
  
  // Keep track of burst length.
  always @ (posedge ACLK) begin
    if (ARESET) begin
      first_mi_word    <= 1'b1;
      length_counter_1 <= 4'b0;
    end else begin
      if ( pop_mi_data ) begin
        if ( M_AXI_WLAST_I ) begin
          first_mi_word    <= 1'b1;
        end else begin
          first_mi_word    <= 1'b0;
        end
      
        length_counter_1 <= next_length_counter;
      end
    end
  end
  
  // Detect last beat in a burst.
  assign last_beat = ( length_counter == 4'b0 );
  
  // Determine if this last word that shall be extracted from this SI-side word.
  assign last_word = ( last_beat ) |
                     ( C_SUPPORT_BURSTS == 0 );
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Select the SI-side word to write.
  // 
  // Most information can be reused directly (DATA, STRB, ID and USER).
  // ID is taken from the Command FIFO.
  //
  // Split transactions needs to insert new LAST transactions. So to simplify
  // is the LAST signal always generated.
  //
  /////////////////////////////////////////////////////////////////////////////
  
  // ID and USER is copied from the SI word to all MI word transactions.
  assign M_AXI_WUSER_I  = ( C_AXI_SUPPORTS_USER_SIGNALS ) ? S_AXI_WUSER : {C_AXI_WUSER_WIDTH{1'b0}};
  
  // Data has to be multiplexed.
  assign M_AXI_WDATA_I  = S_AXI_WDATA;
  assign M_AXI_WSTRB_I  = S_AXI_WSTRB;
  
  // ID is taken directly from the command queue.
  assign M_AXI_WID_I    = cmd_id;
  
  // Handle last flag, i.e. set for MI-side last word.
  assign M_AXI_WLAST_I  = last_word;
  
  
  /////////////////////////////////////////////////////////////////////////////
  // MI-side output handling
  // 
  /////////////////////////////////////////////////////////////////////////////
// TODO: registered?
  assign M_AXI_WID      = M_AXI_WID_I;
  assign M_AXI_WDATA    = M_AXI_WDATA_I;
  assign M_AXI_WSTRB    = M_AXI_WSTRB_I;
  assign M_AXI_WLAST    = M_AXI_WLAST_I;
  assign M_AXI_WUSER    = M_AXI_WUSER_I;
  assign M_AXI_WVALID   = M_AXI_WVALID_I;
  assign M_AXI_WREADY_I = M_AXI_WREADY;
  
  
endmodule


// -- (c) Copyright 2009 - 2011 Xilinx, Inc. All rights reserved.
// --
// -- This file contains confidential and proprietary information
// -- of Xilinx, Inc. and is protected under U.S. and 
// -- international copyright and other intellectual property
// -- laws.
// --
// -- DISCLAIMER
// -- This disclaimer is not a license and does not grant any
// -- rights to the materials distributed herewith. Except as
// -- otherwise provided in a valid license issued to you by
// -- Xilinx, and to the maximum extent permitted by applicable
// -- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
// -- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
// -- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
// -- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
// -- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
// -- (2) Xilinx shall not be liable (whether in contract or tort,
// -- including negligence, or under any other theory of
// -- liability) for any loss or damage of any kind or nature
// -- related to, arising under or in connection with these
// -- materials, including for any direct, or any indirect,
// -- special, incidental, or consequential loss or damage
// -- (including loss of data, profits, goodwill, or any type of
// -- loss or damage suffered as a result of any action brought
// -- by a third party) even if such damage or loss was
// -- reasonably foreseeable or Xilinx had been advised of the
// -- possibility of the same.
// --
// -- CRITICAL APPLICATIONS
// -- Xilinx products are not designed or intended to be fail-
// -- safe, or for use in any application requiring fail-safe
// -- performance, such as life-support or safety devices or
// -- systems, Class III medical devices, nuclear facilities,
// -- applications related to the deployment of airbags, or any
// -- other applications that could lead to death, personal
// -- injury, or severe property or environmental damage
// -- (individually and collectively, "Critical
// -- Applications"). Customer assumes the sole risk and
// -- liability of any use of Xilinx products in Critical
// -- Applications, subject only to applicable laws and
// -- regulations governing limitations on product liability.
// --
// -- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
// -- PART OF THIS FILE AT ALL TIMES.
//-----------------------------------------------------------------------------
//
// File name: wdata_mux.v
//
// Description: 
//   Contains MI-side write command queue.
//   SI-slot index selected by AW arbiter is pushed onto queue when S_AVALID transfer is received.
//   Queue is popped when WLAST data beat is transferred.
//   W-channel input from SI-slot selected by queue output is transferred to MI-side output .
//--------------------------------------------------------------------------
//
// Structure:
//    wdata_mux
//      axic_reg_srl_fifo
//      mux_enc
//      
//-----------------------------------------------------------------------------

`timescale 1ps/1ps
`default_nettype none

(* DowngradeIPIdentifiedWarnings="yes" *) 
module axi_interconnect_v1_7_13_wdata_mux #
  (
   parameter         C_FAMILY       = "none", // FPGA Family.
   parameter integer C_WMESG_WIDTH            =  1, // Width of W-channel payload.
   parameter integer C_NUM_SLAVE_SLOTS     =  1, // Number of S_* ports.
   parameter integer C_SELECT_WIDTH      =  1, // Width of ASELECT.
   parameter integer C_FIFO_DEPTH_LOG     =  0 // Queue depth = 2**C_FIFO_DEPTH_LOG.
   )
  (
   // System Signals
   input  wire                                        ACLK,
   input  wire                                        ARESET,
   // Slave Data Ports
   input  wire [C_NUM_SLAVE_SLOTS*C_WMESG_WIDTH-1:0]     S_WMESG,
   input  wire [C_NUM_SLAVE_SLOTS-1:0]                S_WLAST,
   input  wire [C_NUM_SLAVE_SLOTS-1:0]                S_WVALID,
   output wire [C_NUM_SLAVE_SLOTS-1:0]                S_WREADY,
   // Master Data Ports
   output wire [C_WMESG_WIDTH-1:0]                       M_WMESG,
   output wire                                        M_WLAST,
   output wire                                        M_WVALID,
   input  wire                                        M_WREADY,
   // Write Command Ports
   input  wire [C_SELECT_WIDTH-1:0]                 S_ASELECT,  // SI-slot index from AW arbiter
   input  wire                                        S_AVALID,
   output wire                                        S_AREADY
   );

  // Decode select input to 1-hot
  function [C_NUM_SLAVE_SLOTS-1:0] f_decoder (
      input [C_SELECT_WIDTH-1:0] sel
    );
    integer i;
    begin
      for (i=0; i<C_NUM_SLAVE_SLOTS; i=i+1) begin
        f_decoder[i] = (sel == i);
      end
    end
  endfunction

  wire                                          m_valid_i;
  wire                                          m_last_i;
  wire [C_NUM_SLAVE_SLOTS-1:0]             m_select_hot;
  wire [C_SELECT_WIDTH-1:0]                 m_select_enc;
  wire                                          m_avalid;
  wire                                          m_aready;
  
  generate
    if (C_NUM_SLAVE_SLOTS>1) begin : gen_wmux
      // SI-side write command queue
  axi_interconnect_v1_7_13_axic_reg_srl_fifo #
        (
         .C_FAMILY          (C_FAMILY),
         .C_FIFO_WIDTH      (C_SELECT_WIDTH),
         .C_FIFO_DEPTH_LOG  (C_FIFO_DEPTH_LOG),
         .C_USE_FULL        (0)
         )
        wmux_aw_fifo
          (
           .ACLK    (ACLK),
           .ARESET  (ARESET),
           .S_MESG  (S_ASELECT),
           .S_VALID (S_AVALID),
           .S_READY (S_AREADY),
           .M_MESG  (m_select_enc),
           .M_VALID (m_avalid),
           .M_READY (m_aready)
           );
    
      assign m_select_hot = f_decoder(m_select_enc);
      
      // Instantiate MUX
  axi_interconnect_v1_7_13_mux_enc # 
        (
         .C_FAMILY      (C_FAMILY),
         .C_RATIO       (C_NUM_SLAVE_SLOTS),
         .C_SEL_WIDTH   (C_SELECT_WIDTH),
         .C_DATA_WIDTH  (C_WMESG_WIDTH)
        ) mux_w 
        (
         .S   (m_select_enc),
         .A   (S_WMESG),
         .O   (M_WMESG),
         .OE  (1'b1)
        ); 
        
      assign m_last_i  = |(S_WLAST & m_select_hot);
      assign m_valid_i = |(S_WVALID & m_select_hot);
      
      assign m_aready = m_valid_i & m_avalid & m_last_i & M_WREADY;
      assign M_WLAST = m_last_i;
      assign M_WVALID = m_valid_i & m_avalid;
      assign S_WREADY = m_select_hot & {C_NUM_SLAVE_SLOTS{m_avalid & M_WREADY}};
    end else begin : gen_no_wmux
      assign S_AREADY = 1'b1;
      assign M_WVALID = S_WVALID;
      assign S_WREADY = M_WREADY;
      assign M_WLAST = S_WLAST;
      assign M_WMESG = S_WMESG;
    end
  endgenerate
  
endmodule

`default_nettype wire


// -- (c) Copyright 2009 - 2011 Xilinx, Inc. All rights reserved.
// --
// -- This file contains confidential and proprietary information
// -- of Xilinx, Inc. and is protected under U.S. and 
// -- international copyright and other intellectual property
// -- laws.
// --
// -- DISCLAIMER
// -- This disclaimer is not a license and does not grant any
// -- rights to the materials distributed herewith. Except as
// -- otherwise provided in a valid license issued to you by
// -- Xilinx, and to the maximum extent permitted by applicable
// -- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
// -- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
// -- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
// -- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
// -- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
// -- (2) Xilinx shall not be liable (whether in contract or tort,
// -- including negligence, or under any other theory of
// -- liability) for any loss or damage of any kind or nature
// -- related to, arising under or in connection with these
// -- materials, including for any direct, or any indirect,
// -- special, incidental, or consequential loss or damage
// -- (including loss of data, profits, goodwill, or any type of
// -- loss or damage suffered as a result of any action brought
// -- by a third party) even if such damage or loss was
// -- reasonably foreseeable or Xilinx had been advised of the
// -- possibility of the same.
// --
// -- CRITICAL APPLICATIONS
// -- Xilinx products are not designed or intended to be fail-
// -- safe, or for use in any application requiring fail-safe
// -- performance, such as life-support or safety devices or
// -- systems, Class III medical devices, nuclear facilities,
// -- applications related to the deployment of airbags, or any
// -- other applications that could lead to death, personal
// -- injury, or severe property or environmental damage
// -- (individually and collectively, "Critical
// -- Applications"). Customer assumes the sole risk and
// -- liability of any use of Xilinx products in Critical
// -- Applications, subject only to applicable laws and
// -- regulations governing limitations on product liability.
// --
// -- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
// -- PART OF THIS FILE AT ALL TIMES.
//-----------------------------------------------------------------------------
//
// File name: wdata_router.v
//
// Description: 
//   Contains SI-side write command queue.
//   Target MI-slot index is pushed onto queue when S_AVALID transfer is received.
//   Queue is popped when WLAST data beat is transferred.
//   W-channel input is transferred to MI-slot output selected by queue output.
//--------------------------------------------------------------------------
//
// Structure:
//    wdata_router
//      axic_reg_srl_fifo
//      
//-----------------------------------------------------------------------------

`timescale 1ps/1ps
`default_nettype none

(* DowngradeIPIdentifiedWarnings="yes" *) 
module axi_interconnect_v1_7_13_wdata_router #
  (
   parameter         C_FAMILY       = "none", // FPGA Family.
   parameter integer C_WMESG_WIDTH          = 1, // Width of all data signals
   parameter integer C_NUM_MASTER_SLOTS     = 1, // Number of M_* ports.
   parameter integer C_SELECT_WIDTH     =  1, // Width of S_ASELECT.
   parameter integer C_FIFO_DEPTH_LOG     =  0 // Queue depth = 2**C_FIFO_DEPTH_LOG.
   )
  (
   // System Signals
   input  wire                                        ACLK,
   input  wire                                        ARESET,
   // Slave Data Ports
   input  wire [C_WMESG_WIDTH-1:0]                    S_WMESG,
   input  wire                                        S_WLAST,
   input  wire                                        S_WVALID,
   output wire                                        S_WREADY,
   // Master Data Ports
   output wire [C_WMESG_WIDTH-1:0]                    M_WMESG,  // Broadcast to all MI-slots
   output wire                                        M_WLAST,  // Broadcast to all MI-slots
   output wire [C_NUM_MASTER_SLOTS-1:0]               M_WVALID,  // Per MI-slot
   input  wire [C_NUM_MASTER_SLOTS-1:0]               M_WREADY,  // Per MI-slot
   // Address Arbiter Ports
   input  wire [C_SELECT_WIDTH-1:0]                   S_ASELECT,  // Target MI-slot index from SI-side AW command
   input  wire                                        S_AVALID,
   output wire                                        S_AREADY
   );

  // Decode select input to 1-hot
  function [C_NUM_MASTER_SLOTS-1:0] f_decoder (
      input [C_SELECT_WIDTH-1:0] sel
    );
    integer i;
    begin
      for (i=0; i<C_NUM_MASTER_SLOTS; i=i+1) begin
        f_decoder[i] = (sel == i);
      end
    end
  endfunction

  //---------------------------------------------------------------------------
  // Internal signal declarations
  //---------------------------------------------------------------------------
  wire [C_NUM_MASTER_SLOTS-1:0]             m_select_hot;
  wire [C_SELECT_WIDTH-1:0]                 m_select_enc;
  wire                                          m_avalid;
  wire                                          m_aready;
  
  //---------------------------------------------------------------------------
  // Router
  //---------------------------------------------------------------------------

  // SI-side write command queue
  axi_interconnect_v1_7_13_axic_reg_srl_fifo #
    (
     .C_FAMILY          (C_FAMILY),
     .C_FIFO_WIDTH      (C_SELECT_WIDTH),
     .C_FIFO_DEPTH_LOG  (C_FIFO_DEPTH_LOG),
     .C_USE_FULL        (1)
     )
    wrouter_aw_fifo
      (
       .ACLK    (ACLK),
       .ARESET  (ARESET),
       .S_MESG  (S_ASELECT),
       .S_VALID (S_AVALID),
       .S_READY (S_AREADY),
       .M_MESG  (m_select_enc),
       .M_VALID (m_avalid),
       .M_READY (m_aready)
       );

  assign m_select_hot = f_decoder(m_select_enc);
  
  // W-channel payload and LAST are broadcast to all MI-slot's W-mux
  assign M_WMESG   = S_WMESG;
  assign M_WLAST =   S_WLAST;
  
  // Assert m_aready when last beat acknowledged by slave
  assign m_aready = m_avalid & S_WVALID & S_WLAST & (|(M_WREADY & m_select_hot));

  // M_WVALID is generated per MI-slot (including error handler at slot C_NUM_MASTER_SLOTS).
  // The slot selected by the head of the queue (m_select_enc) is enabled.
  assign M_WVALID = {C_NUM_MASTER_SLOTS{S_WVALID & m_avalid}} & m_select_hot;

  // S_WREADY is muxed from the MI slot selected by the head of the queue (m_select_enc).
  assign S_WREADY = m_avalid & (|(M_WREADY & m_select_hot));
  
endmodule

`default_nettype wire


// -- (c) Copyright 2010 - 2011 Xilinx, Inc. All rights reserved.
// --
// -- This file contains confidential and proprietary information
// -- of Xilinx, Inc. and is protected under U.S. and 
// -- international copyright and other intellectual property
// -- laws.
// --
// -- DISCLAIMER
// -- This disclaimer is not a license and does not grant any
// -- rights to the materials distributed herewith. Except as
// -- otherwise provided in a valid license issued to you by
// -- Xilinx, and to the maximum extent permitted by applicable
// -- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
// -- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
// -- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
// -- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
// -- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
// -- (2) Xilinx shall not be liable (whether in contract or tort,
// -- including negligence, or under any other theory of
// -- liability) for any loss or damage of any kind or nature
// -- related to, arising under or in connection with these
// -- materials, including for any direct, or any indirect,
// -- special, incidental, or consequential loss or damage
// -- (including loss of data, profits, goodwill, or any type of
// -- loss or damage suffered as a result of any action brought
// -- by a third party) even if such damage or loss was
// -- reasonably foreseeable or Xilinx had been advised of the
// -- possibility of the same.
// --
// -- CRITICAL APPLICATIONS
// -- Xilinx products are not designed or intended to be fail-
// -- safe, or for use in any application requiring fail-safe
// -- performance, such as life-support or safety devices or
// -- systems, Class III medical devices, nuclear facilities,
// -- applications related to the deployment of airbags, or any
// -- other applications that could lead to death, personal
// -- injury, or severe property or environmental damage
// -- (individually and collectively, "Critical
// -- Applications"). Customer assumes the sole risk and
// -- liability of any use of Xilinx products in Critical
// -- Applications, subject only to applicable laws and
// -- regulations governing limitations on product liability.
// --
// -- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
// -- PART OF THIS FILE AT ALL TIMES.
//-----------------------------------------------------------------------------
//
// Description: Write Data Down-Sizer
// Mirror data for simple accesses.
// Merge data for burst.
//
//
// Verilog-standard:  Verilog 2001
//--------------------------------------------------------------------------
//
// Structure:
//   w_downsizer
//
//--------------------------------------------------------------------------
`timescale 1ps/1ps

(* DowngradeIPIdentifiedWarnings="yes" *) 
module axi_interconnect_v1_7_13_w_downsizer #
  (
   parameter         C_FAMILY                         = "none", 
                       // FPGA Family. Current version: virtex6 or spartan6.
   parameter integer C_AXI_ID_WIDTH                   = 4, 
                       // Width of all ID signals on SI and MI side of converter.
                       // Range: >= 1.
   parameter         C_S_AXI_DATA_WIDTH               = 32'h00000040,
                       // Width of S_AXI_WDATA and S_AXI_RDATA.
                       // Format: Bit32;
                       // Range: 'h00000040, 'h00000080, 'h00000100.
   parameter         C_M_AXI_DATA_WIDTH               = 32'h00000020, 
                       // Width of M_AXI_WDATA and M_AXI_RDATA. 
                       // Assume always smaller than C_S_AXI_DATA_WIDTH.
                       // Format: Bit32; 
                       // Range: 'h00000020, 'h00000040, 'h00000080.
   parameter integer C_AXI_SUPPORTS_USER_SIGNALS      = 0,
                       // 1 = Propagate all USER signals, 0 = Dont propagate.
   parameter integer C_AXI_WUSER_WIDTH                = 1,
                       // Width of WUSER signals. 
                       // Range: >= 1.
   parameter integer C_SUPPORT_SPLITTING              = 1,
                       // Implement transaction splitting logic.
   parameter integer C_SUPPORT_BURSTS                 = 1,
                       // Disabled when all connected slaves and masters are AxiLite,
                       //   allowing logic to be simplified.
   parameter integer C_SINGLE_THREAD                  = 1,
                       // Allow multiple outstanding transactions only if the IDs are the same.
   parameter integer C_S_AXI_BYTES_LOG                = 3,
                       // Log2 of number of 32bit word on SI-side.
   parameter integer C_M_AXI_BYTES_LOG                = 2,
                       // Log2 of number of 32bit word on MI-side.
   parameter integer C_RATIO_LOG                      = 1
                       // Log2 of Up-Sizing ratio for data.
   )
  (
   // Global Signals
   input  wire                                                    ARESET,
   input  wire                                                    ACLK,

   // Command Interface
   input  wire                              cmd_valid,
   input  wire                              cmd_mirror,
   input  wire                              cmd_fix,
   input  wire [C_S_AXI_BYTES_LOG-1:0]      cmd_first_word, 
   input  wire [C_S_AXI_BYTES_LOG-1:0]      cmd_offset,
   input  wire [C_S_AXI_BYTES_LOG-1:0]      cmd_mask,
   input  wire [C_M_AXI_BYTES_LOG:0]        cmd_step,
   input  wire [3-1:0]                      cmd_size,
   input  wire [8-1:0]                      cmd_length,
   output wire                              cmd_ready,
   
   // Slave Interface Write Data Ports
   input  wire [C_S_AXI_DATA_WIDTH-1:0]     S_AXI_WDATA,
   input  wire [C_S_AXI_DATA_WIDTH/8-1:0]   S_AXI_WSTRB,
   input  wire                                                    S_AXI_WLAST,
   input  wire [C_AXI_WUSER_WIDTH-1:0]          S_AXI_WUSER,
   input  wire                                                    S_AXI_WVALID,
   output wire                                                    S_AXI_WREADY,

   // Master Interface Write Data Ports
   output wire [C_M_AXI_DATA_WIDTH-1:0]    M_AXI_WDATA,
   output wire [C_M_AXI_DATA_WIDTH/8-1:0]  M_AXI_WSTRB,
   output wire                                                   M_AXI_WLAST,
   output wire [C_AXI_WUSER_WIDTH-1:0]         M_AXI_WUSER,
   output wire                                                   M_AXI_WVALID,
   input  wire                                                   M_AXI_WREADY
   );

   
  /////////////////////////////////////////////////////////////////////////////
  // Variables for generating parameter controlled instances.
  /////////////////////////////////////////////////////////////////////////////
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Local params
  /////////////////////////////////////////////////////////////////////////////
  
  // .
  localparam [24-1:0] C_DOUBLE_LEN       = 24'b0000_0000_0000_0000_1111_1111;
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Functions
  /////////////////////////////////////////////////////////////////////////////
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Internal signals
  /////////////////////////////////////////////////////////////////////////////

  // Sub-word handling.
  reg                             first_word;
  reg  [C_S_AXI_BYTES_LOG-1:0]    current_word_1;
  reg  [C_S_AXI_BYTES_LOG-1:0]    current_word;
  wire [C_S_AXI_BYTES_LOG-1:0]    current_word_adjusted;
  wire [C_RATIO_LOG-1:0]          current_index;
  wire                            last_beat;
  wire                            last_word;
  reg  [C_S_AXI_BYTES_LOG-1:0]    size_mask;
  
  // Sub-word handling for the next cycle.
  wire [C_S_AXI_BYTES_LOG-1:0]    next_word;
  
  // Burst length handling.
  reg                             first_mi_word;
  reg  [8-1:0]                    length_counter_1;
  reg  [8-1:0]                    length_counter;
  wire [8-1:0]                    next_length_counter;
  
  // Throttling help signals.
  wire                            word_completed;
  wire                            cmd_ready_i;
  wire                            pop_mi_data;
  wire                            mi_stalling;
  
  // Internal SI side control signals.
  wire                            S_AXI_WREADY_I;
  
  // Internal signals for MI-side.
  wire [C_M_AXI_DATA_WIDTH-1:0]   M_AXI_WDATA_I;
  wire [C_M_AXI_DATA_WIDTH/8-1:0] M_AXI_WSTRB_I;
  wire                            M_AXI_WLAST_I;
  wire [C_AXI_WUSER_WIDTH-1:0]    M_AXI_WUSER_I;
  wire                            M_AXI_WVALID_I;
  wire                            M_AXI_WREADY_I;
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Handle interface handshaking:
  //
  // Determine if a SI-side word has been completely used. For FIX transactions
  // the SI-side word is used to extract a single data word. 
  // Otherwise is the SI-side word considered to be used when last MI-side beat
  // has been extracted or when the last (most significant) MI-side word has 
  // been extracted from the SI-side word.
  //
  // Data on the MI-side is available when data is being taken from SI-side.
  //
  // The command is popped from the command queue once the last beat on the 
  // MI-side has been ackowledged.
  // 
  /////////////////////////////////////////////////////////////////////////////
  
  // Generate address bits used for SI-side transaction size.
  always @ *
  begin
    case (cmd_size)
      3'b000: size_mask = C_DOUBLE_LEN[8 +: C_S_AXI_BYTES_LOG];
      3'b001: size_mask = C_DOUBLE_LEN[7 +: C_S_AXI_BYTES_LOG];
      3'b010: size_mask = C_DOUBLE_LEN[6 +: C_S_AXI_BYTES_LOG];
      3'b011: size_mask = C_DOUBLE_LEN[5 +: C_S_AXI_BYTES_LOG];
      3'b100: size_mask = C_DOUBLE_LEN[4 +: C_S_AXI_BYTES_LOG];
      3'b101: size_mask = C_DOUBLE_LEN[3 +: C_S_AXI_BYTES_LOG];
      3'b110: size_mask = C_DOUBLE_LEN[2 +: C_S_AXI_BYTES_LOG];
      3'b111: size_mask = C_DOUBLE_LEN[1 +: C_S_AXI_BYTES_LOG];  // Illegal setting.
    endcase
  end
  
  // Detect when SI-side word is completely used.
  assign word_completed = ( cmd_fix ) |
                          ( cmd_mirror ) |
                          ( ~cmd_fix & ( ( next_word & size_mask ) == {C_S_AXI_BYTES_LOG{1'b0}} ) ) | 
                          ( ~cmd_fix & last_word ) | 
                          ( C_SUPPORT_BURSTS == 0 );
  
  // Pop word from SI-side.
  assign S_AXI_WREADY_I = S_AXI_WVALID & cmd_valid & word_completed & ~mi_stalling;
  assign S_AXI_WREADY   = S_AXI_WREADY_I;
  
  // Indicate when there is data available @ MI-side.
  assign M_AXI_WVALID_I = S_AXI_WVALID & cmd_valid;
  
  // Get MI-side data.
  assign pop_mi_data    = M_AXI_WVALID_I & M_AXI_WREADY_I;
  
  // Signal that the command is done (so that it can be poped from command queue).
  assign cmd_ready_i    = cmd_valid & pop_mi_data & last_word;
  assign cmd_ready      = cmd_ready_i;
  
  // Detect when MI-side is stalling.
  assign mi_stalling    = M_AXI_WVALID_I & ~M_AXI_WREADY_I;
                          
  
  /////////////////////////////////////////////////////////////////////////////
  // Keep track of data extraction:
  // 
  // Current address is taken form the command buffer for the first data beat
  // to handle unaligned Read transactions. After this is the extraction 
  // address usually calculated from this point.
  // FIX transactions uses the same word address for all data beats. 
  // 
  // Next word address is generated as current word plus the current step 
  // size, with masking to facilitate sub-sized wraping. The Mask is all ones
  // for normal wraping, and less when sub-sized wraping is used.
  // 
  // The calculated word addresses (current and next) is offseted by the 
  // current Offset. For sub-sized transaction the Offset points to the least 
  // significant address of the included data beats. (The least significant 
  // word is not necessarily the first data to be extracted, consider WRAP).
  // Offset is only used for sub-sized WRAP transcation that are Complete.
  // 
  // First word is active during the first MI-side data beat.
  // 
  // First MI is set during the first MI-side data beat.
  //
  // The transaction length is taken from the command buffer combinatorialy
  // during the First MI cycle. For each generated MI word it is decreased 
  // until Last Beat is reached.
  // 
  // Last word is determined depending as the last MI-side word generated for 
  // the command (generated from the AW translation).
  // If burst aren't supported all MI-side words are concidered to be the last.
  //
  /////////////////////////////////////////////////////////////////////////////
  
  // Select if the offset comes from command queue directly or 
  // from a counter while when extracting multiple MI words per SI word
  always @ *
  begin
    if ( first_word | cmd_fix )
      current_word = cmd_first_word;
    else
      current_word = current_word_1;
  end
  
  // Calculate next word.
  assign next_word              = ( current_word + cmd_step ) & cmd_mask;
  
  // Calculate the word address with offset.
  assign current_word_adjusted  = current_word + cmd_offset;
  
  // Get the ratio bits (MI-side words vs SI-side words).
  assign current_index          = current_word_adjusted[C_S_AXI_BYTES_LOG-C_RATIO_LOG +: C_RATIO_LOG];
  
  // Prepare next word address.
  always @ (posedge ACLK) begin
    if (ARESET) begin
      first_word      <= 1'b1;
      current_word_1  <= 'b0;
    end else begin
      if ( pop_mi_data ) begin
        if ( M_AXI_WLAST_I ) begin
          // Prepare for next access.
          first_word      <=  1'b1;
        end else begin
          first_word      <=  1'b0;
        end
      
        current_word_1  <= next_word;
      end
    end
  end
  
  // Select command length or counted length.
  always @ *
  begin
    if ( first_mi_word )
      length_counter = cmd_length;
    else
      length_counter = length_counter_1;
  end
  
  // Calculate next length counter value.
  assign next_length_counter = length_counter - 1'b1;
  
  // Keep track of burst length.
  always @ (posedge ACLK) begin
    if (ARESET) begin
      first_mi_word    <= 1'b1;
      length_counter_1 <= 8'b0;
    end else begin
      if ( pop_mi_data ) begin
        if ( M_AXI_WLAST_I ) begin
          first_mi_word    <= 1'b1;
        end else begin
          first_mi_word    <= 1'b0;
        end
      
        length_counter_1 <= next_length_counter;
      end
    end
  end
  
  // Detect last beat in a burst.
  assign last_beat = ( length_counter == 8'b0 );
  
  // Determine if this last word that shall be extracted from this SI-side word.
  assign last_word = ( last_beat ) |
                     ( C_SUPPORT_BURSTS == 0 );
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Select the SI-side word to write.
  // Data must be multiplexed but the other information can be reused 
  // directly (ID and USER).
  //
  // Last need special handling since it is the last MI-side word generated 
  // from the SI-side word that shall be marked.
  // Split transactions needs to insert new LAST transactions. So to simplify
  // is the LAST signal always generated.
  //
  /////////////////////////////////////////////////////////////////////////////
  
  // ID and USER is copied from the SI word to all MI word transactions.
  assign M_AXI_WUSER_I  = ( C_AXI_SUPPORTS_USER_SIGNALS ) ? S_AXI_WUSER : {C_AXI_WUSER_WIDTH{1'b0}};
  
  // Data has to be multiplexed.
  assign M_AXI_WDATA_I  = S_AXI_WDATA[current_index * C_M_AXI_DATA_WIDTH   +: C_M_AXI_DATA_WIDTH];
  assign M_AXI_WSTRB_I  = S_AXI_WSTRB[current_index * C_M_AXI_DATA_WIDTH/8 +: C_M_AXI_DATA_WIDTH/8];
  
  // Handle last flag, i.e. set for MI-side last word.
  assign M_AXI_WLAST_I  = last_word;
  
  
  /////////////////////////////////////////////////////////////////////////////
  // MI-side output handling
  /////////////////////////////////////////////////////////////////////////////
// TODO: registered?  
  assign M_AXI_WDATA    = M_AXI_WDATA_I;
  assign M_AXI_WSTRB    = M_AXI_WSTRB_I;
  assign M_AXI_WLAST    = M_AXI_WLAST_I;
  assign M_AXI_WUSER    = M_AXI_WUSER_I;
  assign M_AXI_WVALID   = M_AXI_WVALID_I;
  assign M_AXI_WREADY_I = M_AXI_WREADY;
  
  
endmodule


// -- (c) Copyright 2010 - 2011 Xilinx, Inc. All rights reserved.
// --
// -- This file contains confidential and proprietary information
// -- of Xilinx, Inc. and is protected under U.S. and 
// -- international copyright and other intellectual property
// -- laws.
// --
// -- DISCLAIMER
// -- This disclaimer is not a license and does not grant any
// -- rights to the materials distributed herewith. Except as
// -- otherwise provided in a valid license issued to you by
// -- Xilinx, and to the maximum extent permitted by applicable
// -- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
// -- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
// -- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
// -- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
// -- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
// -- (2) Xilinx shall not be liable (whether in contract or tort,
// -- including negligence, or under any other theory of
// -- liability) for any loss or damage of any kind or nature
// -- related to, arising under or in connection with these
// -- materials, including for any direct, or any indirect,
// -- special, incidental, or consequential loss or damage
// -- (including loss of data, profits, goodwill, or any type of
// -- loss or damage suffered as a result of any action brought
// -- by a third party) even if such damage or loss was
// -- reasonably foreseeable or Xilinx had been advised of the
// -- possibility of the same.
// --
// -- CRITICAL APPLICATIONS
// -- Xilinx products are not designed or intended to be fail-
// -- safe, or for use in any application requiring fail-safe
// -- performance, such as life-support or safety devices or
// -- systems, Class III medical devices, nuclear facilities,
// -- applications related to the deployment of airbags, or any
// -- other applications that could lead to death, personal
// -- injury, or severe property or environmental damage
// -- (individually and collectively, "Critical
// -- Applications"). Customer assumes the sole risk and
// -- liability of any use of Xilinx products in Critical
// -- Applications, subject only to applicable laws and
// -- regulations governing limitations on product liability.
// --
// -- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
// -- PART OF THIS FILE AT ALL TIMES.
//-----------------------------------------------------------------------------
//
// Description: Write Data Up-Sizer
// Mirror data for simple accesses.
// Merge data for burst.
//
//
// Verilog-standard:  Verilog 2001
//--------------------------------------------------------------------------
//
// Structure:
//   w_upsizer
//
//--------------------------------------------------------------------------
`timescale 1ps/1ps


(* DowngradeIPIdentifiedWarnings="yes" *) 
module axi_interconnect_v1_7_13_w_upsizer #
  (
   parameter         C_FAMILY                         = "rtl", 
                       // FPGA Family. Current version: virtex6 or spartan6.
   parameter         C_S_AXI_DATA_WIDTH               = 32'h00000020, 
                       // Width of S_AXI_WDATA and S_AXI_RDATA.
                       // Format: Bit32; 
                       // Range: 'h00000020, 'h00000040, 'h00000080, 'h00000100.
   parameter         C_M_AXI_DATA_WIDTH               = 32'h00000040, 
                       // Width of M_AXI_WDATA and M_AXI_RDATA.
                       // Assume greater than or equal to C_S_AXI_DATA_WIDTH.
                       // Format: Bit32;
                       // Range: 'h00000020, 'h00000040, 'h00000080, 'h00000100.
   parameter integer C_M_AXI_REGISTER                 = 0,
                       // Clock output data.
                       // Range: 0, 1
   parameter integer C_AXI_SUPPORTS_USER_SIGNALS      = 0,
                       // 1 = Propagate all USER signals, 0 = Dont propagate.
   parameter integer C_AXI_WUSER_WIDTH                = 1,
                       // Width of WUSER signals. 
                       // Range: >= 1.
   parameter integer C_PACKING_LEVEL                    = 1,
                       // 0 = Never pack (expander only); packing logic is omitted.
                       // 1 = Pack only when CACHE[1] (Modifiable) is high.
                       // 2 = Always pack, regardless of sub-size transaction or Modifiable bit.
                       //     (Required when used as helper-core by mem-con.)
   parameter integer C_SUPPORT_BURSTS                 = 1,
                       // Disabled when all connected masters and slaves are AxiLite,
                       //   allowing logic to be simplified.
   parameter integer C_S_AXI_BYTES_LOG                = 3,
                       // Log2 of number of 32bit word on SI-side.
   parameter integer C_M_AXI_BYTES_LOG                = 3,
                       // Log2 of number of 32bit word on MI-side.
   parameter integer C_RATIO                          = 2,
                       // Up-Sizing ratio for data.
   parameter integer C_RATIO_LOG                      = 1
                       // Log2 of Up-Sizing ratio for data.
   )
  (
   // Global Signals
   input  wire                                                    ARESET,
   input  wire                                                    ACLK,

   // Command Interface
   input  wire                              cmd_valid,
   input  wire                              cmd_fix,
   input  wire                              cmd_modified,
   input  wire                              cmd_complete_wrap,
   input  wire                              cmd_packed_wrap,
   input  wire [C_M_AXI_BYTES_LOG-1:0]      cmd_first_word, 
   input  wire [C_M_AXI_BYTES_LOG-1:0]      cmd_next_word,
   input  wire [C_M_AXI_BYTES_LOG-1:0]      cmd_last_word,
   input  wire [C_M_AXI_BYTES_LOG-1:0]      cmd_offset,
   input  wire [C_M_AXI_BYTES_LOG-1:0]      cmd_mask,
   input  wire [C_S_AXI_BYTES_LOG:0]        cmd_step,
   input  wire [8-1:0]                      cmd_length,
   output wire                              cmd_ready,
   
   // Slave Interface Write Data Ports
   input  wire [C_S_AXI_DATA_WIDTH-1:0]     S_AXI_WDATA,
   input  wire [C_S_AXI_DATA_WIDTH/8-1:0]   S_AXI_WSTRB,
   input  wire                                                    S_AXI_WLAST,
   input  wire [C_AXI_WUSER_WIDTH-1:0]          S_AXI_WUSER,
   input  wire                                                    S_AXI_WVALID,
   output wire                                                    S_AXI_WREADY,

   // Master Interface Write Data Ports
   output wire [C_M_AXI_DATA_WIDTH-1:0]    M_AXI_WDATA,
   output wire [C_M_AXI_DATA_WIDTH/8-1:0]  M_AXI_WSTRB,
   output wire                                                   M_AXI_WLAST,
   output wire [C_AXI_WUSER_WIDTH-1:0]         M_AXI_WUSER,
   output wire                                                   M_AXI_WVALID,
   input  wire                                                   M_AXI_WREADY
   );
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Variables for generating parameter controlled instances.
  /////////////////////////////////////////////////////////////////////////////
  
  // Generate variable for SI-side word lanes on MI-side.
  genvar word_cnt;
  
  // Generate variable for intra SI-word byte control (on MI-side) for always pack.
  genvar byte_cnt;
  genvar bit_cnt;
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Local params
  /////////////////////////////////////////////////////////////////////////////
  
  // Constants for packing levels.
  localparam integer C_NEVER_PACK        = 0;
  localparam integer C_DEFAULT_PACK      = 1;
  localparam integer C_ALWAYS_PACK       = 2;
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Functions
  /////////////////////////////////////////////////////////////////////////////
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Internal signals
  /////////////////////////////////////////////////////////////////////////////

  // Sub-word handling.
  wire                            sel_first_word;
  wire                            first_word;
  wire [C_M_AXI_BYTES_LOG-1:0]    current_word_1;
  wire [C_M_AXI_BYTES_LOG-1:0]    current_word;
  wire [C_M_AXI_BYTES_LOG-1:0]    current_word_adjusted;
  wire [C_RATIO-1:0]              current_word_idx;
  wire                            last_beat;
  wire                            last_word;
  wire                            last_word_extra_carry;
  wire [C_M_AXI_BYTES_LOG-1:0]    cmd_step_i;
  
  // Sub-word handling for the next cycle.
  wire [C_M_AXI_BYTES_LOG-1:0]    pre_next_word_i;
  wire [C_M_AXI_BYTES_LOG-1:0]    pre_next_word;
  wire [C_M_AXI_BYTES_LOG-1:0]    pre_next_word_1;
  wire [C_M_AXI_BYTES_LOG-1:0]    next_word_i;
  wire [C_M_AXI_BYTES_LOG-1:0]    next_word;
  
  // Burst length handling.
  wire                            first_mi_word;
  wire [8-1:0]                    length_counter_1;
  reg  [8-1:0]                    length_counter;
  wire [8-1:0]                    next_length_counter;
  
  // Handle wrap buffering.
  wire                            store_in_wrap_buffer_enabled;
  wire                            store_in_wrap_buffer;
  wire                            ARESET_or_store_in_wrap_buffer;
  wire                            use_wrap_buffer;
  reg                             wrap_buffer_available;
  
  // Detect start of MI word.
  wire                            first_si_in_mi;
  
  // Throttling help signals.
  wire                            word_complete_next_wrap;
  wire                            word_complete_next_wrap_qual;
  wire                            word_complete_next_wrap_valid;
  wire                            word_complete_next_wrap_pop;
  wire                            word_complete_next_wrap_last;
  wire                            word_complete_next_wrap_stall;
  wire                            word_complete_last_word;
  wire                            word_complete_rest;
  wire                            word_complete_rest_qual;
  wire                            word_complete_rest_valid;
  wire                            word_complete_rest_pop;
  wire                            word_complete_rest_last;
  wire                            word_complete_rest_stall;
  wire                            word_completed;
  wire                            word_completed_qualified;
  wire                            cmd_ready_i;
  wire                            pop_si_data;
  wire                            pop_mi_data_i;
  wire                            pop_mi_data;
  wire                            mi_stalling;
  
  // Internal SI side control signals.
  wire                            S_AXI_WREADY_I;
   
  // Internal packed write data.
  wire                            use_expander_data;
  wire [C_M_AXI_DATA_WIDTH/8-1:0] wdata_qualifier;          // For FPGA only
  wire [C_M_AXI_DATA_WIDTH/8-1:0] wstrb_qualifier;          // For FPGA only
  wire [C_M_AXI_DATA_WIDTH/8-1:0] wrap_qualifier;           // For FPGA only
  wire [C_M_AXI_DATA_WIDTH-1:0]   wdata_buffer_i;           // For FPGA only
  wire [C_M_AXI_DATA_WIDTH/8-1:0] wstrb_buffer_i;           // For FPGA only
  reg  [C_M_AXI_DATA_WIDTH-1:0]   wdata_buffer_q;           // For RTL only
  reg  [C_M_AXI_DATA_WIDTH/8-1:0] wstrb_buffer_q;           // For RTL only
  wire [C_M_AXI_DATA_WIDTH-1:0]   wdata_buffer;
  wire [C_M_AXI_DATA_WIDTH/8-1:0] wstrb_buffer;
  reg  [C_AXI_WUSER_WIDTH-1:0]    M_AXI_WUSER_II;
  reg  [C_M_AXI_DATA_WIDTH-1:0]   wdata_last_word_mux;
  reg  [C_M_AXI_DATA_WIDTH/8-1:0] wstrb_last_word_mux;
  reg  [C_M_AXI_DATA_WIDTH-1:0]   wdata_wrap_buffer_cmb;    // For FPGA only
  reg  [C_M_AXI_DATA_WIDTH/8-1:0] wstrb_wrap_buffer_cmb;    // For FPGA only
  reg  [C_M_AXI_DATA_WIDTH-1:0]   wdata_wrap_buffer_q;      // For RTL only
  reg  [C_M_AXI_DATA_WIDTH/8-1:0] wstrb_wrap_buffer_q;      // For RTL only
  wire [C_M_AXI_DATA_WIDTH-1:0]   wdata_wrap_buffer;
  wire [C_M_AXI_DATA_WIDTH/8-1:0] wstrb_wrap_buffer;
  
  // Internal signals for MI-side.
  wire [C_M_AXI_DATA_WIDTH-1:0]   M_AXI_WDATA_cmb;          // For FPGA only
  wire [C_M_AXI_DATA_WIDTH-1:0]   M_AXI_WDATA_q;            // For FPGA only
  reg  [C_M_AXI_DATA_WIDTH-1:0]   M_AXI_WDATA_I;
  wire [C_M_AXI_DATA_WIDTH/8-1:0] M_AXI_WSTRB_cmb;          // For FPGA only
  wire [C_M_AXI_DATA_WIDTH/8-1:0] M_AXI_WSTRB_q;            // For FPGA only
  reg  [C_M_AXI_DATA_WIDTH/8-1:0] M_AXI_WSTRB_I;
  wire                            M_AXI_WLAST_I;
  reg  [C_AXI_WUSER_WIDTH-1:0]    M_AXI_WUSER_I;
  wire                            M_AXI_WVALID_I;
  wire                            M_AXI_WREADY_I;
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Handle interface handshaking:
  //
  // Data on the MI-side is available when data a complete word has been 
  // assembled from the data on SI-side (and potentially from any remainder in
  // the wrap buffer).
  // No data is produced on the MI-side when a unaligned packed wrap is 
  // encountered, instead it stored in the wrap buffer to be used when the 
  // last SI-side data beat is received.
  //
  // The command is popped from the command queue once the last beat on the 
  // SI-side has been ackowledged.
  // 
  // The packing process is stalled when a new MI-side is completed but not 
  // yet acknowledged (by ready).
  //
  /////////////////////////////////////////////////////////////////////////////
  
  generate
    if ( C_RATIO_LOG > 1 ) begin : USE_LARGE_UPSIZING
      assign cmd_step_i = {{C_RATIO_LOG-1{1'b0}}, cmd_step};
    end else begin : NO_LARGE_UPSIZING
      assign cmd_step_i = cmd_step;
    end
  endgenerate
  
  generate
    if ( C_FAMILY == "rtl" || ( C_SUPPORT_BURSTS == 0 ) || 
       ( C_PACKING_LEVEL == C_NEVER_PACK ) ) begin : USE_RTL_WORD_COMPLETED
      
      // Detect when MI-side word is completely assembled.
      assign word_completed = ( cmd_fix ) |
                              ( ~cmd_fix & ~cmd_complete_wrap & next_word == {C_M_AXI_BYTES_LOG{1'b0}} ) | 
                              ( ~cmd_fix & last_word ) | 
                              ( ~cmd_modified ) |
                              ( C_PACKING_LEVEL == C_NEVER_PACK ) | 
                              ( C_SUPPORT_BURSTS == 0 );
      
      assign word_completed_qualified   = word_completed & cmd_valid & ~store_in_wrap_buffer_enabled;
      
      // RTL equivalent of optimized partial extressions (address wrap for next word).
      assign word_complete_next_wrap        = ( ~cmd_fix & ~cmd_complete_wrap & 
                                                next_word == {C_M_AXI_BYTES_LOG{1'b0}} ) | 
                                              ( C_PACKING_LEVEL == C_NEVER_PACK ) | 
                                              ( C_SUPPORT_BURSTS == 0 );
      assign word_complete_next_wrap_qual   = word_complete_next_wrap & cmd_valid & ~store_in_wrap_buffer_enabled;
      assign word_complete_next_wrap_valid  = word_complete_next_wrap_qual & S_AXI_WVALID;
      assign word_complete_next_wrap_pop    = word_complete_next_wrap_valid & M_AXI_WREADY_I;
      assign word_complete_next_wrap_last   = word_complete_next_wrap_pop & M_AXI_WLAST_I;
      assign word_complete_next_wrap_stall  = word_complete_next_wrap_valid & ~M_AXI_WREADY_I;
      
      // RTL equivalent of optimized partial extressions (last word and the remaining).
      assign word_complete_last_word   = last_word & ~cmd_fix;
      assign word_complete_rest        = word_complete_last_word | cmd_fix | ~cmd_modified;
      assign word_complete_rest_qual   = word_complete_rest & cmd_valid & ~store_in_wrap_buffer_enabled;
      assign word_complete_rest_valid  = word_complete_rest_qual & S_AXI_WVALID;
      assign word_complete_rest_pop    = word_complete_rest_valid & M_AXI_WREADY_I;
      assign word_complete_rest_last   = word_complete_rest_pop & M_AXI_WLAST_I;
      assign word_complete_rest_stall  = word_complete_rest_valid & ~M_AXI_WREADY_I;
      
    end else begin : USE_FPGA_WORD_COMPLETED
    
      wire next_word_wrap;
      wire sel_word_complete_next_wrap;
      wire sel_word_complete_next_wrap_qual;
      wire sel_word_complete_next_wrap_stall;
      
      wire sel_last_word;
      wire sel_word_complete_rest;
      wire sel_word_complete_rest_qual;
      wire sel_word_complete_rest_stall;
      
      
      // Optimize next word address wrap branch of expression.
      //
  axi_interconnect_v1_7_13_comparator_sel_static #
        (
         .C_FAMILY(C_FAMILY),
         .C_VALUE({C_M_AXI_BYTES_LOG{1'b0}}),
         .C_DATA_WIDTH(C_M_AXI_BYTES_LOG)
         ) next_word_wrap_inst
        (
         .CIN(1'b1),
         .S(sel_first_word),
         .A(pre_next_word_1),
         .B(cmd_next_word),
         .COUT(next_word_wrap)
         );
         
      assign sel_word_complete_next_wrap = ~cmd_fix & ~cmd_complete_wrap;
      
  axi_interconnect_v1_7_13_carry_and #
        (
         .C_FAMILY(C_FAMILY)
         ) word_complete_next_wrap_inst
        (
         .CIN(next_word_wrap),
         .S(sel_word_complete_next_wrap),
         .COUT(word_complete_next_wrap)
         );
         
      assign sel_word_complete_next_wrap_qual = cmd_valid & ~store_in_wrap_buffer_enabled;
      
  axi_interconnect_v1_7_13_carry_and #
        (
         .C_FAMILY(C_FAMILY)
         ) word_complete_next_wrap_valid_inst
        (
         .CIN(word_complete_next_wrap),
         .S(sel_word_complete_next_wrap_qual),
         .COUT(word_complete_next_wrap_qual)
         );
         
  axi_interconnect_v1_7_13_carry_and #
        (
         .C_FAMILY(C_FAMILY)
         ) word_complete_next_wrap_qual_inst
        (
         .CIN(word_complete_next_wrap_qual),
         .S(S_AXI_WVALID),
         .COUT(word_complete_next_wrap_valid)
         );
         
  axi_interconnect_v1_7_13_carry_and #
        (
         .C_FAMILY(C_FAMILY)
         ) word_complete_next_wrap_pop_inst
        (
         .CIN(word_complete_next_wrap_valid),
         .S(M_AXI_WREADY_I),
         .COUT(word_complete_next_wrap_pop)
         );
         
      assign sel_word_complete_next_wrap_stall = ~M_AXI_WREADY_I;
      
  axi_interconnect_v1_7_13_carry_latch_and #
        (
         .C_FAMILY(C_FAMILY)
         ) word_complete_next_wrap_stall_inst
        (
         .CIN(word_complete_next_wrap_valid),
         .I(sel_word_complete_next_wrap_stall),
         .O(word_complete_next_wrap_stall)
         );
         
  axi_interconnect_v1_7_13_carry_and #
        (
         .C_FAMILY(C_FAMILY)
         ) word_complete_next_wrap_last_inst
        (
         .CIN(word_complete_next_wrap_pop),
         .S(M_AXI_WLAST_I),
         .COUT(word_complete_next_wrap_last)
         );
         
      // Optimize last word and "rest" branch of expression.
      //
      assign sel_last_word = ~cmd_fix;
      
  axi_interconnect_v1_7_13_carry_and #
        (
         .C_FAMILY(C_FAMILY)
         ) last_word_inst_2
        (
         .CIN(last_word_extra_carry),
         .S(sel_last_word),
         .COUT(word_complete_last_word)
         );
      
      assign sel_word_complete_rest = cmd_fix | ~cmd_modified;
      
  axi_interconnect_v1_7_13_carry_or #
        (
         .C_FAMILY(C_FAMILY)
         ) pop_si_data_inst
        (
         .CIN(word_complete_last_word),
         .S(sel_word_complete_rest),
         .COUT(word_complete_rest)
         );
      
      assign sel_word_complete_rest_qual = cmd_valid & ~store_in_wrap_buffer_enabled;
      
  axi_interconnect_v1_7_13_carry_and #
        (
         .C_FAMILY(C_FAMILY)
         ) word_complete_rest_valid_inst
        (
         .CIN(word_complete_rest),
         .S(sel_word_complete_rest_qual),
         .COUT(word_complete_rest_qual)
         );
         
  axi_interconnect_v1_7_13_carry_and #
        (
         .C_FAMILY(C_FAMILY)
         ) word_complete_rest_qual_inst
        (
         .CIN(word_complete_rest_qual),
         .S(S_AXI_WVALID),
         .COUT(word_complete_rest_valid)
         );
         
  axi_interconnect_v1_7_13_carry_and #
        (
         .C_FAMILY(C_FAMILY)
         ) word_complete_rest_pop_inst
        (
         .CIN(word_complete_rest_valid),
         .S(M_AXI_WREADY_I),
         .COUT(word_complete_rest_pop)
         );
         
      assign sel_word_complete_rest_stall = ~M_AXI_WREADY_I;
      
  axi_interconnect_v1_7_13_carry_latch_and #
        (
         .C_FAMILY(C_FAMILY)
         ) word_complete_rest_stall_inst
        (
         .CIN(word_complete_rest_valid),
         .I(sel_word_complete_rest_stall),
         .O(word_complete_rest_stall)
         );
         
  axi_interconnect_v1_7_13_carry_and #
        (
         .C_FAMILY(C_FAMILY)
         ) word_complete_rest_last_inst
        (
         .CIN(word_complete_rest_pop),
         .S(M_AXI_WLAST_I),
         .COUT(word_complete_rest_last)
         );
      
      // Combine the two branches to generate the full signal.
      assign word_completed = word_complete_next_wrap | word_complete_rest;
      
      assign word_completed_qualified   = word_complete_next_wrap_qual | word_complete_rest_qual;
      
    end
  endgenerate
      
  // Pop word from SI-side.
  assign S_AXI_WREADY_I = ~mi_stalling & cmd_valid;
  assign S_AXI_WREADY   = S_AXI_WREADY_I;
  
  // Indicate when there is data available @ MI-side.
  generate
    if ( C_FAMILY == "rtl" ) begin : USE_RTL_M_WVALID
      assign M_AXI_WVALID_I = S_AXI_WVALID & word_completed_qualified;
      
    end else begin : USE_FPGA_M_WVALID
      
      assign M_AXI_WVALID_I = ( word_complete_next_wrap_valid | word_complete_rest_valid);
      
    end
  endgenerate
  
  // Get SI-side data.
  generate
    if ( C_M_AXI_REGISTER ) begin : USE_REGISTER_SI_POP
      assign pop_si_data    = S_AXI_WVALID & ~mi_stalling & cmd_valid;
    end else begin : NO_REGISTER_SI_POP
      if ( C_FAMILY == "rtl" ) begin : USE_RTL_POP_SI
        assign pop_si_data    = S_AXI_WVALID & S_AXI_WREADY_I;
      end else begin : USE_FPGA_POP_SI
        assign pop_si_data = ~( word_complete_next_wrap_stall | word_complete_rest_stall ) &
                             cmd_valid & S_AXI_WVALID;
      end
    end
  endgenerate
      
  // Signal that the command is done (so that it can be poped from command queue).
  generate
    if ( C_FAMILY == "rtl" ) begin : USE_RTL_CMD_READY
      assign cmd_ready_i    = cmd_valid & M_AXI_WLAST_I & pop_mi_data_i;
      
    end else begin : USE_FPGA_CMD_READY
      assign cmd_ready_i = ( word_complete_next_wrap_last | word_complete_rest_last);
      
    end
  endgenerate
  assign cmd_ready      = cmd_ready_i;
  
  // Set last upsized word.
  assign M_AXI_WLAST_I  = S_AXI_WLAST;
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Keep track of data extraction:
  // 
  // Current address is taken form the command buffer for the first data beat
  // to handle unaligned Write transactions. After this is the extraction 
  // address usually calculated from this point.
  // FIX transactions uses the same word address for all data beats. 
  // 
  // Next word address is generated as current word plus the current step 
  // size, with masking to facilitate sub-sized wraping. The Mask is all ones
  // for normal wraping, and less when sub-sized wraping is used.
  // 
  // The calculated word addresses (current and next) is offseted by the 
  // current Offset. For sub-sized transaction the Offest points to the least 
  // significant address of the included data beats. (The least significant 
  // word is not necessarily the first data to be packed, consider WRAP).
  // Offset is only used for sub-sized WRAP transcation that are Complete.
  // 
  // First word is active during the first SI-side data beat.
  // 
  // First MI is set while the entire first MI-side word is processed.
  //
  // The transaction length is taken from the command buffer combinatorialy
  // during the First MI cycle. For each generated MI word it is decreased 
  // until Last beat is reached.
  // 
  /////////////////////////////////////////////////////////////////////////////
  
  // Select if the offset comes from command queue directly or 
  // from a counter while when extracting multiple SI words per MI word
  assign sel_first_word = first_word | cmd_fix;
  assign current_word   = sel_first_word ? cmd_first_word : 
                                           current_word_1;
  
  generate
    if ( C_FAMILY == "rtl" ) begin : USE_RTL_NEXT_WORD
      
      // Calculate next word.
      assign pre_next_word_i  = ( next_word_i + cmd_step_i );
      
      // Calculate next word.
      assign next_word_i      = sel_first_word ? cmd_next_word : 
                                                 pre_next_word_1;
      
    end else begin : USE_FPGA_NEXT_WORD
      wire [C_M_AXI_BYTES_LOG-1:0]  next_sel;
      wire [C_M_AXI_BYTES_LOG:0]    next_carry_local;
      
      // Assign input to local vectors.
      assign next_carry_local[0]      = 1'b0;
    
      // Instantiate one carry and per level.
      for (bit_cnt = 0; bit_cnt < C_M_AXI_BYTES_LOG ; bit_cnt = bit_cnt + 1) begin : LUT_LEVEL
        
        LUT6_2 # (
         .INIT(64'h5A5A_5A66_F0F0_F0CC) 
        ) LUT6_2_inst (
        .O6(next_sel[bit_cnt]),         // 6/5-LUT output (1-bit)
        .O5(next_word_i[bit_cnt]),      // 5-LUT output (1-bit)
        .I0(cmd_step_i[bit_cnt]),       // LUT input (1-bit)
        .I1(pre_next_word_1[bit_cnt]),  // LUT input (1-bit)
        .I2(cmd_next_word[bit_cnt]),    // LUT input (1-bit)
        .I3(first_word),                // LUT input (1-bit)
        .I4(cmd_fix),                   // LUT input (1-bit)
        .I5(1'b1)                       // LUT input (1-bit)
        );
        
        MUXCY next_carry_inst 
        (
         .O (next_carry_local[bit_cnt+1]), 
         .CI (next_carry_local[bit_cnt]), 
         .DI (cmd_step_i[bit_cnt]), 
         .S (next_sel[bit_cnt])
        ); 
        
        XORCY next_xorcy_inst 
        (
         .O(pre_next_word_i[bit_cnt]),
         .CI(next_carry_local[bit_cnt]),
         .LI(next_sel[bit_cnt])
        );
        
      end // end for bit_cnt
      
    end
  endgenerate
  
  // Calculate next word.
  assign next_word              = next_word_i & cmd_mask;
  assign pre_next_word          = pre_next_word_i & cmd_mask;
      
  // Calculate the word address with offset.
  assign current_word_adjusted  = sel_first_word ? ( cmd_first_word | cmd_offset ) : 
                                                   ( current_word_1 | cmd_offset );

  // Prepare next word address.
  generate
    if ( C_FAMILY == "rtl" || C_M_AXI_REGISTER ) begin : USE_RTL_CURR_WORD
      reg  [C_M_AXI_BYTES_LOG-1:0]    current_word_q;
      reg                             first_word_q;
      reg  [C_M_AXI_BYTES_LOG-1:0]    pre_next_word_q;
    
      always @ (posedge ACLK) begin
        if (ARESET) begin
          first_word_q    <= 1'b1;
          current_word_q  <= {C_M_AXI_BYTES_LOG{1'b0}};
          pre_next_word_q <= {C_M_AXI_BYTES_LOG{1'b0}};
        end else begin
          if ( pop_si_data ) begin
            if ( S_AXI_WLAST ) begin
              // Prepare for next access.
              first_word_q    <= 1'b1;
            end else begin
              first_word_q    <= 1'b0;
            end
            
            current_word_q  <= next_word;
            pre_next_word_q <= pre_next_word;
          end
        end
      end
      
      assign first_word       = first_word_q;
      assign current_word_1   = current_word_q;
      assign pre_next_word_1  = pre_next_word_q;
      
    end else begin : USE_FPGA_CURR_WORD
      reg                             first_word_cmb;
      wire                            first_word_i;
      wire [C_M_AXI_BYTES_LOG-1:0]    current_word_i;
      wire [C_M_AXI_BYTES_LOG-1:0]    local_pre_next_word_i;
      
      
      always @ *
      begin
          if ( S_AXI_WLAST ) begin
            // Prepare for next access.
            first_word_cmb    = 1'b1;
          end else begin
            first_word_cmb    = 1'b0;
          end
      end
      
      for (bit_cnt = 0; bit_cnt < C_M_AXI_BYTES_LOG ; bit_cnt = bit_cnt + 1) begin : BIT_LANE
        LUT6 # (
         .INIT(64'hCCCA_CCCC_CCCC_CCCC) 
        ) LUT6_current_inst (
        .O(current_word_i[bit_cnt]),          // 6-LUT output (1-bit)
        .I0(next_word[bit_cnt]),              // LUT input (1-bit)
        .I1(current_word_1[bit_cnt]),         // LUT input (1-bit)
        .I2(word_complete_rest_stall),        // LUT input (1-bit)
        .I3(word_complete_next_wrap_stall),   // LUT input (1-bit)
        .I4(cmd_valid),                       // LUT input (1-bit)
        .I5(S_AXI_WVALID)                     // LUT input (1-bit)
        );
            
        FDRE #(
         .INIT(1'b0)                          // Initial value of register (1'b0 or 1'b1)
         ) FDRE_current_inst (
         .Q(current_word_1[bit_cnt]),         // Data output
         .C(ACLK),                            // Clock input
         .CE(1'b1),                           // Clock enable input
         .R(ARESET),                          // Synchronous reset input
         .D(current_word_i[bit_cnt])          // Data input
         );
         
        LUT6 # (
         .INIT(64'hCCCA_CCCC_CCCC_CCCC) 
        ) LUT6_next_inst (
        .O(local_pre_next_word_i[bit_cnt]),   // 6-LUT output (1-bit)
        .I0(pre_next_word[bit_cnt]),          // LUT input (1-bit)
        .I1(pre_next_word_1[bit_cnt]),        // LUT input (1-bit)
        .I2(word_complete_rest_stall),        // LUT input (1-bit)
        .I3(word_complete_next_wrap_stall),   // LUT input (1-bit)
        .I4(cmd_valid),                       // LUT input (1-bit)
        .I5(S_AXI_WVALID)                     // LUT input (1-bit)
        );
            
        FDRE #(
         .INIT(1'b0)                          // Initial value of register (1'b0 or 1'b1)
         ) FDRE_next_inst (
         .Q(pre_next_word_1[bit_cnt]),        // Data output
         .C(ACLK),                            // Clock input
         .CE(1'b1),                           // Clock enable input
         .R(ARESET),                          // Synchronous reset input
         .D(local_pre_next_word_i[bit_cnt])   // Data input
         );
      end // end for bit_cnt
      
      LUT6 # (
       .INIT(64'hCCCA_CCCC_CCCC_CCCC) 
      ) LUT6_first_inst (
      .O(first_word_i),                     // 6-LUT output (1-bit)
      .I0(first_word_cmb),                  // LUT input (1-bit)
      .I1(first_word),                      // LUT input (1-bit)
      .I2(word_complete_rest_stall),        // LUT input (1-bit)
      .I3(word_complete_next_wrap_stall),   // LUT input (1-bit)
      .I4(cmd_valid),                       // LUT input (1-bit)
      .I5(S_AXI_WVALID)                     // LUT input (1-bit)
      );
          
      FDSE #(
       .INIT(1'b1)                    // Initial value of register (1'b0 or 1'b1)
       ) FDSE_first_inst (
       .Q(first_word),                // Data output
       .C(ACLK),                      // Clock input
       .CE(1'b1),                     // Clock enable input
       .S(ARESET),                    // Synchronous reset input
       .D(first_word_i)               // Data input
       );
    end
  endgenerate
  
  // Select command length or counted length.
  always @ *
  begin
    if ( first_mi_word )
      length_counter = cmd_length;
    else
      length_counter = length_counter_1;
  end
  
  generate
    if ( C_FAMILY == "rtl" ) begin : USE_RTL_LENGTH
      reg  [8-1:0]                    length_counter_q;
      reg                             first_mi_word_q;
    
      // Calculate next length counter value.
      assign next_length_counter = length_counter - 1'b1;
      
      // Keep track of burst length.
      always @ (posedge ACLK) begin
        if (ARESET) begin
          first_mi_word_q  <= 1'b1;
          length_counter_q <= 8'b0;
        end else begin
          if ( pop_mi_data_i ) begin
            if ( M_AXI_WLAST_I ) begin
              first_mi_word_q  <= 1'b1;
            end else begin
              first_mi_word_q  <= 1'b0;
            end
          
            length_counter_q <= next_length_counter;
          end
        end
      end
      
      assign first_mi_word    = first_mi_word_q;
      assign length_counter_1 = length_counter_q;
      
    end else begin : USE_FPGA_LENGTH
      wire [8-1:0]  length_counter_i;
      wire [8-1:0]  length_counter_ii;
      wire [8-1:0]  length_sel;
      wire [8-1:0]  length_di;
      wire [8:0]    length_local_carry;
      
      // Assign input to local vectors.
      assign length_local_carry[0] = 1'b0;
    
      for (bit_cnt = 0; bit_cnt < 8 ; bit_cnt = bit_cnt + 1) begin : BIT_LANE

        LUT6_2 # (
         .INIT(64'h333C_555A_FFF0_FFF0) 
        ) LUT6_length_inst (
        .O6(length_sel[bit_cnt]),           // 6/5-LUT output (1-bit)
        .O5(length_di[bit_cnt]),            // 5-LUT output (1-bit)
        .I0(length_counter_1[bit_cnt]),     // LUT input (1-bit)
        .I1(cmd_length[bit_cnt]),           // LUT input (1-bit)
        .I2(1'b1),                          // LUT input (1-bit)
        .I3(1'b1),                          // LUT input (1-bit)
        .I4(first_mi_word),                 // LUT input (1-bit)
        .I5(1'b1)                           // LUT input (1-bit)
        );
        
        MUXCY carry_inst 
        (
         .O (length_local_carry[bit_cnt+1]), 
         .CI (length_local_carry[bit_cnt]), 
         .DI (length_di[bit_cnt]), 
         .S (length_sel[bit_cnt])
        ); 
        
        XORCY xorcy_inst 
        (
         .O(length_counter_ii[bit_cnt]),
         .CI(length_local_carry[bit_cnt]),
         .LI(length_sel[bit_cnt])
        );
        
        LUT4 # (
         .INIT(16'hCCCA) 
        ) LUT4_inst (
        .O(length_counter_i[bit_cnt]),    // 5-LUT output (1-bit)
        .I0(length_counter_1[bit_cnt]),     // LUT input (1-bit)
        .I1(length_counter_ii[bit_cnt]),  // LUT input (1-bit)
        .I2(word_complete_rest_pop),      // LUT input (1-bit)
        .I3(word_complete_next_wrap_pop)  // LUT input (1-bit)
        );
        
        FDRE #(
         .INIT(1'b0)                    // Initial value of register (1'b0 or 1'b1)
         ) FDRE_length_inst (
         .Q(length_counter_1[bit_cnt]), // Data output
         .C(ACLK),                      // Clock input
         .CE(1'b1),                     // Clock enable input
         .R(ARESET),                    // Synchronous reset input
         .D(length_counter_i[bit_cnt])  // Data input
         );
         
      end // end for bit_cnt
      
      wire first_mi_word_i;
      
      LUT6 # (
       .INIT(64'hAAAC_AAAC_AAAC_AAAC) 
      ) LUT6_first_mi_inst (
      .O(first_mi_word_i),                // 6-LUT output (1-bit)
      .I0(M_AXI_WLAST_I),                 // LUT input (1-bit)
      .I1(first_mi_word),                 // LUT input (1-bit)
      .I2(word_complete_rest_pop),        // LUT input (1-bit)
      .I3(word_complete_next_wrap_pop),   // LUT input (1-bit)
      .I4(1'b1),                          // LUT input (1-bit)
      .I5(1'b1)                           // LUT input (1-bit)
      );
          
      FDSE #(
       .INIT(1'b1)                    // Initial value of register (1'b0 or 1'b1)
       ) FDSE_inst (
       .Q(first_mi_word),             // Data output
       .C(ACLK),                      // Clock input
       .CE(1'b1),                     // Clock enable input
       .S(ARESET),                    // Synchronous reset input
       .D(first_mi_word_i)            // Data input
       );
      
    end
  endgenerate
  
  generate
    if ( C_FAMILY == "rtl" || C_SUPPORT_BURSTS == 0 ) begin : USE_RTL_LAST_WORD
      // Detect last beat in a burst.
      assign last_beat = ( length_counter == 8'b0 );
      
      // Determine if this last word that shall be assembled into this MI-side word.
      assign last_word = ( cmd_modified & last_beat & ( current_word == cmd_last_word ) ) |
                         ( C_SUPPORT_BURSTS == 0 );
      
    end else begin : USE_FPGA_LAST_WORD
      wire last_beat_curr_word;
      
  axi_interconnect_v1_7_13_comparator_sel_static #
        (
         .C_FAMILY(C_FAMILY),
         .C_VALUE(8'b0),
         .C_DATA_WIDTH(8)
         ) last_beat_inst
        (
         .CIN(1'b1),
         .S(first_mi_word),
         .A(length_counter_1),
         .B(cmd_length),
         .COUT(last_beat)
         );
      
  axi_interconnect_v1_7_13_comparator_sel #
        (
         .C_FAMILY(C_FAMILY),
         .C_DATA_WIDTH(C_M_AXI_BYTES_LOG)
         ) last_beat_curr_word_inst
        (
         .CIN(last_beat),
         .S(sel_first_word),
         .A(current_word_1),
         .B(cmd_first_word),
         .V(cmd_last_word),
         .COUT(last_beat_curr_word)
         );
      
  axi_interconnect_v1_7_13_carry_and #
        (
         .C_FAMILY(C_FAMILY)
         ) last_word_inst
        (
         .CIN(last_beat_curr_word),
         .S(cmd_modified),
         .COUT(last_word)
         );

    end
  endgenerate
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Handle wrap buffer:
  //
  // The wrap buffer is used to move data around in an unaligned WRAP 
  // transaction. SI-side data word(s) for an unaligned accesses are delay 
  // to be packed with with the tail of the transaction to make it a WRAP
  // transaction that is aligned to native MI-side data with.
  // For example: an 32bit to 64bit write upsizing @ 0x4 will delay the first 
  // word until the 0x0 data arrives in the last data beat. This will make the 
  // Upsized transaction be WRAP at 0x8 on the MI-side 
  // (was WRAP @ 0x4 on SI-side).
  // 
  /////////////////////////////////////////////////////////////////////////////
  
  // The unaligned SI-side words are pushed into the wrap buffer.
  assign store_in_wrap_buffer_enabled   = cmd_packed_wrap & ~wrap_buffer_available & cmd_valid;
  assign store_in_wrap_buffer           = store_in_wrap_buffer_enabled & S_AXI_WVALID;
  assign ARESET_or_store_in_wrap_buffer = store_in_wrap_buffer | ARESET;
  // The wrap buffer is used to complete last word.
  generate
    if ( C_FAMILY == "rtl" ) begin : USE_RTL_USE_WRAP
      assign use_wrap_buffer      = wrap_buffer_available & last_word;
      
    end else begin : USE_FPGA_USE_WRAP
      wire last_word_carry;  
    
  axi_interconnect_v1_7_13_carry_and #
        (
         .C_FAMILY(C_FAMILY)
         ) last_word_inst2
        (
         .CIN(last_word),
         .S(1'b1),
         .COUT(last_word_carry)
         );

  axi_interconnect_v1_7_13_carry_and #
        (
         .C_FAMILY(C_FAMILY)
         ) last_word_inst3
        (
         .CIN(last_word_carry),
         .S(1'b1),
         .COUT(last_word_extra_carry)
         );

  axi_interconnect_v1_7_13_carry_latch_and #
        (
         .C_FAMILY(C_FAMILY)
         ) word_complete_next_wrap_stall_inst
        (
         .CIN(last_word_carry),
         .I(wrap_buffer_available),
         .O(use_wrap_buffer)
         );
    end
  endgenerate
  
  // Wrap buffer becomes available when the unaligned wrap words has been taken care of.
  always @ (posedge ACLK) begin
    if (ARESET) begin
      wrap_buffer_available <= 1'b0;
    end else begin
      if ( store_in_wrap_buffer & word_completed ) begin
        wrap_buffer_available <= 1'b1;
      end else if ( cmd_ready_i ) begin
        wrap_buffer_available <= 1'b0;
      end
    end
  end
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Handle USER bits:
  // 
  // The USER bits are always propagated from the least significant SI-side 
  // beat to the Up-Sized MI-side data beat. That means:
  // * FIX transactions propagate all USER data (1:1 SI- vs MI-side beat ratio).
  // * INCR transactions uses the first SI-side beat that goes into a MI-side
  //   data word.
  // * WRAP always propagates the USER bits from the most zero aligned SI-side 
  //   data word, regardless if the data is packed or not. For unpacked data 
  //   this would be a 1:1 ratio.
  /////////////////////////////////////////////////////////////////////////////
  
  // Detect first SI-side word per MI-side word.
  assign first_si_in_mi = cmd_fix | 
                          first_word |
                          ~cmd_modified |
                          (cmd_modified & current_word == {C_M_AXI_BYTES_LOG{1'b0}}) |
                          ( C_SUPPORT_BURSTS == 0 );
  
  // Select USER bits combinatorially when expanding or fix.
  always @ *
  begin
    if ( C_AXI_SUPPORTS_USER_SIGNALS ) begin
      if ( first_si_in_mi ) begin
        M_AXI_WUSER_I = S_AXI_WUSER;
      end else begin
        M_AXI_WUSER_I = M_AXI_WUSER_II;
      end
    end else begin
      M_AXI_WUSER_I = {C_AXI_WUSER_WIDTH{1'b0}};
    end
  end
  
  // Capture user bits.
  always @ (posedge ACLK) begin
    if (ARESET) begin
      M_AXI_WUSER_II <= {C_AXI_WUSER_WIDTH{1'b0}};
    end else begin
      if ( first_si_in_mi & pop_si_data ) begin
        M_AXI_WUSER_II <= S_AXI_WUSER;
      end
    end
  end
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Pack multiple data SI-side words into fewer MI-side data word.
  // Data is only packed when modify is set. Granularity is SI-side word for 
  // the combinatorial data mux.
  //
  // Expander:
  // WDATA is expanded to all SI-word lane on the MI-side.
  // WSTRB is activted to the correct SI-word lane on the MI-side.
  //
  // Packer:
  // The WDATA and WSTRB registers are always cleared before a new word is 
  // assembled.
  // WDATA is (SI-side word granularity)
  //  * Combinatorial WDATA is used for current word line or when expanding.
  //  * All other is taken from registers.
  // WSTRB is
  //  * Combinatorial for single data to matching word lane
  //  * Zero for single data to mismatched word lane
  //  * Register data when multiple data
  // 
  // To support sub-sized packing during Always Pack is the combinatorial 
  // information packed with "or" instead of multiplexing.
  //
  /////////////////////////////////////////////////////////////////////////////
  
  // Determine if expander data should be used.
  assign use_expander_data = ~cmd_modified & cmd_valid;
  
  // Registers and combinatorial data word mux.
  generate
    for (word_cnt = 0; word_cnt < C_RATIO ; word_cnt = word_cnt + 1) begin : WORD_LANE
      
      // Generate select signal per SI-side word.
      if ( C_RATIO == 1 ) begin : SINGLE_WORD
        assign current_word_idx[word_cnt] = 1'b1;
      end else begin : MULTIPLE_WORD
        assign current_word_idx[word_cnt] = current_word_adjusted[C_M_AXI_BYTES_LOG-C_RATIO_LOG +: C_RATIO_LOG] == word_cnt;
      end
      
      if ( ( C_PACKING_LEVEL == C_NEVER_PACK ) | ( C_SUPPORT_BURSTS == 0 ) ) begin : USE_EXPANDER
        // Expander only functionality.
      
        if ( C_M_AXI_REGISTER ) begin : USE_REGISTER
            
          always @ (posedge ACLK) begin
            if (ARESET) begin
              M_AXI_WDATA_I[word_cnt*C_S_AXI_DATA_WIDTH   +: C_S_AXI_DATA_WIDTH]    = {C_S_AXI_DATA_WIDTH{1'b0}};
              M_AXI_WSTRB_I[word_cnt*C_S_AXI_DATA_WIDTH/8 +: C_S_AXI_DATA_WIDTH/8]  = {C_S_AXI_DATA_WIDTH/8{1'b0}};
            end else begin
              if ( pop_si_data ) begin
                M_AXI_WDATA_I[word_cnt*C_S_AXI_DATA_WIDTH   +: C_S_AXI_DATA_WIDTH] = S_AXI_WDATA;
            
                // Multiplex write strobe.
                if ( current_word_idx[word_cnt] ) begin
                  // Combinatorial for last word to MI-side (only word for single).
                  M_AXI_WSTRB_I[word_cnt*C_S_AXI_DATA_WIDTH/8 +: C_S_AXI_DATA_WIDTH/8] = S_AXI_WSTRB;
                end else begin
                  // Use registered strobes. Registers are zero until valid data is written.
                  // I.e. zero when used for mismatched lanes while expanding.
                  M_AXI_WSTRB_I[word_cnt*C_S_AXI_DATA_WIDTH/8 +: C_S_AXI_DATA_WIDTH/8] = {C_S_AXI_DATA_WIDTH/8{1'b0}};
                end
              end
            end
          end
          
        end else begin : NO_REGISTER
          always @ *
          begin
            M_AXI_WDATA_I[word_cnt*C_S_AXI_DATA_WIDTH   +: C_S_AXI_DATA_WIDTH] = S_AXI_WDATA;
          
            // Multiplex write strobe.
            if ( current_word_idx[word_cnt] ) begin
              // Combinatorial for last word to MI-side (only word for single).
              M_AXI_WSTRB_I[word_cnt*C_S_AXI_DATA_WIDTH/8 +: C_S_AXI_DATA_WIDTH/8] = S_AXI_WSTRB;
            end else begin
              // Use registered strobes. Registers are zero until valid data is written.
              // I.e. zero when used for mismatched lanes while expanding.
              M_AXI_WSTRB_I[word_cnt*C_S_AXI_DATA_WIDTH/8 +: C_S_AXI_DATA_WIDTH/8] = {C_S_AXI_DATA_WIDTH/8{1'b0}};
            end
          end
          
        end // end if C_M_AXI_REGISTER
        
      end else begin : USE_ALWAYS_PACKER
        // Packer functionality
      
        for (byte_cnt = 0; byte_cnt < C_S_AXI_DATA_WIDTH / 8 ; byte_cnt = byte_cnt + 1) begin : BYTE_LANE
        
          if ( C_FAMILY == "rtl" ) begin : USE_RTL_DATA
            // Generate extended write data and strobe in wrap buffer.
            always @ (posedge ACLK) begin
              if (ARESET) begin
                wdata_wrap_buffer_q[word_cnt*C_S_AXI_DATA_WIDTH+byte_cnt*8 +: 8] <= 8'b0;
                wstrb_wrap_buffer_q[word_cnt*C_S_AXI_DATA_WIDTH/8+byte_cnt +: 1] <= 1'b0;
              end else begin
                if ( cmd_ready_i ) begin
                  wdata_wrap_buffer_q[word_cnt*C_S_AXI_DATA_WIDTH+byte_cnt*8 +: 8] <= 8'b0;
                  wstrb_wrap_buffer_q[word_cnt*C_S_AXI_DATA_WIDTH/8+byte_cnt +: 1] <= 1'b0;
                end else if ( current_word_idx[word_cnt] & store_in_wrap_buffer & S_AXI_WSTRB[byte_cnt] ) begin
                  wdata_wrap_buffer_q[word_cnt*C_S_AXI_DATA_WIDTH+byte_cnt*8 +: 8] <= S_AXI_WDATA[byte_cnt*8 +: 8];
                  wstrb_wrap_buffer_q[word_cnt*C_S_AXI_DATA_WIDTH/8+byte_cnt +: 1] <= S_AXI_WSTRB[byte_cnt];
                end
              end
            end
            
            assign wdata_wrap_buffer[word_cnt*C_S_AXI_DATA_WIDTH+byte_cnt*8 +: 8] = 
                                    wdata_wrap_buffer_q[word_cnt*C_S_AXI_DATA_WIDTH+byte_cnt*8 +: 8];
            assign wstrb_wrap_buffer[word_cnt*C_S_AXI_DATA_WIDTH/8+byte_cnt +: 1] = 
                                    wstrb_wrap_buffer_q[word_cnt*C_S_AXI_DATA_WIDTH/8+byte_cnt +: 1];
            
            if ( C_M_AXI_REGISTER ) begin : USE_REGISTER
              
              always @ (posedge ACLK) begin
                if (ARESET) begin
                  M_AXI_WDATA_I[word_cnt*C_S_AXI_DATA_WIDTH+byte_cnt*8 +: 8] <= 8'b0;
                  M_AXI_WSTRB_I[word_cnt*C_S_AXI_DATA_WIDTH/8+byte_cnt +: 1] <= 1'b0;
                end else begin
                  if ( ( current_word_idx[word_cnt] & S_AXI_WSTRB[byte_cnt] | use_expander_data ) & pop_si_data & ~store_in_wrap_buffer ) begin
                    M_AXI_WDATA_I[word_cnt*C_S_AXI_DATA_WIDTH+byte_cnt*8 +: 8] <= S_AXI_WDATA[byte_cnt*8 +: 8];
                  end else if ( use_wrap_buffer & pop_si_data &
                                wstrb_wrap_buffer[word_cnt*C_S_AXI_DATA_WIDTH/8+byte_cnt +: 1] ) begin
                    M_AXI_WDATA_I[word_cnt*C_S_AXI_DATA_WIDTH+byte_cnt*8 +: 8] <= wdata_wrap_buffer[word_cnt*C_S_AXI_DATA_WIDTH+byte_cnt*8 +: 8];
                  end else if ( pop_mi_data ) begin
                    M_AXI_WDATA_I[word_cnt*C_S_AXI_DATA_WIDTH+byte_cnt*8 +: 8] <= 8'b0;
                  end
                  
                  if ( current_word_idx[word_cnt] & S_AXI_WSTRB[byte_cnt] & pop_si_data & ~store_in_wrap_buffer ) begin
                    M_AXI_WSTRB_I[word_cnt*C_S_AXI_DATA_WIDTH/8+byte_cnt +: 1] <= S_AXI_WSTRB[byte_cnt];
                  end else if ( use_wrap_buffer & pop_si_data &
                                wstrb_wrap_buffer[word_cnt*C_S_AXI_DATA_WIDTH/8+byte_cnt +: 1] ) begin
                    M_AXI_WSTRB_I[word_cnt*C_S_AXI_DATA_WIDTH/8+byte_cnt +: 1] <= 1'b1;
                  end else if ( pop_mi_data ) begin
                    M_AXI_WSTRB_I[word_cnt*C_S_AXI_DATA_WIDTH/8+byte_cnt +: 1] <= 1'b0;
                  end
                end
              end
              
            end else begin : NO_REGISTER
              
              // Generate extended write data and strobe.
              always @ (posedge ACLK) begin
                if (ARESET) begin
                  wdata_buffer_q[word_cnt*C_S_AXI_DATA_WIDTH+byte_cnt*8 +: 8] <= 8'b0;
                  wstrb_buffer_q[word_cnt*C_S_AXI_DATA_WIDTH/8+byte_cnt +: 1] <= 1'b0;
                end else begin
                  if ( pop_mi_data | store_in_wrap_buffer_enabled ) begin
                    wdata_buffer_q[word_cnt*C_S_AXI_DATA_WIDTH+byte_cnt*8 +: 8] <= 8'b0;
                    wstrb_buffer_q[word_cnt*C_S_AXI_DATA_WIDTH/8+byte_cnt +: 1] <= 1'b0;
                  end else if ( current_word_idx[word_cnt] & pop_si_data & S_AXI_WSTRB[byte_cnt] ) begin
                    wdata_buffer_q[word_cnt*C_S_AXI_DATA_WIDTH+byte_cnt*8 +: 8] <= S_AXI_WDATA[byte_cnt*8 +: 8];
                    wstrb_buffer_q[word_cnt*C_S_AXI_DATA_WIDTH/8+byte_cnt +: 1] <= S_AXI_WSTRB[byte_cnt];
                  end
                end
              end
              
              assign wdata_buffer[word_cnt*C_S_AXI_DATA_WIDTH+byte_cnt*8 +: 8] = 
                                 wdata_buffer_q[word_cnt*C_S_AXI_DATA_WIDTH+byte_cnt*8 +: 8];
              assign wstrb_buffer[word_cnt*C_S_AXI_DATA_WIDTH/8+byte_cnt +: 1] = 
                                 wstrb_buffer_q[word_cnt*C_S_AXI_DATA_WIDTH/8+byte_cnt +: 1];
              
              // Select packed or extended data.
              always @ *
              begin
                // Multiplex data.
                if ( ( current_word_idx[word_cnt] & S_AXI_WSTRB[byte_cnt] ) | use_expander_data ) begin
                  wdata_last_word_mux[word_cnt*C_S_AXI_DATA_WIDTH+byte_cnt*8 +: 8] = S_AXI_WDATA[byte_cnt*8 +: 8];
                end else begin
                  wdata_last_word_mux[word_cnt*C_S_AXI_DATA_WIDTH+byte_cnt*8 +: 8] = 8'b0;
                end
              
                // Multiplex write strobe.
                if ( current_word_idx[word_cnt] ) begin
                  // Combinatorial for last word to MI-side (only word for single).
                  wstrb_last_word_mux[word_cnt*C_S_AXI_DATA_WIDTH/8+byte_cnt +: 1] = S_AXI_WSTRB[byte_cnt];
                end else begin
                  // Use registered strobes. Registers are zero until valid data is written.
                  // I.e. zero when used for mismatched lanes while expanding.
                  wstrb_last_word_mux[word_cnt*C_S_AXI_DATA_WIDTH/8+byte_cnt +: 1] = 1'b0;
                end
              end
              
              // Merge previous with current data.
              always @ *
              begin
                M_AXI_WSTRB_I[word_cnt*C_S_AXI_DATA_WIDTH/8+byte_cnt +: 1] = 
                                (        wstrb_buffer[word_cnt*C_S_AXI_DATA_WIDTH/8+byte_cnt +: 1] ) | 
                                ( wstrb_last_word_mux[word_cnt*C_S_AXI_DATA_WIDTH/8+byte_cnt +: 1] ) | 
                                (   wstrb_wrap_buffer[word_cnt*C_S_AXI_DATA_WIDTH/8+byte_cnt +: 1] & use_wrap_buffer );
                                
                M_AXI_WDATA_I[word_cnt*C_S_AXI_DATA_WIDTH+byte_cnt*8 +: 8] = 
                                (        wdata_buffer[word_cnt*C_S_AXI_DATA_WIDTH+byte_cnt*8 +: 8] ) | 
                                ( wdata_last_word_mux[word_cnt*C_S_AXI_DATA_WIDTH+byte_cnt*8 +: 8] ) |
                                (   wdata_wrap_buffer[word_cnt*C_S_AXI_DATA_WIDTH+byte_cnt*8 +: 8] & {8{use_wrap_buffer}} );
              end
              
            end // end if C_M_AXI_REGISTER
          end else begin : USE_FPGA_DATA
          
            always @ *
            begin
              if ( cmd_ready_i ) begin
                wdata_wrap_buffer_cmb[word_cnt*C_S_AXI_DATA_WIDTH+byte_cnt*8 +: 8] = 8'b0;
                wstrb_wrap_buffer_cmb[word_cnt*C_S_AXI_DATA_WIDTH/8+byte_cnt +: 1] = 1'b0;
              end else if ( current_word_idx[word_cnt] & store_in_wrap_buffer & S_AXI_WSTRB[byte_cnt] ) begin
                wdata_wrap_buffer_cmb[word_cnt*C_S_AXI_DATA_WIDTH+byte_cnt*8 +: 8] = S_AXI_WDATA[byte_cnt*8 +: 8];
                wstrb_wrap_buffer_cmb[word_cnt*C_S_AXI_DATA_WIDTH/8+byte_cnt +: 1] = S_AXI_WSTRB[byte_cnt];
              end else begin
                wdata_wrap_buffer_cmb[word_cnt*C_S_AXI_DATA_WIDTH+byte_cnt*8 +: 8] = 
                                      wdata_wrap_buffer[word_cnt*C_S_AXI_DATA_WIDTH+byte_cnt*8 +: 8];
                wstrb_wrap_buffer_cmb[word_cnt*C_S_AXI_DATA_WIDTH/8+byte_cnt +: 1] = 
                                      wstrb_wrap_buffer[word_cnt*C_S_AXI_DATA_WIDTH/8+byte_cnt +: 1];
              end
            end
            
            for (bit_cnt = 0; bit_cnt < 8 ; bit_cnt = bit_cnt + 1) begin : BIT_LANE
              FDRE #(
               .INIT(1'b0)             // Initial value of register (1'b0 or 1'b1)
               ) FDRE_wdata_inst (
               .Q(wdata_wrap_buffer[word_cnt*C_S_AXI_DATA_WIDTH+byte_cnt*8+bit_cnt]),    // Data output
               .C(ACLK),                                                                 // Clock input
               .CE(1'b1),                                                                // Clock enable input
               .R(ARESET),                                                               // Synchronous reset input
               .D(wdata_wrap_buffer_cmb[word_cnt*C_S_AXI_DATA_WIDTH+byte_cnt*8+bit_cnt]) // Data input
               );
              
            end // end for bit_cnt
            
            FDRE #(
             .INIT(1'b0)             // Initial value of register (1'b0 or 1'b1)
             ) FDRE_wstrb_inst (
             .Q(wstrb_wrap_buffer[word_cnt*C_S_AXI_DATA_WIDTH/8+byte_cnt]),      // Data output
             .C(ACLK),                                                           // Clock input
             .CE(1'b1),                                                          // Clock enable input
             .R(ARESET),                                                         // Synchronous reset input
             .D(wstrb_wrap_buffer_cmb[word_cnt*C_S_AXI_DATA_WIDTH/8+byte_cnt])   // Data input
             );
             
            if ( C_M_AXI_REGISTER ) begin : USE_REGISTER
            
              assign wdata_qualifier[word_cnt*C_S_AXI_DATA_WIDTH/8+byte_cnt] = ( current_word_idx[word_cnt] & S_AXI_WSTRB[byte_cnt] | use_expander_data ) & pop_si_data & ~store_in_wrap_buffer_enabled;
              assign wstrb_qualifier[word_cnt*C_S_AXI_DATA_WIDTH/8+byte_cnt] = current_word_idx[word_cnt] & S_AXI_WSTRB[byte_cnt] & pop_si_data & ~store_in_wrap_buffer_enabled;
            
              assign wrap_qualifier[word_cnt*C_S_AXI_DATA_WIDTH/8+byte_cnt]  = use_wrap_buffer & pop_si_data &
                                                                               wstrb_wrap_buffer[word_cnt*C_S_AXI_DATA_WIDTH/8+byte_cnt +: 1];
            
              for (bit_cnt = 0; bit_cnt < 8 ; bit_cnt = bit_cnt + 1) begin : BIT_LANE
                    
                LUT6 # (
                 .INIT(64'hF0F0_F0F0_CCCC_00AA) 
                ) LUT6_data_inst (
                .O(M_AXI_WDATA_cmb[word_cnt*C_S_AXI_DATA_WIDTH+byte_cnt*8+bit_cnt]),    // 6-LUT output (1-bit)
                .I0(M_AXI_WDATA_q[word_cnt*C_S_AXI_DATA_WIDTH+byte_cnt*8+bit_cnt]),     // LUT input (1-bit)
                .I1(wdata_wrap_buffer[word_cnt*C_S_AXI_DATA_WIDTH+byte_cnt*8+bit_cnt]), // LUT input (1-bit)
                .I2(S_AXI_WDATA[byte_cnt*8+bit_cnt]),                                   // LUT input (1-bit)
                .I3(pop_mi_data),                                                       // LUT input (1-bit)
                .I4(wrap_qualifier[word_cnt*C_S_AXI_DATA_WIDTH/8+byte_cnt]),            // LUT input (1-bit)
                .I5(wdata_qualifier[word_cnt*C_S_AXI_DATA_WIDTH/8+byte_cnt])            // LUT input (1-bit)
                );
                    
                FDRE #(
                 .INIT(1'b0)             // Initial value of register (1'b0 or 1'b1)
                 ) FDRE_wdata_inst (
                 .Q(M_AXI_WDATA_q[word_cnt*C_S_AXI_DATA_WIDTH+byte_cnt*8+bit_cnt]),     // Data output
                 .C(ACLK),                                                              // Clock input
                 .CE(1'b1),                                                             // Clock enable input
                 .R(ARESET),                                                            // Synchronous reset input
                 .D(M_AXI_WDATA_cmb[word_cnt*C_S_AXI_DATA_WIDTH+byte_cnt*8+bit_cnt])    // Data input
                 );
                
              end // end for bit_cnt
              
              LUT6 # (
               .INIT(64'hF0F0_F0F0_CCCC_00AA) 
              ) LUT6_strb_inst (
              .O(M_AXI_WSTRB_cmb[word_cnt*C_S_AXI_DATA_WIDTH/8+byte_cnt]),            // 6-LUT output (1-bit)
              .I0(M_AXI_WSTRB_q[word_cnt*C_S_AXI_DATA_WIDTH/8+byte_cnt]),             // LUT input (1-bit)
              .I1(wrap_qualifier[word_cnt*C_S_AXI_DATA_WIDTH/8+byte_cnt]),            // LUT input (1-bit)
              .I2(S_AXI_WSTRB[byte_cnt]),                                             // LUT input (1-bit)
              .I3(pop_mi_data),                                                       // LUT input (1-bit)
              .I4(wrap_qualifier[word_cnt*C_S_AXI_DATA_WIDTH/8+byte_cnt]),            // LUT input (1-bit)
              .I5(wstrb_qualifier[word_cnt*C_S_AXI_DATA_WIDTH/8+byte_cnt])            // LUT input (1-bit)
              );
            
              FDRE #(
               .INIT(1'b0)             // Initial value of register (1'b0 or 1'b1)
               ) FDRE_wstrb_inst (
               .Q(M_AXI_WSTRB_q[word_cnt*C_S_AXI_DATA_WIDTH/8+byte_cnt]),     // Data output
               .C(ACLK),                                                      // Clock input
               .CE(1'b1),                                                     // Clock enable input
               .R(ARESET),                                                    // Synchronous reset input
               .D(M_AXI_WSTRB_cmb[word_cnt*C_S_AXI_DATA_WIDTH/8+byte_cnt])    // Data input
               );
               
              always @ * 
              begin
                M_AXI_WDATA_I[word_cnt*C_S_AXI_DATA_WIDTH+byte_cnt*8 +: 8] = M_AXI_WDATA_q[word_cnt*C_S_AXI_DATA_WIDTH+byte_cnt*8 +: 8];
                M_AXI_WSTRB_I[word_cnt*C_S_AXI_DATA_WIDTH/8+byte_cnt +: 1] = M_AXI_WSTRB_q[word_cnt*C_S_AXI_DATA_WIDTH/8+byte_cnt +: 1];
              end
              
            end else begin : NO_REGISTER
            
              assign wdata_qualifier[word_cnt*C_S_AXI_DATA_WIDTH/8+byte_cnt]  = current_word_idx[word_cnt] & cmd_valid & S_AXI_WSTRB[byte_cnt];
            
              assign wstrb_qualifier[word_cnt*C_S_AXI_DATA_WIDTH/8+byte_cnt]  = current_word_idx[word_cnt] & 
                                                                                S_AXI_WSTRB[byte_cnt] & 
                                                                                cmd_valid & S_AXI_WVALID;
              
              for (bit_cnt = 0; bit_cnt < 8 ; bit_cnt = bit_cnt + 1) begin : BIT_LANE
                LUT6 # (
                 .INIT(64'hCCCA_CCCC_CCCC_CCCC) 
                ) LUT6_data_inst (
                .O(wdata_buffer_i[word_cnt*C_S_AXI_DATA_WIDTH+byte_cnt*8+bit_cnt]),   // 6-LUT output (1-bit)
                .I0(S_AXI_WDATA[byte_cnt*8+bit_cnt]),                                 // LUT input (1-bit)
                .I1(wdata_buffer[word_cnt*C_S_AXI_DATA_WIDTH+byte_cnt*8+bit_cnt]),    // LUT input (1-bit)
                .I2(word_complete_rest_stall),                                        // LUT input (1-bit)
                .I3(word_complete_next_wrap_stall),                                   // LUT input (1-bit)
                .I4(wdata_qualifier[word_cnt*C_S_AXI_DATA_WIDTH/8+byte_cnt]),         // LUT input (1-bit)
                .I5(S_AXI_WVALID)                                                     // LUT input (1-bit)
                );
                    
                FDRE #(
                 .INIT(1'b0)             // Initial value of register (1'b0 or 1'b1)
                 ) FDRE_wdata_inst (
                 .Q(wdata_buffer[word_cnt*C_S_AXI_DATA_WIDTH+byte_cnt*8+bit_cnt]),    // Data output
                 .C(ACLK),                                                            // Clock input
                 .CE(1'b1),                                                           // Clock enable input
                 .R(ARESET),                                                          // Synchronous reset input
                 .D(wdata_buffer_i[word_cnt*C_S_AXI_DATA_WIDTH+byte_cnt*8+bit_cnt])   // Data input
                 );
                
              end // end for bit_cnt
              
              LUT6 # (
               .INIT(64'h0000_0000_0000_AAAE) 
              ) LUT6_strb_inst (
              .O(wstrb_buffer_i[word_cnt*C_S_AXI_DATA_WIDTH/8+byte_cnt]),     // 6-LUT output (1-bit)
              .I0(wstrb_buffer[word_cnt*C_S_AXI_DATA_WIDTH/8+byte_cnt]),      // LUT input (1-bit)
              .I1(wstrb_qualifier[word_cnt*C_S_AXI_DATA_WIDTH/8+byte_cnt]),   // LUT input (1-bit)
              .I2(word_complete_rest_stall),                                  // LUT input (1-bit)
              .I3(word_complete_next_wrap_stall),                             // LUT input (1-bit)
              .I4(word_complete_rest_pop),                                    // LUT input (1-bit)
              .I5(word_complete_next_wrap_pop)                                // LUT input (1-bit)
              );
              
              FDRE #(
               .INIT(1'b0)             // Initial value of register (1'b0 or 1'b1)
               ) FDRE_wstrb_inst (
               .Q(wstrb_buffer[word_cnt*C_S_AXI_DATA_WIDTH/8+byte_cnt]),      // Data output
               .C(ACLK),                                                      // Clock input
               .CE(1'b1),                                                     // Clock enable input
               .R(ARESET_or_store_in_wrap_buffer),                            // Synchronous reset input
               .D(wstrb_buffer_i[word_cnt*C_S_AXI_DATA_WIDTH/8+byte_cnt])     // Data input
               );
              
              // Select packed or extended data.
              always @ *
              begin
                // Multiplex data.
                if ( ( current_word_idx[word_cnt] & S_AXI_WSTRB[byte_cnt] ) | use_expander_data ) begin
                  wdata_last_word_mux[word_cnt*C_S_AXI_DATA_WIDTH+byte_cnt*8 +: 8] = S_AXI_WDATA[byte_cnt*8 +: 8];
                end else begin
                  wdata_last_word_mux[word_cnt*C_S_AXI_DATA_WIDTH+byte_cnt*8 +: 8] = 
                                (        wdata_buffer[word_cnt*C_S_AXI_DATA_WIDTH+byte_cnt*8 +: 8] & {8{wstrb_buffer[word_cnt*C_S_AXI_DATA_WIDTH/8+byte_cnt]}} ) | 
                                (   wdata_wrap_buffer[word_cnt*C_S_AXI_DATA_WIDTH+byte_cnt*8 +: 8] & {8{use_wrap_buffer}} );
                end
              
                // Multiplex write strobe.
                if ( current_word_idx[word_cnt] ) begin
                  // Combinatorial for last word to MI-side (only word for single).
                  wstrb_last_word_mux[word_cnt*C_S_AXI_DATA_WIDTH/8+byte_cnt +: 1] = S_AXI_WSTRB[byte_cnt] |
                                (        wstrb_buffer[word_cnt*C_S_AXI_DATA_WIDTH/8+byte_cnt] ) | 
                                (   wstrb_wrap_buffer[word_cnt*C_S_AXI_DATA_WIDTH/8+byte_cnt +: 1] & use_wrap_buffer );
                end else begin
                  // Use registered strobes. Registers are zero until valid data is written.
                  // I.e. zero when used for mismatched lanes while expanding.
                  wstrb_last_word_mux[word_cnt*C_S_AXI_DATA_WIDTH/8+byte_cnt +: 1] = 
                                (        wstrb_buffer[word_cnt*C_S_AXI_DATA_WIDTH/8+byte_cnt] ) | 
                                (   wstrb_wrap_buffer[word_cnt*C_S_AXI_DATA_WIDTH/8+byte_cnt +: 1] & use_wrap_buffer );
                end
              end
              
              // Merge previous with current data.
              always @ *
              begin
                M_AXI_WSTRB_I[word_cnt*C_S_AXI_DATA_WIDTH/8+byte_cnt +: 1] = 
                                ( wstrb_last_word_mux[word_cnt*C_S_AXI_DATA_WIDTH/8+byte_cnt +: 1] );
                                
                M_AXI_WDATA_I[word_cnt*C_S_AXI_DATA_WIDTH+byte_cnt*8 +: 8] = 
                                ( wdata_last_word_mux[word_cnt*C_S_AXI_DATA_WIDTH+byte_cnt*8 +: 8] );
              end
              
            end // end if C_M_AXI_REGISTER
          end // end if C_FAMILY
        end // end for byte_cnt
      end // end if USE_ALWAYS_PACKER
    end // end for word_cnt
  endgenerate
      
  
  /////////////////////////////////////////////////////////////////////////////
  // MI-side output handling
  /////////////////////////////////////////////////////////////////////////////
  
  generate
    if ( C_M_AXI_REGISTER ) begin : USE_REGISTER
      reg                             M_AXI_WLAST_q;
      reg  [C_AXI_WUSER_WIDTH-1:0]    M_AXI_WUSER_q;
      reg                             M_AXI_WVALID_q;
    
      // Register MI-side Data.
      always @ (posedge ACLK) begin
        if (ARESET) begin
          M_AXI_WLAST_q     <= 1'b0;
          M_AXI_WUSER_q     <= {C_AXI_WUSER_WIDTH{1'b0}};
          M_AXI_WVALID_q    <= 1'b0;
          
        end else begin
          if ( M_AXI_WREADY_I ) begin
            M_AXI_WLAST_q     <= M_AXI_WLAST_I;
            M_AXI_WUSER_q     <= M_AXI_WUSER_I;
            M_AXI_WVALID_q    <= M_AXI_WVALID_I;
          end
          
        end
      end
      
      assign M_AXI_WDATA    = M_AXI_WDATA_I;
      assign M_AXI_WSTRB    = M_AXI_WSTRB_I;
      assign M_AXI_WLAST    = M_AXI_WLAST_q;
      assign M_AXI_WUSER    = M_AXI_WUSER_q;
      assign M_AXI_WVALID   = M_AXI_WVALID_q;
      assign M_AXI_WREADY_I = ( M_AXI_WVALID_q & M_AXI_WREADY) | ~M_AXI_WVALID_q;
      
      // Get MI-side data.
      assign pop_mi_data_i  = M_AXI_WVALID_I & M_AXI_WREADY_I;
      assign pop_mi_data    = M_AXI_WVALID_q & M_AXI_WREADY_I;
      
      // Detect when MI-side is stalling.
      assign mi_stalling    = ( M_AXI_WVALID_q & ~M_AXI_WREADY_I ) & ~store_in_wrap_buffer_enabled;
                          
    end else begin : NO_REGISTER
    
      // Combinatorial MI-side Data.
      assign M_AXI_WDATA    = M_AXI_WDATA_I;
      assign M_AXI_WSTRB    = M_AXI_WSTRB_I;
      assign M_AXI_WLAST    = M_AXI_WLAST_I;
      assign M_AXI_WUSER    = M_AXI_WUSER_I;
      assign M_AXI_WVALID   = M_AXI_WVALID_I;
      assign M_AXI_WREADY_I = M_AXI_WREADY;
      
      // Get MI-side data.
      if ( C_FAMILY == "rtl" ) begin : USE_RTL_POP_MI
        assign pop_mi_data_i  = M_AXI_WVALID_I & M_AXI_WREADY_I;
        
      end else begin : USE_FPGA_POP_MI
        
        assign pop_mi_data_i  = ( word_complete_next_wrap_pop | word_complete_rest_pop);
                             
      end
      assign pop_mi_data    = pop_mi_data_i;
      
      // Detect when MI-side is stalling.
      assign mi_stalling    = word_completed_qualified & ~M_AXI_WREADY_I;
                          
    end
  endgenerate
  
  
endmodule



// -- (c) Copyright 2011 - 2012 Xilinx, Inc. All rights reserved.
// --
// -- This file contains confidential and proprietary information
// -- of Xilinx, Inc. and is protected under U.S. and 
// -- international copyright and other intellectual property
// -- laws.
// --
// -- DISCLAIMER
// -- This disclaimer is not a license and does not grant any
// -- rights to the materials distributed herewith. Except as
// -- otherwise provided in a valid license issued to you by
// -- Xilinx, and to the maximum extent permitted by applicable
// -- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
// -- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
// -- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
// -- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
// -- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
// -- (2) Xilinx shall not be liable (whether in contract or tort,
// -- including negligence, or under any other theory of
// -- liability) for any loss or damage of any kind or nature
// -- related to, arising under or in connection with these
// -- materials, including for any direct, or any indirect,
// -- special, incidental, or consequential loss or damage
// -- (including loss of data, profits, goodwill, or any type of
// -- loss or damage suffered as a result of any action brought
// -- by a third party) even if such damage or loss was
// -- reasonably foreseeable or Xilinx had been advised of the
// -- possibility of the same.
// --
// -- CRITICAL APPLICATIONS
// -- Xilinx products are not designed or intended to be fail-
// -- safe, or for use in any application requiring fail-safe
// -- performance, such as life-support or safety devices or
// -- systems, Class III medical devices, nuclear facilities,
// -- applications related to the deployment of airbags, or any
// -- other applications that could lead to death, personal
// -- injury, or severe property or environmental damage
// -- (individually and collectively, "Critical
// -- Applications"). Customer assumes the sole risk and
// -- liability of any use of Xilinx products in Critical
// -- Applications, subject only to applicable laws and
// -- regulations governing limitations on product liability.
// --
// -- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
// -- PART OF THIS FILE AT ALL TIMES.
//-----------------------------------------------------------------------------
//
// Register Slice
//   Generic single-channel AXI pipeline register on forward and/or reverse signal path
//
// Verilog-standard:  Verilog 2001
//--------------------------------------------------------------------------
//
// Structure:
//   axic_sample_cycle_ratio
//
//--------------------------------------------------------------------------

`timescale 1ps/1ps
`default_nettype none

(* DowngradeIPIdentifiedWarnings="yes" *) 
module axi_interconnect_v1_7_13_axic_sample_cycle_ratio # (
///////////////////////////////////////////////////////////////////////////////
// Parameter Definitions
///////////////////////////////////////////////////////////////////////////////
  parameter C_RATIO = 2 // Must be > 0
  )
 (
///////////////////////////////////////////////////////////////////////////////
// Port Declarations
///////////////////////////////////////////////////////////////////////////////
  input  wire                    SLOW_ACLK,
  input  wire                    FAST_ACLK,

  output wire                    SAMPLE_CYCLE_EARLY,
  output wire                    SAMPLE_CYCLE
);

////////////////////////////////////////////////////////////////////////////////
// Functions
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// Local parameters
////////////////////////////////////////////////////////////////////////////////
localparam P_DELAY = C_RATIO > 2 ? C_RATIO-1 : C_RATIO-1; 
////////////////////////////////////////////////////////////////////////////////
// Wires/Reg declarations
////////////////////////////////////////////////////////////////////////////////
reg                slow_aclk_div2 = 0;
reg                posedge_finder_first;
reg                posedge_finder_second;
wire               first_edge;
wire               second_edge;
reg  [P_DELAY-1:0] sample_cycle_d;
(* shreg_extract = "no" *) reg                sample_cycle_r;


////////////////////////////////////////////////////////////////////////////////
// BEGIN RTL
////////////////////////////////////////////////////////////////////////////////
generate
  if (C_RATIO == 1) begin : gen_always_sample
    assign SAMPLE_CYCLE_EARLY = 1'b1;
    assign SAMPLE_CYCLE = 1'b1;
  end
  else begin : gen_sample_cycle
    genvar i;
    always @(posedge SLOW_ACLK) begin 
      slow_aclk_div2 <= ~slow_aclk_div2;
    end

    // Find matching rising edges by clocking slow_aclk_div2 onto faster clock
    always @(posedge FAST_ACLK) begin 
      posedge_finder_first <= slow_aclk_div2;
    end
    always @(posedge FAST_ACLK) begin 
      posedge_finder_second <= ~slow_aclk_div2;
    end

    assign first_edge = slow_aclk_div2 & ~posedge_finder_first;
    assign second_edge = ~slow_aclk_div2 & ~posedge_finder_second;

    always @(*) begin 
      sample_cycle_d[P_DELAY-1] = first_edge | second_edge;
    end
   
    // delay the posedge alignment by C_RATIO - 1 to set the sample cycle as
    // the clock one cycle before the posedge.
    for (i = P_DELAY-1; i > 0; i = i - 1) begin : gen_delay
      always @(posedge FAST_ACLK) begin
        sample_cycle_d[i-1] <= sample_cycle_d[i];
      end
    end

    always @(posedge FAST_ACLK) begin 
      sample_cycle_r <= sample_cycle_d[0];
    end
    assign SAMPLE_CYCLE_EARLY = sample_cycle_d[0];
    assign SAMPLE_CYCLE = sample_cycle_r;
  end
endgenerate

endmodule // axisc_sample_cycle_ratio

`default_nettype wire


// -- (c) Copyright 2011 - 2012 Xilinx, Inc. All rights reserved.
// --
// -- This file contains confidential and proprietary information
// -- of Xilinx, Inc. and is protected under U.S. and 
// -- international copyright and other intellectual property
// -- laws.
// --
// -- DISCLAIMER
// -- This disclaimer is not a license and does not grant any
// -- rights to the materials distributed herewith. Except as
// -- otherwise provided in a valid license issued to you by
// -- Xilinx, and to the maximum extent permitted by applicable
// -- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
// -- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
// -- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
// -- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
// -- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
// -- (2) Xilinx shall not be liable (whether in contract or tort,
// -- including negligence, or under any other theory of
// -- liability) for any loss or damage of any kind or nature
// -- related to, arising under or in connection with these
// -- materials, including for any direct, or any indirect,
// -- special, incidental, or consequential loss or damage
// -- (including loss of data, profits, goodwill, or any type of
// -- loss or damage suffered as a result of any action brought
// -- by a third party) even if such damage or loss was
// -- reasonably foreseeable or Xilinx had been advised of the
// -- possibility of the same.
// --
// -- CRITICAL APPLICATIONS
// -- Xilinx products are not designed or intended to be fail-
// -- safe, or for use in any application requiring fail-safe
// -- performance, such as life-support or safety devices or
// -- systems, Class III medical devices, nuclear facilities,
// -- applications related to the deployment of airbags, or any
// -- other applications that could lead to death, personal
// -- injury, or severe property or environmental damage
// -- (individually and collectively, "Critical
// -- Applications"). Customer assumes the sole risk and
// -- liability of any use of Xilinx products in Critical
// -- Applications, subject only to applicable laws and
// -- regulations governing limitations on product liability.
// --
// -- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
// -- PART OF THIS FILE AT ALL TIMES.
//-----------------------------------------------------------------------------
//
// Register Slice
//   Generic single-channel AXI pipeline register on forward and/or reverse signal path
//
// Verilog-standard:  Verilog 2001
//--------------------------------------------------------------------------
//
// Structure:
//   axic_sync_clock_converter
//     axic_sample_cycle_ratio
//
//--------------------------------------------------------------------------

`timescale 1ps/1ps
`default_nettype none

(* DowngradeIPIdentifiedWarnings="yes" *) 
module axi_interconnect_v1_7_13_axic_sync_clock_converter # (
///////////////////////////////////////////////////////////////////////////////
// Parameter Definitions
///////////////////////////////////////////////////////////////////////////////
  parameter C_FAMILY     = "virtex6",
  parameter integer C_PAYLOAD_WIDTH = 32,
  parameter integer C_S_ACLK_RATIO = 1,
  parameter integer C_M_ACLK_RATIO = 1 ,
  parameter integer C_MODE = 0  // 0 = light-weight (1-deep); 1 = fully-pipelined (2-deep)
  )
 (
///////////////////////////////////////////////////////////////////////////////
// Port Declarations
///////////////////////////////////////////////////////////////////////////////
  input wire                    SAMPLE_CYCLE_EARLY,
  input wire                    SAMPLE_CYCLE,
  // Slave side
  input  wire                        S_ACLK,
  input  wire                        S_ARESET,
  input  wire [C_PAYLOAD_WIDTH-1:0] S_PAYLOAD,
  input  wire                        S_VALID,
  output wire                        S_READY,

  // Master side
  input  wire                        M_ACLK,
  input  wire                        M_ARESET,
  output wire [C_PAYLOAD_WIDTH-1:0] M_PAYLOAD,
  output wire                        M_VALID,
  input  wire                        M_READY
);

////////////////////////////////////////////////////////////////////////////////
// Functions
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// Local parameters
////////////////////////////////////////////////////////////////////////////////
localparam [1:0] ZERO = 2'b10;
localparam [1:0] ONE  = 2'b11;
localparam [1:0] TWO  = 2'b01;
localparam [1:0] INIT = 2'b00;
localparam integer P_LIGHT_WT = 0;
localparam integer P_FULLY_REG = 1;

////////////////////////////////////////////////////////////////////////////////
// Wires/Reg declarations
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// BEGIN RTL
////////////////////////////////////////////////////////////////////////////////

generate
  if (C_S_ACLK_RATIO == C_M_ACLK_RATIO) begin : gen_passthru
    assign M_PAYLOAD = S_PAYLOAD;
    assign M_VALID   = S_VALID;
    assign S_READY   = M_READY;      
  end else begin : gen_sync_clock_converter
    wire s_sample_cycle;
    wire s_sample_cycle_early;
    wire m_sample_cycle;
    wire m_sample_cycle_early;

    wire slow_aclk;
    wire slow_areset;
    reg  s_areset_r;
    reg  m_areset_r;
   
    reg  s_tready_r; 
    wire s_tready_ns; 
    reg  m_tvalid_r; 
    wire m_tvalid_ns; 
    reg  [C_PAYLOAD_WIDTH-1:0] m_tpayload_r;
    reg  [C_PAYLOAD_WIDTH-1:0] m_tstorage_r;
    wire [C_PAYLOAD_WIDTH-1:0] m_tpayload_ns; 
    wire [C_PAYLOAD_WIDTH-1:0] m_tstorage_ns; 
    reg  m_tready_hold;
    wire m_tready_sample;
    wire load_tpayload;
    wire load_tstorage;
    wire load_tpayload_from_tstorage;
    reg [1:0] state;
    reg [1:0] next_state;
    
    always @(posedge S_ACLK) begin
      s_areset_r <= S_ARESET | M_ARESET;
    end
  
    always @(posedge M_ACLK) begin
      m_areset_r <= S_ARESET | M_ARESET;
    end

    assign slow_aclk   = (C_S_ACLK_RATIO > C_M_ACLK_RATIO) ? M_ACLK   : S_ACLK;
    assign slow_areset = (C_S_ACLK_RATIO > C_M_ACLK_RATIO) ? m_areset_r : s_areset_r;
    assign s_sample_cycle_early = (C_S_ACLK_RATIO > C_M_ACLK_RATIO) ? SAMPLE_CYCLE_EARLY : 1'b1;
    assign s_sample_cycle       = (C_S_ACLK_RATIO > C_M_ACLK_RATIO) ? SAMPLE_CYCLE : 1'b1;
    assign m_sample_cycle_early = (C_S_ACLK_RATIO > C_M_ACLK_RATIO) ? 1'b1 : SAMPLE_CYCLE_EARLY;
    assign m_sample_cycle       = (C_S_ACLK_RATIO > C_M_ACLK_RATIO) ? 1'b1 : SAMPLE_CYCLE;

    // Output flop for S_READY, value is encoded into state machine.
    assign s_tready_ns = (C_S_ACLK_RATIO > C_M_ACLK_RATIO) ? state[1] & (state != INIT) : next_state[1];

    always @(posedge S_ACLK) begin 
      if (s_areset_r) begin
        s_tready_r <= 1'b0;
      end
      else begin
        s_tready_r <= s_sample_cycle_early ? s_tready_ns : 1'b0;
      end
    end

    assign S_READY = s_tready_r;

    // Output flop for M_VALID
    assign m_tvalid_ns = next_state[0];

    always @(posedge M_ACLK) begin 
      if (m_areset_r) begin
        m_tvalid_r <= 1'b0;
      end
      else begin
        m_tvalid_r <= m_sample_cycle ? m_tvalid_ns : m_tvalid_r & ~M_READY;
      end
    end

    assign M_VALID = m_tvalid_r;

    // Hold register for M_READY when M_ACLK is fast.
    always @(posedge M_ACLK) begin 
      if (m_areset_r) begin
        m_tready_hold <= 1'b0;
      end
      else begin
        m_tready_hold <= m_sample_cycle ? 1'b0 : m_tready_sample;
      end
    end

    assign m_tready_sample = (M_READY ) | m_tready_hold;
    // Output/storage flops for PAYLOAD
    assign m_tpayload_ns = ~load_tpayload ? m_tpayload_r :
                           load_tpayload_from_tstorage ? m_tstorage_r : 
                           S_PAYLOAD;

    assign m_tstorage_ns = C_MODE ? (load_tstorage ? S_PAYLOAD : m_tstorage_r) : 0;

    always @(posedge slow_aclk) begin 
      m_tpayload_r <= m_tpayload_ns;
      m_tstorage_r <= C_MODE ? m_tstorage_ns : 0;
    end

    assign M_PAYLOAD = m_tpayload_r;

    // load logic
    assign load_tstorage = C_MODE && (state != TWO);
    assign load_tpayload = m_tready_sample || (state == ZERO);
    assign load_tpayload_from_tstorage = C_MODE && (state == TWO) && m_tready_sample;
    
    // State machine
    always @(posedge slow_aclk) begin 
      state <= next_state;
    end

    always @* begin 
      if (slow_areset) begin 
        next_state = INIT;
      end else begin
        case (state)
          INIT: begin
            next_state = ZERO;
          end
          // No transaction stored locally
          ZERO: begin
            if (S_VALID) begin
              next_state = C_MODE ? ONE : TWO; // Push from empty
            end
            else begin
              next_state = ZERO;
            end
          end

          // One transaction stored locally
          ONE: begin
            if (C_MODE == 0) begin
              next_state = TWO;  // State ONE is inaccessible when C_MODE=0
            end 
            else if (m_tready_sample & ~S_VALID) begin 
              next_state = ZERO; // Read out one so move to ZERO
            end
            else if (~m_tready_sample & S_VALID) begin
              next_state = TWO;  // Got another one so move to TWO
            end
            else begin
              next_state = ONE;
            end
          end

          // Storage registers full
          TWO: begin 
            if (m_tready_sample) begin
              next_state = C_MODE ? ONE : ZERO; // Pop from full
            end
            else begin
              next_state = TWO;
            end
          end
        endcase // case (state)
      end
    end
  end // gen_sync_clock_converter
  endgenerate
endmodule

`default_nettype wire


// -- (c) Copyright 2009 - 2011 Xilinx, Inc. All rights reserved.
// --
// -- This file contains confidential and proprietary information
// -- of Xilinx, Inc. and is protected under U.S. and 
// -- international copyright and other intellectual property
// -- laws.
// --
// -- DISCLAIMER
// -- This disclaimer is not a license and does not grant any
// -- rights to the materials distributed herewith. Except as
// -- otherwise provided in a valid license issued to you by
// -- Xilinx, and to the maximum extent permitted by applicable
// -- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
// -- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
// -- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
// -- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
// -- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
// -- (2) Xilinx shall not be liable (whether in contract or tort,
// -- including negligence, or under any other theory of
// -- liability) for any loss or damage of any kind or nature
// -- related to, arising under or in connection with these
// -- materials, including for any direct, or any indirect,
// -- special, incidental, or consequential loss or damage
// -- (including loss of data, profits, goodwill, or any type of
// -- loss or damage suffered as a result of any action brought
// -- by a third party) even if such damage or loss was
// -- reasonably foreseeable or Xilinx had been advised of the
// -- possibility of the same.
// --
// -- CRITICAL APPLICATIONS
// -- Xilinx products are not designed or intended to be fail-
// -- safe, or for use in any application requiring fail-safe
// -- performance, such as life-support or safety devices or
// -- systems, Class III medical devices, nuclear facilities,
// -- applications related to the deployment of airbags, or any
// -- other applications that could lead to death, personal
// -- injury, or severe property or environmental damage
// -- (individually and collectively, "Critical
// -- Applications"). Customer assumes the sole risk and
// -- liability of any use of Xilinx products in Critical
// -- Applications, subject only to applicable laws and
// -- regulations governing limitations on product liability.
// --
// -- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
// -- PART OF THIS FILE AT ALL TIMES.
//-----------------------------------------------------------------------------
//
// File name: axi_interconnect.v
//
// Description: 
//   This is the top-level module of a NxM AXI Interconnect core.
//   The interface of this module consists of vectored slave and master interfaces,
//     each of which are the concatenation of all connected AXI master and slave signals,
//     plus various vectored parameters concatenated from parameters propagated
//     from connected master and slave IP.
//   The interface of this version also contains various vectored DEBUG ports.
//   This module instantiates the major vectored sub-modules that comprise the
//     AXI Interconnect core.
//   Supports AXI4, AXI3 and AXI4-Lite protocols.
//
//-----------------------------------------------------------------------------
//
// Structure:
//    axi_interconnect
//      register_slice_bank
//        axi_register_slice
//      protocol_conv_bank
//        axilite_conv
//        axi3_conv
//          a_axi3_conv
//            axic_fifo
//          w_axi3_conv
//          b_downsizer
//          r_axi3_conv
//      converter_bank
//        axi_upsizer
//        clock_conv
//          fifo_gen
//          clock_sync_accel
//          clock_sync_decel
//        axi_downsizer
//      data_fifo_bank
//        axi_data_fifo
//      crossbar
//        si_transactor
//          addr_decoder
//            comparator_static
//          mux_enc
//          axic_srl_fifo
//          arbiter_resp
//        splitter
//        wdata_router
//          axic_reg_srl_fifo
//        wdata_mux
//          axic_reg_srl_fifo
//          mux_enc
//        addr_decoder
//          comparator_static
//        axic_srl_fifo
//        axi_register_slice
//        addr_arbiter
//          mux_enc
//        decerr_slave
//      crossbar_sasd
//        addr_arbiter_sasd
//          mux_enc
//        addr_decoder
//          comparator_static
//        splitter
//        mux_enc
//        axic_register_slice
//        decerr_slave
//      
//-----------------------------------------------------------------------------
`timescale 1ps/1ps
`default_nettype none

`define P_MAX_S 16
`define P_MAX_M 16
`define P_NUM_ADDR_RANGES 16

(* DowngradeIPIdentifiedWarnings="yes" *) 
module axi_interconnect_v1_7_13_axi_interconnect #
  (
   parameter         C_BASEFAMILY                         = "rtl", 
                       // FPGA Base Family. Current version: virtex6 or spartan6.
   parameter integer C_NUM_SLAVE_SLOTS                = 1, 
                       // Number of Slave Interface (SI) slots for connecting 
                       // to master IP. Range: 1-`P_MAX_S.
   parameter integer C_NUM_MASTER_SLOTS               = 1, 
                       // Number of Master Interface (MI) slots for connecting 
                       // to slave IP. Range: 1-`P_MAX_M.
   parameter integer C_AXI_ID_WIDTH                   = 1, 
                       // Width of ID signals propagated by the Interconnect.
                       // Width of ID signals produced on all MI slots.
                       // Range: 1-16.
   parameter integer C_AXI_ADDR_WIDTH                 = 32, 
                       // Width of S_AXI_AWADDR, S_AXI_ARADDR, M_AXI_AWADDR and 
                       // M_AXI_ARADDR for all SI/MI slots.
                       // Range: 32.
   parameter integer C_AXI_DATA_MAX_WIDTH             = 32, 
                       // Largest value specified for any DATA_WIDTH (including C_INTERCONNECT_DATA_WIDTH).
                       // Determines the stride of all DATA signals.
                       // Range: 32, 64, 128, 256, 512, 1024.
   parameter [`P_MAX_S*32-1:0] C_S_AXI_DATA_WIDTH               = {`P_MAX_S{32'h00000020}}, 
                       // Width of S_AXI_WDATA and S_AXI_RDATA for each SI slot.
                       // Format: C_NUM_SLAVE_SLOTS{Bit32}; 
                       // Range: 'h00000020, 'h00000040, 'h00000080, 'h00000100.
   parameter [`P_MAX_M*32-1:0] C_M_AXI_DATA_WIDTH               = {`P_MAX_M{32'h00000020}}, 
                       // Width of M_AXI_WDATA and M_AXI_RDATA for each MI slot.
                       // Format: C_NUM_MASTER_SLOTS{Bit32};
                       // Range: 'h00000020, 'h00000040, 'h00000080, 'h00000100.
   parameter integer C_INTERCONNECT_DATA_WIDTH        = 32, 
                       // Data width of the internal interconnect write and read 
                       // data paths.
                       // Range: 32, 64, 128, 256, 512, 1024.
   parameter [`P_MAX_S*32-1:0] C_S_AXI_PROTOCOL                 = {`P_MAX_S{32'h00000000}}, 
                       // Indicates whether connected master is 
                       // Full-AXI4 ('h00000000),
                       // AXI3 ('h00000001) or 
                       // Axi4Lite ('h00000002), for each SI slot.
                       // Format: C_NUM_MASTER_SLOTS{Bit32}.
   parameter [`P_MAX_M*32-1:0] C_M_AXI_PROTOCOL                 = {`P_MAX_M{32'h00000000}}, 
                       // Indicates whether connected slave is
                       // Full-AXI4 ('h00000000),
                       // AXI3 ('h00000001) or 
                       // Axi4Lite ('h00000002), for each SI slot.
                       // Format: C_NUM_SLAVE_SLOTS{Bit32}.
   parameter [`P_MAX_M*`P_NUM_ADDR_RANGES*64-1:0] C_M_AXI_BASE_ADDR                 = {`P_MAX_M*`P_NUM_ADDR_RANGES{64'hFFFFFFFF_FFFFFFFF}}, 
                       // Base address of each range of each MI slot. 
                       // For unused ranges, set base address to 'hFFFFFFFF.
                       // Format: C_NUM_MASTER_SLOTS{`P_NUM_ADDR_RANGES{Bit64}}.
   parameter [`P_MAX_M*`P_NUM_ADDR_RANGES*64-1:0] C_M_AXI_HIGH_ADDR                 = {`P_MAX_M*`P_NUM_ADDR_RANGES{64'h00000000_00000000}}, 
                       // High address of each range of each MI slot. 
                       // For unused ranges, set high address to 'h00000000.
                       // Format: C_NUM_MASTER_SLOTS{`P_NUM_ADDR_RANGES{Bit64}}.
   parameter [`P_MAX_S*32-1:0] C_S_AXI_BASE_ID                  = {`P_MAX_S{32'h00000000}},
                       // Base ID of each SI slot. 
                       // Format: C_NUM_SLAVE_SLOTS{Bit32};
                       // Range: 0 to 2**C_AXI_ID_WIDTH-1.
   parameter [`P_MAX_S*32-1:0] C_S_AXI_THREAD_ID_WIDTH                  = {`P_MAX_S{32'h00000000}},
                       // Width of variable ID signals received from master connected 
                       //   to each SI slot. 
                       // Format: C_NUM_SLAVE_SLOTS{Bit32};
                       // Range: 0 to C_AXI_ID_WIDTH.
   parameter [`P_MAX_S*1-1:0] C_S_AXI_IS_INTERCONNECT          = {`P_MAX_S{1'b0}}, 
                       // Indicates whether connected master is an end-point
                       // master (0) or an interconnect (1), for each SI slot.
                       // Format: C_NUM_SLAVE_SLOTS{Bit1}.
   parameter [`P_MAX_S*32-1:0] C_S_AXI_ACLK_RATIO               = {`P_MAX_S{32'h00000001}}, 
                       // Clock frequency ratio of each SI slot w.r.t. internal 
                       // interconnect. (Slowest clock input should have ratio=1.)
                       // Format: C_NUM_SLAVE_SLOTS{Bit32}; Range: >='h00000001.
   parameter [`P_MAX_S*1-1:0] C_S_AXI_IS_ACLK_ASYNC            = {`P_MAX_S{1'b0}}, 
                       // Indicates whether the clock for each SI slot is asynchronous
                       // to the interconnect native clock.
                       // Format: C_NUM_SLAVE_SLOTS{Bit1}.
   parameter [`P_MAX_M*32-1:0] C_M_AXI_ACLK_RATIO               = {`P_MAX_M{32'h00000001}}, 
                       // Clock frequency ratio of each MI slot w.r.t. internal 
                       // interconnect. (Slowest clock input should have ratio=1.)
                       // Format: C_NUM_MASTER_SLOTS{Bit32}; Range: >='h00000001.
   parameter [`P_MAX_M*1-1:0] C_M_AXI_IS_ACLK_ASYNC            = {`P_MAX_M{1'b0}}, 
                       // Indicates whether the clock for each MI slot is asynchronous
                       // to the interconnect native clock.
                       // Format: C_NUM_MASTER_SLOTS{Bit1}.
   parameter integer C_INTERCONNECT_ACLK_RATIO        = 1,
                       // Clock frequency ratio of the internal interconnect w.r.t. 
                       // all SI and MI slots. (Slowest clock input should have 
                       // ratio=1.) Range: >= 1.
   parameter [`P_MAX_S*1-1:0] C_S_AXI_SUPPORTS_WRITE           = {`P_MAX_S{1'b1}}, 
                       // Indicates whether each SI supports write transactions.
                       // Format: C_NUM_SLAVE_SLOTS{Bit1}.
   parameter [`P_MAX_S*1-1:0] C_S_AXI_SUPPORTS_READ            = {`P_MAX_S{1'b1}}, 
                       // Indicates whether each SI supports read transactions.
                       // Format: C_NUM_SLAVE_SLOTS{Bit1}.
   parameter [`P_MAX_M*1-1:0] C_M_AXI_SUPPORTS_WRITE           = {`P_MAX_M{1'b1}}, 
                       // Indicates whether each MI supports write transactions.
                       // Format: C_NUM_MASTER_SLOTS{Bit1}.
   parameter [`P_MAX_M*1-1:0] C_M_AXI_SUPPORTS_READ            = {`P_MAX_M{1'b1}}, 
                       // Indicates whether each MI supports read transactions.
                       // Format: C_NUM_MASTER_SLOTS{Bit1}.
   parameter integer C_AXI_SUPPORTS_USER_SIGNALS      = 0,
                       // 1 = Propagate all USER signals, 0 = Dont propagate.
   parameter integer C_AXI_AWUSER_WIDTH               = 1,
                       // Width of AWUSER signals for all SI slots and MI slots. 
                       // Range: >= 1.
   parameter integer C_AXI_ARUSER_WIDTH               = 1,
                       // Width of ARUSER signals for all SI slots and MI slots. 
                       // Range: >= 1.
   parameter integer C_AXI_WUSER_WIDTH                = 1,
                       // Width of WUSER signals for all SI slots and MI slots. 
                       // Range: >= 1.
   parameter integer C_AXI_RUSER_WIDTH                = 1,
                       // Width of RUSER signals for all SI slots and MI slots. 
                       // Range: >= 1.
   parameter integer C_AXI_BUSER_WIDTH                = 1,
                       // Width of BUSER signals for all SI slots and MI slots. 
                       // Range: >= 1.
   parameter [`P_MAX_M*32-1:0] C_AXI_CONNECTIVITY               = {`P_MAX_M{32'hFFFFFFFF}},
                       // Multi-pathway connectivity from each SI slot (N) to each 
                       // MI slot (M):
                       // 0 = no pathway required; 1 = pathway required.
                       // Format: C_NUM_MASTER_SLOTS{Bit32}; 
                       // Range: C_NUM_SLAVE_SLOTS{Bit1}.
   parameter [`P_MAX_S*1-1:0] C_S_AXI_SINGLE_THREAD                 = {`P_MAX_S{1'b0}}, 
                       // 0 = Implement separate command queues per ID thread.
                       // 1 = Force corresponding SI slot to be single-threaded.
                       // Format: C_NUM_SLAVE_SLOTS{Bit1}; 
   parameter [`P_MAX_M*1-1:0] C_M_AXI_SUPPORTS_REORDERING      = {`P_MAX_M{1'b1}},
                       // Indicates whether the slave connected to each MI slot 
                       // supports response reordering.
                       // Format: C_NUM_MASTER_SLOTS{Bit1}; 
   parameter [`P_MAX_S*1-1:0] C_S_AXI_SUPPORTS_NARROW_BURST       = {`P_MAX_S{1'b1}},
                       // This parameter is ignored by the hdl.
                       // Indicates whether the master connected to each SI slot 
                       // is assumed to generate narrow bursts.
                       // Format: C_NUM_SLAVE_SLOTS{Bit1}; 
   parameter [`P_MAX_M*1-1:0] C_M_AXI_SUPPORTS_NARROW_BURST       = {`P_MAX_M{1'b1}},
                       // This parameter is ignored by the hdl.
                       // Indicates whether the slave connected to each MI slot 
                       // can handle narrow-burst transactions.
                       // Format: C_NUM_MASTER_SLOTS{Bit1}; 
   parameter [`P_MAX_S*32-1:0] C_S_AXI_WRITE_ACCEPTANCE         = {`P_MAX_S{32'h00000001}},
                       // Maximum number of active write transactions that each SI 
                       // slot can accept.
                       // Format: C_NUM_SLAVE_SLOTS{Bit32}; 
                       // Range: 2**0 - 2**5.
   parameter [`P_MAX_S*32-1:0] C_S_AXI_READ_ACCEPTANCE          = {`P_MAX_S{32'h00000001}},
                       // Maximum number of active read transactions that each SI 
                       // slot can accept.
                       // Format: C_NUM_SLAVE_SLOTS{Bit32};
                       // Range: 2**0 - 2**5.
   parameter [`P_MAX_M*32-1:0] C_M_AXI_WRITE_ISSUING            = {`P_MAX_M{32'h00000001}},
                       // Maximum number of data-active write transactions that 
                       // each MI slot can generate at any one time.
                       // Format: C_NUM_MASTER_SLOTS{Bit32};
                       // Range: 2**0 - 2**5.
   parameter [`P_MAX_M*32-1:0] C_M_AXI_READ_ISSUING            = {`P_MAX_M{32'h00000001}},
                       // Maximum number of active read transactions that 
                       // each MI slot can generate at any one time.
                       // Format: C_NUM_MASTER_SLOTS{Bit32};
                       // Range: 2**0 - 2**5.
//   parameter         C_AXI_ARB_METHOD = "priority", // Reserved for future
//                       // Arbitration method.
//                       // Format: String; 
//                       // Range: "priority" ("tdm" not yet implemented).
   parameter [`P_MAX_S*32-1:0] C_S_AXI_ARB_PRIORITY             = {`P_MAX_S{32'h00000000}},
                       // Arbitration priority among each SI slot. 
                       // Higher values indicate higher priority.
                       // Format: C_NUM_SLAVE_SLOTS{Bit32};
                       // Range: 'h0-'hF.
//   parameter [`P_MAX_S*32-1:0] C_S_AXI_ARB_TDM_SLOTS            = {`P_MAX_S{32'h00000000}}, // Reserved for future
//                       // Maximum number of consecutive TDM arbitration slots 
//                       // allocated among each SI slot.
//                       // Format: C_NUM_SLAVE_SLOTS{Bit32});
//   parameter integer C_AXI_ARB_TDM_TOTAL            = 0, // Reserved for future
//                       // Total number of TDM arbitration slots during which all 
//                       // TDM masters must be serviced.
//                       // (Must be >= sum of all C_S_AXI_ARB_TDM_SLOTS.)
   parameter [`P_MAX_M*1-1:0] C_M_AXI_SECURE                   = {`P_MAX_M{1'b0}},
                       // Indicates whether each MI slot connects to a secure slave 
                       // (allows only TrustZone secure access).
                       // Format: C_NUM_MASTER_SLOTS{Bit1}.
   parameter [`P_MAX_S*32-1:0] C_S_AXI_WRITE_FIFO_DEPTH         = {`P_MAX_S{32'h00000000}},
                       // Depth of SI-side write data FIFO for each SI slot.
                       // Format: C_NUM_SLAVE_SLOTS{Bit32}; 
                       // Range: 'h00000000, 'h00000020, 'h00000200.
   parameter [`P_MAX_S*1-1:0] C_S_AXI_WRITE_FIFO_TYPE          = {`P_MAX_S{1'b1}},
                       // Type of SI-side write data FIFO for each SI slot.
                       // 0 = LUT flop/RAM only, 1 = BRAM allowed.
                       // Format: C_NUM_SLAVE_SLOTS{Bit1}.
   parameter [`P_MAX_S*1-1:0] C_S_AXI_WRITE_FIFO_DELAY         = {`P_MAX_S{1'b0}},
                       // Indicates whether AWVALID assertion is delayed until the 
                       // last burst data beat is received by the SI-side 
                       // write data FIFO, for each SI slot. 
                       // 0 means VALID is asserted whenever FIFO not empty.
                       // Format: C_NUM_SLAVE_SLOTS{Bit1}.
   parameter [`P_MAX_S*32-1:0] C_S_AXI_READ_FIFO_DEPTH          = {`P_MAX_S{32'h00000000}},
                       // Depth of SI-side read data FIFO for each SI slot.
                       // Format: C_NUM_SLAVE_SLOTS{Bit32};
                       // Range: 'h00000000, 'h00000020, 'h00000200.
   parameter [`P_MAX_S*1-1:0] C_S_AXI_READ_FIFO_TYPE           = {`P_MAX_S{1'b1}},
                       // Type of SI-side read data FIFO for each SI slot.
                       // 0 = LUT flop/RAM only, 1 = BRAM allowed.
                       // Format: C_NUM_SLAVE_SLOTS{Bit1}.
   parameter [`P_MAX_S*1-1:0] C_S_AXI_READ_FIFO_DELAY          = {`P_MAX_S{1'b0}},
                       // Indicates whether ARVALID assertion is delayed until the SI-side 
                       // read data FIFO has vacancy for whole burst, for each SI slot. 
                       // Format: C_NUM_SLAVE_SLOTS{Bit1}.
   parameter [`P_MAX_M*32-1:0] C_M_AXI_WRITE_FIFO_DEPTH         = {`P_MAX_M{32'h00000000}},
                       // Depth of MI-side write data FIFO for each MI slot.
                       // Format: C_NUM_MASTER_SLOTS{Bit32};
                       // Range: 'h00000000, 'h00000020, 'h00000200.
   parameter [`P_MAX_M*1-1:0] C_M_AXI_WRITE_FIFO_TYPE          = {`P_MAX_M{1'b1}},
                       // Type of MI-side write data FIFO for each MI slot.
                       // 0 = LUT flop/RAM only, 1 = BRAM allowed.
                       // Format: C_NUM_MASTER_SLOTS{Bit1}.
   parameter [`P_MAX_M*1-1:0] C_M_AXI_WRITE_FIFO_DELAY         = {`P_MAX_M{1'b0}},
                       // Indicates whether AWVALID assertion is delayed until the 
                       // last burst data beat is received by the MI-side 
                       // write data FIFO, for each MI slot. 
                       // Format: C_NUM_MASTER_SLOTS{Bit1}.
   parameter [`P_MAX_M*32-1:0] C_M_AXI_READ_FIFO_DEPTH          = {`P_MAX_M{32'h00000000}},
                       // Depth of MI-side read data FIFO for each MI slot.
                       // Format: C_NUM_MASTER_SLOTS{Bit32};
                       // Range: 'h00000000, 'h00000020, 'h00000200.
   parameter [`P_MAX_M*1-1:0] C_M_AXI_READ_FIFO_TYPE           = {`P_MAX_M{1'b1}},
                       // Type of MI-side read data FIFO for each MI slot.
                       //      = LUT flop/RAM only, 1 = BRAM allowed.
                       // Format: C_NUM_MASTER_SLOTS{Bit1}.
   parameter [`P_MAX_M*1-1:0] C_M_AXI_READ_FIFO_DELAY          = {`P_MAX_M{1'b0}},
                       // Indicates whether ARVALID assertion is delayed until the MI-side 
                       // read data FIFO has vacancy for whole burst, for each MI slot. 
                       // Format: C_NUM_MASTER_SLOTS{Bit1}.
   parameter [`P_MAX_S*32-1:0] C_S_AXI_AW_REGISTER              = {`P_MAX_S{32'h00000000}},
                       // Insert register slice on AW channel at each SI slot.
                       // Format: C_NUM_SLAVE_SLOTS{Bit32}.
   parameter [`P_MAX_S*32-1:0] C_S_AXI_AR_REGISTER              = {`P_MAX_S{32'h00000000}},
                       // Insert register slice on AR channel at each SI slot.
                       // Format: C_NUM_SLAVE_SLOTS{Bit32}.
   parameter [`P_MAX_S*32-1:0] C_S_AXI_W_REGISTER               = {`P_MAX_S{32'h00000000}},
                       // Insert register slice on W channel at each SI slot.
                       // Format: C_NUM_SLAVE_SLOTS{Bit32}.
   parameter [`P_MAX_S*32-1:0] C_S_AXI_R_REGISTER               = {`P_MAX_S{32'h00000000}},
                       // Insert register slice on R channel at each SI slot.
                       // Format: C_NUM_SLAVE_SLOTS{Bit32}.
   parameter [`P_MAX_S*32-1:0] C_S_AXI_B_REGISTER               = {`P_MAX_S{32'h00000000}},
                       // Insert register slice on B channel at each SI slot.
                       // Format: C_NUM_SLAVE_SLOTS{Bit32}.
   parameter [`P_MAX_M*32-1:0] C_M_AXI_AW_REGISTER              = {`P_MAX_M{32'h00000000}},
                       // Insert register slice on AW channel at each MI slot.
                       // Format: C_NUM_MASTER_SLOTS{Bit32}.
   parameter [`P_MAX_M*32-1:0] C_M_AXI_AR_REGISTER              = {`P_MAX_M{32'h00000000}},
                       // Insert register slice on AR channel at each MI slot.
                       // Format: C_NUM_MASTER_SLOTS{Bit32}.
   parameter [`P_MAX_M*32-1:0] C_M_AXI_W_REGISTER               = {`P_MAX_M{32'h00000000}},
                       // Insert register slice on W channel at each MI slot.
                       // Format: C_NUM_MASTER_SLOTS{Bit32}.
   parameter [`P_MAX_M*32-1:0] C_M_AXI_R_REGISTER               = {`P_MAX_M{32'h00000000}},
                       // Insert register slice on R channel at each MI slot.
                       // Format: C_NUM_MASTER_SLOTS{Bit32}.
   parameter [`P_MAX_M*32-1:0] C_M_AXI_B_REGISTER               = {`P_MAX_M{32'h00000000}},
                       // Insert register slice on B channel at each MI slot.
                       // Format: C_NUM_MASTER_SLOTS{Bit32}.
   parameter integer C_INTERCONNECT_R_REGISTER               = 0,
                       // Insert register slice on R channel in the crossbar.
                       // Range: 0-8.
   parameter integer C_USE_CTRL_PORT                  = 0,
                       // Indicates whether diagnostic information is accessible 
                       // via the S_AXI_CTRL interface.
   parameter integer C_USE_INTERRUPT                  = 1,
                       // If CTRL interface enabled, indicates whether interrupts 
                       // are generated.
   parameter integer C_RANGE_CHECK                    = 2,
                       // 1 (non-zero) = Detect and issue DECERR on the following conditions:
                       //   a. address range mismatch (no valid MI slot)
                       //   b. Burst or >32-bit transfer to AxiLite slave
                       //   c. TrustZone access violation
                       //   d. R/W direction unsupported by target
                       // 0 = Pass all transactions (no DECERR):
                       //   a. Omit DECERR detection and response logic
                       //   b. Omit address decoder when only 1 MI slot (M_AXI_A*REGION = 0 always)
                       //   c. Unpredictable target MI-slot if address mismatch and >1 MI-slot
                       //   d. Transaction corruption if any burst or >32-bit transfer to AxiLite slave
                       // Illegal combination: C_RANGE_CHECK = 0 && C_M_AXI_SECURE != 0.
   parameter integer C_S_AXI_CTRL_ADDR_WIDTH          = 32,
                       // ADDR width of CTRL interface.
   parameter integer C_S_AXI_CTRL_DATA_WIDTH          = 32,
                       // DATA width of CTRL interface.
   parameter integer C_INTERCONNECT_CONNECTIVITY_MODE = 1,
                       // 0 = Shared-Address Shared-Data (SASD).
                       // 1 = Shared-Address Multi-Data (SAMD).
   parameter integer C_SYNCHRONIZER_STAGE = 3,
   parameter integer C_DEBUG          = 1,
                       // Generate internal debug transaction sequence counters and data beat counters
                       // Default = 1 for testbench simulation
                       // Default = 0 for MPD
   parameter integer C_S_AXI_DEBUG_SLOT   = 0,
                       // SI slot slice of all SI-related DEBUG signals to connect to DEBUG output ports.
                       // Range: [0 : (C_NUM_SLAVE_SLOTS-1)] 
   parameter integer C_M_AXI_DEBUG_SLOT   = 0,
                       // MI slot slice of all MI-related DEBUG signals to connect to DEBUG output ports.
                       // Range: [0 : (C_NUM_MASTER_SLOTS-1)] 
   parameter integer C_MAX_DEBUG_THREADS  = 1
                       // Number of sets of ID-thread-specific DEBUG signals to monitor from each SI-slot (SAMD crossbar only)
                       // Range: [1 : (2**max(C_S_AXI_THREAD_ID_WIDTH))] 
   )
  (
   // Global Signals
   input  wire                                                  INTERCONNECT_ACLK,
   (* KEEP = "TRUE" *) input  wire                              INTERCONNECT_ARESETN /* synthesis syn_keep = 1 */,
   output wire                                                  IRQ,
   output wire [C_NUM_SLAVE_SLOTS-1:0]                          S_AXI_ARESET_OUT_N,  // Non-AXI resynchronized reset output
   output wire [C_NUM_MASTER_SLOTS-1:0]                         M_AXI_ARESET_OUT_N,  // Non-AXI resynchronized reset output
   output wire                                                  INTERCONNECT_ARESET_OUT_N,  // Non-AXI resynchronized reset for DEBUG
   // Slave Interface System Signals
   input  wire [C_NUM_SLAVE_SLOTS-1:0]                          S_AXI_ACLK,
   // Slave Interface Write Address Ports
   input  wire [C_NUM_SLAVE_SLOTS*C_AXI_ID_WIDTH-1:0]           S_AXI_AWID,
   input  wire [C_NUM_SLAVE_SLOTS*C_AXI_ADDR_WIDTH-1:0]         S_AXI_AWADDR,
   input  wire [C_NUM_SLAVE_SLOTS*8-1:0]                        S_AXI_AWLEN,
   input  wire [C_NUM_SLAVE_SLOTS*3-1:0]                        S_AXI_AWSIZE,
   input  wire [C_NUM_SLAVE_SLOTS*2-1:0]                        S_AXI_AWBURST,
   input  wire [C_NUM_SLAVE_SLOTS*2-1:0]                        S_AXI_AWLOCK,
   input  wire [C_NUM_SLAVE_SLOTS*4-1:0]                        S_AXI_AWCACHE,
   input  wire [C_NUM_SLAVE_SLOTS*3-1:0]                        S_AXI_AWPROT,
   input  wire [C_NUM_SLAVE_SLOTS*4-1:0]                        S_AXI_AWQOS,
   input  wire [C_NUM_SLAVE_SLOTS*C_AXI_AWUSER_WIDTH-1:0]       S_AXI_AWUSER,
   input  wire [C_NUM_SLAVE_SLOTS-1:0]                          S_AXI_AWVALID,
   output wire [C_NUM_SLAVE_SLOTS-1:0]                          S_AXI_AWREADY,
   // Slave Interface Write Data Ports
   input  wire [C_NUM_SLAVE_SLOTS*C_AXI_ID_WIDTH-1:0]           S_AXI_WID,
   input  wire [C_NUM_SLAVE_SLOTS*C_AXI_DATA_MAX_WIDTH-1:0]     S_AXI_WDATA,
   input  wire [C_NUM_SLAVE_SLOTS*C_AXI_DATA_MAX_WIDTH/8-1:0]   S_AXI_WSTRB,
   input  wire [C_NUM_SLAVE_SLOTS-1:0]                          S_AXI_WLAST,
   input  wire [C_NUM_SLAVE_SLOTS*C_AXI_WUSER_WIDTH-1:0]        S_AXI_WUSER,
   input  wire [C_NUM_SLAVE_SLOTS-1:0]                          S_AXI_WVALID,
   output wire [C_NUM_SLAVE_SLOTS-1:0]                          S_AXI_WREADY,
   // Slave Interface Write Response Ports
   output wire [C_NUM_SLAVE_SLOTS*C_AXI_ID_WIDTH-1:0]           S_AXI_BID,
   output wire [C_NUM_SLAVE_SLOTS*2-1:0]                        S_AXI_BRESP,
   output wire [C_NUM_SLAVE_SLOTS*C_AXI_BUSER_WIDTH-1:0]        S_AXI_BUSER,
   output wire [C_NUM_SLAVE_SLOTS-1:0]                          S_AXI_BVALID,
   input  wire [C_NUM_SLAVE_SLOTS-1:0]                          S_AXI_BREADY,
   // Slave Interface Read Address Ports
   input  wire [C_NUM_SLAVE_SLOTS*C_AXI_ID_WIDTH-1:0]           S_AXI_ARID,
   input  wire [C_NUM_SLAVE_SLOTS*C_AXI_ADDR_WIDTH-1:0]         S_AXI_ARADDR,
   input  wire [C_NUM_SLAVE_SLOTS*8-1:0]                        S_AXI_ARLEN,
   input  wire [C_NUM_SLAVE_SLOTS*3-1:0]                        S_AXI_ARSIZE,
   input  wire [C_NUM_SLAVE_SLOTS*2-1:0]                        S_AXI_ARBURST,
   input  wire [C_NUM_SLAVE_SLOTS*2-1:0]                        S_AXI_ARLOCK,
   input  wire [C_NUM_SLAVE_SLOTS*4-1:0]                        S_AXI_ARCACHE,
   input  wire [C_NUM_SLAVE_SLOTS*3-1:0]                        S_AXI_ARPROT,
   input  wire [C_NUM_SLAVE_SLOTS*4-1:0]                        S_AXI_ARQOS,
   input  wire [C_NUM_SLAVE_SLOTS*C_AXI_ARUSER_WIDTH-1:0]       S_AXI_ARUSER,
   input  wire [C_NUM_SLAVE_SLOTS-1:0]                          S_AXI_ARVALID,
   output wire [C_NUM_SLAVE_SLOTS-1:0]                          S_AXI_ARREADY,
   // Slave Interface Read Data Ports
   output wire [C_NUM_SLAVE_SLOTS*C_AXI_ID_WIDTH-1:0]           S_AXI_RID,
   output wire [C_NUM_SLAVE_SLOTS*C_AXI_DATA_MAX_WIDTH-1:0]     S_AXI_RDATA,
   output wire [C_NUM_SLAVE_SLOTS*2-1:0]                        S_AXI_RRESP,
   output wire [C_NUM_SLAVE_SLOTS-1:0]                          S_AXI_RLAST,
   output wire [C_NUM_SLAVE_SLOTS*C_AXI_RUSER_WIDTH-1:0]        S_AXI_RUSER,
   output wire [C_NUM_SLAVE_SLOTS-1:0]                          S_AXI_RVALID,
   input  wire [C_NUM_SLAVE_SLOTS-1:0]                          S_AXI_RREADY,
   // Master Interface System Signals
   input  wire [C_NUM_MASTER_SLOTS-1:0]                         M_AXI_ACLK,
   // Master Interface Write Address Port
   output wire [C_NUM_MASTER_SLOTS*C_AXI_ID_WIDTH-1:0]          M_AXI_AWID,
   output wire [C_NUM_MASTER_SLOTS*C_AXI_ADDR_WIDTH-1:0]        M_AXI_AWADDR,
   output wire [C_NUM_MASTER_SLOTS*8-1:0]                       M_AXI_AWLEN,
   output wire [C_NUM_MASTER_SLOTS*3-1:0]                       M_AXI_AWSIZE,
   output wire [C_NUM_MASTER_SLOTS*2-1:0]                       M_AXI_AWBURST,
   output wire [C_NUM_MASTER_SLOTS*2-1:0]                       M_AXI_AWLOCK,
   output wire [C_NUM_MASTER_SLOTS*4-1:0]                       M_AXI_AWCACHE,
   output wire [C_NUM_MASTER_SLOTS*3-1:0]                       M_AXI_AWPROT,
   output wire [C_NUM_MASTER_SLOTS*4-1:0]                       M_AXI_AWREGION,
   output wire [C_NUM_MASTER_SLOTS*4-1:0]                       M_AXI_AWQOS,
   output wire [C_NUM_MASTER_SLOTS*C_AXI_AWUSER_WIDTH-1:0]      M_AXI_AWUSER,
   output wire [C_NUM_MASTER_SLOTS-1:0]                         M_AXI_AWVALID,
   input  wire [C_NUM_MASTER_SLOTS-1:0]                         M_AXI_AWREADY,
   // Master Interface Write Data Ports
   output wire [C_NUM_MASTER_SLOTS*C_AXI_ID_WIDTH-1:0]          M_AXI_WID,
   output wire [C_NUM_MASTER_SLOTS*C_AXI_DATA_MAX_WIDTH-1:0]    M_AXI_WDATA,
   output wire [C_NUM_MASTER_SLOTS*C_AXI_DATA_MAX_WIDTH/8-1:0]  M_AXI_WSTRB,
   output wire [C_NUM_MASTER_SLOTS-1:0]                         M_AXI_WLAST,
   output wire [C_NUM_MASTER_SLOTS*C_AXI_WUSER_WIDTH-1:0]       M_AXI_WUSER,
   output wire [C_NUM_MASTER_SLOTS-1:0]                         M_AXI_WVALID,
   input  wire [C_NUM_MASTER_SLOTS-1:0]                         M_AXI_WREADY,
   // Master Interface Write Response Ports
   input  wire [C_NUM_MASTER_SLOTS*C_AXI_ID_WIDTH-1:0]          M_AXI_BID,
   input  wire [C_NUM_MASTER_SLOTS*2-1:0]                       M_AXI_BRESP,
   input  wire [C_NUM_MASTER_SLOTS*C_AXI_BUSER_WIDTH-1:0]       M_AXI_BUSER,
   input  wire [C_NUM_MASTER_SLOTS-1:0]                         M_AXI_BVALID,
   output wire [C_NUM_MASTER_SLOTS-1:0]                         M_AXI_BREADY,
   // Master Interface Read Address Port
   output wire [C_NUM_MASTER_SLOTS*C_AXI_ID_WIDTH-1:0]          M_AXI_ARID,
   output wire [C_NUM_MASTER_SLOTS*C_AXI_ADDR_WIDTH-1:0]        M_AXI_ARADDR,
   output wire [C_NUM_MASTER_SLOTS*8-1:0]                       M_AXI_ARLEN,
   output wire [C_NUM_MASTER_SLOTS*3-1:0]                       M_AXI_ARSIZE,
   output wire [C_NUM_MASTER_SLOTS*2-1:0]                       M_AXI_ARBURST,
   output wire [C_NUM_MASTER_SLOTS*2-1:0]                       M_AXI_ARLOCK,
   output wire [C_NUM_MASTER_SLOTS*4-1:0]                       M_AXI_ARCACHE,
   output wire [C_NUM_MASTER_SLOTS*3-1:0]                       M_AXI_ARPROT,
   output wire [C_NUM_MASTER_SLOTS*4-1:0]                       M_AXI_ARREGION,
   output wire [C_NUM_MASTER_SLOTS*4-1:0]                       M_AXI_ARQOS,
   output wire [C_NUM_MASTER_SLOTS*C_AXI_ARUSER_WIDTH-1:0]      M_AXI_ARUSER,
   output wire [C_NUM_MASTER_SLOTS-1:0]                         M_AXI_ARVALID,
   input  wire [C_NUM_MASTER_SLOTS-1:0]                         M_AXI_ARREADY,
   // Master Interface Read Data Ports
   input  wire [C_NUM_MASTER_SLOTS*C_AXI_ID_WIDTH-1:0]          M_AXI_RID,
   input  wire [C_NUM_MASTER_SLOTS*C_AXI_DATA_MAX_WIDTH-1:0]    M_AXI_RDATA,
   input  wire [C_NUM_MASTER_SLOTS*2-1:0]                       M_AXI_RRESP,
   input  wire [C_NUM_MASTER_SLOTS-1:0]                         M_AXI_RLAST,
   input  wire [C_NUM_MASTER_SLOTS*C_AXI_RUSER_WIDTH-1:0]       M_AXI_RUSER,
   input  wire [C_NUM_MASTER_SLOTS-1:0]                         M_AXI_RVALID,
   output wire [C_NUM_MASTER_SLOTS-1:0]                         M_AXI_RREADY,
   // Diagnostic AxiLite Slave Interface
   input wire [(C_S_AXI_CTRL_ADDR_WIDTH-1):0]                   S_AXI_CTRL_AWADDR,
   input wire                                                   S_AXI_CTRL_AWVALID,
   output wire                                                  S_AXI_CTRL_AWREADY,
   input wire [(C_S_AXI_CTRL_DATA_WIDTH-1):0]                   S_AXI_CTRL_WDATA,
   input wire                                                   S_AXI_CTRL_WVALID,
   output wire                                                  S_AXI_CTRL_WREADY,
   output wire [1:0]                                            S_AXI_CTRL_BRESP,
   output wire                                                  S_AXI_CTRL_BVALID,
   input wire                                                   S_AXI_CTRL_BREADY,
   input wire [(C_S_AXI_CTRL_ADDR_WIDTH-1):0]                   S_AXI_CTRL_ARADDR,
   input wire                                                   S_AXI_CTRL_ARVALID,
   output wire                                                  S_AXI_CTRL_ARREADY,
   output wire [(C_S_AXI_CTRL_DATA_WIDTH-1):0]                  S_AXI_CTRL_RDATA,
   output wire [1:0]                                            S_AXI_CTRL_RRESP,
   output wire                                                  S_AXI_CTRL_RVALID,
   input wire                                                   S_AXI_CTRL_RREADY,
   
   // Debug ports monitoring Crossbar module internal diagnostic nets:
   // DEBUG_A*_ERROR codes:                    
                               // Bit 0 = Invalid target address        
                               // Bit 1 = TrustZone violation           
                               // Bit 2 = AxiLite access violation      
                               // Bit 3 = R/W direction unsupported by target (SASD only)
                               // Bit 4-7 = Reserved
   // Global debug ports (independent of selected SI/MI slot):
   output wire [8-1:0]                       DEBUG_AW_TRANS_SEQ,      // Write transaction sequence #, increments each M_AW transfer (modulo 256)      
   output wire [8-1:0]                       DEBUG_AW_ARB_GRANT,      // SI currently granted for write (Bit8)                                               
   output wire [8-1:0]                       DEBUG_AR_TRANS_SEQ,      // Read transaction sequence #, increments each M_AR transfer (modulo 256) 
   output wire [8-1:0]                       DEBUG_AR_ARB_GRANT,      // SI currently granted for read  (Bit8)                                          

   // Debug ports selected by C_S_AXI_DEBUG_SLOT:
   output wire [C_MAX_DEBUG_THREADS-1:0]     DEBUG_AW_TRANS_QUAL,     // ID thread is qualified for write arbitration (1-hot)                          
   output wire [C_MAX_DEBUG_THREADS*8-1:0]   DEBUG_AW_ACCEPT_CNT,     // Write accetance counter, per ID thread (Bit8)                                 
   output wire [16-1:0]                      DEBUG_AW_ACTIVE_THREAD,  // Last issued AWID value, when SINGLE_THREADed (Bit16)                           
   output wire [C_MAX_DEBUG_THREADS*8-1:0]   DEBUG_AW_ACTIVE_TARGET,  // Last MI to be issued a write, per ID thread (Bit8)                                  
   output wire [C_MAX_DEBUG_THREADS*8-1:0]   DEBUG_AW_ACTIVE_REGION,  // Last M_REGION issued for write, per ID thread (Bit8)                                    
   output wire [8-1:0]                       DEBUG_AW_ERROR,          // Write transaction error code (Bit8)                                   
   output wire [8-1:0]                       DEBUG_AW_TARGET,         // MI currently targeted for write (Bit8)                               
   output wire [C_MAX_DEBUG_THREADS-1:0]     DEBUG_AR_TRANS_QUAL,     // ID thread is qualified for read arbitration (1-hot)                     
   output wire [C_MAX_DEBUG_THREADS*8-1:0]   DEBUG_AR_ACCEPT_CNT,     // Read accetance counter, per ID thread (Bit8)                            
   output wire [16-1:0]                      DEBUG_AR_ACTIVE_THREAD,  // Last issued ARID value, when SINGLE_THREADed (Bit16)                      
   output wire [C_MAX_DEBUG_THREADS*8-1:0]   DEBUG_AR_ACTIVE_TARGET,  // Last MI to be issued a read, per ID thread (Bit8)                             
   output wire [C_MAX_DEBUG_THREADS*8-1:0]   DEBUG_AR_ACTIVE_REGION,  // Last M_REGION issued for read, per ID thread (Bit8)                               
   output wire [8-1:0]                       DEBUG_AR_ERROR,          // Read transaction error code (Bit8)                              
   output wire [8-1:0]                       DEBUG_AR_TARGET,         // MI currently targeted for read (Bit8)                          
   output wire [C_MAX_DEBUG_THREADS*8-1:0]   DEBUG_B_TRANS_SEQ,       // Write transaction sequence # of last B-channel transfer, per ID thread (Bit8)
   output wire [C_MAX_DEBUG_THREADS*8-1:0]   DEBUG_R_BEAT_CNT,        // Beat within burst of last R-channel transfer, per ID thread (Bit8)              
   output wire [C_MAX_DEBUG_THREADS*8-1:0]   DEBUG_R_TRANS_SEQ,       // Read transaction sequence # of last R-channel transfer, per ID thread (Bit8)    

   // Debug ports selected by C_M_AXI_DEBUG_SLOT:
   output wire [8-1:0]                       DEBUG_AW_ISSUING_CNT,    // Write issuing counter (Bit8)                                          
   output wire [8-1:0]                       DEBUG_AR_ISSUING_CNT,    // Read issuing counter (Bit8)                                     
   output wire [8-1:0]                       DEBUG_W_BEAT_CNT,        // Beat within burst of last W-channel transfer (Bit8)                      
   output wire [8-1:0]                       DEBUG_W_TRANS_SEQ,       // Write transaction sequence # of last W-channel transfer (Bit8)          
   output wire [8-1:0]                       DEBUG_BID_TARGET,        // SI targeted by current BID (Bit8)                                                                                              
   output wire                               DEBUG_BID_ERROR,         // Invalid SI targeted by current BID                                                                                     
   output wire [8-1:0]                       DEBUG_RID_TARGET,        // SI targeted by current RID (Bit8)                                        
   output wire                               DEBUG_RID_ERROR,         // Invalid SI targeted by current RID                               
   
  // DEBUG ports monitoring AXI signals connecting major functional blocks
  //   Format: DEBUG_<si_side_module>_<mi_side_module>_<debug_port_name>
  //   Module mnemonics:
  //   "SR" = SI-hemisphere Register-slice bank
  //   "SC" = SI-hemisphere Converter bank (upsizer -> clock_conv -> downsizer)
  //   "SF" = SI-hemisphere data-path FIFO bank
  //   "CB" = Crossbar module (crossbar or crossbar_sasd)
  //   "MF" = MI-hemisphere data-path FIFO bank
  //   "MC" = MI-hemisphere Converter bank (upsizer -> clock_conv -> downsizer)
  //   "MP" = MI-hemisphere Protocol converter bank (axi4lite conv or axi3 conv)
  //   "MR" = MI-hemisphere Register-slice bank
  
  //   Debug port contents:
  //
  //   ARADDRCONTROL[0:0]                         = arvalid
  //   ARADDRCONTROL[1:1]                         = arready
  //   ARADDRCONTROL[9:2]                         = arlen[7:0]
  //   ARADDRCONTROL[12:10]                       = arsize[2:0]
  //   ARADDRCONTROL[14:13]                       = arburst[1:0]
  //   ARADDRCONTROL[15:15]                       = arlock 
  //   ARADDRCONTROL[19:16]                       = arcache[3:0]
  //   ARADDRCONTROL[22:20]                       = arprot[2:0]
  //   ARADDRCONTROL[22+C_AXI_ID_WIDTH:23]        = arid[C_AXI_ID_WIDTH-1:0]
  //                                              
  //   AWADDRCONTROL[0:0]                         = awvalid
  //   AWADDRCONTROL[1:1]                         = awready
  //   AWADDRCONTROL[9:2]                         = awlen[7:0]
  //   AWADDRCONTROL[12:10]                       = awsize[2:0]
  //   AWADDRCONTROL[14:13]                       = awburst[1:0]
  //   AWADDRCONTROL[15:15]                       = awlock 
  //   AWADDRCONTROL[19:16]                       = awcache[3:0]
  //   AWADDRCONTROL[22:20]                       = awprot[2:0]
  //   AWADDRCONTROL[22+C_AXI_ID_WIDTH:23]        = awid[C_AXI_ID_WIDTH-1:0]
  //          
  //   BRESP[0:0]                                 = bvalid 
  //   BRESP[1:1]                                 = bready 
  //   BRESP[3:2]                                 = bresp[1:0]  
  //   BRESP[3+C_AXI_ID_WIDTH:4]                  = bid[C_AXI_ID_WIDTH-1:0]    
  //          
  //   RDATACONTROL[0:0]                          = rvalid 
  //   RDATACONTROL[1:1]                          = rready 
  //   RDATACONTROL[2:2]                          = rlast  
  //   RDATACONTROL[4:3]                          = rresp[1:0]  
  //   RDATACONTROL[4+C_AXI_ID_WIDTH:5]           = rid[C_AXI_ID_WIDTH-1:0]    
  //          
  //   WDATACONTROL[0:0]                          = wvalid 
  //   WDATACONTROL[1:1]                          = wready 
  //   WDATACONTROL[2:2]                          = wlast  
  //   WDATACONTROL[2+(C_AXI_DATA_MAX_WIDTH/8):3] = wstrb[(C_AXI_DATA_MAX_WIDTH/8)-1:0]  
  
  // SI-side DEBUG ports selected by C_S_AXI_DEBUG_SLOT:
       
   output wire [C_AXI_ADDR_WIDTH-1:0]                             DEBUG_SR_SC_ARADDR        ,
   output wire [(1+1+8+3+2+1+4+3+C_AXI_ID_WIDTH)-1:0]             DEBUG_SR_SC_ARADDRCONTROL ,
   output wire [C_AXI_ADDR_WIDTH-1:0]                             DEBUG_SR_SC_AWADDR        ,
   output wire [(1+1+8+3+2+1+4+3+C_AXI_ID_WIDTH)-1:0]             DEBUG_SR_SC_AWADDRCONTROL ,
   output wire [(1+1+2+C_AXI_ID_WIDTH)-1:0]                       DEBUG_SR_SC_BRESP         ,
   output wire [C_AXI_DATA_MAX_WIDTH-1:0]                         DEBUG_SR_SC_RDATA         ,
   output wire [(1+1+1+2+C_AXI_ID_WIDTH)-1:0]                     DEBUG_SR_SC_RDATACONTROL  ,
   output wire [C_AXI_DATA_MAX_WIDTH-1:0]                         DEBUG_SR_SC_WDATA         ,
   output wire [(1+1+1+(C_AXI_DATA_MAX_WIDTH/8))-1:0]             DEBUG_SR_SC_WDATACONTROL  ,
       
   output wire [C_AXI_ADDR_WIDTH-1:0]                             DEBUG_SC_SF_ARADDR        ,
   output wire [(1+1+8+3+2+1+4+3+C_AXI_ID_WIDTH)-1:0]             DEBUG_SC_SF_ARADDRCONTROL ,
   output wire [C_AXI_ADDR_WIDTH-1:0]                             DEBUG_SC_SF_AWADDR        ,
   output wire [(1+1+8+3+2+1+4+3+C_AXI_ID_WIDTH)-1:0]             DEBUG_SC_SF_AWADDRCONTROL ,
   output wire [(1+1+2+C_AXI_ID_WIDTH)-1:0]                       DEBUG_SC_SF_BRESP         ,
   output wire [C_AXI_DATA_MAX_WIDTH-1:0]                         DEBUG_SC_SF_RDATA         ,
   output wire [(1+1+1+2+C_AXI_ID_WIDTH)-1:0]                     DEBUG_SC_SF_RDATACONTROL  ,
   output wire [C_AXI_DATA_MAX_WIDTH-1:0]                         DEBUG_SC_SF_WDATA         ,
   output wire [(1+1+1+(C_AXI_DATA_MAX_WIDTH/8))-1:0]             DEBUG_SC_SF_WDATACONTROL  ,
       
   output wire [C_AXI_ADDR_WIDTH-1:0]                             DEBUG_SF_CB_ARADDR        ,
   output wire [(1+1+8+3+2+1+4+3+C_AXI_ID_WIDTH)-1:0]             DEBUG_SF_CB_ARADDRCONTROL ,
   output wire [C_AXI_ADDR_WIDTH-1:0]                             DEBUG_SF_CB_AWADDR        ,
   output wire [(1+1+8+3+2+1+4+3+C_AXI_ID_WIDTH)-1:0]             DEBUG_SF_CB_AWADDRCONTROL ,
   output wire [(1+1+2+C_AXI_ID_WIDTH)-1:0]                       DEBUG_SF_CB_BRESP         ,
   output wire [C_AXI_DATA_MAX_WIDTH-1:0]                         DEBUG_SF_CB_RDATA         ,
   output wire [(1+1+1+2+C_AXI_ID_WIDTH)-1:0]                     DEBUG_SF_CB_RDATACONTROL  ,
   output wire [C_AXI_DATA_MAX_WIDTH-1:0]                         DEBUG_SF_CB_WDATA         ,
   output wire [(1+1+1+(C_AXI_DATA_MAX_WIDTH/8))-1:0]             DEBUG_SF_CB_WDATACONTROL  ,
   
  // MI-side DEBUG ports selected by C_M_AXI_DEBUG_SLOT:
  
   output wire [C_AXI_ADDR_WIDTH-1:0]                             DEBUG_CB_MF_ARADDR        ,
   output wire [(1+1+8+3+2+1+4+3+C_AXI_ID_WIDTH)-1:0]             DEBUG_CB_MF_ARADDRCONTROL ,
   output wire [C_AXI_ADDR_WIDTH-1:0]                             DEBUG_CB_MF_AWADDR        ,
   output wire [(1+1+8+3+2+1+4+3+C_AXI_ID_WIDTH)-1:0]             DEBUG_CB_MF_AWADDRCONTROL ,
   output wire [(1+1+2+C_AXI_ID_WIDTH)-1:0]                       DEBUG_CB_MF_BRESP         ,
   output wire [C_AXI_DATA_MAX_WIDTH-1:0]                         DEBUG_CB_MF_RDATA         ,
   output wire [(1+1+1+2+C_AXI_ID_WIDTH)-1:0]                     DEBUG_CB_MF_RDATACONTROL  ,
   output wire [C_AXI_DATA_MAX_WIDTH-1:0]                         DEBUG_CB_MF_WDATA         ,
   output wire [(1+1+1+(C_AXI_DATA_MAX_WIDTH/8))-1:0]             DEBUG_CB_MF_WDATACONTROL  ,
  
   output wire [C_AXI_ADDR_WIDTH-1:0]                             DEBUG_MF_MC_ARADDR        ,
   output wire [(1+1+8+3+2+1+4+3+C_AXI_ID_WIDTH)-1:0]             DEBUG_MF_MC_ARADDRCONTROL ,
   output wire [C_AXI_ADDR_WIDTH-1:0]                             DEBUG_MF_MC_AWADDR        ,
   output wire [(1+1+8+3+2+1+4+3+C_AXI_ID_WIDTH)-1:0]             DEBUG_MF_MC_AWADDRCONTROL ,
   output wire [(1+1+2+C_AXI_ID_WIDTH)-1:0]                       DEBUG_MF_MC_BRESP         ,
   output wire [C_AXI_DATA_MAX_WIDTH-1:0]                         DEBUG_MF_MC_RDATA         ,
   output wire [(1+1+1+2+C_AXI_ID_WIDTH)-1:0]                     DEBUG_MF_MC_RDATACONTROL  ,
   output wire [C_AXI_DATA_MAX_WIDTH-1:0]                         DEBUG_MF_MC_WDATA         ,
   output wire [(1+1+1+(C_AXI_DATA_MAX_WIDTH/8))-1:0]             DEBUG_MF_MC_WDATACONTROL  ,
  
   output wire [C_AXI_ADDR_WIDTH-1:0]                             DEBUG_MC_MP_ARADDR        ,
   output wire [(1+1+8+3+2+1+4+3+C_AXI_ID_WIDTH)-1:0]             DEBUG_MC_MP_ARADDRCONTROL ,
   output wire [C_AXI_ADDR_WIDTH-1:0]                             DEBUG_MC_MP_AWADDR        ,
   output wire [(1+1+8+3+2+1+4+3+C_AXI_ID_WIDTH)-1:0]             DEBUG_MC_MP_AWADDRCONTROL ,
   output wire [(1+1+2+C_AXI_ID_WIDTH)-1:0]                       DEBUG_MC_MP_BRESP         ,
   output wire [C_AXI_DATA_MAX_WIDTH-1:0]                         DEBUG_MC_MP_RDATA         ,
   output wire [(1+1+1+2+C_AXI_ID_WIDTH)-1:0]                     DEBUG_MC_MP_RDATACONTROL  ,
   output wire [C_AXI_DATA_MAX_WIDTH-1:0]                         DEBUG_MC_MP_WDATA         ,
   output wire [(1+1+1+(C_AXI_DATA_MAX_WIDTH/8))-1:0]             DEBUG_MC_MP_WDATACONTROL  ,
  
   output wire [C_AXI_ADDR_WIDTH-1:0]                             DEBUG_MP_MR_ARADDR        ,
   output wire [(1+1+8+3+2+1+4+3+C_AXI_ID_WIDTH)-1:0]             DEBUG_MP_MR_ARADDRCONTROL ,
   output wire [C_AXI_ADDR_WIDTH-1:0]                             DEBUG_MP_MR_AWADDR        ,
   output wire [(1+1+8+3+2+1+4+3+C_AXI_ID_WIDTH)-1:0]             DEBUG_MP_MR_AWADDRCONTROL ,
   output wire [(1+1+2+C_AXI_ID_WIDTH)-1:0]                       DEBUG_MP_MR_BRESP         ,
   output wire [C_AXI_DATA_MAX_WIDTH-1:0]                         DEBUG_MP_MR_RDATA         ,
   output wire [(1+1+1+2+C_AXI_ID_WIDTH)-1:0]                     DEBUG_MP_MR_RDATACONTROL  ,
   output wire [C_AXI_DATA_MAX_WIDTH-1:0]                         DEBUG_MP_MR_WDATA         ,
   output wire [(1+1+1+(C_AXI_DATA_MAX_WIDTH/8))-1:0]             DEBUG_MP_MR_WDATACONTROL  
   );

  // Nets connecting major functional blocks
  //   Format: <si_side_module>_<mi_side_module>_<axi_net_name>
  //   Module mnemonics:
  //   "si" = Slave Interface of axi_interconnect
  //   "sr" = SI-hemisphere Register-slice bank
  //   "sc" = SI-hemisphere Converter bank (upsizer -> clock_conv -> downsizer)
  //   "sf" = SI-hemisphere data-path FIFO bank
  //   "cb" = Crossbar module (crossbar or crossbar_sasd)
  //   "mf" = MI-hemisphere data-path FIFO bank
  //   "mc" = MI-hemisphere Converter bank (upsizer -> clock_conv -> downsizer)
  //   "mp" = MI-hemisphere Protocol converter bank (axi4lite conv or axi3 conv)
  //   "mr" = MI-hemisphere Register-slice bank
  //   "mi" = Master Interface of axi_interconnect
  wire [C_NUM_SLAVE_SLOTS*C_AXI_ID_WIDTH-1:0]          si_sr_awid            ;
  wire [C_NUM_SLAVE_SLOTS*C_AXI_ADDR_WIDTH-1:0]        si_sr_awaddr          ;
  wire [C_NUM_SLAVE_SLOTS*8-1:0]                       si_sr_awlen           ;
  wire [C_NUM_SLAVE_SLOTS*3-1:0]                       si_sr_awsize          ;
  wire [C_NUM_SLAVE_SLOTS*2-1:0]                       si_sr_awburst         ;
  wire [C_NUM_SLAVE_SLOTS*2-1:0]                       si_sr_awlock          ;
  wire [C_NUM_SLAVE_SLOTS*4-1:0]                       si_sr_awcache         ;
  wire [C_NUM_SLAVE_SLOTS*3-1:0]                       si_sr_awprot          ;
  wire [C_NUM_SLAVE_SLOTS*4-1:0]                       si_sr_awqos           ;
  wire [C_NUM_SLAVE_SLOTS*C_AXI_AWUSER_WIDTH-1:0]      si_sr_awuser          ;
  wire [C_NUM_SLAVE_SLOTS-1:0]                         si_sr_awvalid         ;
  wire [C_NUM_SLAVE_SLOTS-1:0]                         si_sr_awready         ;
  wire [C_NUM_SLAVE_SLOTS*C_AXI_DATA_MAX_WIDTH-1:0]    si_sr_wdata           ;
  wire [C_NUM_SLAVE_SLOTS*C_AXI_DATA_MAX_WIDTH/8-1:0]  si_sr_wstrb           ;
  wire [C_NUM_SLAVE_SLOTS-1:0]                         si_sr_wlast           ;
  wire [C_NUM_SLAVE_SLOTS*C_AXI_WUSER_WIDTH-1:0]       si_sr_wuser           ;
  wire [C_NUM_SLAVE_SLOTS-1:0]                         si_sr_wvalid          ;
  wire [C_NUM_SLAVE_SLOTS-1:0]                         si_sr_wready          ;
  wire [C_NUM_SLAVE_SLOTS*C_AXI_ID_WIDTH-1:0]          si_sr_bid             ;
  wire [C_NUM_SLAVE_SLOTS*2-1:0]                       si_sr_bresp           ;
  wire [C_NUM_SLAVE_SLOTS*C_AXI_BUSER_WIDTH-1:0]       si_sr_buser           ;
  wire [C_NUM_SLAVE_SLOTS-1:0]                         si_sr_bvalid          ;
  wire [C_NUM_SLAVE_SLOTS-1:0]                         si_sr_bready          ;
  wire [C_NUM_SLAVE_SLOTS*C_AXI_ID_WIDTH-1:0]          si_sr_arid            ;
  wire [C_NUM_SLAVE_SLOTS*C_AXI_ADDR_WIDTH-1:0]        si_sr_araddr          ;
  wire [C_NUM_SLAVE_SLOTS*8-1:0]                       si_sr_arlen           ;
  wire [C_NUM_SLAVE_SLOTS*3-1:0]                       si_sr_arsize          ;
  wire [C_NUM_SLAVE_SLOTS*2-1:0]                       si_sr_arburst         ;
  wire [C_NUM_SLAVE_SLOTS*2-1:0]                       si_sr_arlock          ;
  wire [C_NUM_SLAVE_SLOTS*4-1:0]                       si_sr_arcache         ;
  wire [C_NUM_SLAVE_SLOTS*3-1:0]                       si_sr_arprot          ;
  wire [C_NUM_SLAVE_SLOTS*4-1:0]                       si_sr_arqos           ;
  wire [C_NUM_SLAVE_SLOTS*C_AXI_ARUSER_WIDTH-1:0]      si_sr_aruser          ;
  wire [C_NUM_SLAVE_SLOTS-1:0]                         si_sr_arvalid         ;
  wire [C_NUM_SLAVE_SLOTS-1:0]                         si_sr_arready         ;
  wire [C_NUM_SLAVE_SLOTS*C_AXI_ID_WIDTH-1:0]          si_sr_rid             ;
  wire [C_NUM_SLAVE_SLOTS*C_AXI_DATA_MAX_WIDTH-1:0]    si_sr_rdata           ;
  wire [C_NUM_SLAVE_SLOTS*2-1:0]                       si_sr_rresp           ;
  wire [C_NUM_SLAVE_SLOTS-1:0]                         si_sr_rlast           ;
  wire [C_NUM_SLAVE_SLOTS*C_AXI_RUSER_WIDTH-1:0]       si_sr_ruser           ;
  wire [C_NUM_SLAVE_SLOTS-1:0]                         si_sr_rvalid          ;
  wire [C_NUM_SLAVE_SLOTS-1:0]                         si_sr_rready          ;
                                             
  wire [C_NUM_SLAVE_SLOTS*C_AXI_ID_WIDTH-1:0]          sr_sc_awid            ;
  wire [C_NUM_SLAVE_SLOTS*C_AXI_ADDR_WIDTH-1:0]        sr_sc_awaddr          ;
  wire [C_NUM_SLAVE_SLOTS*8-1:0]                       sr_sc_awlen           ;
  wire [C_NUM_SLAVE_SLOTS*3-1:0]                       sr_sc_awsize          ;
  wire [C_NUM_SLAVE_SLOTS*2-1:0]                       sr_sc_awburst         ;
  wire [C_NUM_SLAVE_SLOTS*2-1:0]                       sr_sc_awlock          ;
  wire [C_NUM_SLAVE_SLOTS*4-1:0]                       sr_sc_awcache         ;
  wire [C_NUM_SLAVE_SLOTS*3-1:0]                       sr_sc_awprot          ;
  wire [C_NUM_SLAVE_SLOTS*4-1:0]                       sr_sc_awqos           ;
  wire [C_NUM_SLAVE_SLOTS*C_AXI_AWUSER_WIDTH-1:0]      sr_sc_awuser          ;
  wire [C_NUM_SLAVE_SLOTS-1:0]                         sr_sc_awvalid         ;
  wire [C_NUM_SLAVE_SLOTS-1:0]                         sr_sc_awready         ;
  wire [C_NUM_SLAVE_SLOTS*C_AXI_DATA_MAX_WIDTH-1:0]    sr_sc_wdata           ;
  wire [C_NUM_SLAVE_SLOTS*C_AXI_DATA_MAX_WIDTH/8-1:0]  sr_sc_wstrb           ;
  wire [C_NUM_SLAVE_SLOTS-1:0]                         sr_sc_wlast           ;
  wire [C_NUM_SLAVE_SLOTS*C_AXI_WUSER_WIDTH-1:0]       sr_sc_wuser           ;
  wire [C_NUM_SLAVE_SLOTS-1:0]                         sr_sc_wvalid          ;
  wire [C_NUM_SLAVE_SLOTS-1:0]                         sr_sc_wready          ;
  wire [C_NUM_SLAVE_SLOTS*C_AXI_ID_WIDTH-1:0]          sr_sc_bid             ;
  wire [C_NUM_SLAVE_SLOTS*2-1:0]                       sr_sc_bresp           ;
  wire [C_NUM_SLAVE_SLOTS*C_AXI_BUSER_WIDTH-1:0]       sr_sc_buser           ;
  wire [C_NUM_SLAVE_SLOTS-1:0]                         sr_sc_bvalid          ;
  wire [C_NUM_SLAVE_SLOTS-1:0]                         sr_sc_bready          ;
  wire [C_NUM_SLAVE_SLOTS*C_AXI_ID_WIDTH-1:0]          sr_sc_arid            ;
  wire [C_NUM_SLAVE_SLOTS*C_AXI_ADDR_WIDTH-1:0]        sr_sc_araddr          ;
  wire [C_NUM_SLAVE_SLOTS*8-1:0]                       sr_sc_arlen           ;
  wire [C_NUM_SLAVE_SLOTS*3-1:0]                       sr_sc_arsize          ;
  wire [C_NUM_SLAVE_SLOTS*2-1:0]                       sr_sc_arburst         ;
  wire [C_NUM_SLAVE_SLOTS*2-1:0]                       sr_sc_arlock          ;
  wire [C_NUM_SLAVE_SLOTS*4-1:0]                       sr_sc_arcache         ;
  wire [C_NUM_SLAVE_SLOTS*3-1:0]                       sr_sc_arprot          ;
  wire [C_NUM_SLAVE_SLOTS*4-1:0]                       sr_sc_arqos           ;
  wire [C_NUM_SLAVE_SLOTS*C_AXI_ARUSER_WIDTH-1:0]      sr_sc_aruser          ;
  wire [C_NUM_SLAVE_SLOTS-1:0]                         sr_sc_arvalid         ;
  wire [C_NUM_SLAVE_SLOTS-1:0]                         sr_sc_arready         ;
  wire [C_NUM_SLAVE_SLOTS*C_AXI_ID_WIDTH-1:0]          sr_sc_rid             ;
  wire [C_NUM_SLAVE_SLOTS*C_AXI_DATA_MAX_WIDTH-1:0]    sr_sc_rdata           ;
  wire [C_NUM_SLAVE_SLOTS*2-1:0]                       sr_sc_rresp           ;
  wire [C_NUM_SLAVE_SLOTS-1:0]                         sr_sc_rlast           ;
  wire [C_NUM_SLAVE_SLOTS*C_AXI_RUSER_WIDTH-1:0]       sr_sc_ruser           ;
  wire [C_NUM_SLAVE_SLOTS-1:0]                         sr_sc_rvalid          ;
  wire [C_NUM_SLAVE_SLOTS-1:0]                         sr_sc_rready          ;
                                             
  wire [C_NUM_SLAVE_SLOTS*C_AXI_ID_WIDTH-1:0]          sc_sf_awid            ;
  wire [C_NUM_SLAVE_SLOTS*C_AXI_ADDR_WIDTH-1:0]        sc_sf_awaddr          ;
  wire [C_NUM_SLAVE_SLOTS*8-1:0]                       sc_sf_awlen           ;
  wire [C_NUM_SLAVE_SLOTS*3-1:0]                       sc_sf_awsize          ;
  wire [C_NUM_SLAVE_SLOTS*2-1:0]                       sc_sf_awburst         ;
  wire [C_NUM_SLAVE_SLOTS*2-1:0]                       sc_sf_awlock          ;
  wire [C_NUM_SLAVE_SLOTS*4-1:0]                       sc_sf_awcache         ;
  wire [C_NUM_SLAVE_SLOTS*3-1:0]                       sc_sf_awprot          ;
  wire [C_NUM_SLAVE_SLOTS*4-1:0]                       sc_sf_awqos           ;
  wire [C_NUM_SLAVE_SLOTS*C_AXI_AWUSER_WIDTH-1:0]      sc_sf_awuser          ;
  wire [C_NUM_SLAVE_SLOTS-1:0]                         sc_sf_awvalid         ;
  wire [C_NUM_SLAVE_SLOTS-1:0]                         sc_sf_awready         ;
  wire [C_NUM_SLAVE_SLOTS*C_AXI_DATA_MAX_WIDTH-1:0]    sc_sf_wdata           ;
  wire [C_NUM_SLAVE_SLOTS*C_AXI_DATA_MAX_WIDTH/8-1:0]  sc_sf_wstrb           ;
  wire [C_NUM_SLAVE_SLOTS-1:0]                         sc_sf_wlast           ;
  wire [C_NUM_SLAVE_SLOTS*C_AXI_WUSER_WIDTH-1:0]       sc_sf_wuser           ;
  wire [C_NUM_SLAVE_SLOTS-1:0]                         sc_sf_wvalid          ;
  wire [C_NUM_SLAVE_SLOTS-1:0]                         sc_sf_wready          ;
  wire [C_NUM_SLAVE_SLOTS*C_AXI_ID_WIDTH-1:0]          sc_sf_bid             ;
  wire [C_NUM_SLAVE_SLOTS*2-1:0]                       sc_sf_bresp           ;
  wire [C_NUM_SLAVE_SLOTS*C_AXI_BUSER_WIDTH-1:0]       sc_sf_buser           ;
  wire [C_NUM_SLAVE_SLOTS-1:0]                         sc_sf_bvalid          ;
  wire [C_NUM_SLAVE_SLOTS-1:0]                         sc_sf_bready          ;
  wire [C_NUM_SLAVE_SLOTS*C_AXI_ID_WIDTH-1:0]          sc_sf_arid            ;
  wire [C_NUM_SLAVE_SLOTS*C_AXI_ADDR_WIDTH-1:0]        sc_sf_araddr          ;
  wire [C_NUM_SLAVE_SLOTS*8-1:0]                       sc_sf_arlen           ;
  wire [C_NUM_SLAVE_SLOTS*3-1:0]                       sc_sf_arsize          ;
  wire [C_NUM_SLAVE_SLOTS*2-1:0]                       sc_sf_arburst         ;
  wire [C_NUM_SLAVE_SLOTS*2-1:0]                       sc_sf_arlock          ;
  wire [C_NUM_SLAVE_SLOTS*4-1:0]                       sc_sf_arcache         ;
  wire [C_NUM_SLAVE_SLOTS*3-1:0]                       sc_sf_arprot          ;
  wire [C_NUM_SLAVE_SLOTS*4-1:0]                       sc_sf_arqos           ;
  wire [C_NUM_SLAVE_SLOTS*C_AXI_ARUSER_WIDTH-1:0]      sc_sf_aruser          ;
  wire [C_NUM_SLAVE_SLOTS-1:0]                         sc_sf_arvalid         ;
  wire [C_NUM_SLAVE_SLOTS-1:0]                         sc_sf_arready         ;
  wire [C_NUM_SLAVE_SLOTS*C_AXI_ID_WIDTH-1:0]          sc_sf_rid             ;
  wire [C_NUM_SLAVE_SLOTS*C_AXI_DATA_MAX_WIDTH-1:0]    sc_sf_rdata           ;
  wire [C_NUM_SLAVE_SLOTS*2-1:0]                       sc_sf_rresp           ;
  wire [C_NUM_SLAVE_SLOTS-1:0]                         sc_sf_rlast           ;
  wire [C_NUM_SLAVE_SLOTS*C_AXI_RUSER_WIDTH-1:0]       sc_sf_ruser           ;
  wire [C_NUM_SLAVE_SLOTS-1:0]                         sc_sf_rvalid          ;
  wire [C_NUM_SLAVE_SLOTS-1:0]                         sc_sf_rready          ;
                                             
  wire [C_NUM_SLAVE_SLOTS*C_AXI_ID_WIDTH-1:0]          sf_cb_awid            ;
  wire [C_NUM_SLAVE_SLOTS*C_AXI_ADDR_WIDTH-1:0]        sf_cb_awaddr          ;
  wire [C_NUM_SLAVE_SLOTS*8-1:0]                       sf_cb_awlen           ;
  wire [C_NUM_SLAVE_SLOTS*3-1:0]                       sf_cb_awsize          ;
  wire [C_NUM_SLAVE_SLOTS*2-1:0]                       sf_cb_awburst         ;
  wire [C_NUM_SLAVE_SLOTS*2-1:0]                       sf_cb_awlock          ;
  wire [C_NUM_SLAVE_SLOTS*4-1:0]                       sf_cb_awcache         ;
  wire [C_NUM_SLAVE_SLOTS*3-1:0]                       sf_cb_awprot          ;
  wire [C_NUM_SLAVE_SLOTS*4-1:0]                       sf_cb_awqos           ;
  wire [C_NUM_SLAVE_SLOTS*C_AXI_AWUSER_WIDTH-1:0]      sf_cb_awuser          ;
  wire [C_NUM_SLAVE_SLOTS-1:0]                         sf_cb_awvalid         ;
  wire [C_NUM_SLAVE_SLOTS-1:0]                         sf_cb_awready         ;
  wire [C_NUM_SLAVE_SLOTS*C_AXI_DATA_MAX_WIDTH-1:0]    sf_cb_wdata           ;
  wire [C_NUM_SLAVE_SLOTS*C_AXI_DATA_MAX_WIDTH/8-1:0]  sf_cb_wstrb           ;
  wire [C_NUM_SLAVE_SLOTS-1:0]                         sf_cb_wlast           ;
  wire [C_NUM_SLAVE_SLOTS*C_AXI_WUSER_WIDTH-1:0]       sf_cb_wuser           ;
  wire [C_NUM_SLAVE_SLOTS-1:0]                         sf_cb_wvalid          ;
  wire [C_NUM_SLAVE_SLOTS-1:0]                         sf_cb_wready          ;
  wire [C_NUM_SLAVE_SLOTS*C_AXI_ID_WIDTH-1:0]          sf_cb_bid             ;
  wire [C_NUM_SLAVE_SLOTS*2-1:0]                       sf_cb_bresp           ;
  wire [C_NUM_SLAVE_SLOTS*C_AXI_BUSER_WIDTH-1:0]       sf_cb_buser           ;
  wire [C_NUM_SLAVE_SLOTS-1:0]                         sf_cb_bvalid          ;
  wire [C_NUM_SLAVE_SLOTS-1:0]                         sf_cb_bready          ;
  wire [C_NUM_SLAVE_SLOTS*C_AXI_ID_WIDTH-1:0]          sf_cb_arid            ;
  wire [C_NUM_SLAVE_SLOTS*C_AXI_ADDR_WIDTH-1:0]        sf_cb_araddr          ;
  wire [C_NUM_SLAVE_SLOTS*8-1:0]                       sf_cb_arlen           ;
  wire [C_NUM_SLAVE_SLOTS*3-1:0]                       sf_cb_arsize          ;
  wire [C_NUM_SLAVE_SLOTS*2-1:0]                       sf_cb_arburst         ;
  wire [C_NUM_SLAVE_SLOTS*2-1:0]                       sf_cb_arlock          ;
  wire [C_NUM_SLAVE_SLOTS*4-1:0]                       sf_cb_arcache         ;
  wire [C_NUM_SLAVE_SLOTS*3-1:0]                       sf_cb_arprot          ;
  wire [C_NUM_SLAVE_SLOTS*4-1:0]                       sf_cb_arqos           ;
  wire [C_NUM_SLAVE_SLOTS*C_AXI_ARUSER_WIDTH-1:0]      sf_cb_aruser          ;
  wire [C_NUM_SLAVE_SLOTS-1:0]                         sf_cb_arvalid         ;
  wire [C_NUM_SLAVE_SLOTS-1:0]                         sf_cb_arready         ;
  wire [C_NUM_SLAVE_SLOTS*C_AXI_ID_WIDTH-1:0]          sf_cb_rid             ;
  wire [C_NUM_SLAVE_SLOTS*C_AXI_DATA_MAX_WIDTH-1:0]    sf_cb_rdata           ;
  wire [C_NUM_SLAVE_SLOTS*2-1:0]                       sf_cb_rresp           ;
  wire [C_NUM_SLAVE_SLOTS-1:0]                         sf_cb_rlast           ;
  wire [C_NUM_SLAVE_SLOTS*C_AXI_RUSER_WIDTH-1:0]       sf_cb_ruser           ;
  wire [C_NUM_SLAVE_SLOTS-1:0]                         sf_cb_rvalid          ;
  wire [C_NUM_SLAVE_SLOTS-1:0]                         sf_cb_rready          ;
                                             
  wire [C_NUM_MASTER_SLOTS*C_AXI_ID_WIDTH-1:0]         cb_mf_awid            ;
  wire [C_NUM_MASTER_SLOTS*C_AXI_ADDR_WIDTH-1:0]       cb_mf_awaddr          ;
  wire [C_NUM_MASTER_SLOTS*8-1:0]                      cb_mf_awlen           ;
  wire [C_NUM_MASTER_SLOTS*3-1:0]                      cb_mf_awsize          ;
  wire [C_NUM_MASTER_SLOTS*2-1:0]                      cb_mf_awburst         ;
  wire [C_NUM_MASTER_SLOTS*2-1:0]                      cb_mf_awlock          ;
  wire [C_NUM_MASTER_SLOTS*4-1:0]                      cb_mf_awcache         ;
  wire [C_NUM_MASTER_SLOTS*3-1:0]                      cb_mf_awprot          ;
  wire [C_NUM_MASTER_SLOTS*4-1:0]                      cb_mf_awregion        ;
  wire [C_NUM_MASTER_SLOTS*4-1:0]                      cb_mf_awqos           ;
  wire [C_NUM_MASTER_SLOTS*C_AXI_AWUSER_WIDTH-1:0]     cb_mf_awuser          ;
  wire [C_NUM_MASTER_SLOTS-1:0]                        cb_mf_awvalid         ;
  wire [C_NUM_MASTER_SLOTS-1:0]                        cb_mf_awready         ;
  wire [C_NUM_MASTER_SLOTS*C_AXI_DATA_MAX_WIDTH-1:0]   cb_mf_wdata           ;
  wire [C_NUM_MASTER_SLOTS*C_AXI_DATA_MAX_WIDTH/8-1:0] cb_mf_wstrb           ;
  wire [C_NUM_MASTER_SLOTS-1:0]                        cb_mf_wlast           ;
  wire [C_NUM_MASTER_SLOTS*C_AXI_WUSER_WIDTH-1:0]      cb_mf_wuser           ;
  wire [C_NUM_MASTER_SLOTS-1:0]                        cb_mf_wvalid          ;
  wire [C_NUM_MASTER_SLOTS-1:0]                        cb_mf_wready          ;
  wire [C_NUM_MASTER_SLOTS*C_AXI_ID_WIDTH-1:0]         cb_mf_bid             ;
  wire [C_NUM_MASTER_SLOTS*2-1:0]                      cb_mf_bresp           ;
  wire [C_NUM_MASTER_SLOTS*C_AXI_BUSER_WIDTH-1:0]      cb_mf_buser           ;
  wire [C_NUM_MASTER_SLOTS-1:0]                        cb_mf_bvalid          ;
  wire [C_NUM_MASTER_SLOTS-1:0]                        cb_mf_bready          ;
  wire [C_NUM_MASTER_SLOTS*C_AXI_ID_WIDTH-1:0]         cb_mf_arid            ;
  wire [C_NUM_MASTER_SLOTS*C_AXI_ADDR_WIDTH-1:0]       cb_mf_araddr          ;
  wire [C_NUM_MASTER_SLOTS*8-1:0]                      cb_mf_arlen           ;
  wire [C_NUM_MASTER_SLOTS*3-1:0]                      cb_mf_arsize          ;
  wire [C_NUM_MASTER_SLOTS*2-1:0]                      cb_mf_arburst         ;
  wire [C_NUM_MASTER_SLOTS*2-1:0]                      cb_mf_arlock          ;
  wire [C_NUM_MASTER_SLOTS*4-1:0]                      cb_mf_arcache         ;
  wire [C_NUM_MASTER_SLOTS*3-1:0]                      cb_mf_arprot          ;
  wire [C_NUM_MASTER_SLOTS*4-1:0]                      cb_mf_arregion        ;
  wire [C_NUM_MASTER_SLOTS*4-1:0]                      cb_mf_arqos           ;
  wire [C_NUM_MASTER_SLOTS*C_AXI_ARUSER_WIDTH-1:0]     cb_mf_aruser          ;
  wire [C_NUM_MASTER_SLOTS-1:0]                        cb_mf_arvalid         ;
  wire [C_NUM_MASTER_SLOTS-1:0]                        cb_mf_arready         ;
  wire [C_NUM_MASTER_SLOTS*C_AXI_ID_WIDTH-1:0]         cb_mf_rid             ;
  wire [C_NUM_MASTER_SLOTS*C_AXI_DATA_MAX_WIDTH-1:0]   cb_mf_rdata           ;
  wire [C_NUM_MASTER_SLOTS*2-1:0]                      cb_mf_rresp           ;
  wire [C_NUM_MASTER_SLOTS-1:0]                        cb_mf_rlast           ;
  wire [C_NUM_MASTER_SLOTS*C_AXI_RUSER_WIDTH-1:0]      cb_mf_ruser           ;
  wire [C_NUM_MASTER_SLOTS-1:0]                        cb_mf_rvalid          ;
  wire [C_NUM_MASTER_SLOTS-1:0]                        cb_mf_rready          ;
                                             
  wire [C_NUM_MASTER_SLOTS*C_AXI_ID_WIDTH-1:0]         mf_mc_awid            ;
  wire [C_NUM_MASTER_SLOTS*C_AXI_ADDR_WIDTH-1:0]       mf_mc_awaddr          ;
  wire [C_NUM_MASTER_SLOTS*8-1:0]                      mf_mc_awlen           ;
  wire [C_NUM_MASTER_SLOTS*3-1:0]                      mf_mc_awsize          ;
  wire [C_NUM_MASTER_SLOTS*2-1:0]                      mf_mc_awburst         ;
  wire [C_NUM_MASTER_SLOTS*2-1:0]                      mf_mc_awlock          ;
  wire [C_NUM_MASTER_SLOTS*4-1:0]                      mf_mc_awcache         ;
  wire [C_NUM_MASTER_SLOTS*3-1:0]                      mf_mc_awprot          ;
  wire [C_NUM_MASTER_SLOTS*4-1:0]                      mf_mc_awregion        ;
  wire [C_NUM_MASTER_SLOTS*4-1:0]                      mf_mc_awqos           ;
  wire [C_NUM_MASTER_SLOTS*C_AXI_AWUSER_WIDTH-1:0]     mf_mc_awuser          ;
  wire [C_NUM_MASTER_SLOTS-1:0]                        mf_mc_awvalid         ;
  wire [C_NUM_MASTER_SLOTS-1:0]                        mf_mc_awready         ;
  wire [C_NUM_MASTER_SLOTS*C_AXI_DATA_MAX_WIDTH-1:0]   mf_mc_wdata           ;
  wire [C_NUM_MASTER_SLOTS*C_AXI_DATA_MAX_WIDTH/8-1:0] mf_mc_wstrb           ;
  wire [C_NUM_MASTER_SLOTS-1:0]                        mf_mc_wlast           ;
  wire [C_NUM_MASTER_SLOTS*C_AXI_WUSER_WIDTH-1:0]      mf_mc_wuser           ;
  wire [C_NUM_MASTER_SLOTS-1:0]                        mf_mc_wvalid          ;
  wire [C_NUM_MASTER_SLOTS-1:0]                        mf_mc_wready          ;
  wire [C_NUM_MASTER_SLOTS*C_AXI_ID_WIDTH-1:0]         mf_mc_bid             ;
  wire [C_NUM_MASTER_SLOTS*2-1:0]                      mf_mc_bresp           ;
  wire [C_NUM_MASTER_SLOTS*C_AXI_BUSER_WIDTH-1:0]      mf_mc_buser           ;
  wire [C_NUM_MASTER_SLOTS-1:0]                        mf_mc_bvalid          ;
  wire [C_NUM_MASTER_SLOTS-1:0]                        mf_mc_bready          ;
  wire [C_NUM_MASTER_SLOTS*C_AXI_ID_WIDTH-1:0]         mf_mc_arid            ;
  wire [C_NUM_MASTER_SLOTS*C_AXI_ADDR_WIDTH-1:0]       mf_mc_araddr          ;
  wire [C_NUM_MASTER_SLOTS*8-1:0]                      mf_mc_arlen           ;
  wire [C_NUM_MASTER_SLOTS*3-1:0]                      mf_mc_arsize          ;
  wire [C_NUM_MASTER_SLOTS*2-1:0]                      mf_mc_arburst         ;
  wire [C_NUM_MASTER_SLOTS*2-1:0]                      mf_mc_arlock          ;
  wire [C_NUM_MASTER_SLOTS*4-1:0]                      mf_mc_arcache         ;
  wire [C_NUM_MASTER_SLOTS*3-1:0]                      mf_mc_arprot          ;
  wire [C_NUM_MASTER_SLOTS*4-1:0]                      mf_mc_arregion        ;
  wire [C_NUM_MASTER_SLOTS*4-1:0]                      mf_mc_arqos           ;
  wire [C_NUM_MASTER_SLOTS*C_AXI_ARUSER_WIDTH-1:0]     mf_mc_aruser          ;
  wire [C_NUM_MASTER_SLOTS-1:0]                        mf_mc_arvalid         ;
  wire [C_NUM_MASTER_SLOTS-1:0]                        mf_mc_arready         ;
  wire [C_NUM_MASTER_SLOTS*C_AXI_ID_WIDTH-1:0]         mf_mc_rid             ;
  wire [C_NUM_MASTER_SLOTS*C_AXI_DATA_MAX_WIDTH-1:0]   mf_mc_rdata           ;
  wire [C_NUM_MASTER_SLOTS*2-1:0]                      mf_mc_rresp           ;
  wire [C_NUM_MASTER_SLOTS-1:0]                        mf_mc_rlast           ;
  wire [C_NUM_MASTER_SLOTS*C_AXI_RUSER_WIDTH-1:0]      mf_mc_ruser           ;
  wire [C_NUM_MASTER_SLOTS-1:0]                        mf_mc_rvalid          ;
  wire [C_NUM_MASTER_SLOTS-1:0]                        mf_mc_rready          ;
                                             
  wire [C_NUM_MASTER_SLOTS*C_AXI_ID_WIDTH-1:0]         mc_mp_awid            ;
  wire [C_NUM_MASTER_SLOTS*C_AXI_ADDR_WIDTH-1:0]       mc_mp_awaddr          ;
  wire [C_NUM_MASTER_SLOTS*8-1:0]                      mc_mp_awlen           ;
  wire [C_NUM_MASTER_SLOTS*3-1:0]                      mc_mp_awsize          ;
  wire [C_NUM_MASTER_SLOTS*2-1:0]                      mc_mp_awburst         ;
  wire [C_NUM_MASTER_SLOTS*2-1:0]                      mc_mp_awlock          ;
  wire [C_NUM_MASTER_SLOTS*4-1:0]                      mc_mp_awcache         ;
  wire [C_NUM_MASTER_SLOTS*3-1:0]                      mc_mp_awprot          ;
  wire [C_NUM_MASTER_SLOTS*4-1:0]                      mc_mp_awregion        ;
  wire [C_NUM_MASTER_SLOTS*4-1:0]                      mc_mp_awqos           ;
  wire [C_NUM_MASTER_SLOTS*C_AXI_AWUSER_WIDTH-1:0]     mc_mp_awuser          ;
  wire [C_NUM_MASTER_SLOTS-1:0]                        mc_mp_awvalid         ;
  wire [C_NUM_MASTER_SLOTS-1:0]                        mc_mp_awready         ;
  wire [C_NUM_MASTER_SLOTS*C_AXI_DATA_MAX_WIDTH-1:0]   mc_mp_wdata           ;
  wire [C_NUM_MASTER_SLOTS*C_AXI_DATA_MAX_WIDTH/8-1:0] mc_mp_wstrb           ;
  wire [C_NUM_MASTER_SLOTS-1:0]                        mc_mp_wlast           ;
  wire [C_NUM_MASTER_SLOTS*C_AXI_WUSER_WIDTH-1:0]      mc_mp_wuser           ;
  wire [C_NUM_MASTER_SLOTS-1:0]                        mc_mp_wvalid          ;
  wire [C_NUM_MASTER_SLOTS-1:0]                        mc_mp_wready          ;
  wire [C_NUM_MASTER_SLOTS*C_AXI_ID_WIDTH-1:0]         mc_mp_bid             ;
  wire [C_NUM_MASTER_SLOTS*2-1:0]                      mc_mp_bresp           ;
  wire [C_NUM_MASTER_SLOTS*C_AXI_BUSER_WIDTH-1:0]      mc_mp_buser           ;
  wire [C_NUM_MASTER_SLOTS-1:0]                        mc_mp_bvalid          ;
  wire [C_NUM_MASTER_SLOTS-1:0]                        mc_mp_bready          ;
  wire [C_NUM_MASTER_SLOTS*C_AXI_ID_WIDTH-1:0]         mc_mp_arid            ;
  wire [C_NUM_MASTER_SLOTS*C_AXI_ADDR_WIDTH-1:0]       mc_mp_araddr          ;
  wire [C_NUM_MASTER_SLOTS*8-1:0]                      mc_mp_arlen           ;
  wire [C_NUM_MASTER_SLOTS*3-1:0]                      mc_mp_arsize          ;
  wire [C_NUM_MASTER_SLOTS*2-1:0]                      mc_mp_arburst         ;
  wire [C_NUM_MASTER_SLOTS*2-1:0]                      mc_mp_arlock          ;
  wire [C_NUM_MASTER_SLOTS*4-1:0]                      mc_mp_arcache         ;
  wire [C_NUM_MASTER_SLOTS*3-1:0]                      mc_mp_arprot          ;
  wire [C_NUM_MASTER_SLOTS*4-1:0]                      mc_mp_arregion        ;
  wire [C_NUM_MASTER_SLOTS*4-1:0]                      mc_mp_arqos           ;
  wire [C_NUM_MASTER_SLOTS*C_AXI_ARUSER_WIDTH-1:0]     mc_mp_aruser          ;
  wire [C_NUM_MASTER_SLOTS-1:0]                        mc_mp_arvalid         ;
  wire [C_NUM_MASTER_SLOTS-1:0]                        mc_mp_arready         ;
  wire [C_NUM_MASTER_SLOTS*C_AXI_ID_WIDTH-1:0]         mc_mp_rid             ;
  wire [C_NUM_MASTER_SLOTS*C_AXI_DATA_MAX_WIDTH-1:0]   mc_mp_rdata           ;
  wire [C_NUM_MASTER_SLOTS*2-1:0]                      mc_mp_rresp           ;
  wire [C_NUM_MASTER_SLOTS-1:0]                        mc_mp_rlast           ;
  wire [C_NUM_MASTER_SLOTS*C_AXI_RUSER_WIDTH-1:0]      mc_mp_ruser           ;
  wire [C_NUM_MASTER_SLOTS-1:0]                        mc_mp_rvalid          ;
  wire [C_NUM_MASTER_SLOTS-1:0]                        mc_mp_rready          ;
                                                
  wire [C_NUM_MASTER_SLOTS*C_AXI_ID_WIDTH-1:0]         mp_mr_awid            ;
  wire [C_NUM_MASTER_SLOTS*C_AXI_ADDR_WIDTH-1:0]       mp_mr_awaddr          ;
  wire [C_NUM_MASTER_SLOTS*8-1:0]                      mp_mr_awlen           ;
  wire [C_NUM_MASTER_SLOTS*3-1:0]                      mp_mr_awsize          ;
  wire [C_NUM_MASTER_SLOTS*2-1:0]                      mp_mr_awburst         ;
  wire [C_NUM_MASTER_SLOTS*2-1:0]                      mp_mr_awlock          ;
  wire [C_NUM_MASTER_SLOTS*4-1:0]                      mp_mr_awcache         ;
  wire [C_NUM_MASTER_SLOTS*3-1:0]                      mp_mr_awprot          ;
  wire [C_NUM_MASTER_SLOTS*4-1:0]                      mp_mr_awregion        ;
  wire [C_NUM_MASTER_SLOTS*4-1:0]                      mp_mr_awqos           ;
  wire [C_NUM_MASTER_SLOTS*C_AXI_AWUSER_WIDTH-1:0]     mp_mr_awuser          ;
  wire [C_NUM_MASTER_SLOTS-1:0]                        mp_mr_awvalid         ;
  wire [C_NUM_MASTER_SLOTS-1:0]                        mp_mr_awready         ;
  wire [C_NUM_MASTER_SLOTS*C_AXI_ID_WIDTH-1:0]         mp_mr_wid             ;
  wire [C_NUM_MASTER_SLOTS*C_AXI_DATA_MAX_WIDTH-1:0]   mp_mr_wdata           ;
  wire [C_NUM_MASTER_SLOTS*C_AXI_DATA_MAX_WIDTH/8-1:0] mp_mr_wstrb           ;
  wire [C_NUM_MASTER_SLOTS-1:0]                        mp_mr_wlast           ;
  wire [C_NUM_MASTER_SLOTS*C_AXI_WUSER_WIDTH-1:0]      mp_mr_wuser           ;
  wire [C_NUM_MASTER_SLOTS-1:0]                        mp_mr_wvalid          ;
  wire [C_NUM_MASTER_SLOTS-1:0]                        mp_mr_wready          ;
  wire [C_NUM_MASTER_SLOTS*C_AXI_ID_WIDTH-1:0]         mp_mr_bid             ;
  wire [C_NUM_MASTER_SLOTS*2-1:0]                      mp_mr_bresp           ;
  wire [C_NUM_MASTER_SLOTS*C_AXI_BUSER_WIDTH-1:0]      mp_mr_buser           ;
  wire [C_NUM_MASTER_SLOTS-1:0]                        mp_mr_bvalid          ;
  wire [C_NUM_MASTER_SLOTS-1:0]                        mp_mr_bready          ;
  wire [C_NUM_MASTER_SLOTS*C_AXI_ID_WIDTH-1:0]         mp_mr_arid            ;
  wire [C_NUM_MASTER_SLOTS*C_AXI_ADDR_WIDTH-1:0]       mp_mr_araddr          ;
  wire [C_NUM_MASTER_SLOTS*8-1:0]                      mp_mr_arlen           ;
  wire [C_NUM_MASTER_SLOTS*3-1:0]                      mp_mr_arsize          ;
  wire [C_NUM_MASTER_SLOTS*2-1:0]                      mp_mr_arburst         ;
  wire [C_NUM_MASTER_SLOTS*2-1:0]                      mp_mr_arlock          ;
  wire [C_NUM_MASTER_SLOTS*4-1:0]                      mp_mr_arcache         ;
  wire [C_NUM_MASTER_SLOTS*3-1:0]                      mp_mr_arprot          ;
  wire [C_NUM_MASTER_SLOTS*4-1:0]                      mp_mr_arregion        ;
  wire [C_NUM_MASTER_SLOTS*4-1:0]                      mp_mr_arqos           ;
  wire [C_NUM_MASTER_SLOTS*C_AXI_ARUSER_WIDTH-1:0]     mp_mr_aruser          ;
  wire [C_NUM_MASTER_SLOTS-1:0]                        mp_mr_arvalid         ;
  wire [C_NUM_MASTER_SLOTS-1:0]                        mp_mr_arready         ;
  wire [C_NUM_MASTER_SLOTS*C_AXI_ID_WIDTH-1:0]         mp_mr_rid             ;
  wire [C_NUM_MASTER_SLOTS*C_AXI_DATA_MAX_WIDTH-1:0]   mp_mr_rdata           ;
  wire [C_NUM_MASTER_SLOTS*2-1:0]                      mp_mr_rresp           ;
  wire [C_NUM_MASTER_SLOTS-1:0]                        mp_mr_rlast           ;
  wire [C_NUM_MASTER_SLOTS*C_AXI_RUSER_WIDTH-1:0]      mp_mr_ruser           ;
  wire [C_NUM_MASTER_SLOTS-1:0]                        mp_mr_rvalid          ;
  wire [C_NUM_MASTER_SLOTS-1:0]                        mp_mr_rready          ;
                                                
  wire [C_NUM_MASTER_SLOTS*C_AXI_ID_WIDTH-1:0]         mr_mi_awid            ;
  wire [C_NUM_MASTER_SLOTS*C_AXI_ADDR_WIDTH-1:0]       mr_mi_awaddr          ;
  wire [C_NUM_MASTER_SLOTS*8-1:0]                      mr_mi_awlen           ;
  wire [C_NUM_MASTER_SLOTS*3-1:0]                      mr_mi_awsize          ;
  wire [C_NUM_MASTER_SLOTS*2-1:0]                      mr_mi_awburst         ;
  wire [C_NUM_MASTER_SLOTS*2-1:0]                      mr_mi_awlock          ;
  wire [C_NUM_MASTER_SLOTS*4-1:0]                      mr_mi_awcache         ;
  wire [C_NUM_MASTER_SLOTS*3-1:0]                      mr_mi_awprot          ;
  wire [C_NUM_MASTER_SLOTS*4-1:0]                      mr_mi_awregion        ;
  wire [C_NUM_MASTER_SLOTS*4-1:0]                      mr_mi_awqos           ;
  wire [C_NUM_MASTER_SLOTS*C_AXI_AWUSER_WIDTH-1:0]     mr_mi_awuser          ;
  wire [C_NUM_MASTER_SLOTS-1:0]                        mr_mi_awvalid         ;
  wire [C_NUM_MASTER_SLOTS-1:0]                        mr_mi_awready         ;
  wire [C_NUM_MASTER_SLOTS*C_AXI_ID_WIDTH-1:0]         mr_mi_wid             ;
  wire [C_NUM_MASTER_SLOTS*C_AXI_DATA_MAX_WIDTH-1:0]   mr_mi_wdata           ;
  wire [C_NUM_MASTER_SLOTS*C_AXI_DATA_MAX_WIDTH/8-1:0] mr_mi_wstrb           ;
  wire [C_NUM_MASTER_SLOTS-1:0]                        mr_mi_wlast           ;
  wire [C_NUM_MASTER_SLOTS*C_AXI_WUSER_WIDTH-1:0]      mr_mi_wuser           ;
  wire [C_NUM_MASTER_SLOTS-1:0]                        mr_mi_wvalid          ;
  wire [C_NUM_MASTER_SLOTS-1:0]                        mr_mi_wready          ;
  wire [C_NUM_MASTER_SLOTS*C_AXI_ID_WIDTH-1:0]         mr_mi_bid             ;
  wire [C_NUM_MASTER_SLOTS*2-1:0]                      mr_mi_bresp           ;
  wire [C_NUM_MASTER_SLOTS*C_AXI_BUSER_WIDTH-1:0]      mr_mi_buser           ;
  wire [C_NUM_MASTER_SLOTS-1:0]                        mr_mi_bvalid          ;
  wire [C_NUM_MASTER_SLOTS-1:0]                        mr_mi_bready          ;
  wire [C_NUM_MASTER_SLOTS*C_AXI_ID_WIDTH-1:0]         mr_mi_arid            ;
  wire [C_NUM_MASTER_SLOTS*C_AXI_ADDR_WIDTH-1:0]       mr_mi_araddr          ;
  wire [C_NUM_MASTER_SLOTS*8-1:0]                      mr_mi_arlen           ;
  wire [C_NUM_MASTER_SLOTS*3-1:0]                      mr_mi_arsize          ;
  wire [C_NUM_MASTER_SLOTS*2-1:0]                      mr_mi_arburst         ;
  wire [C_NUM_MASTER_SLOTS*2-1:0]                      mr_mi_arlock          ;
  wire [C_NUM_MASTER_SLOTS*4-1:0]                      mr_mi_arcache         ;
  wire [C_NUM_MASTER_SLOTS*3-1:0]                      mr_mi_arprot          ;
  wire [C_NUM_MASTER_SLOTS*4-1:0]                      mr_mi_arregion        ;
  wire [C_NUM_MASTER_SLOTS*4-1:0]                      mr_mi_arqos           ;
  wire [C_NUM_MASTER_SLOTS*C_AXI_ARUSER_WIDTH-1:0]     mr_mi_aruser          ;
  wire [C_NUM_MASTER_SLOTS-1:0]                        mr_mi_arvalid         ;
  wire [C_NUM_MASTER_SLOTS-1:0]                        mr_mi_arready         ;
  wire [C_NUM_MASTER_SLOTS*C_AXI_ID_WIDTH-1:0]         mr_mi_rid             ;
  wire [C_NUM_MASTER_SLOTS*C_AXI_DATA_MAX_WIDTH-1:0]   mr_mi_rdata           ;
  wire [C_NUM_MASTER_SLOTS*2-1:0]                      mr_mi_rresp           ;
  wire [C_NUM_MASTER_SLOTS-1:0]                        mr_mi_rlast           ;
  wire [C_NUM_MASTER_SLOTS*C_AXI_RUSER_WIDTH-1:0]      mr_mi_ruser           ;
  wire [C_NUM_MASTER_SLOTS-1:0]                        mr_mi_rvalid          ;
  wire [C_NUM_MASTER_SLOTS-1:0]                        mr_mi_rready          ;
  
  wire                                                  interconnect_aresetn_i;
  wire [C_NUM_SLAVE_SLOTS-1:0]                          s_axi_reset_out_n_i;
  wire [C_NUM_MASTER_SLOTS-1:0]                         m_axi_reset_out_n_i;
                                                                    
  wire [C_S_AXI_CTRL_ADDR_WIDTH-1:0]    cb_ctrl_awaddr            ;
  wire                                  cb_ctrl_awvalid           ;
  wire                                  cb_ctrl_awready           ;
  wire [C_S_AXI_CTRL_DATA_WIDTH-1:0]    cb_ctrl_wdata             ;
  wire                                  cb_ctrl_wvalid            ;
  wire                                  cb_ctrl_wready            ;
  wire [2-1:0]                          cb_ctrl_bresp             ;
  wire                                  cb_ctrl_bvalid            ;
  wire                                  cb_ctrl_bready            ;
  wire [C_S_AXI_CTRL_ADDR_WIDTH-1:0]    cb_ctrl_araddr            ;
  wire                                  cb_ctrl_arvalid           ;
  wire                                  cb_ctrl_arready           ;
  wire [C_S_AXI_CTRL_DATA_WIDTH-1:0]    cb_ctrl_rdata             ;
  wire [2-1:0]                          cb_ctrl_rresp             ;
  wire                                  cb_ctrl_rvalid            ;
  wire                                  cb_ctrl_rready            ;

   // Diagnostic Probe Nets from Crossbar module
   // DEBUG_A*_ERROR codes:                    
                               // Bit 0 = Invalid target address        
                               // Bit 1 = TrustZone violation           
                               // Bit 2 = AxiLite access violation      
                               // Bit 3 = R/W direction unsupported by target (SASD only)
                               // Bit 4-7 = Reserved

  wire [8-1:0]                                            aw_trans_seq;      // Write transaction sequence #, increments each M_AW transfer (modulo 256)      
  wire [C_NUM_SLAVE_SLOTS*C_MAX_DEBUG_THREADS-1:0]        aw_trans_qual;     // ID thread is qualified for write arbitration (1-hot)                          
  wire [C_NUM_SLAVE_SLOTS*C_MAX_DEBUG_THREADS*8-1:0]      aw_accept_cnt;     // Write accetance counter, per ID thread (Bit8)                                 
  wire [C_NUM_SLAVE_SLOTS*16-1:0]                         aw_active_thread;  // Last issued AWID value, when SINGLE_THREADed (Bit16)                           
  wire [C_NUM_SLAVE_SLOTS*C_MAX_DEBUG_THREADS*8-1:0]      aw_active_target;  // Last MI to be issued a write, per ID thread (Bit8)                                  
  wire [C_NUM_SLAVE_SLOTS*C_MAX_DEBUG_THREADS*8-1:0]      aw_active_region;  // Last M_REGION issued for write, per ID thread (Bit8)                                    
  wire [C_NUM_SLAVE_SLOTS*8-1:0]                          aw_error;          // Write transaction error code, per SI (Bit8)                                   
  wire [C_NUM_SLAVE_SLOTS*8-1:0]                          aw_target;         // MI currently targeted for write, per SI (Bit8)                               
  wire [(C_NUM_MASTER_SLOTS+1)*8-1:0]                     aw_issuing_cnt;    // Write issuing counter, per MI (Bit8)                                          
  wire [8-1:0]                                            aw_arb_grant;      // SI currently granted for write (Bit8)                                               
  wire [8-1:0]                                            ar_trans_seq;      // Read transaction sequence #, increments each M_AR transfer (modulo 256) 
  wire [C_NUM_SLAVE_SLOTS*C_MAX_DEBUG_THREADS-1:0]        ar_trans_qual;     // ID thread is qualified for read arbitration (1-hot)                     
  wire [C_NUM_SLAVE_SLOTS*C_MAX_DEBUG_THREADS*8-1:0]      ar_accept_cnt;     // Read accetance counter, per ID thread (Bit8)                            
  wire [C_NUM_SLAVE_SLOTS*16-1:0]                         ar_active_thread;  // Last issued ARID value, when SINGLE_THREADed (Bit16)                      
  wire [C_NUM_SLAVE_SLOTS*C_MAX_DEBUG_THREADS*8-1:0]      ar_active_target;  // Last MI to be issued a read, per ID thread (Bit8)                             
  wire [C_NUM_SLAVE_SLOTS*C_MAX_DEBUG_THREADS*8-1:0]      ar_active_region;  // Last M_REGION issued for read, per ID thread (Bit8)                               
  wire [C_NUM_SLAVE_SLOTS*8-1:0]                          ar_error;          // Read transaction error code, per SI (Bit8)                              
  wire [C_NUM_SLAVE_SLOTS*8-1:0]                          ar_target;         // MI currently targeted for read, per SI (Bit8)                          
  wire [(C_NUM_MASTER_SLOTS+1)*8-1:0]                     ar_issuing_cnt;    // Read issuing counter, per MI (Bit8)                                     
  wire [8-1:0]                                            ar_arb_grant;      // SI currently granted for read  (Bit8)                                          
  wire [(C_NUM_MASTER_SLOTS+1)*8-1:0]                     w_beat_cnt;        // Beat within burst of last W-channel transfer, per MI (Bit8)                      
  wire [(C_NUM_MASTER_SLOTS+1)*8-1:0]                     w_trans_seq;       // Write transaction sequence # of last W-channel transfer, per MI (Bit8)          
  wire [C_NUM_SLAVE_SLOTS*C_MAX_DEBUG_THREADS*8-1:0]      b_trans_seq;       // Write transaction sequence # of last B-channel transfer, per ID thread (Bit8)
  wire [C_NUM_SLAVE_SLOTS*C_MAX_DEBUG_THREADS*8-1:0]      r_beat_cnt;        // Beat within burst of last R-channel transfer, per ID thread (Bit8)              
  wire [C_NUM_SLAVE_SLOTS*C_MAX_DEBUG_THREADS*8-1:0]      r_trans_seq;       // Read transaction sequence # of last R-channel transfer, per ID thread (Bit8)    
  wire [(C_NUM_MASTER_SLOTS+1)*8-1:0]                     bid_target;        // SI targeted by current BID, per MI (Bit8)                                                                                              
  wire [(C_NUM_MASTER_SLOTS+1)-1:0]                       bid_error;         // Invalid SI targeted by current BID, per MI (1-hot)                                                                                     
  wire [(C_NUM_MASTER_SLOTS+1)*8-1:0]                     rid_target;        // SI targeted by current RID, per MI (Bit8)                                        
  wire [(C_NUM_MASTER_SLOTS+1)-1:0]                       rid_error;         // Invalid SI targeted by current RID, per MI (1-hot)                               

  assign DEBUG_AW_TRANS_SEQ     = aw_trans_seq;
  assign DEBUG_AW_TRANS_QUAL    = aw_trans_qual[C_S_AXI_DEBUG_SLOT*C_MAX_DEBUG_THREADS+:C_MAX_DEBUG_THREADS];
  assign DEBUG_AW_ACCEPT_CNT    = aw_accept_cnt[C_S_AXI_DEBUG_SLOT*C_MAX_DEBUG_THREADS*8+:C_MAX_DEBUG_THREADS*8];
  assign DEBUG_AW_ACTIVE_THREAD = aw_active_thread[C_S_AXI_DEBUG_SLOT*16+:16];
  assign DEBUG_AW_ACTIVE_TARGET = aw_active_target[C_S_AXI_DEBUG_SLOT*C_MAX_DEBUG_THREADS*8+:C_MAX_DEBUG_THREADS*8];
  assign DEBUG_AW_ACTIVE_REGION = aw_active_region[C_S_AXI_DEBUG_SLOT*C_MAX_DEBUG_THREADS*8+:C_MAX_DEBUG_THREADS*8];
  assign DEBUG_AW_ERROR         = aw_error[C_S_AXI_DEBUG_SLOT*8+:8];
  assign DEBUG_AW_TARGET        = aw_target[C_S_AXI_DEBUG_SLOT*8+:8];
  assign DEBUG_AW_ISSUING_CNT   = aw_issuing_cnt[C_M_AXI_DEBUG_SLOT*8+:8];
  assign DEBUG_AW_ARB_GRANT     = aw_arb_grant;
  assign DEBUG_AR_TRANS_SEQ     = ar_trans_seq;
  assign DEBUG_AR_TRANS_QUAL    = ar_trans_qual[C_S_AXI_DEBUG_SLOT*C_MAX_DEBUG_THREADS+:C_MAX_DEBUG_THREADS];
  assign DEBUG_AR_ACCEPT_CNT    = ar_accept_cnt[C_S_AXI_DEBUG_SLOT*C_MAX_DEBUG_THREADS*8+:C_MAX_DEBUG_THREADS*8];
  assign DEBUG_AR_ACTIVE_THREAD = ar_active_thread[C_S_AXI_DEBUG_SLOT*16+:16];
  assign DEBUG_AR_ACTIVE_TARGET = ar_active_target[C_S_AXI_DEBUG_SLOT*C_MAX_DEBUG_THREADS*8+:C_MAX_DEBUG_THREADS*8];
  assign DEBUG_AR_ACTIVE_REGION = ar_active_region[C_S_AXI_DEBUG_SLOT*C_MAX_DEBUG_THREADS*8+:C_MAX_DEBUG_THREADS*8];
  assign DEBUG_AR_ERROR         = ar_error[C_S_AXI_DEBUG_SLOT*8+:8];
  assign DEBUG_AR_TARGET        = ar_target[C_S_AXI_DEBUG_SLOT*8+:8];
  assign DEBUG_AR_ISSUING_CNT   = ar_issuing_cnt[C_M_AXI_DEBUG_SLOT*8+:8];
  assign DEBUG_AR_ARB_GRANT     = ar_arb_grant;
  assign DEBUG_W_BEAT_CNT       = w_beat_cnt[C_M_AXI_DEBUG_SLOT*8+:8];
  assign DEBUG_W_TRANS_SEQ      = w_trans_seq[C_M_AXI_DEBUG_SLOT*8+:8];
  assign DEBUG_B_TRANS_SEQ      = b_trans_seq[C_S_AXI_DEBUG_SLOT*C_MAX_DEBUG_THREADS*8+:C_MAX_DEBUG_THREADS*8];
  assign DEBUG_R_BEAT_CNT       = r_beat_cnt[C_S_AXI_DEBUG_SLOT*C_MAX_DEBUG_THREADS*8+:C_MAX_DEBUG_THREADS*8];
  assign DEBUG_R_TRANS_SEQ      = r_trans_seq[C_S_AXI_DEBUG_SLOT*C_MAX_DEBUG_THREADS*8+:C_MAX_DEBUG_THREADS*8];
  assign DEBUG_BID_TARGET       = bid_target[C_M_AXI_DEBUG_SLOT*8+:8];
  assign DEBUG_BID_ERROR        = bid_error[C_M_AXI_DEBUG_SLOT];
  assign DEBUG_RID_TARGET       = rid_target[C_M_AXI_DEBUG_SLOT*8+:8];
  assign DEBUG_RID_ERROR        = rid_error[C_M_AXI_DEBUG_SLOT];

  assign DEBUG_SR_SC_ARADDR        =  sr_sc_araddr[(C_S_AXI_DEBUG_SLOT*C_AXI_ADDR_WIDTH)+:C_AXI_ADDR_WIDTH];
  assign DEBUG_SR_SC_ARADDRCONTROL = {
                                      sr_sc_arid[(C_S_AXI_DEBUG_SLOT*C_AXI_ID_WIDTH)+:C_AXI_ID_WIDTH],
                                      sr_sc_arprot[(C_S_AXI_DEBUG_SLOT*3)+:3],
                                      sr_sc_arcache[(C_S_AXI_DEBUG_SLOT*4)+:4],
                                      sr_sc_arlock[(C_S_AXI_DEBUG_SLOT*1)+:1],
                                      sr_sc_arburst[(C_S_AXI_DEBUG_SLOT*2)+:2],
                                      sr_sc_arsize[(C_S_AXI_DEBUG_SLOT*3)+:3],
                                      sr_sc_arlen[(C_S_AXI_DEBUG_SLOT*8)+:8],
                                      sr_sc_arready[(C_S_AXI_DEBUG_SLOT*1)+:1],
                                      sr_sc_arvalid[(C_S_AXI_DEBUG_SLOT*1)+:1]
                                     };
  assign DEBUG_SR_SC_AWADDR        =  sr_sc_awaddr[(C_S_AXI_DEBUG_SLOT*C_AXI_ADDR_WIDTH)+:C_AXI_ADDR_WIDTH];
  assign DEBUG_SR_SC_AWADDRCONTROL = {
                                      sr_sc_awid[(C_S_AXI_DEBUG_SLOT*C_AXI_ID_WIDTH)+:C_AXI_ID_WIDTH],
                                      sr_sc_awprot[(C_S_AXI_DEBUG_SLOT*3)+:3],
                                      sr_sc_awcache[(C_S_AXI_DEBUG_SLOT*4)+:4],
                                      sr_sc_awlock[(C_S_AXI_DEBUG_SLOT*1)+:1],
                                      sr_sc_awburst[(C_S_AXI_DEBUG_SLOT*2)+:2],
                                      sr_sc_awsize[(C_S_AXI_DEBUG_SLOT*3)+:3],
                                      sr_sc_awlen[(C_S_AXI_DEBUG_SLOT*8)+:8],
                                      sr_sc_awready[(C_S_AXI_DEBUG_SLOT*1)+:1],
                                      sr_sc_awvalid[(C_S_AXI_DEBUG_SLOT*1)+:1]
                                     };
  assign DEBUG_SR_SC_BRESP         = {
                                      sr_sc_bid[(C_S_AXI_DEBUG_SLOT*C_AXI_ID_WIDTH)+:C_AXI_ID_WIDTH],
                                      sr_sc_bresp[(C_S_AXI_DEBUG_SLOT*2)+:2],
                                      sr_sc_bready[(C_S_AXI_DEBUG_SLOT*1)+:1],
                                      sr_sc_bvalid[(C_S_AXI_DEBUG_SLOT*1)+:1]
                                     };
  assign DEBUG_SR_SC_RDATA         =  sr_sc_rdata[(C_S_AXI_DEBUG_SLOT*C_AXI_DATA_MAX_WIDTH)+:C_AXI_DATA_MAX_WIDTH];
  assign DEBUG_SR_SC_RDATACONTROL  = {
                                      sr_sc_rid[(C_S_AXI_DEBUG_SLOT*C_AXI_ID_WIDTH)+:C_AXI_ID_WIDTH],
                                      sr_sc_rresp[(C_S_AXI_DEBUG_SLOT*2)+:2],
                                      sr_sc_rlast[(C_S_AXI_DEBUG_SLOT*1)+:1],
                                      sr_sc_rready[(C_S_AXI_DEBUG_SLOT*1)+:1],
                                      sr_sc_rvalid[(C_S_AXI_DEBUG_SLOT*1)+:1]
                                     };
  assign DEBUG_SR_SC_WDATA         =  sr_sc_wdata[(C_S_AXI_DEBUG_SLOT*C_AXI_DATA_MAX_WIDTH)+:C_AXI_DATA_MAX_WIDTH];
  assign DEBUG_SR_SC_WDATACONTROL  = {
                                      sr_sc_wstrb[(C_S_AXI_DEBUG_SLOT*C_AXI_DATA_MAX_WIDTH/8)+:C_AXI_DATA_MAX_WIDTH/8],
                                      sr_sc_wlast[(C_S_AXI_DEBUG_SLOT*1)+:1],
                                      sr_sc_wready[(C_S_AXI_DEBUG_SLOT*1)+:1],
                                      sr_sc_wvalid[(C_S_AXI_DEBUG_SLOT*1)+:1]
                                     };

  assign DEBUG_SC_SF_ARADDR        =  sc_sf_araddr[(C_S_AXI_DEBUG_SLOT*C_AXI_ADDR_WIDTH)+:C_AXI_ADDR_WIDTH];
  assign DEBUG_SC_SF_ARADDRCONTROL = {
                                      sc_sf_arid[(C_S_AXI_DEBUG_SLOT*C_AXI_ID_WIDTH)+:C_AXI_ID_WIDTH],
                                      sc_sf_arprot[(C_S_AXI_DEBUG_SLOT*3)+:3],
                                      sc_sf_arcache[(C_S_AXI_DEBUG_SLOT*4)+:4],
                                      sc_sf_arlock[(C_S_AXI_DEBUG_SLOT*1)+:1],
                                      sc_sf_arburst[(C_S_AXI_DEBUG_SLOT*2)+:2],
                                      sc_sf_arsize[(C_S_AXI_DEBUG_SLOT*3)+:3],
                                      sc_sf_arlen[(C_S_AXI_DEBUG_SLOT*8)+:8],
                                      sc_sf_arready[(C_S_AXI_DEBUG_SLOT*1)+:1],
                                      sc_sf_arvalid[(C_S_AXI_DEBUG_SLOT*1)+:1]
                                     };
  assign DEBUG_SC_SF_AWADDR        =  sc_sf_awaddr[(C_S_AXI_DEBUG_SLOT*C_AXI_ADDR_WIDTH)+:C_AXI_ADDR_WIDTH];
  assign DEBUG_SC_SF_AWADDRCONTROL = {
                                      sc_sf_awid[(C_S_AXI_DEBUG_SLOT*C_AXI_ID_WIDTH)+:C_AXI_ID_WIDTH],
                                      sc_sf_awprot[(C_S_AXI_DEBUG_SLOT*3)+:3],
                                      sc_sf_awcache[(C_S_AXI_DEBUG_SLOT*4)+:4],
                                      sc_sf_awlock[(C_S_AXI_DEBUG_SLOT*1)+:1],
                                      sc_sf_awburst[(C_S_AXI_DEBUG_SLOT*2)+:2],
                                      sc_sf_awsize[(C_S_AXI_DEBUG_SLOT*3)+:3],
                                      sc_sf_awlen[(C_S_AXI_DEBUG_SLOT*8)+:8],
                                      sc_sf_awready[(C_S_AXI_DEBUG_SLOT*1)+:1],
                                      sc_sf_awvalid[(C_S_AXI_DEBUG_SLOT*1)+:1]
                                     };
  assign DEBUG_SC_SF_BRESP         = {
                                      sc_sf_bid[(C_S_AXI_DEBUG_SLOT*C_AXI_ID_WIDTH)+:C_AXI_ID_WIDTH],
                                      sc_sf_bresp[(C_S_AXI_DEBUG_SLOT*2)+:2],
                                      sc_sf_bready[(C_S_AXI_DEBUG_SLOT*1)+:1],
                                      sc_sf_bvalid[(C_S_AXI_DEBUG_SLOT*1)+:1]
                                     };
  assign DEBUG_SC_SF_RDATA         =  sc_sf_rdata[(C_S_AXI_DEBUG_SLOT*C_AXI_DATA_MAX_WIDTH)+:C_AXI_DATA_MAX_WIDTH];
  assign DEBUG_SC_SF_RDATACONTROL  = {
                                      sc_sf_rid[(C_S_AXI_DEBUG_SLOT*C_AXI_ID_WIDTH)+:C_AXI_ID_WIDTH],
                                      sc_sf_rresp[(C_S_AXI_DEBUG_SLOT*2)+:2],
                                      sc_sf_rlast[(C_S_AXI_DEBUG_SLOT*1)+:1],
                                      sc_sf_rready[(C_S_AXI_DEBUG_SLOT*1)+:1],
                                      sc_sf_rvalid[(C_S_AXI_DEBUG_SLOT*1)+:1]
                                     };
  assign DEBUG_SC_SF_WDATA         =  sc_sf_wdata[(C_S_AXI_DEBUG_SLOT*C_AXI_DATA_MAX_WIDTH)+:C_AXI_DATA_MAX_WIDTH];
  assign DEBUG_SC_SF_WDATACONTROL  = {
                                      sc_sf_wstrb[(C_S_AXI_DEBUG_SLOT*C_AXI_DATA_MAX_WIDTH/8)+:C_AXI_DATA_MAX_WIDTH/8],
                                      sc_sf_wlast[(C_S_AXI_DEBUG_SLOT*1)+:1],
                                      sc_sf_wready[(C_S_AXI_DEBUG_SLOT*1)+:1],
                                      sc_sf_wvalid[(C_S_AXI_DEBUG_SLOT*1)+:1]
                                     };

  assign DEBUG_SF_CB_ARADDR        =  sf_cb_araddr[(C_S_AXI_DEBUG_SLOT*C_AXI_ADDR_WIDTH)+:C_AXI_ADDR_WIDTH];
  assign DEBUG_SF_CB_ARADDRCONTROL = {
                                      sf_cb_arid[(C_S_AXI_DEBUG_SLOT*C_AXI_ID_WIDTH)+:C_AXI_ID_WIDTH],
                                      sf_cb_arprot[(C_S_AXI_DEBUG_SLOT*3)+:3],
                                      sf_cb_arcache[(C_S_AXI_DEBUG_SLOT*4)+:4],
                                      sf_cb_arlock[(C_S_AXI_DEBUG_SLOT*1)+:1],
                                      sf_cb_arburst[(C_S_AXI_DEBUG_SLOT*2)+:2],
                                      sf_cb_arsize[(C_S_AXI_DEBUG_SLOT*3)+:3],
                                      sf_cb_arlen[(C_S_AXI_DEBUG_SLOT*8)+:8],
                                      sf_cb_arready[(C_S_AXI_DEBUG_SLOT*1)+:1],
                                      sf_cb_arvalid[(C_S_AXI_DEBUG_SLOT*1)+:1]
                                     };
  assign DEBUG_SF_CB_AWADDR        =  sf_cb_awaddr[(C_S_AXI_DEBUG_SLOT*C_AXI_ADDR_WIDTH)+:C_AXI_ADDR_WIDTH];
  assign DEBUG_SF_CB_AWADDRCONTROL = {
                                      sf_cb_awid[(C_S_AXI_DEBUG_SLOT*C_AXI_ID_WIDTH)+:C_AXI_ID_WIDTH],
                                      sf_cb_awprot[(C_S_AXI_DEBUG_SLOT*3)+:3],
                                      sf_cb_awcache[(C_S_AXI_DEBUG_SLOT*4)+:4],
                                      sf_cb_awlock[(C_S_AXI_DEBUG_SLOT*1)+:1],
                                      sf_cb_awburst[(C_S_AXI_DEBUG_SLOT*2)+:2],
                                      sf_cb_awsize[(C_S_AXI_DEBUG_SLOT*3)+:3],
                                      sf_cb_awlen[(C_S_AXI_DEBUG_SLOT*8)+:8],
                                      sf_cb_awready[(C_S_AXI_DEBUG_SLOT*1)+:1],
                                      sf_cb_awvalid[(C_S_AXI_DEBUG_SLOT*1)+:1]
                                     };
  assign DEBUG_SF_CB_BRESP         = {
                                      sf_cb_bid[(C_S_AXI_DEBUG_SLOT*C_AXI_ID_WIDTH)+:C_AXI_ID_WIDTH],
                                      sf_cb_bresp[(C_S_AXI_DEBUG_SLOT*2)+:2],
                                      sf_cb_bready[(C_S_AXI_DEBUG_SLOT*1)+:1],
                                      sf_cb_bvalid[(C_S_AXI_DEBUG_SLOT*1)+:1]
                                     };
  assign DEBUG_SF_CB_RDATA         =  sf_cb_rdata[(C_S_AXI_DEBUG_SLOT*C_AXI_DATA_MAX_WIDTH)+:C_AXI_DATA_MAX_WIDTH];
  assign DEBUG_SF_CB_RDATACONTROL  = {
                                      sf_cb_rid[(C_S_AXI_DEBUG_SLOT*C_AXI_ID_WIDTH)+:C_AXI_ID_WIDTH],
                                      sf_cb_rresp[(C_S_AXI_DEBUG_SLOT*2)+:2],
                                      sf_cb_rlast[(C_S_AXI_DEBUG_SLOT*1)+:1],
                                      sf_cb_rready[(C_S_AXI_DEBUG_SLOT*1)+:1],
                                      sf_cb_rvalid[(C_S_AXI_DEBUG_SLOT*1)+:1]
                                     };
  assign DEBUG_SF_CB_WDATA         =  sf_cb_wdata[(C_S_AXI_DEBUG_SLOT*C_AXI_DATA_MAX_WIDTH)+:C_AXI_DATA_MAX_WIDTH];
  assign DEBUG_SF_CB_WDATACONTROL  = {
                                      sf_cb_wstrb[(C_S_AXI_DEBUG_SLOT*C_AXI_DATA_MAX_WIDTH/8)+:C_AXI_DATA_MAX_WIDTH/8],
                                      sf_cb_wlast[(C_S_AXI_DEBUG_SLOT*1)+:1],
                                      sf_cb_wready[(C_S_AXI_DEBUG_SLOT*1)+:1],
                                      sf_cb_wvalid[(C_S_AXI_DEBUG_SLOT*1)+:1]
                                     };

  assign DEBUG_CB_MF_ARADDR        =  cb_mf_araddr[(C_M_AXI_DEBUG_SLOT*C_AXI_ADDR_WIDTH)+:C_AXI_ADDR_WIDTH];
  assign DEBUG_CB_MF_ARADDRCONTROL = {
                                      cb_mf_arid[(C_M_AXI_DEBUG_SLOT*C_AXI_ID_WIDTH)+:C_AXI_ID_WIDTH],
                                      cb_mf_arprot[(C_M_AXI_DEBUG_SLOT*3)+:3],
                                      cb_mf_arcache[(C_M_AXI_DEBUG_SLOT*4)+:4],
                                      cb_mf_arlock[(C_M_AXI_DEBUG_SLOT*1)+:1],
                                      cb_mf_arburst[(C_M_AXI_DEBUG_SLOT*2)+:2],
                                      cb_mf_arsize[(C_M_AXI_DEBUG_SLOT*3)+:3],
                                      cb_mf_arlen[(C_M_AXI_DEBUG_SLOT*8)+:8],
                                      cb_mf_arready[(C_M_AXI_DEBUG_SLOT*1)+:1],
                                      cb_mf_arvalid[(C_M_AXI_DEBUG_SLOT*1)+:1]
                                     };
  assign DEBUG_CB_MF_AWADDR        =  cb_mf_awaddr[(C_M_AXI_DEBUG_SLOT*C_AXI_ADDR_WIDTH)+:C_AXI_ADDR_WIDTH];
  assign DEBUG_CB_MF_AWADDRCONTROL = {
                                      cb_mf_awid[(C_M_AXI_DEBUG_SLOT*C_AXI_ID_WIDTH)+:C_AXI_ID_WIDTH],
                                      cb_mf_awprot[(C_M_AXI_DEBUG_SLOT*3)+:3],
                                      cb_mf_awcache[(C_M_AXI_DEBUG_SLOT*4)+:4],
                                      cb_mf_awlock[(C_M_AXI_DEBUG_SLOT*1)+:1],
                                      cb_mf_awburst[(C_M_AXI_DEBUG_SLOT*2)+:2],
                                      cb_mf_awsize[(C_M_AXI_DEBUG_SLOT*3)+:3],
                                      cb_mf_awlen[(C_M_AXI_DEBUG_SLOT*8)+:8],
                                      cb_mf_awready[(C_M_AXI_DEBUG_SLOT*1)+:1],
                                      cb_mf_awvalid[(C_M_AXI_DEBUG_SLOT*1)+:1]
                                     };
  assign DEBUG_CB_MF_BRESP         = {
                                      cb_mf_bid[(C_M_AXI_DEBUG_SLOT*C_AXI_ID_WIDTH)+:C_AXI_ID_WIDTH],
                                      cb_mf_bresp[(C_M_AXI_DEBUG_SLOT*2)+:2],
                                      cb_mf_bready[(C_M_AXI_DEBUG_SLOT*1)+:1],
                                      cb_mf_bvalid[(C_M_AXI_DEBUG_SLOT*1)+:1]
                                     };
  assign DEBUG_CB_MF_RDATA         =  cb_mf_rdata[(C_M_AXI_DEBUG_SLOT*C_AXI_DATA_MAX_WIDTH)+:C_AXI_DATA_MAX_WIDTH];
  assign DEBUG_CB_MF_RDATACONTROL  = {
                                      cb_mf_rid[(C_M_AXI_DEBUG_SLOT*C_AXI_ID_WIDTH)+:C_AXI_ID_WIDTH],
                                      cb_mf_rresp[(C_M_AXI_DEBUG_SLOT*2)+:2],
                                      cb_mf_rlast[(C_M_AXI_DEBUG_SLOT*1)+:1],
                                      cb_mf_rready[(C_M_AXI_DEBUG_SLOT*1)+:1],
                                      cb_mf_rvalid[(C_M_AXI_DEBUG_SLOT*1)+:1]
                                     };
  assign DEBUG_CB_MF_WDATA         =  cb_mf_wdata[(C_M_AXI_DEBUG_SLOT*C_AXI_DATA_MAX_WIDTH)+:C_AXI_DATA_MAX_WIDTH];
  assign DEBUG_CB_MF_WDATACONTROL  = {
                                      cb_mf_wstrb[(C_M_AXI_DEBUG_SLOT*C_AXI_DATA_MAX_WIDTH/8)+:C_AXI_DATA_MAX_WIDTH/8],
                                      cb_mf_wlast[(C_M_AXI_DEBUG_SLOT*1)+:1],
                                      cb_mf_wready[(C_M_AXI_DEBUG_SLOT*1)+:1],
                                      cb_mf_wvalid[(C_M_AXI_DEBUG_SLOT*1)+:1]
                                     };

  assign DEBUG_MF_MC_ARADDR        =  mf_mc_araddr[(C_M_AXI_DEBUG_SLOT*C_AXI_ADDR_WIDTH)+:C_AXI_ADDR_WIDTH];
  assign DEBUG_MF_MC_ARADDRCONTROL = {
                                      mf_mc_arid[(C_M_AXI_DEBUG_SLOT*C_AXI_ID_WIDTH)+:C_AXI_ID_WIDTH],
                                      mf_mc_arprot[(C_M_AXI_DEBUG_SLOT*3)+:3],
                                      mf_mc_arcache[(C_M_AXI_DEBUG_SLOT*4)+:4],
                                      mf_mc_arlock[(C_M_AXI_DEBUG_SLOT*1)+:1],
                                      mf_mc_arburst[(C_M_AXI_DEBUG_SLOT*2)+:2],
                                      mf_mc_arsize[(C_M_AXI_DEBUG_SLOT*3)+:3],
                                      mf_mc_arlen[(C_M_AXI_DEBUG_SLOT*8)+:8],
                                      mf_mc_arready[(C_M_AXI_DEBUG_SLOT*1)+:1],
                                      mf_mc_arvalid[(C_M_AXI_DEBUG_SLOT*1)+:1]
                                     };
  assign DEBUG_MF_MC_AWADDR        =  mf_mc_awaddr[(C_M_AXI_DEBUG_SLOT*C_AXI_ADDR_WIDTH)+:C_AXI_ADDR_WIDTH];
  assign DEBUG_MF_MC_AWADDRCONTROL = {
                                      mf_mc_awid[(C_M_AXI_DEBUG_SLOT*C_AXI_ID_WIDTH)+:C_AXI_ID_WIDTH],
                                      mf_mc_awprot[(C_M_AXI_DEBUG_SLOT*3)+:3],
                                      mf_mc_awcache[(C_M_AXI_DEBUG_SLOT*4)+:4],
                                      mf_mc_awlock[(C_M_AXI_DEBUG_SLOT*1)+:1],
                                      mf_mc_awburst[(C_M_AXI_DEBUG_SLOT*2)+:2],
                                      mf_mc_awsize[(C_M_AXI_DEBUG_SLOT*3)+:3],
                                      mf_mc_awlen[(C_M_AXI_DEBUG_SLOT*8)+:8],
                                      mf_mc_awready[(C_M_AXI_DEBUG_SLOT*1)+:1],
                                      mf_mc_awvalid[(C_M_AXI_DEBUG_SLOT*1)+:1]
                                     };
  assign DEBUG_MF_MC_BRESP         = {
                                      mf_mc_bid[(C_M_AXI_DEBUG_SLOT*C_AXI_ID_WIDTH)+:C_AXI_ID_WIDTH],
                                      mf_mc_bresp[(C_M_AXI_DEBUG_SLOT*2)+:2],
                                      mf_mc_bready[(C_M_AXI_DEBUG_SLOT*1)+:1],
                                      mf_mc_bvalid[(C_M_AXI_DEBUG_SLOT*1)+:1]
                                     };
  assign DEBUG_MF_MC_RDATA         =  mf_mc_rdata[(C_M_AXI_DEBUG_SLOT*C_AXI_DATA_MAX_WIDTH)+:C_AXI_DATA_MAX_WIDTH];
  assign DEBUG_MF_MC_RDATACONTROL  = {
                                      mf_mc_rid[(C_M_AXI_DEBUG_SLOT*C_AXI_ID_WIDTH)+:C_AXI_ID_WIDTH],
                                      mf_mc_rresp[(C_M_AXI_DEBUG_SLOT*2)+:2],
                                      mf_mc_rlast[(C_M_AXI_DEBUG_SLOT*1)+:1],
                                      mf_mc_rready[(C_M_AXI_DEBUG_SLOT*1)+:1],
                                      mf_mc_rvalid[(C_M_AXI_DEBUG_SLOT*1)+:1]
                                     };
  assign DEBUG_MF_MC_WDATA         =  mf_mc_wdata[(C_M_AXI_DEBUG_SLOT*C_AXI_DATA_MAX_WIDTH)+:C_AXI_DATA_MAX_WIDTH];
  assign DEBUG_MF_MC_WDATACONTROL  = {
                                      mf_mc_wstrb[(C_M_AXI_DEBUG_SLOT*C_AXI_DATA_MAX_WIDTH/8)+:C_AXI_DATA_MAX_WIDTH/8],
                                      mf_mc_wlast[(C_M_AXI_DEBUG_SLOT*1)+:1],
                                      mf_mc_wready[(C_M_AXI_DEBUG_SLOT*1)+:1],
                                      mf_mc_wvalid[(C_M_AXI_DEBUG_SLOT*1)+:1]
                                     };

  assign DEBUG_MC_MP_ARADDR        =  mc_mp_araddr[(C_M_AXI_DEBUG_SLOT*C_AXI_ADDR_WIDTH)+:C_AXI_ADDR_WIDTH];
  assign DEBUG_MC_MP_ARADDRCONTROL = {
                                      mc_mp_arid[(C_M_AXI_DEBUG_SLOT*C_AXI_ID_WIDTH)+:C_AXI_ID_WIDTH],
                                      mc_mp_arprot[(C_M_AXI_DEBUG_SLOT*3)+:3],
                                      mc_mp_arcache[(C_M_AXI_DEBUG_SLOT*4)+:4],
                                      mc_mp_arlock[(C_M_AXI_DEBUG_SLOT*1)+:1],
                                      mc_mp_arburst[(C_M_AXI_DEBUG_SLOT*2)+:2],
                                      mc_mp_arsize[(C_M_AXI_DEBUG_SLOT*3)+:3],
                                      mc_mp_arlen[(C_M_AXI_DEBUG_SLOT*8)+:8],
                                      mc_mp_arready[(C_M_AXI_DEBUG_SLOT*1)+:1],
                                      mc_mp_arvalid[(C_M_AXI_DEBUG_SLOT*1)+:1]
                                     };
  assign DEBUG_MC_MP_AWADDR        =  mc_mp_awaddr[(C_M_AXI_DEBUG_SLOT*C_AXI_ADDR_WIDTH)+:C_AXI_ADDR_WIDTH];
  assign DEBUG_MC_MP_AWADDRCONTROL = {
                                      mc_mp_awid[(C_M_AXI_DEBUG_SLOT*C_AXI_ID_WIDTH)+:C_AXI_ID_WIDTH],
                                      mc_mp_awprot[(C_M_AXI_DEBUG_SLOT*3)+:3],
                                      mc_mp_awcache[(C_M_AXI_DEBUG_SLOT*4)+:4],
                                      mc_mp_awlock[(C_M_AXI_DEBUG_SLOT*1)+:1],
                                      mc_mp_awburst[(C_M_AXI_DEBUG_SLOT*2)+:2],
                                      mc_mp_awsize[(C_M_AXI_DEBUG_SLOT*3)+:3],
                                      mc_mp_awlen[(C_M_AXI_DEBUG_SLOT*8)+:8],
                                      mc_mp_awready[(C_M_AXI_DEBUG_SLOT*1)+:1],
                                      mc_mp_awvalid[(C_M_AXI_DEBUG_SLOT*1)+:1]
                                     };
  assign DEBUG_MC_MP_BRESP         = {
                                      mc_mp_bid[(C_M_AXI_DEBUG_SLOT*C_AXI_ID_WIDTH)+:C_AXI_ID_WIDTH],
                                      mc_mp_bresp[(C_M_AXI_DEBUG_SLOT*2)+:2],
                                      mc_mp_bready[(C_M_AXI_DEBUG_SLOT*1)+:1],
                                      mc_mp_bvalid[(C_M_AXI_DEBUG_SLOT*1)+:1]
                                     };
  assign DEBUG_MC_MP_RDATA         =  mc_mp_rdata[(C_M_AXI_DEBUG_SLOT*C_AXI_DATA_MAX_WIDTH)+:C_AXI_DATA_MAX_WIDTH];
  assign DEBUG_MC_MP_RDATACONTROL  = {
                                      mc_mp_rid[(C_M_AXI_DEBUG_SLOT*C_AXI_ID_WIDTH)+:C_AXI_ID_WIDTH],
                                      mc_mp_rresp[(C_M_AXI_DEBUG_SLOT*2)+:2],
                                      mc_mp_rlast[(C_M_AXI_DEBUG_SLOT*1)+:1],
                                      mc_mp_rready[(C_M_AXI_DEBUG_SLOT*1)+:1],
                                      mc_mp_rvalid[(C_M_AXI_DEBUG_SLOT*1)+:1]
                                     };
  assign DEBUG_MC_MP_WDATA         =  mc_mp_wdata[(C_M_AXI_DEBUG_SLOT*C_AXI_DATA_MAX_WIDTH)+:C_AXI_DATA_MAX_WIDTH];
  assign DEBUG_MC_MP_WDATACONTROL  = {
                                      mc_mp_wstrb[(C_M_AXI_DEBUG_SLOT*C_AXI_DATA_MAX_WIDTH/8)+:C_AXI_DATA_MAX_WIDTH/8],
                                      mc_mp_wlast[(C_M_AXI_DEBUG_SLOT*1)+:1],
                                      mc_mp_wready[(C_M_AXI_DEBUG_SLOT*1)+:1],
                                      mc_mp_wvalid[(C_M_AXI_DEBUG_SLOT*1)+:1]
                                     };

  assign DEBUG_MP_MR_ARADDR        =  mp_mr_araddr[(C_M_AXI_DEBUG_SLOT*C_AXI_ADDR_WIDTH)+:C_AXI_ADDR_WIDTH];
  assign DEBUG_MP_MR_ARADDRCONTROL = {
                                      mp_mr_arid[(C_M_AXI_DEBUG_SLOT*C_AXI_ID_WIDTH)+:C_AXI_ID_WIDTH],
                                      mp_mr_arprot[(C_M_AXI_DEBUG_SLOT*3)+:3],
                                      mp_mr_arcache[(C_M_AXI_DEBUG_SLOT*4)+:4],
                                      mp_mr_arlock[(C_M_AXI_DEBUG_SLOT*1)+:1],
                                      mp_mr_arburst[(C_M_AXI_DEBUG_SLOT*2)+:2],
                                      mp_mr_arsize[(C_M_AXI_DEBUG_SLOT*3)+:3],
                                      mp_mr_arlen[(C_M_AXI_DEBUG_SLOT*8)+:8],
                                      mp_mr_arready[(C_M_AXI_DEBUG_SLOT*1)+:1],
                                      mp_mr_arvalid[(C_M_AXI_DEBUG_SLOT*1)+:1]
                                     };
  assign DEBUG_MP_MR_AWADDR        =  mp_mr_awaddr[(C_M_AXI_DEBUG_SLOT*C_AXI_ADDR_WIDTH)+:C_AXI_ADDR_WIDTH];
  assign DEBUG_MP_MR_AWADDRCONTROL = {
                                      mp_mr_awid[(C_M_AXI_DEBUG_SLOT*C_AXI_ID_WIDTH)+:C_AXI_ID_WIDTH],
                                      mp_mr_awprot[(C_M_AXI_DEBUG_SLOT*3)+:3],
                                      mp_mr_awcache[(C_M_AXI_DEBUG_SLOT*4)+:4],
                                      mp_mr_awlock[(C_M_AXI_DEBUG_SLOT*1)+:1],
                                      mp_mr_awburst[(C_M_AXI_DEBUG_SLOT*2)+:2],
                                      mp_mr_awsize[(C_M_AXI_DEBUG_SLOT*3)+:3],
                                      mp_mr_awlen[(C_M_AXI_DEBUG_SLOT*8)+:8],
                                      mp_mr_awready[(C_M_AXI_DEBUG_SLOT*1)+:1],
                                      mp_mr_awvalid[(C_M_AXI_DEBUG_SLOT*1)+:1]
                                     };
  assign DEBUG_MP_MR_BRESP         = {
                                      mp_mr_bid[(C_M_AXI_DEBUG_SLOT*C_AXI_ID_WIDTH)+:C_AXI_ID_WIDTH],
                                      mp_mr_bresp[(C_M_AXI_DEBUG_SLOT*2)+:2],
                                      mp_mr_bready[(C_M_AXI_DEBUG_SLOT*1)+:1],
                                      mp_mr_bvalid[(C_M_AXI_DEBUG_SLOT*1)+:1]
                                     };
  assign DEBUG_MP_MR_RDATA         =  mp_mr_rdata[(C_M_AXI_DEBUG_SLOT*C_AXI_DATA_MAX_WIDTH)+:C_AXI_DATA_MAX_WIDTH];
  assign DEBUG_MP_MR_RDATACONTROL  = {
                                      mp_mr_rid[(C_M_AXI_DEBUG_SLOT*C_AXI_ID_WIDTH)+:C_AXI_ID_WIDTH],
                                      mp_mr_rresp[(C_M_AXI_DEBUG_SLOT*2)+:2],
                                      mp_mr_rlast[(C_M_AXI_DEBUG_SLOT*1)+:1],
                                      mp_mr_rready[(C_M_AXI_DEBUG_SLOT*1)+:1],
                                      mp_mr_rvalid[(C_M_AXI_DEBUG_SLOT*1)+:1]
                                     };
  assign DEBUG_MP_MR_WDATA         =  mp_mr_wdata[(C_M_AXI_DEBUG_SLOT*C_AXI_DATA_MAX_WIDTH)+:C_AXI_DATA_MAX_WIDTH];
  assign DEBUG_MP_MR_WDATACONTROL  = {
                                      mp_mr_wstrb[(C_M_AXI_DEBUG_SLOT*C_AXI_DATA_MAX_WIDTH/8)+:C_AXI_DATA_MAX_WIDTH/8],
                                      mp_mr_wlast[(C_M_AXI_DEBUG_SLOT*1)+:1],
                                      mp_mr_wready[(C_M_AXI_DEBUG_SLOT*1)+:1],
                                      mp_mr_wvalid[(C_M_AXI_DEBUG_SLOT*1)+:1]
                                     };

  assign INTERCONNECT_ARESET_OUT_N = interconnect_aresetn_i;

  localparam [`P_MAX_M*32-1:0] P_M_AXI_ID_WIDTH = {`P_MAX_M{f_bit32_qual(C_AXI_ID_WIDTH, 1, 0)}};
  localparam [`P_MAX_S*32-1:0] P_S_AXI_ID_WIDTH_MAX1 = f_thread_id_width(0);
  localparam [`P_MAX_S*64-1:0] P_S_AXI_BASE_ID = f_base_id(0);
  localparam [`P_MAX_S*64-1:0] P_S_AXI_HIGH_ID = f_high_id(0);
  localparam [31:0]  P_AXI4 = 32'h0;
  localparam [31:0]  P_AXI3 = 32'h1;
  localparam [31:0]  P_AXILITE = 32'h2;
  localparam [2:0]   P_AXILITE_SIZE = 3'b010;
  localparam [1:0]   P_INCR = 2'b01;
  localparam integer P_RANGE_CHECK = (C_RANGE_CHECK == 0) ? 0 : 1;  // Re-code 2 -> 1
  localparam integer P_ADDR_DECODE = (P_RANGE_CHECK || (C_NUM_MASTER_SLOTS>1) || f_multi_addr_ranges(0)) ? 1 : 0;
  localparam integer P_IGNORE_RID = ((C_INTERCONNECT_CONNECTIVITY_MODE==0) && ((C_NUM_MASTER_SLOTS>1) || (C_NUM_SLAVE_SLOTS>1) || (P_ADDR_DECODE!=0))) ? 1 : 0;
  localparam integer P_AXI3_BYPASS = (C_NUM_MASTER_SLOTS == 1) && (C_NUM_SLAVE_SLOTS == 1) && (P_ADDR_DECODE == 0) && 
             (C_S_AXI_PROTOCOL[31:0] == P_AXI3) && (C_M_AXI_PROTOCOL[31:0] == P_AXI3) &&
             (C_S_AXI_DATA_WIDTH[31:0] == C_M_AXI_DATA_WIDTH[31:0]) && (C_S_AXI_DATA_WIDTH[31:0] == C_INTERCONNECT_DATA_WIDTH) &&
             (C_S_AXI_ACLK_RATIO[31:0] == C_M_AXI_ACLK_RATIO[31:0]) && (C_S_AXI_ACLK_RATIO[31:0] == C_INTERCONNECT_ACLK_RATIO) &&
             (C_S_AXI_IS_ACLK_ASYNC[0] == 1'b0) && (C_M_AXI_IS_ACLK_ASYNC[0] == 1'b0) &&
             (C_S_AXI_WRITE_FIFO_DEPTH[31:0] == 0) && (C_S_AXI_READ_FIFO_DEPTH[31:0] == 0) && (C_M_AXI_WRITE_FIFO_DEPTH[31:0] == 0) && (C_M_AXI_READ_FIFO_DEPTH[31:0] == 0) && 
             (C_S_AXI_AW_REGISTER[31:0] == 0) && (C_S_AXI_W_REGISTER[31:0] == 0) && (C_S_AXI_B_REGISTER[31:0] == 0) && (C_S_AXI_AR_REGISTER[31:0] == 0) && (C_S_AXI_R_REGISTER[31:0] == 0) && 
             (C_M_AXI_AW_REGISTER[31:0] == 0) && (C_M_AXI_W_REGISTER[31:0] == 0) && (C_M_AXI_B_REGISTER[31:0] == 0) && (C_M_AXI_AR_REGISTER[31:0] == 0) && (C_M_AXI_R_REGISTER[31:0] == 0);
  localparam P_FAMILY = ((C_BASEFAMILY == "virtex7") || (C_BASEFAMILY == "kintex7") || (C_BASEFAMILY == "artix7") || (C_BASEFAMILY == "zynq")) ? C_BASEFAMILY : "rtl";
  
  function integer f_ceil_log2
    (
     input integer x
     );
    integer acc;
    begin
      acc=0;
      while ((2**acc) < x)
        acc = acc + 1;
      f_ceil_log2 = acc;
    end
  endfunction

  function [31:0] f_bit32_qual(
  // Cast as bit32. Replace with null_value if not qualified.
      input [31:0] arg,
      input        qual, // boolean
      input [31:0] null_val
    );
    begin
      f_bit32_qual = qual ? arg : null_val;
    end
  endfunction

  // Convert C_S_AXI_BASE_ID vector from Bit32 to Bit64 format
  function [`P_MAX_S*64-1:0] f_base_id
    (input null_arg);
    integer si;
    reg [`P_MAX_S*64-1:0] result;
    begin
      result = 0;
      for (si=0; si<C_NUM_SLAVE_SLOTS; si=si+1) begin
        result[si*64+:32] = C_S_AXI_BASE_ID[si*32+:32];
      end
      f_base_id = result;
    end
  endfunction

  // Construct P_S_HIGH_ID vector
  function [`P_MAX_S*64-1:0] f_high_id
    (input null_arg);
    integer si;
    reg [`P_MAX_S*64-1:0] result;
    begin
      result = 0;
      for (si=0; si<C_NUM_SLAVE_SLOTS; si=si+1) begin
        // Guard against any C_S_AXI_THREAD_ID_WIDTH > C_AXI_ID_WIDTH to prevent logic blow-up.
        // If violated, crossbar behaves as if all ID inputs sampled by corresponding SI-slot are all-zeros.
        result[si*64+:32] = 
          (C_S_AXI_THREAD_ID_WIDTH[si*32+16+:16] != 16'b0) ? C_S_AXI_BASE_ID[si*32+:32] :
          (C_S_AXI_THREAD_ID_WIDTH[si*32+:32] > C_AXI_ID_WIDTH) ? C_S_AXI_BASE_ID[si*32+:32] :
          (C_S_AXI_BASE_ID[si*32+:32] + 2**C_S_AXI_THREAD_ID_WIDTH[si*32+:32] - 1);
      end
      f_high_id = result;
    end
  endfunction

  // For a given slot (32-bit value) in C_S_AXI_THREAD_ID_WIDTH, generate a mask of valid ID bits.
  function [C_AXI_ID_WIDTH-1:0] f_thread_id_mask
    (input integer slot);
    integer i;
    begin
      f_thread_id_mask = 
        (C_S_AXI_THREAD_ID_WIDTH[slot*32+:32] == 32'b0) ? {C_AXI_ID_WIDTH{1'b0}} : 
        (C_S_AXI_THREAD_ID_WIDTH[slot*32+16+:16] != 16'b0) ? {C_AXI_ID_WIDTH{1'b0}} :
        (C_S_AXI_THREAD_ID_WIDTH[slot*32+:32] > C_AXI_ID_WIDTH) ? {C_AXI_ID_WIDTH{1'b0}} :
        ((2**C_S_AXI_THREAD_ID_WIDTH[slot*32+:32])-1);
    end
  endfunction

  function [`P_MAX_S*32-1:0] f_thread_id_width
  // For each 32-bit value in C_S_AXI_THREAD_ID_WIDTH, force within range 1-C_AXI_ID_WIDTH.
    (input null_arg);
    integer i;
    reg [`P_MAX_S*32-1:0] result;
    begin
      for (i=0; i<`P_MAX_S; i=i+1) begin
        result[i*32+:32] = 
          (C_S_AXI_THREAD_ID_WIDTH[i*32+:32] == 32'b0) ? 32'h00000001 : 
          (C_S_AXI_THREAD_ID_WIDTH[i*32+16+:16] != 16'b0) ? 32'h00000001 :
          (C_S_AXI_THREAD_ID_WIDTH[i*32+:32] > C_AXI_ID_WIDTH) ? 32'h00000001 :
          C_S_AXI_THREAD_ID_WIDTH[i*32+:32];
      end
      f_thread_id_width = result;
    end
  endfunction

  // Widths of all write issuance counters implemented in crossbar (before counter carry-out bit)
  function [(`P_MAX_M+1)*32-1:0] f_write_issue_width_vec
    (input null_arg);
    integer mi;
    reg [(`P_MAX_M+1)*32-1:0] result;
    begin
      result = 0;
      for (mi=0; mi<C_NUM_MASTER_SLOTS; mi=mi+1) begin
        result[mi*32+:32] = (C_M_AXI_PROTOCOL[mi*32+:32] == P_AXILITE) ? 32'h0 : f_ceil_log2(C_M_AXI_WRITE_ISSUING[mi*32+:32]);
      end
      result[C_NUM_MASTER_SLOTS*32+:32] = 32'h0;
      f_write_issue_width_vec = result;
    end
  endfunction

  // Widths of all read issuance counters implemented in crossbar (before counter carry-out bit)
  function [(`P_MAX_M+1)*32-1:0] f_read_issue_width_vec
    (input null_arg);
    integer mi;
    reg [(`P_MAX_M+1)*32-1:0] result;
    begin
      result = 0;
      for (mi=0; mi<C_NUM_MASTER_SLOTS; mi=mi+1) begin
        result[mi*32+:32] = (C_M_AXI_PROTOCOL[mi*32+:32] == P_AXILITE) ? 32'h0 : f_ceil_log2(C_M_AXI_READ_ISSUING[mi*32+:32]);
      end
      result[C_NUM_MASTER_SLOTS*32+:32] = 32'h0;
      f_read_issue_width_vec = result;
    end
  endfunction

  // Widths of all write acceptance counters implemented in crossbar (before counter carry-out bit)
  function [`P_MAX_S*32-1:0] f_write_accept_width_vec
    (input null_arg);
    integer si;
    reg [`P_MAX_S*32-1:0] result;
    begin
      result = 0;
      for (si=0; si<C_NUM_SLAVE_SLOTS; si=si+1) begin
        result[si*32+:32] = (C_S_AXI_PROTOCOL[si*32+:32] == P_AXILITE) ? 32'h0 : f_ceil_log2(C_S_AXI_WRITE_ACCEPTANCE[si*32+:32]);
      end
      f_write_accept_width_vec = result;
    end
  endfunction

  // Widths of all read acceptance counters implemented in crossbar (before counter carry-out bit)
  function [`P_MAX_S*32-1:0] f_read_accept_width_vec
    (input null_arg);
    integer si;
    reg [`P_MAX_S*32-1:0] result;
    begin
      result = 0;
      for (si=0; si<C_NUM_SLAVE_SLOTS; si=si+1) begin
        result[si*32+:32] = (C_S_AXI_PROTOCOL[si*32+:32] == P_AXILITE) ? 32'h0 : f_ceil_log2(C_S_AXI_READ_ACCEPTANCE[si*32+:32]);
      end
      f_read_accept_width_vec = result;
    end
  endfunction

  // Count number of valid address ranges for MI-slot #0
  function f_multi_addr_ranges
    (
      input integer null_arg
    );
    reg multi;
    integer rng;
    begin
      multi = 1'b0;
      for (rng=1; rng<`P_NUM_ADDR_RANGES; rng=rng+1) begin
        multi = multi | (~C_M_AXI_BASE_ADDR[rng*64+C_AXI_ADDR_WIDTH-1]) | C_M_AXI_HIGH_ADDR[rng*64+C_AXI_ADDR_WIDTH-1];
      end
      f_multi_addr_ranges = multi;
    end
  endfunction
  
  assign S_AXI_ARESET_OUT_N = s_axi_reset_out_n_i;
  assign M_AXI_ARESET_OUT_N = m_axi_reset_out_n_i;
  
genvar slot;

generate
  for (slot=0;slot<C_NUM_SLAVE_SLOTS;slot=slot+1) begin : gen_si_tieoff
    assign si_sr_awid[slot*C_AXI_ID_WIDTH+:C_AXI_ID_WIDTH]                             = (C_S_AXI_SUPPORTS_WRITE[slot] && C_S_AXI_PROTOCOL[slot*32+:32]!=P_AXILITE                                ) ? (S_AXI_AWID[slot*C_AXI_ID_WIDTH+:C_AXI_ID_WIDTH] & f_thread_id_mask(slot))              : 0 ;
    assign si_sr_awaddr[slot*C_AXI_ADDR_WIDTH+:C_AXI_ADDR_WIDTH]                       = (C_S_AXI_SUPPORTS_WRITE[slot]                                                                            ) ? S_AXI_AWADDR[slot*C_AXI_ADDR_WIDTH+:C_AXI_ADDR_WIDTH]                       : 0 ;
    assign si_sr_awlen[slot*8+:8]                                                      = (~C_S_AXI_SUPPORTS_WRITE[slot]) ? 0 : (C_S_AXI_PROTOCOL[slot*32+:32]==P_AXI4                             ) ? S_AXI_AWLEN[slot*8+:8] : (C_S_AXI_PROTOCOL[slot*32+:32]==P_AXI3) ? S_AXI_AWLEN[slot*8+:4] : 0 ;
    assign si_sr_awsize[slot*3+:3]                                                     = (C_S_AXI_SUPPORTS_WRITE[slot] && C_S_AXI_PROTOCOL[slot*32+:32]!=P_AXILITE                                ) ? S_AXI_AWSIZE[slot*3+:3]                                                     : P_AXILITE_SIZE ;
    assign si_sr_awburst[slot*2+:2]                                                    = (C_S_AXI_SUPPORTS_WRITE[slot] && C_S_AXI_PROTOCOL[slot*32+:32]!=P_AXILITE                                ) ? S_AXI_AWBURST[slot*2+:2]                                                    : P_INCR ;
    assign si_sr_awlock[slot*2+:2]                                                     = (C_S_AXI_SUPPORTS_WRITE[slot] && C_S_AXI_PROTOCOL[slot*32+:32]!=P_AXILITE                                ) ? {1'b0, S_AXI_AWLOCK[slot*2+:1]}                                             : 0 ;
    assign si_sr_awcache[slot*4+:4]                                                    = (C_S_AXI_SUPPORTS_WRITE[slot] && C_S_AXI_PROTOCOL[slot*32+:32]!=P_AXILITE                                ) ? S_AXI_AWCACHE[slot*4+:4]                                                    : 0 ;
    assign si_sr_awprot[slot*3+:3]                                                     = (C_S_AXI_SUPPORTS_WRITE[slot]                                                                            ) ? S_AXI_AWPROT[slot*3+:3]                                                     : 0 ;
    assign si_sr_awqos[slot*4+:4]                                                      = (C_S_AXI_SUPPORTS_WRITE[slot] && C_S_AXI_PROTOCOL[slot*32+:32]!=P_AXILITE                                ) ? S_AXI_AWQOS[slot*4+:4]                                                      : 0 ;
    assign si_sr_awuser[slot*C_AXI_AWUSER_WIDTH+:C_AXI_AWUSER_WIDTH]                   = (C_S_AXI_SUPPORTS_WRITE[slot] && C_S_AXI_PROTOCOL[slot*32+:32]!=P_AXILITE && C_AXI_SUPPORTS_USER_SIGNALS ) ? S_AXI_AWUSER[slot*C_AXI_AWUSER_WIDTH+:C_AXI_AWUSER_WIDTH]                   : 0 ;
    assign si_sr_awvalid[slot*1+:1]                                                    = (C_S_AXI_SUPPORTS_WRITE[slot]                                                                            ) ? S_AXI_AWVALID[slot*1+:1]                                                    : 0 ;
    assign si_sr_wdata[slot*C_AXI_DATA_MAX_WIDTH+:C_AXI_DATA_MAX_WIDTH]                = (C_S_AXI_SUPPORTS_WRITE[slot]                                                                            ) ? S_AXI_WDATA[slot*C_AXI_DATA_MAX_WIDTH+:C_S_AXI_DATA_WIDTH[slot*32+:32]]     : 0 ;
    assign si_sr_wstrb[slot*C_AXI_DATA_MAX_WIDTH/8+:C_AXI_DATA_MAX_WIDTH/8]            = (C_S_AXI_SUPPORTS_WRITE[slot]                                                                            ) ? S_AXI_WSTRB[slot*C_AXI_DATA_MAX_WIDTH/8+:C_S_AXI_DATA_WIDTH[slot*32+:32]/8] : 0 ;
    assign si_sr_wlast[slot*1+:1]                                                      = (C_S_AXI_SUPPORTS_WRITE[slot] && C_S_AXI_PROTOCOL[slot*32+:32]!=P_AXILITE                                ) ? S_AXI_WLAST[slot*1+:1]                                                      : 1'b1 ;
    assign si_sr_wuser[slot*C_AXI_WUSER_WIDTH+:C_AXI_WUSER_WIDTH]                      = (C_S_AXI_SUPPORTS_WRITE[slot] && C_S_AXI_PROTOCOL[slot*32+:32]!=P_AXILITE && C_AXI_SUPPORTS_USER_SIGNALS ) ? S_AXI_WUSER[slot*C_AXI_WUSER_WIDTH+:C_AXI_WUSER_WIDTH]                      : 0 ;
    assign si_sr_wvalid[slot*1+:1]                                                     = (C_S_AXI_SUPPORTS_WRITE[slot]                                                                            ) ? S_AXI_WVALID[slot*1+:1]                                                     : 0 ;
    assign si_sr_bready[slot*1+:1]                                                     = (C_S_AXI_SUPPORTS_WRITE[slot]                                                                            ) ? S_AXI_BREADY[slot*1+:1]                                                     : 0 ;
    assign si_sr_arid[slot*C_AXI_ID_WIDTH+:C_AXI_ID_WIDTH]                             = (C_S_AXI_SUPPORTS_READ[slot]  && C_S_AXI_PROTOCOL[slot*32+:32]!=P_AXILITE                                ) ? (S_AXI_ARID[slot*C_AXI_ID_WIDTH+:C_AXI_ID_WIDTH] & f_thread_id_mask(slot))              : 0 ;
    assign si_sr_araddr[slot*C_AXI_ADDR_WIDTH+:C_AXI_ADDR_WIDTH]                       = (C_S_AXI_SUPPORTS_READ[slot]                                                                             ) ? S_AXI_ARADDR[slot*C_AXI_ADDR_WIDTH+:C_AXI_ADDR_WIDTH]                       : 0 ;
    assign si_sr_arlen[slot*8+:8]                                                      = (~C_S_AXI_SUPPORTS_READ[slot]) ? 0 : (C_S_AXI_PROTOCOL[slot*32+:32]==P_AXI4                              ) ? S_AXI_ARLEN[slot*8+:8] : (C_S_AXI_PROTOCOL[slot*32+:32]==P_AXI3) ? S_AXI_ARLEN[slot*8+:4] : 0 ;
    assign si_sr_arsize[slot*3+:3]                                                     = (C_S_AXI_SUPPORTS_READ[slot]  && C_S_AXI_PROTOCOL[slot*32+:32]!=P_AXILITE                                ) ? S_AXI_ARSIZE[slot*3+:3]                                                     : P_AXILITE_SIZE ;
    assign si_sr_arburst[slot*2+:2]                                                    = (C_S_AXI_SUPPORTS_READ[slot]  && C_S_AXI_PROTOCOL[slot*32+:32]!=P_AXILITE                                ) ? S_AXI_ARBURST[slot*2+:2]                                                    : P_INCR ;
    assign si_sr_arlock[slot*2+:2]                                                     = (C_S_AXI_SUPPORTS_READ[slot]  && C_S_AXI_PROTOCOL[slot*32+:32]!=P_AXILITE                                ) ? {1'b0, S_AXI_ARLOCK[slot*2+:1]}                                             : 0 ;
    assign si_sr_arcache[slot*4+:4]                                                    = (C_S_AXI_SUPPORTS_READ[slot]  && C_S_AXI_PROTOCOL[slot*32+:32]!=P_AXILITE                                ) ? S_AXI_ARCACHE[slot*4+:4]                                                    : 0 ;
    assign si_sr_arprot[slot*3+:3]                                                     = (C_S_AXI_SUPPORTS_READ[slot]                                                                             ) ? S_AXI_ARPROT[slot*3+:3]                                                     : 0 ;
    assign si_sr_arqos[slot*4+:4]                                                      = (C_S_AXI_SUPPORTS_READ[slot]  && C_S_AXI_PROTOCOL[slot*32+:32]!=P_AXILITE                                ) ? S_AXI_ARQOS[slot*4+:4]                                                      : 0 ;
    assign si_sr_aruser[slot*C_AXI_ARUSER_WIDTH+:C_AXI_ARUSER_WIDTH]                   = (C_S_AXI_SUPPORTS_READ[slot]  && C_S_AXI_PROTOCOL[slot*32+:32]!=P_AXILITE && C_AXI_SUPPORTS_USER_SIGNALS ) ? S_AXI_ARUSER[slot*C_AXI_ARUSER_WIDTH+:C_AXI_ARUSER_WIDTH]                   : 0 ;
    assign si_sr_arvalid[slot*1+:1]                                                    = (C_S_AXI_SUPPORTS_READ[slot]                                                                             ) ? S_AXI_ARVALID[slot*1+:1]                                                    : 0 ;
    assign si_sr_rready[slot*1+:1]                                                     = (C_S_AXI_SUPPORTS_READ[slot]                                                                             ) ? S_AXI_RREADY[slot*1+:1]                                                     : 0 ;                                       
                                                                                                                                                                                                                                                                                      
    assign S_AXI_AWREADY[slot*1+:1]                                                    = (C_S_AXI_SUPPORTS_WRITE[slot]                                                                            ) ? si_sr_awready[slot*1+:1]                                                    : 0 ;
    assign S_AXI_WREADY[slot*1+:1]                                                     = (C_S_AXI_SUPPORTS_WRITE[slot]                                                                            ) ? si_sr_wready[slot*1+:1]                                                     : 0 ;
    assign S_AXI_BID[slot*C_AXI_ID_WIDTH+:C_AXI_ID_WIDTH]                              = (C_S_AXI_SUPPORTS_WRITE[slot] && C_S_AXI_PROTOCOL[slot*32+:32]!=P_AXILITE                                ) ? (si_sr_bid[slot*C_AXI_ID_WIDTH+:C_AXI_ID_WIDTH] & f_thread_id_mask(slot))               : 0 ;
    assign S_AXI_BRESP[slot*2+:2]                                                      = (C_S_AXI_SUPPORTS_WRITE[slot]                                                                            ) ? si_sr_bresp[slot*2+:2]                                                      : 0 ;
    assign S_AXI_BUSER[slot*C_AXI_BUSER_WIDTH+:C_AXI_BUSER_WIDTH]                      = (C_S_AXI_SUPPORTS_WRITE[slot] && C_S_AXI_PROTOCOL[slot*32+:32]!=P_AXILITE && C_AXI_SUPPORTS_USER_SIGNALS ) ? si_sr_buser[slot*C_AXI_BUSER_WIDTH+:C_AXI_BUSER_WIDTH]                      : 0 ;
    assign S_AXI_BVALID[slot*1+:1]                                                     = (C_S_AXI_SUPPORTS_WRITE[slot]                                                                            ) ? si_sr_bvalid[slot*1+:1]                                                     : 0 ;
    assign S_AXI_ARREADY[slot*1+:1]                                                    = (C_S_AXI_SUPPORTS_READ[slot]                                                                             ) ? si_sr_arready[slot*1+:1]                                                    : 0 ;
    assign S_AXI_RID[slot*C_AXI_ID_WIDTH+:C_AXI_ID_WIDTH]                              = (C_S_AXI_SUPPORTS_READ[slot]  && C_S_AXI_PROTOCOL[slot*32+:32]!=P_AXILITE                                ) ? (si_sr_rid[slot*C_AXI_ID_WIDTH+:C_AXI_ID_WIDTH] & f_thread_id_mask(slot))               : 0 ;
    assign S_AXI_RDATA[slot*C_AXI_DATA_MAX_WIDTH+:C_AXI_DATA_MAX_WIDTH]                = (C_S_AXI_SUPPORTS_READ[slot]                                                                             ) ? si_sr_rdata[slot*C_AXI_DATA_MAX_WIDTH+:C_S_AXI_DATA_WIDTH[slot*32+:32]]     : 0 ;
    assign S_AXI_RRESP[slot*2+:2]                                                      = (C_S_AXI_SUPPORTS_READ[slot]                                                                             ) ? si_sr_rresp[slot*2+:2]                                                      : 0 ;
    assign S_AXI_RLAST[slot*1+:1]                                                      = (C_S_AXI_SUPPORTS_READ[slot]  && C_S_AXI_PROTOCOL[slot*32+:32]!=P_AXILITE                                ) ? si_sr_rlast[slot*1+:1]                                                      : 0 ;
    assign S_AXI_RUSER[slot*C_AXI_RUSER_WIDTH+:C_AXI_RUSER_WIDTH]                      = (C_S_AXI_SUPPORTS_READ[slot]  && C_S_AXI_PROTOCOL[slot*32+:32]!=P_AXILITE && C_AXI_SUPPORTS_USER_SIGNALS ) ? si_sr_ruser[slot*C_AXI_RUSER_WIDTH+:C_AXI_RUSER_WIDTH]                      : 0 ;
    assign S_AXI_RVALID[slot*1+:1]                                                     = (C_S_AXI_SUPPORTS_READ[slot]                                                                             ) ? si_sr_rvalid[slot*1+:1]                                                     : 0 ;
  end
endgenerate

generate
  for (slot=0;slot<C_NUM_MASTER_SLOTS;slot=slot+1) begin : gen_mi_tieoff
    assign M_AXI_AWID[slot*C_AXI_ID_WIDTH+:C_AXI_ID_WIDTH]                             = (C_M_AXI_SUPPORTS_WRITE[slot]                                                                            ) ? mr_mi_awid[slot*C_AXI_ID_WIDTH+:C_AXI_ID_WIDTH]                             : 0 ;
    assign M_AXI_AWADDR[slot*C_AXI_ADDR_WIDTH+:C_AXI_ADDR_WIDTH]                       = (C_M_AXI_SUPPORTS_WRITE[slot]                                                                            ) ? mr_mi_awaddr[slot*C_AXI_ADDR_WIDTH+:C_AXI_ADDR_WIDTH]                       : 0 ;
    assign M_AXI_AWLEN[slot*8+:8]                                                      = (C_M_AXI_SUPPORTS_WRITE[slot]                                                                            ) ? mr_mi_awlen[slot*8+:8]                                                      : 0 ;
    assign M_AXI_AWSIZE[slot*3+:3]                                                     = (C_M_AXI_SUPPORTS_WRITE[slot]                                                                            ) ? mr_mi_awsize[slot*3+:3]                                                     : 0 ;
    assign M_AXI_AWBURST[slot*2+:2]                                                    = (C_M_AXI_SUPPORTS_WRITE[slot]                                                                            ) ? mr_mi_awburst[slot*2+:2]                                                    : 0 ;
    assign M_AXI_AWLOCK[slot*2+:2]                                                     = (C_M_AXI_SUPPORTS_WRITE[slot]                                                                            ) ? mr_mi_awlock[slot*2+:2]                                                     : 0 ;
    assign M_AXI_AWCACHE[slot*4+:4]                                                    = (C_M_AXI_SUPPORTS_WRITE[slot]                                                                            ) ? mr_mi_awcache[slot*4+:4]                                                    : 0 ;
    assign M_AXI_AWPROT[slot*3+:3]                                                     = (C_M_AXI_SUPPORTS_WRITE[slot]                                                                            ) ? mr_mi_awprot[slot*3+:3]                                                     : 0 ;
    assign M_AXI_AWREGION[slot*4+:4]                                                   = (C_M_AXI_SUPPORTS_WRITE[slot]                                                                            ) ? mr_mi_awregion[slot*4+:4]                                                   : 0 ;
    assign M_AXI_AWQOS[slot*4+:4]                                                      = (C_M_AXI_SUPPORTS_WRITE[slot]                                                                            ) ? mr_mi_awqos[slot*4+:4]                                                      : 0 ;
    assign M_AXI_AWUSER[slot*C_AXI_AWUSER_WIDTH+:C_AXI_AWUSER_WIDTH]                   = (C_M_AXI_SUPPORTS_WRITE[slot] && C_AXI_SUPPORTS_USER_SIGNALS                                             ) ? mr_mi_awuser[slot*C_AXI_AWUSER_WIDTH+:C_AXI_AWUSER_WIDTH]                   : 0 ;
    assign M_AXI_AWVALID[slot*1+:1]                                                    = (C_M_AXI_SUPPORTS_WRITE[slot]                                                                            ) ? mr_mi_awvalid[slot*1+:1]                                                    : 0 ;
    assign M_AXI_WID[slot*C_AXI_ID_WIDTH+:C_AXI_ID_WIDTH]                              = (C_M_AXI_SUPPORTS_WRITE[slot]                                                                            ) ? mr_mi_wid[slot*C_AXI_ID_WIDTH+:C_AXI_ID_WIDTH]                              : 0 ;
    assign M_AXI_WDATA[slot*C_AXI_DATA_MAX_WIDTH+:C_AXI_DATA_MAX_WIDTH]                = (C_M_AXI_SUPPORTS_WRITE[slot]                                                                            ) ? mr_mi_wdata[slot*C_AXI_DATA_MAX_WIDTH+:C_M_AXI_DATA_WIDTH[slot*32+:32]]     : 0 ;
    assign M_AXI_WSTRB[slot*C_AXI_DATA_MAX_WIDTH/8+:C_AXI_DATA_MAX_WIDTH/8]            = (C_M_AXI_SUPPORTS_WRITE[slot]                                                                            ) ? mr_mi_wstrb[slot*C_AXI_DATA_MAX_WIDTH/8+:C_M_AXI_DATA_WIDTH[slot*32+:32]/8] : 0 ;
    assign M_AXI_WLAST[slot*1+:1]                                                      = (C_M_AXI_SUPPORTS_WRITE[slot]                                                                            ) ? mr_mi_wlast[slot*1+:1]                                                      : 0 ;
    assign M_AXI_WUSER[slot*C_AXI_WUSER_WIDTH+:C_AXI_WUSER_WIDTH]                      = (C_M_AXI_SUPPORTS_WRITE[slot] && C_AXI_SUPPORTS_USER_SIGNALS                                             ) ? mr_mi_wuser[slot*C_AXI_WUSER_WIDTH+:C_AXI_WUSER_WIDTH]                      : 0 ;
    assign M_AXI_WVALID[slot*1+:1]                                                     = (C_M_AXI_SUPPORTS_WRITE[slot]                                                                            ) ? mr_mi_wvalid[slot*1+:1]                                                     : 0 ;
    assign M_AXI_BREADY[slot*1+:1]                                                     = (C_M_AXI_SUPPORTS_WRITE[slot]                                                                            ) ? mr_mi_bready[slot*1+:1]                                                     : 0 ;
    assign M_AXI_ARID[slot*C_AXI_ID_WIDTH+:C_AXI_ID_WIDTH]                             = (C_M_AXI_SUPPORTS_READ[slot]                                                                             ) ? mr_mi_arid[slot*C_AXI_ID_WIDTH+:C_AXI_ID_WIDTH]                            : 0 ;
    assign M_AXI_ARADDR[slot*C_AXI_ADDR_WIDTH+:C_AXI_ADDR_WIDTH]                       = (C_M_AXI_SUPPORTS_READ[slot]                                                                             ) ? mr_mi_araddr[slot*C_AXI_ADDR_WIDTH+:C_AXI_ADDR_WIDTH]                       : 0 ;
    assign M_AXI_ARLEN[slot*8+:8]                                                      = (C_M_AXI_SUPPORTS_READ[slot]                                                                             ) ? mr_mi_arlen[slot*8+:8]                                                      : 0 ;
    assign M_AXI_ARSIZE[slot*3+:3]                                                     = (C_M_AXI_SUPPORTS_READ[slot]                                                                             ) ? mr_mi_arsize[slot*3+:3]                                                     : 0 ;
    assign M_AXI_ARBURST[slot*2+:2]                                                    = (C_M_AXI_SUPPORTS_READ[slot]                                                                             ) ? mr_mi_arburst[slot*2+:2]                                                    : 0 ;
    assign M_AXI_ARLOCK[slot*2+:2]                                                     = (C_M_AXI_SUPPORTS_READ[slot]                                                                             ) ? mr_mi_arlock[slot*2+:2]                                                     : 0 ;
    assign M_AXI_ARCACHE[slot*4+:4]                                                    = (C_M_AXI_SUPPORTS_READ[slot]                                                                             ) ? mr_mi_arcache[slot*4+:4]                                                    : 0 ;
    assign M_AXI_ARPROT[slot*3+:3]                                                     = (C_M_AXI_SUPPORTS_READ[slot]                                                                             ) ? mr_mi_arprot[slot*3+:3]                                                     : 0 ;
    assign M_AXI_ARREGION[slot*4+:4]                                                   = (C_M_AXI_SUPPORTS_READ[slot]                                                                             ) ? mr_mi_arregion[slot*4+:4]                                                   : 0 ;
    assign M_AXI_ARQOS[slot*4+:4]                                                      = (C_M_AXI_SUPPORTS_READ[slot]                                                                             ) ? mr_mi_arqos[slot*4+:4]                                                      : 0 ;
    assign M_AXI_ARUSER[slot*C_AXI_ARUSER_WIDTH+:C_AXI_ARUSER_WIDTH]                   = (C_M_AXI_SUPPORTS_READ[slot]  && C_AXI_SUPPORTS_USER_SIGNALS                                             ) ? mr_mi_aruser[slot*C_AXI_ARUSER_WIDTH+:C_AXI_ARUSER_WIDTH]                   : 0 ;
    assign M_AXI_ARVALID[slot*1+:1]                                                    = (C_M_AXI_SUPPORTS_READ[slot]                                                                             ) ? mr_mi_arvalid[slot*1+:1]                                                    : 0 ;
    assign M_AXI_RREADY[slot*1+:1]                                                     = (C_M_AXI_SUPPORTS_READ[slot]                                                                             ) ? mr_mi_rready[slot*1+:1]                                                     : 0 ;
                                                                                                                                                                                                                                                                                      
    assign mr_mi_awready[slot*1+:1]                                                    = (C_M_AXI_SUPPORTS_WRITE[slot]                                                                            ) ? M_AXI_AWREADY[slot*1+:1]                                                    : 0 ;
    assign mr_mi_wready[slot*1+:1]                                                     = (C_M_AXI_SUPPORTS_WRITE[slot]                                                                            ) ? M_AXI_WREADY[slot*1+:1]                                                     : 0 ;
    assign mr_mi_bid[slot*C_AXI_ID_WIDTH+:C_AXI_ID_WIDTH]                              = (C_M_AXI_SUPPORTS_WRITE[slot] && C_M_AXI_PROTOCOL[slot*32+:32]!=P_AXILITE                                ) ? M_AXI_BID[slot*C_AXI_ID_WIDTH+:C_AXI_ID_WIDTH]                              : 0 ;
    assign mr_mi_bresp[slot*2+:2]                                                      = (C_M_AXI_SUPPORTS_WRITE[slot]                                                                            ) ? M_AXI_BRESP[slot*2+:2]                                                      : 0 ;
    assign mr_mi_buser[slot*C_AXI_BUSER_WIDTH+:C_AXI_BUSER_WIDTH]                      = (C_M_AXI_SUPPORTS_WRITE[slot] && C_M_AXI_PROTOCOL[slot*32+:32]!=P_AXILITE && C_AXI_SUPPORTS_USER_SIGNALS ) ? M_AXI_BUSER[slot*C_AXI_BUSER_WIDTH+:C_AXI_BUSER_WIDTH]                      : 0 ;
    assign mr_mi_bvalid[slot*1+:1]                                                     = (C_M_AXI_SUPPORTS_WRITE[slot]                                                                            ) ? M_AXI_BVALID[slot*1+:1]                                                     : 0 ;
    assign mr_mi_arready[slot*1+:1]                                                    = (C_M_AXI_SUPPORTS_READ[slot]                                                                             ) ? M_AXI_ARREADY[slot*1+:1]                                                    : 0 ;
    assign mr_mi_rid[slot*C_AXI_ID_WIDTH+:C_AXI_ID_WIDTH]                              = (C_M_AXI_SUPPORTS_READ[slot]  && C_M_AXI_PROTOCOL[slot*32+:32]!=P_AXILITE                                ) ? M_AXI_RID[slot*C_AXI_ID_WIDTH+:C_AXI_ID_WIDTH]                              : 0 ;
    assign mr_mi_rdata[slot*C_AXI_DATA_MAX_WIDTH+:C_AXI_DATA_MAX_WIDTH]                = (C_M_AXI_SUPPORTS_READ[slot]                                                                             ) ? M_AXI_RDATA[slot*C_AXI_DATA_MAX_WIDTH+:C_M_AXI_DATA_WIDTH[slot*32+:32]]     : 0 ;
    assign mr_mi_rresp[slot*2+:2]                                                      = (C_M_AXI_SUPPORTS_READ[slot]                                                                             ) ? M_AXI_RRESP[slot*2+:2]                                                      : 0 ;
    assign mr_mi_rlast[slot*1+:1]                                                      = (C_M_AXI_SUPPORTS_READ[slot]  && C_M_AXI_PROTOCOL[slot*32+:32]!=P_AXILITE                                ) ? M_AXI_RLAST[slot*1+:1]                                                      : 1'b1 ;
    assign mr_mi_ruser[slot*C_AXI_RUSER_WIDTH+:C_AXI_RUSER_WIDTH]                      = (C_M_AXI_SUPPORTS_READ[slot]  && C_M_AXI_PROTOCOL[slot*32+:32]!=P_AXILITE && C_AXI_SUPPORTS_USER_SIGNALS ) ? M_AXI_RUSER[slot*C_AXI_RUSER_WIDTH+:C_AXI_RUSER_WIDTH]                      : 0 ;
    assign mr_mi_rvalid[slot*1+:1]                                                     = (C_M_AXI_SUPPORTS_READ[slot]                                                                             ) ? M_AXI_RVALID[slot*1+:1]                                                     : 0 ;
  end
endgenerate

  axi_interconnect_v1_7_13_register_slice_bank #
  (
    .C_FAMILY                         (P_FAMILY),
    .C_NUM_SLOTS                (C_NUM_SLAVE_SLOTS),
    .C_AXI_ID_WIDTH                 (P_S_AXI_ID_WIDTH_MAX1),
//    .C_AXI_ID_MASK                 (P_S_AXI_ID_MASK),
    .C_AXI_ID_MAX_WIDTH                 (C_AXI_ID_WIDTH),
    .C_AXI_ADDR_WIDTH                 (C_AXI_ADDR_WIDTH),
    .C_AXI_DATA_WIDTH               (C_S_AXI_DATA_WIDTH),
    .C_AXI_DATA_MAX_WIDTH           (C_AXI_DATA_MAX_WIDTH),
    .C_AXI_PROTOCOL                 (C_S_AXI_PROTOCOL),
    .C_AXI_SUPPORTS_WRITE           (C_S_AXI_SUPPORTS_WRITE),
    .C_AXI_SUPPORTS_READ            (C_S_AXI_SUPPORTS_READ),
    .C_AXI_SUPPORTS_USER_SIGNALS      (C_AXI_SUPPORTS_USER_SIGNALS),
    .C_AXI_AWUSER_WIDTH               (C_AXI_AWUSER_WIDTH),
    .C_AXI_ARUSER_WIDTH               (C_AXI_ARUSER_WIDTH),
    .C_AXI_WUSER_WIDTH                (C_AXI_WUSER_WIDTH),
    .C_AXI_RUSER_WIDTH                (C_AXI_RUSER_WIDTH),
    .C_AXI_BUSER_WIDTH                (C_AXI_BUSER_WIDTH),
    .C_AXI_AW_REGISTER              (C_S_AXI_AW_REGISTER),
    .C_AXI_AR_REGISTER              (C_S_AXI_AR_REGISTER),
    .C_AXI_W_REGISTER               (C_S_AXI_W_REGISTER),
    .C_AXI_R_REGISTER               (C_S_AXI_R_REGISTER),
    .C_AXI_B_REGISTER               (C_S_AXI_B_REGISTER)
  )
  si_register_slice_bank 
  (
    .ARESETN                          (s_axi_reset_out_n_i),
    .ACLK                             (S_AXI_ACLK),
    .S_AXI_AWID                       (si_sr_awid        ),
    .S_AXI_AWADDR                     (si_sr_awaddr      ),
    .S_AXI_AWLEN                      (si_sr_awlen       ),
    .S_AXI_AWSIZE                     (si_sr_awsize      ),
    .S_AXI_AWBURST                    (si_sr_awburst     ),
    .S_AXI_AWLOCK                     (si_sr_awlock      ),
    .S_AXI_AWCACHE                    (si_sr_awcache     ),
    .S_AXI_AWPROT                     (si_sr_awprot      ),
    .S_AXI_AWQOS                      (si_sr_awqos       ),
    .S_AXI_AWUSER                     (si_sr_awuser      ),
    .S_AXI_AWVALID                    (si_sr_awvalid     ),
    .S_AXI_AWREADY                    (si_sr_awready     ),
    .S_AXI_WDATA                      (si_sr_wdata       ),
    .S_AXI_WSTRB                      (si_sr_wstrb       ),
    .S_AXI_WLAST                      (si_sr_wlast       ),
    .S_AXI_WUSER                      (si_sr_wuser       ),
    .S_AXI_WVALID                     (si_sr_wvalid      ),
    .S_AXI_WREADY                     (si_sr_wready      ),
    .S_AXI_BID                        (si_sr_bid         ),
    .S_AXI_BRESP                      (si_sr_bresp       ),
    .S_AXI_BUSER                      (si_sr_buser       ),
    .S_AXI_BVALID                     (si_sr_bvalid      ),
    .S_AXI_BREADY                     (si_sr_bready      ),
    .S_AXI_ARID                       (si_sr_arid        ),
    .S_AXI_ARADDR                     (si_sr_araddr      ),
    .S_AXI_ARLEN                      (si_sr_arlen       ),
    .S_AXI_ARSIZE                     (si_sr_arsize      ),
    .S_AXI_ARBURST                    (si_sr_arburst     ),
    .S_AXI_ARLOCK                     (si_sr_arlock      ),
    .S_AXI_ARCACHE                    (si_sr_arcache     ),
    .S_AXI_ARPROT                     (si_sr_arprot      ),
    .S_AXI_ARQOS                      (si_sr_arqos       ),
    .S_AXI_ARUSER                     (si_sr_aruser      ),
    .S_AXI_ARVALID                    (si_sr_arvalid     ),
    .S_AXI_ARREADY                    (si_sr_arready     ),
    .S_AXI_RID                        (si_sr_rid         ),
    .S_AXI_RDATA                      (si_sr_rdata       ),
    .S_AXI_RRESP                      (si_sr_rresp       ),
    .S_AXI_RLAST                      (si_sr_rlast       ),
    .S_AXI_RUSER                      (si_sr_ruser       ),
    .S_AXI_RVALID                     (si_sr_rvalid      ),
    .S_AXI_RREADY                     (si_sr_rready      ),
    .S_AXI_WID                        ({C_NUM_SLAVE_SLOTS*C_AXI_ID_WIDTH{1'b0}}),  // SI has no WID ports
    .S_AXI_AWREGION                   ({C_NUM_SLAVE_SLOTS{4'b0}}),  // SI has no REGION ports
    .S_AXI_ARREGION                   ({C_NUM_SLAVE_SLOTS{4'b0}}),  // SI has no REGION ports
    .M_AXI_AWID                       (sr_sc_awid        ),
    .M_AXI_AWADDR                     (sr_sc_awaddr      ),
    .M_AXI_AWLEN                      (sr_sc_awlen       ),
    .M_AXI_AWSIZE                     (sr_sc_awsize      ),
    .M_AXI_AWBURST                    (sr_sc_awburst     ),
    .M_AXI_AWLOCK                     (sr_sc_awlock      ),
    .M_AXI_AWCACHE                    (sr_sc_awcache     ),
    .M_AXI_AWPROT                     (sr_sc_awprot      ),
    .M_AXI_AWREGION                   (                  ),  // SI has no REGION ports
    .M_AXI_AWQOS                      (sr_sc_awqos       ),
    .M_AXI_AWUSER                     (sr_sc_awuser      ),
    .M_AXI_AWVALID                    (sr_sc_awvalid     ),
    .M_AXI_AWREADY                    (sr_sc_awready     ),
    .M_AXI_WID                        (                  ),  // SI has no WID ports
    .M_AXI_WDATA                      (sr_sc_wdata       ),
    .M_AXI_WSTRB                      (sr_sc_wstrb       ),
    .M_AXI_WLAST                      (sr_sc_wlast       ),
    .M_AXI_WUSER                      (sr_sc_wuser       ),
    .M_AXI_WVALID                     (sr_sc_wvalid      ),
    .M_AXI_WREADY                     (sr_sc_wready      ),
    .M_AXI_BID                        (sr_sc_bid         ),
    .M_AXI_BRESP                      (sr_sc_bresp       ),
    .M_AXI_BUSER                      (sr_sc_buser       ),
    .M_AXI_BVALID                     (sr_sc_bvalid      ),
    .M_AXI_BREADY                     (sr_sc_bready      ),
    .M_AXI_ARID                       (sr_sc_arid        ),
    .M_AXI_ARADDR                     (sr_sc_araddr      ),
    .M_AXI_ARLEN                      (sr_sc_arlen       ),
    .M_AXI_ARSIZE                     (sr_sc_arsize      ),
    .M_AXI_ARBURST                    (sr_sc_arburst     ),
    .M_AXI_ARLOCK                     (sr_sc_arlock      ),
    .M_AXI_ARCACHE                    (sr_sc_arcache     ),
    .M_AXI_ARPROT                     (sr_sc_arprot      ),
    .M_AXI_ARREGION                   (                  ),  // SI has no REGION ports
    .M_AXI_ARQOS                      (sr_sc_arqos       ),
    .M_AXI_ARUSER                     (sr_sc_aruser      ),
    .M_AXI_ARVALID                    (sr_sc_arvalid     ),
    .M_AXI_ARREADY                    (sr_sc_arready     ),
    .M_AXI_RID                        (sr_sc_rid         ),
    .M_AXI_RDATA                      (sr_sc_rdata       ),
    .M_AXI_RRESP                      (sr_sc_rresp       ),
    .M_AXI_RLAST                      (sr_sc_rlast       ),
    .M_AXI_RUSER                      (sr_sc_ruser       ),
    .M_AXI_RVALID                     (sr_sc_rvalid      ),
    .M_AXI_RREADY                     (sr_sc_rready      )
  );

  axi_interconnect_v1_7_13_register_slice_bank #
  (
    .C_FAMILY                         (P_FAMILY),
    .C_NUM_SLOTS                  (C_NUM_MASTER_SLOTS),
    .C_AXI_ID_WIDTH                 (P_M_AXI_ID_WIDTH),
//    .C_AXI_ID_MASK                 ({C_NUM_MASTER_SLOTS*C_AXI_ID_WIDTH{1'b1}}),
    .C_AXI_ID_MAX_WIDTH                 (C_AXI_ID_WIDTH),
    .C_AXI_ADDR_WIDTH                 (C_AXI_ADDR_WIDTH),
    .C_AXI_DATA_WIDTH               (C_M_AXI_DATA_WIDTH),
    .C_AXI_DATA_MAX_WIDTH           (C_AXI_DATA_MAX_WIDTH),
    .C_AXI_PROTOCOL                 (C_M_AXI_PROTOCOL),
    .C_AXI_SUPPORTS_WRITE           (C_M_AXI_SUPPORTS_WRITE),
    .C_AXI_SUPPORTS_READ            (C_M_AXI_SUPPORTS_READ),
    .C_AXI_SUPPORTS_USER_SIGNALS      (C_AXI_SUPPORTS_USER_SIGNALS),
    .C_AXI_AWUSER_WIDTH               (C_AXI_AWUSER_WIDTH),
    .C_AXI_ARUSER_WIDTH               (C_AXI_ARUSER_WIDTH),
    .C_AXI_WUSER_WIDTH                (C_AXI_WUSER_WIDTH),
    .C_AXI_RUSER_WIDTH                (C_AXI_RUSER_WIDTH),
    .C_AXI_BUSER_WIDTH                (C_AXI_BUSER_WIDTH),
    .C_AXI_AW_REGISTER              (C_M_AXI_AW_REGISTER),
    .C_AXI_AR_REGISTER              (C_M_AXI_AR_REGISTER),
    .C_AXI_W_REGISTER               (C_M_AXI_W_REGISTER),
    .C_AXI_R_REGISTER               (C_M_AXI_R_REGISTER),
    .C_AXI_B_REGISTER               (C_M_AXI_B_REGISTER)
  )
  mi_register_slice_bank 
  (
    .ARESETN                          (m_axi_reset_out_n_i),
    .ACLK                             (M_AXI_ACLK),
    .S_AXI_AWID                       (mp_mr_awid         ),
    .S_AXI_AWADDR                     (mp_mr_awaddr       ),
    .S_AXI_AWLEN                      (mp_mr_awlen        ),
    .S_AXI_AWSIZE                     (mp_mr_awsize       ),
    .S_AXI_AWBURST                    (mp_mr_awburst      ),
    .S_AXI_AWLOCK                     (mp_mr_awlock       ),
    .S_AXI_AWCACHE                    (mp_mr_awcache      ),
    .S_AXI_AWPROT                     (mp_mr_awprot       ),
    .S_AXI_AWREGION                   (mp_mr_awregion     ),
    .S_AXI_AWQOS                      (mp_mr_awqos        ),
    .S_AXI_AWUSER                     (mp_mr_awuser       ),
    .S_AXI_AWVALID                    (mp_mr_awvalid      ),
    .S_AXI_AWREADY                    (mp_mr_awready      ),
    .S_AXI_WID                        (mp_mr_wid          ),
    .S_AXI_WDATA                      (mp_mr_wdata        ),
    .S_AXI_WSTRB                      (mp_mr_wstrb        ),
    .S_AXI_WLAST                      (mp_mr_wlast        ),
    .S_AXI_WUSER                      (mp_mr_wuser        ),
    .S_AXI_WVALID                     (mp_mr_wvalid       ),
    .S_AXI_WREADY                     (mp_mr_wready       ),
    .S_AXI_BID                        (mp_mr_bid          ),
    .S_AXI_BRESP                      (mp_mr_bresp        ),
    .S_AXI_BUSER                      (mp_mr_buser        ),
    .S_AXI_BVALID                     (mp_mr_bvalid       ),
    .S_AXI_BREADY                     (mp_mr_bready       ),
    .S_AXI_ARID                       (mp_mr_arid         ),
    .S_AXI_ARADDR                     (mp_mr_araddr       ),
    .S_AXI_ARLEN                      (mp_mr_arlen        ),
    .S_AXI_ARSIZE                     (mp_mr_arsize       ),
    .S_AXI_ARBURST                    (mp_mr_arburst      ),
    .S_AXI_ARLOCK                     (mp_mr_arlock       ),
    .S_AXI_ARCACHE                    (mp_mr_arcache      ),
    .S_AXI_ARPROT                     (mp_mr_arprot       ),
    .S_AXI_ARREGION                   (mp_mr_arregion     ),
    .S_AXI_ARQOS                      (mp_mr_arqos        ),
    .S_AXI_ARUSER                     (mp_mr_aruser       ),
    .S_AXI_ARVALID                    (mp_mr_arvalid      ),
    .S_AXI_ARREADY                    (mp_mr_arready      ),
    .S_AXI_RID                        (mp_mr_rid          ),
    .S_AXI_RDATA                      (mp_mr_rdata        ),
    .S_AXI_RRESP                      (mp_mr_rresp        ),
    .S_AXI_RLAST                      (mp_mr_rlast        ),
    .S_AXI_RUSER                      (mp_mr_ruser        ),
    .S_AXI_RVALID                     (mp_mr_rvalid       ),
    .S_AXI_RREADY                     (mp_mr_rready       ),
    .M_AXI_AWID                       (mr_mi_awid         ),
    .M_AXI_AWADDR                     (mr_mi_awaddr       ),
    .M_AXI_AWLEN                      (mr_mi_awlen        ),
    .M_AXI_AWSIZE                     (mr_mi_awsize       ),
    .M_AXI_AWBURST                    (mr_mi_awburst      ),
    .M_AXI_AWLOCK                     (mr_mi_awlock       ),
    .M_AXI_AWCACHE                    (mr_mi_awcache      ),
    .M_AXI_AWPROT                     (mr_mi_awprot       ),
    .M_AXI_AWREGION                   (mr_mi_awregion     ),
    .M_AXI_AWQOS                      (mr_mi_awqos        ),
    .M_AXI_AWUSER                     (mr_mi_awuser       ),
    .M_AXI_AWVALID                    (mr_mi_awvalid      ),
    .M_AXI_AWREADY                    (mr_mi_awready      ),
    .M_AXI_WID                        (mr_mi_wid          ),
    .M_AXI_WDATA                      (mr_mi_wdata        ),
    .M_AXI_WSTRB                      (mr_mi_wstrb        ),
    .M_AXI_WLAST                      (mr_mi_wlast        ),
    .M_AXI_WUSER                      (mr_mi_wuser        ),
    .M_AXI_WVALID                     (mr_mi_wvalid       ),
    .M_AXI_WREADY                     (mr_mi_wready       ),
    .M_AXI_BID                        (mr_mi_bid          ),
    .M_AXI_BRESP                      (mr_mi_bresp        ),
    .M_AXI_BUSER                      (mr_mi_buser        ),
    .M_AXI_BVALID                     (mr_mi_bvalid       ),
    .M_AXI_BREADY                     (mr_mi_bready       ),
    .M_AXI_ARID                       (mr_mi_arid         ),
    .M_AXI_ARADDR                     (mr_mi_araddr       ),
    .M_AXI_ARLEN                      (mr_mi_arlen        ),
    .M_AXI_ARSIZE                     (mr_mi_arsize       ),
    .M_AXI_ARBURST                    (mr_mi_arburst      ),
    .M_AXI_ARLOCK                     (mr_mi_arlock       ),
    .M_AXI_ARCACHE                    (mr_mi_arcache      ),
    .M_AXI_ARPROT                     (mr_mi_arprot       ),
    .M_AXI_ARREGION                   (mr_mi_arregion     ),
    .M_AXI_ARQOS                      (mr_mi_arqos        ),
    .M_AXI_ARUSER                     (mr_mi_aruser       ),
    .M_AXI_ARVALID                    (mr_mi_arvalid      ),
    .M_AXI_ARREADY                    (mr_mi_arready      ),
    .M_AXI_RID                        (mr_mi_rid          ),
    .M_AXI_RDATA                      (mr_mi_rdata        ),
    .M_AXI_RRESP                      (mr_mi_rresp        ),
    .M_AXI_RLAST                      (mr_mi_rlast        ),
    .M_AXI_RUSER                      (mr_mi_ruser        ),
    .M_AXI_RVALID                     (mr_mi_rvalid       ),
    .M_AXI_RREADY                     (mr_mi_rready       )
  );

  axi_interconnect_v1_7_13_protocol_conv_bank #
  (
    .C_FAMILY                         (P_FAMILY),
    .C_NUM_SLOTS                  (C_NUM_MASTER_SLOTS),
    .C_AXI_ID_MAX_WIDTH                 (C_AXI_ID_WIDTH),
    .C_AXI_ADDR_WIDTH                 (C_AXI_ADDR_WIDTH),
    .C_IGNORE_RID                      (P_IGNORE_RID),
    .C_AXI_DATA_WIDTH               (C_M_AXI_DATA_WIDTH),
    .C_AXI_DATA_MAX_WIDTH           (C_AXI_DATA_MAX_WIDTH),
    .C_AXI_PROTOCOL               (C_M_AXI_PROTOCOL),
    .C_AXI_SUPPORTS_WRITE           (C_M_AXI_SUPPORTS_WRITE),
    .C_AXI_SUPPORTS_READ            (C_M_AXI_SUPPORTS_READ),
    .C_AXI_SUPPORTS_USER_SIGNALS      (C_AXI_SUPPORTS_USER_SIGNALS),
    .C_AXI_AWUSER_WIDTH               (C_AXI_AWUSER_WIDTH),
    .C_AXI_ARUSER_WIDTH               (C_AXI_ARUSER_WIDTH),
    .C_AXI_WUSER_WIDTH                (C_AXI_WUSER_WIDTH),
    .C_AXI_RUSER_WIDTH                (C_AXI_RUSER_WIDTH),
    .C_AXI_BUSER_WIDTH                (C_AXI_BUSER_WIDTH),
    .C_AXI3_BYPASS                    (P_AXI3_BYPASS)
  )
  mi_protocol_conv_bank 
  (
    .ARESETN                          (m_axi_reset_out_n_i),
    .ACLK                             (M_AXI_ACLK),
    .S_AXI_AWID                       (mc_mp_awid         ),
    .S_AXI_AWADDR                     (mc_mp_awaddr       ),
    .S_AXI_AWLEN                      (mc_mp_awlen        ),
    .S_AXI_AWSIZE                     (mc_mp_awsize       ),
    .S_AXI_AWBURST                    (mc_mp_awburst      ),
    .S_AXI_AWLOCK                     (mc_mp_awlock       ),
    .S_AXI_AWCACHE                    (mc_mp_awcache      ),
    .S_AXI_AWPROT                     (mc_mp_awprot       ),
    .S_AXI_AWREGION                   (mc_mp_awregion     ),
    .S_AXI_AWQOS                      (mc_mp_awqos        ),
    .S_AXI_AWUSER                     (mc_mp_awuser       ),
    .S_AXI_AWVALID                    (mc_mp_awvalid      ),
    .S_AXI_AWREADY                    (mc_mp_awready      ),
    .S_AXI_WID                        (S_AXI_WID[C_AXI_ID_WIDTH-1:0]),
    .S_AXI_WDATA                      (mc_mp_wdata        ),
    .S_AXI_WSTRB                      (mc_mp_wstrb        ),
    .S_AXI_WLAST                      (mc_mp_wlast        ),
    .S_AXI_WUSER                      (mc_mp_wuser        ),
    .S_AXI_WVALID                     (mc_mp_wvalid       ),
    .S_AXI_WREADY                     (mc_mp_wready       ),
    .S_AXI_BID                        (mc_mp_bid          ),
    .S_AXI_BRESP                      (mc_mp_bresp        ),
    .S_AXI_BUSER                      (mc_mp_buser        ),
    .S_AXI_BVALID                     (mc_mp_bvalid       ),
    .S_AXI_BREADY                     (mc_mp_bready       ),
    .S_AXI_ARID                       (mc_mp_arid         ),
    .S_AXI_ARADDR                     (mc_mp_araddr       ),
    .S_AXI_ARLEN                      (mc_mp_arlen        ),
    .S_AXI_ARSIZE                     (mc_mp_arsize       ),
    .S_AXI_ARBURST                    (mc_mp_arburst      ),
    .S_AXI_ARLOCK                     (mc_mp_arlock       ),
    .S_AXI_ARCACHE                    (mc_mp_arcache      ),
    .S_AXI_ARPROT                     (mc_mp_arprot       ),
    .S_AXI_ARREGION                   (mc_mp_arregion     ),
    .S_AXI_ARQOS                      (mc_mp_arqos        ),
    .S_AXI_ARUSER                     (mc_mp_aruser       ),
    .S_AXI_ARVALID                    (mc_mp_arvalid      ),
    .S_AXI_ARREADY                    (mc_mp_arready      ),
    .S_AXI_RID                        (mc_mp_rid          ),
    .S_AXI_RDATA                      (mc_mp_rdata        ),
    .S_AXI_RRESP                      (mc_mp_rresp        ),
    .S_AXI_RLAST                      (mc_mp_rlast        ),
    .S_AXI_RUSER                      (mc_mp_ruser        ),
    .S_AXI_RVALID                     (mc_mp_rvalid       ),
    .S_AXI_RREADY                     (mc_mp_rready       ),
    .M_AXI_AWID                       (mp_mr_awid         ),
    .M_AXI_AWADDR                     (mp_mr_awaddr       ),
    .M_AXI_AWLEN                      (mp_mr_awlen        ),
    .M_AXI_AWSIZE                     (mp_mr_awsize       ),
    .M_AXI_AWBURST                    (mp_mr_awburst      ),
    .M_AXI_AWLOCK                     (mp_mr_awlock       ),
    .M_AXI_AWCACHE                    (mp_mr_awcache      ),
    .M_AXI_AWPROT                     (mp_mr_awprot       ),
    .M_AXI_AWREGION                   (mp_mr_awregion     ),
    .M_AXI_AWQOS                      (mp_mr_awqos        ),
    .M_AXI_AWUSER                     (mp_mr_awuser       ),
    .M_AXI_AWVALID                    (mp_mr_awvalid      ),
    .M_AXI_AWREADY                    (mp_mr_awready      ),
    .M_AXI_WID                        (mp_mr_wid          ),
    .M_AXI_WDATA                      (mp_mr_wdata        ),
    .M_AXI_WSTRB                      (mp_mr_wstrb        ),
    .M_AXI_WLAST                      (mp_mr_wlast        ),
    .M_AXI_WUSER                      (mp_mr_wuser        ),
    .M_AXI_WVALID                     (mp_mr_wvalid       ),
    .M_AXI_WREADY                     (mp_mr_wready       ),
    .M_AXI_BID                        (mp_mr_bid          ),
    .M_AXI_BRESP                      (mp_mr_bresp        ),
    .M_AXI_BUSER                      (mp_mr_buser        ),
    .M_AXI_BVALID                     (mp_mr_bvalid       ),
    .M_AXI_BREADY                     (mp_mr_bready       ),
    .M_AXI_ARID                       (mp_mr_arid         ),
    .M_AXI_ARADDR                     (mp_mr_araddr       ),
    .M_AXI_ARLEN                      (mp_mr_arlen        ),
    .M_AXI_ARSIZE                     (mp_mr_arsize       ),
    .M_AXI_ARBURST                    (mp_mr_arburst      ),
    .M_AXI_ARLOCK                     (mp_mr_arlock       ),
    .M_AXI_ARCACHE                    (mp_mr_arcache      ),
    .M_AXI_ARPROT                     (mp_mr_arprot       ),
    .M_AXI_ARREGION                   (mp_mr_arregion     ),
    .M_AXI_ARQOS                      (mp_mr_arqos        ),
    .M_AXI_ARUSER                     (mp_mr_aruser       ),
    .M_AXI_ARVALID                    (mp_mr_arvalid      ),
    .M_AXI_ARREADY                    (mp_mr_arready      ),
    .M_AXI_RID                        (mp_mr_rid          ),
    .M_AXI_RDATA                      (mp_mr_rdata        ),
    .M_AXI_RRESP                      (mp_mr_rresp        ),
    .M_AXI_RLAST                      (mp_mr_rlast        ),
    .M_AXI_RUSER                      (mp_mr_ruser        ),
    .M_AXI_RVALID                     (mp_mr_rvalid       ),
    .M_AXI_RREADY                     (mp_mr_rready       )
  );

  axi_interconnect_v1_7_13_converter_bank #
  (
    .C_FAMILY                         (P_FAMILY),
    .C_NUM_SLOTS                (C_NUM_SLAVE_SLOTS),
    .C_AXI_ID_WIDTH                 (P_S_AXI_ID_WIDTH_MAX1),
    .C_AXI_ID_MAX_WIDTH                 (C_AXI_ID_WIDTH),
    .C_AXI_ADDR_WIDTH                 (C_AXI_ADDR_WIDTH),
    .C_AXI_DATA_MAX_WIDTH           (C_AXI_DATA_MAX_WIDTH),
    .C_S_AXI_DATA_WIDTH               (C_S_AXI_DATA_WIDTH),
    .C_M_AXI_DATA_WIDTH               ({C_NUM_SLAVE_SLOTS{f_bit32_qual(C_INTERCONNECT_DATA_WIDTH,1,0)}}),
    .C_AXI_PROTOCOL                 (C_S_AXI_PROTOCOL),
    .C_AXI_IS_ACLK_ASYNC            (C_S_AXI_IS_ACLK_ASYNC),
    .C_S_AXI_ACLK_RATIO               (C_S_AXI_ACLK_RATIO),
    .C_M_AXI_ACLK_RATIO               ({C_NUM_SLAVE_SLOTS{f_bit32_qual(C_INTERCONNECT_ACLK_RATIO,1,0)}}),
    .C_AXI_SUPPORTS_WRITE           (C_S_AXI_SUPPORTS_WRITE),
    .C_AXI_SUPPORTS_READ            (C_S_AXI_SUPPORTS_READ),
    .C_AXI_SUPPORTS_USER_SIGNALS      (C_AXI_SUPPORTS_USER_SIGNALS),
    .C_AXI_AWUSER_WIDTH               (C_AXI_AWUSER_WIDTH),
    .C_AXI_ARUSER_WIDTH               (C_AXI_ARUSER_WIDTH),
    .C_AXI_WUSER_WIDTH                (C_AXI_WUSER_WIDTH),
    .C_AXI_RUSER_WIDTH                (C_AXI_RUSER_WIDTH),
    .C_AXI_BUSER_WIDTH                (C_AXI_BUSER_WIDTH),
    .C_SYNCHRONIZER_STAGE             (C_SYNCHRONIZER_STAGE),
    .C_HEMISPHERE                   ("si")
  )
  si_converter_bank 
  (
    .INTERCONNECT_ACLK                (INTERCONNECT_ACLK),
    .INTERCONNECT_ARESETN             (INTERCONNECT_ARESETN),
    .LOCAL_ARESETN                    (interconnect_aresetn_i),
    .INTERCONNECT_RESET_OUT_N         (interconnect_aresetn_i),
    .S_AXI_RESET_OUT_N                (s_axi_reset_out_n_i),
    .M_AXI_RESET_OUT_N                (),
    .S_AXI_ACLK                       (S_AXI_ACLK           ),
    .S_AXI_AWID                       (sr_sc_awid           ),
    .S_AXI_AWADDR                     (sr_sc_awaddr         ),
    .S_AXI_AWLEN                      (sr_sc_awlen          ),
    .S_AXI_AWSIZE                     (sr_sc_awsize         ),
    .S_AXI_AWBURST                    (sr_sc_awburst        ),
    .S_AXI_AWLOCK                     (sr_sc_awlock         ),
    .S_AXI_AWCACHE                    (sr_sc_awcache        ),
    .S_AXI_AWPROT                     (sr_sc_awprot         ),
    .S_AXI_AWQOS                      (sr_sc_awqos          ),
    .S_AXI_AWUSER                     (sr_sc_awuser         ),
    .S_AXI_AWVALID                    (sr_sc_awvalid        ),
    .S_AXI_AWREADY                    (sr_sc_awready        ),
    .S_AXI_WDATA                      (sr_sc_wdata          ),
    .S_AXI_WSTRB                      (sr_sc_wstrb          ),
    .S_AXI_WLAST                      (sr_sc_wlast          ),
    .S_AXI_WUSER                      (sr_sc_wuser          ),
    .S_AXI_WVALID                     (sr_sc_wvalid         ),
    .S_AXI_WREADY                     (sr_sc_wready         ),
    .S_AXI_BID                        (sr_sc_bid            ),
    .S_AXI_BRESP                      (sr_sc_bresp          ),
    .S_AXI_BUSER                      (sr_sc_buser          ),
    .S_AXI_BVALID                     (sr_sc_bvalid         ),
    .S_AXI_BREADY                     (sr_sc_bready         ),
    .S_AXI_ARID                       (sr_sc_arid           ),
    .S_AXI_ARADDR                     (sr_sc_araddr         ),
    .S_AXI_ARLEN                      (sr_sc_arlen          ),
    .S_AXI_ARSIZE                     (sr_sc_arsize         ),
    .S_AXI_ARBURST                    (sr_sc_arburst        ),
    .S_AXI_ARLOCK                     (sr_sc_arlock         ),
    .S_AXI_ARCACHE                    (sr_sc_arcache        ),
    .S_AXI_ARPROT                     (sr_sc_arprot         ),
    .S_AXI_ARQOS                      (sr_sc_arqos          ),
    .S_AXI_ARUSER                     (sr_sc_aruser         ),
    .S_AXI_ARVALID                    (sr_sc_arvalid        ),
    .S_AXI_ARREADY                    (sr_sc_arready        ),
    .S_AXI_RID                        (sr_sc_rid            ),
    .S_AXI_RDATA                      (sr_sc_rdata          ),
    .S_AXI_RRESP                      (sr_sc_rresp          ),
    .S_AXI_RLAST                      (sr_sc_rlast          ),
    .S_AXI_RUSER                      (sr_sc_ruser          ),
    .S_AXI_RVALID                     (sr_sc_rvalid         ),
    .S_AXI_RREADY                     (sr_sc_rready         ),
    .S_AXI_AWREGION                   ({C_NUM_SLAVE_SLOTS{4'b0}}),  // SI has no REGION ports
    .S_AXI_ARREGION                   ({C_NUM_SLAVE_SLOTS{4'b0}}),  // SI has no REGION ports
    .M_AXI_ACLK                       ({C_NUM_SLAVE_SLOTS{INTERCONNECT_ACLK}}),
    .M_AXI_AWID                       (sc_sf_awid           ),
    .M_AXI_AWADDR                     (sc_sf_awaddr         ),
    .M_AXI_AWLEN                      (sc_sf_awlen          ),
    .M_AXI_AWSIZE                     (sc_sf_awsize         ),
    .M_AXI_AWBURST                    (sc_sf_awburst        ),
    .M_AXI_AWLOCK                     (sc_sf_awlock         ),
    .M_AXI_AWCACHE                    (sc_sf_awcache        ),
    .M_AXI_AWPROT                     (sc_sf_awprot         ),
    .M_AXI_AWREGION                   (                     ),  // SI has no REGION ports
    .M_AXI_AWQOS                      (sc_sf_awqos          ),
    .M_AXI_AWUSER                     (sc_sf_awuser         ),
    .M_AXI_AWVALID                    (sc_sf_awvalid        ),
    .M_AXI_AWREADY                    (sc_sf_awready        ),
    .M_AXI_WDATA                      (sc_sf_wdata          ),
    .M_AXI_WSTRB                      (sc_sf_wstrb          ),
    .M_AXI_WLAST                      (sc_sf_wlast          ),
    .M_AXI_WUSER                      (sc_sf_wuser          ),
    .M_AXI_WVALID                     (sc_sf_wvalid         ),
    .M_AXI_WREADY                     (sc_sf_wready         ),
    .M_AXI_BID                        (sc_sf_bid            ),
    .M_AXI_BRESP                      (sc_sf_bresp          ),
    .M_AXI_BUSER                      (sc_sf_buser          ),
    .M_AXI_BVALID                     (sc_sf_bvalid         ),
    .M_AXI_BREADY                     (sc_sf_bready         ),
    .M_AXI_ARID                       (sc_sf_arid           ),
    .M_AXI_ARADDR                     (sc_sf_araddr         ),
    .M_AXI_ARLEN                      (sc_sf_arlen          ),
    .M_AXI_ARSIZE                     (sc_sf_arsize         ),
    .M_AXI_ARBURST                    (sc_sf_arburst        ),
    .M_AXI_ARLOCK                     (sc_sf_arlock         ),
    .M_AXI_ARCACHE                    (sc_sf_arcache        ),
    .M_AXI_ARPROT                     (sc_sf_arprot         ),
    .M_AXI_ARREGION                   (                     ),  // SI has no REGION ports
    .M_AXI_ARQOS                      (sc_sf_arqos          ),
    .M_AXI_ARUSER                     (sc_sf_aruser         ),
    .M_AXI_ARVALID                    (sc_sf_arvalid        ),
    .M_AXI_ARREADY                    (sc_sf_arready        ),
    .M_AXI_RID                        (sc_sf_rid            ),
    .M_AXI_RDATA                      (sc_sf_rdata          ),
    .M_AXI_RRESP                      (sc_sf_rresp          ),
    .M_AXI_RLAST                      (sc_sf_rlast          ),
    .M_AXI_RUSER                      (sc_sf_ruser          ),
    .M_AXI_RVALID                     (sc_sf_rvalid         ),
    .M_AXI_RREADY                     (sc_sf_rready         )
  );

  axi_interconnect_v1_7_13_converter_bank #
  (
    .C_FAMILY                         (P_FAMILY),
    .C_NUM_SLOTS                (C_NUM_MASTER_SLOTS),
    .C_AXI_ID_WIDTH                 (P_M_AXI_ID_WIDTH),
    .C_AXI_ID_MAX_WIDTH                 (C_AXI_ID_WIDTH),
    .C_AXI_ADDR_WIDTH                 (C_AXI_ADDR_WIDTH),
    .C_AXI_DATA_MAX_WIDTH           (C_AXI_DATA_MAX_WIDTH),
    .C_S_AXI_DATA_WIDTH               ({C_NUM_MASTER_SLOTS{f_bit32_qual(C_INTERCONNECT_DATA_WIDTH,1,0)}}),
    .C_M_AXI_DATA_WIDTH               (C_M_AXI_DATA_WIDTH),
    .C_AXI_PROTOCOL                 (C_M_AXI_PROTOCOL),
    .C_AXI_IS_ACLK_ASYNC            (C_M_AXI_IS_ACLK_ASYNC),
    .C_S_AXI_ACLK_RATIO               ({C_NUM_MASTER_SLOTS{f_bit32_qual(C_INTERCONNECT_ACLK_RATIO,1,0)}}),
    .C_M_AXI_ACLK_RATIO               (C_M_AXI_ACLK_RATIO),
    .C_AXI_SUPPORTS_WRITE           (C_M_AXI_SUPPORTS_WRITE),
    .C_AXI_SUPPORTS_READ            (C_M_AXI_SUPPORTS_READ),
    .C_AXI_SUPPORTS_USER_SIGNALS      (C_AXI_SUPPORTS_USER_SIGNALS),
    .C_AXI_AWUSER_WIDTH               (C_AXI_AWUSER_WIDTH),
    .C_AXI_ARUSER_WIDTH               (C_AXI_ARUSER_WIDTH),
    .C_AXI_WUSER_WIDTH                (C_AXI_WUSER_WIDTH),
    .C_AXI_RUSER_WIDTH                (C_AXI_RUSER_WIDTH),
    .C_AXI_BUSER_WIDTH                (C_AXI_BUSER_WIDTH),
    .C_SYNCHRONIZER_STAGE             (C_SYNCHRONIZER_STAGE),
    .C_HEMISPHERE                   ("mi")
  )
  mi_converter_bank 
  (
    .INTERCONNECT_ACLK                (INTERCONNECT_ACLK),
    .INTERCONNECT_ARESETN             (INTERCONNECT_ARESETN),
    .LOCAL_ARESETN                    (interconnect_aresetn_i),
    .INTERCONNECT_RESET_OUT_N         (),
    .S_AXI_RESET_OUT_N                (),
    .M_AXI_RESET_OUT_N                (m_axi_reset_out_n_i),
    .S_AXI_ACLK                       ({C_NUM_MASTER_SLOTS{INTERCONNECT_ACLK}}),
    .S_AXI_AWID                       (mf_mc_awid           ),
    .S_AXI_AWADDR                     (mf_mc_awaddr         ),
    .S_AXI_AWLEN                      (mf_mc_awlen          ),
    .S_AXI_AWSIZE                     (mf_mc_awsize         ),
    .S_AXI_AWBURST                    (mf_mc_awburst        ),
    .S_AXI_AWLOCK                     (mf_mc_awlock         ),
    .S_AXI_AWCACHE                    (mf_mc_awcache        ),
    .S_AXI_AWPROT                     (mf_mc_awprot         ),
    .S_AXI_AWREGION                   (mf_mc_awregion       ),
    .S_AXI_AWQOS                      (mf_mc_awqos          ),
    .S_AXI_AWUSER                     (mf_mc_awuser         ),
    .S_AXI_AWVALID                    (mf_mc_awvalid        ),
    .S_AXI_AWREADY                    (mf_mc_awready        ),
    .S_AXI_WDATA                      (mf_mc_wdata          ),
    .S_AXI_WSTRB                      (mf_mc_wstrb          ),
    .S_AXI_WLAST                      (mf_mc_wlast          ),
    .S_AXI_WUSER                      (mf_mc_wuser          ),
    .S_AXI_WVALID                     (mf_mc_wvalid         ),
    .S_AXI_WREADY                     (mf_mc_wready         ),
    .S_AXI_BID                        (mf_mc_bid            ),
    .S_AXI_BRESP                      (mf_mc_bresp          ),
    .S_AXI_BUSER                      (mf_mc_buser          ),
    .S_AXI_BVALID                     (mf_mc_bvalid         ),
    .S_AXI_BREADY                     (mf_mc_bready         ),
    .S_AXI_ARID                       (mf_mc_arid           ),
    .S_AXI_ARADDR                     (mf_mc_araddr         ),
    .S_AXI_ARLEN                      (mf_mc_arlen          ),
    .S_AXI_ARSIZE                     (mf_mc_arsize         ),
    .S_AXI_ARBURST                    (mf_mc_arburst        ),
    .S_AXI_ARLOCK                     (mf_mc_arlock         ),
    .S_AXI_ARCACHE                    (mf_mc_arcache        ),
    .S_AXI_ARPROT                     (mf_mc_arprot         ),
    .S_AXI_ARREGION                   (mf_mc_arregion       ),
    .S_AXI_ARQOS                      (mf_mc_arqos          ),
    .S_AXI_ARUSER                     (mf_mc_aruser         ),
    .S_AXI_ARVALID                    (mf_mc_arvalid        ),
    .S_AXI_ARREADY                    (mf_mc_arready        ),
    .S_AXI_RID                        (mf_mc_rid            ),
    .S_AXI_RDATA                      (mf_mc_rdata          ),
    .S_AXI_RRESP                      (mf_mc_rresp          ),
    .S_AXI_RLAST                      (mf_mc_rlast          ),
    .S_AXI_RUSER                      (mf_mc_ruser          ),
    .S_AXI_RVALID                     (mf_mc_rvalid         ),
    .S_AXI_RREADY                     (mf_mc_rready         ),
    .M_AXI_ACLK                       (M_AXI_ACLK           ),
    .M_AXI_AWID                       (mc_mp_awid           ),
    .M_AXI_AWADDR                     (mc_mp_awaddr         ),
    .M_AXI_AWLEN                      (mc_mp_awlen          ),
    .M_AXI_AWSIZE                     (mc_mp_awsize         ),
    .M_AXI_AWBURST                    (mc_mp_awburst        ),
    .M_AXI_AWLOCK                     (mc_mp_awlock         ),
    .M_AXI_AWCACHE                    (mc_mp_awcache        ),
    .M_AXI_AWPROT                     (mc_mp_awprot         ),
    .M_AXI_AWREGION                   (mc_mp_awregion       ),
    .M_AXI_AWQOS                      (mc_mp_awqos          ),
    .M_AXI_AWUSER                     (mc_mp_awuser         ),
    .M_AXI_AWVALID                    (mc_mp_awvalid        ),
    .M_AXI_AWREADY                    (mc_mp_awready        ),
    .M_AXI_WDATA                      (mc_mp_wdata          ),
    .M_AXI_WSTRB                      (mc_mp_wstrb          ),
    .M_AXI_WLAST                      (mc_mp_wlast          ),
    .M_AXI_WUSER                      (mc_mp_wuser          ),
    .M_AXI_WVALID                     (mc_mp_wvalid         ),
    .M_AXI_WREADY                     (mc_mp_wready         ),
    .M_AXI_BID                        (mc_mp_bid            ),
    .M_AXI_BRESP                      (mc_mp_bresp          ),
    .M_AXI_BUSER                      (mc_mp_buser          ),
    .M_AXI_BVALID                     (mc_mp_bvalid         ),
    .M_AXI_BREADY                     (mc_mp_bready         ),
    .M_AXI_ARID                       (mc_mp_arid           ),
    .M_AXI_ARADDR                     (mc_mp_araddr         ),
    .M_AXI_ARLEN                      (mc_mp_arlen          ),
    .M_AXI_ARSIZE                     (mc_mp_arsize         ),
    .M_AXI_ARBURST                    (mc_mp_arburst        ),
    .M_AXI_ARLOCK                     (mc_mp_arlock         ),
    .M_AXI_ARCACHE                    (mc_mp_arcache        ),
    .M_AXI_ARPROT                     (mc_mp_arprot         ),
    .M_AXI_ARREGION                   (mc_mp_arregion       ),
    .M_AXI_ARQOS                      (mc_mp_arqos          ),
    .M_AXI_ARUSER                     (mc_mp_aruser         ),
    .M_AXI_ARVALID                    (mc_mp_arvalid        ),
    .M_AXI_ARREADY                    (mc_mp_arready        ),
    .M_AXI_RID                        (mc_mp_rid            ),
    .M_AXI_RDATA                      (mc_mp_rdata          ),
    .M_AXI_RRESP                      (mc_mp_rresp          ),
    .M_AXI_RLAST                      (mc_mp_rlast          ),
    .M_AXI_RUSER                      (mc_mp_ruser          ),
    .M_AXI_RVALID                     (mc_mp_rvalid         ),
    .M_AXI_RREADY                     (mc_mp_rready         )
  );

  axi_interconnect_v1_7_13_data_fifo_bank #
  (
    .C_FAMILY                         (P_FAMILY),
    .C_NUM_SLOTS                (C_NUM_SLAVE_SLOTS),
    .C_AXI_ID_WIDTH                 (P_S_AXI_ID_WIDTH_MAX1),
    .C_AXI_ID_MAX_WIDTH                 (C_AXI_ID_WIDTH),
    .C_AXI_ADDR_WIDTH                 (C_AXI_ADDR_WIDTH),
    .C_AXI_DATA_MAX_WIDTH           (C_AXI_DATA_MAX_WIDTH),
    .C_AXI_DATA_WIDTH               ({C_NUM_SLAVE_SLOTS{f_bit32_qual(C_INTERCONNECT_DATA_WIDTH,1,0)}}),
    .C_AXI_SUPPORTS_WRITE           (C_S_AXI_SUPPORTS_WRITE),
    .C_AXI_SUPPORTS_READ            (C_S_AXI_SUPPORTS_READ),
    .C_AXI_SUPPORTS_USER_SIGNALS      (C_AXI_SUPPORTS_USER_SIGNALS),
    .C_AXI_AWUSER_WIDTH               (C_AXI_AWUSER_WIDTH),
    .C_AXI_ARUSER_WIDTH               (C_AXI_ARUSER_WIDTH),
    .C_AXI_WUSER_WIDTH                (C_AXI_WUSER_WIDTH),
    .C_AXI_RUSER_WIDTH                (C_AXI_RUSER_WIDTH),
    .C_AXI_BUSER_WIDTH                (C_AXI_BUSER_WIDTH),
    .C_AXI_WRITE_FIFO_DEPTH         (C_S_AXI_WRITE_FIFO_DEPTH),
    .C_AXI_WRITE_FIFO_TYPE          (C_S_AXI_WRITE_FIFO_TYPE),
    .C_AXI_WRITE_FIFO_DELAY         (C_S_AXI_WRITE_FIFO_DELAY),
    .C_AXI_READ_FIFO_DEPTH          (C_S_AXI_READ_FIFO_DEPTH),
    .C_AXI_READ_FIFO_TYPE           (C_S_AXI_READ_FIFO_TYPE),
    .C_AXI_READ_FIFO_DELAY          (C_S_AXI_READ_FIFO_DELAY)
  )
  si_data_fifo_bank 
  (
    .ARESETN                          (interconnect_aresetn_i),
    .ACLK                             (INTERCONNECT_ACLK),
    .S_AXI_AWID                       (sc_sf_awid           ),
    .S_AXI_AWADDR                     (sc_sf_awaddr         ),
    .S_AXI_AWLEN                      (sc_sf_awlen          ),
    .S_AXI_AWSIZE                     (sc_sf_awsize         ),
    .S_AXI_AWBURST                    (sc_sf_awburst        ),
    .S_AXI_AWLOCK                     (sc_sf_awlock         ),
    .S_AXI_AWCACHE                    (sc_sf_awcache        ),
    .S_AXI_AWPROT                     (sc_sf_awprot         ),
    .S_AXI_AWQOS                      (sc_sf_awqos          ),
    .S_AXI_AWUSER                     (sc_sf_awuser         ),
    .S_AXI_AWVALID                    (sc_sf_awvalid        ),
    .S_AXI_AWREADY                    (sc_sf_awready        ),
    .S_AXI_WDATA                      (sc_sf_wdata          ),
    .S_AXI_WSTRB                      (sc_sf_wstrb          ),
    .S_AXI_WLAST                      (sc_sf_wlast          ),
    .S_AXI_WUSER                      (sc_sf_wuser          ),
    .S_AXI_WVALID                     (sc_sf_wvalid         ),
    .S_AXI_WREADY                     (sc_sf_wready         ),
    .S_AXI_BID                        (sc_sf_bid            ),
    .S_AXI_BRESP                      (sc_sf_bresp          ),
    .S_AXI_BUSER                      (sc_sf_buser          ),
    .S_AXI_BVALID                     (sc_sf_bvalid         ),
    .S_AXI_BREADY                     (sc_sf_bready         ),
    .S_AXI_ARID                       (sc_sf_arid           ),
    .S_AXI_ARADDR                     (sc_sf_araddr         ),
    .S_AXI_ARLEN                      (sc_sf_arlen          ),
    .S_AXI_ARSIZE                     (sc_sf_arsize         ),
    .S_AXI_ARBURST                    (sc_sf_arburst        ),
    .S_AXI_ARLOCK                     (sc_sf_arlock         ),
    .S_AXI_ARCACHE                    (sc_sf_arcache        ),
    .S_AXI_ARPROT                     (sc_sf_arprot         ),
    .S_AXI_ARQOS                      (sc_sf_arqos          ),
    .S_AXI_ARUSER                     (sc_sf_aruser         ),
    .S_AXI_ARVALID                    (sc_sf_arvalid        ),
    .S_AXI_ARREADY                    (sc_sf_arready        ),
    .S_AXI_RID                        (sc_sf_rid            ),
    .S_AXI_RDATA                      (sc_sf_rdata          ),
    .S_AXI_RRESP                      (sc_sf_rresp          ),
    .S_AXI_RLAST                      (sc_sf_rlast          ),
    .S_AXI_RUSER                      (sc_sf_ruser          ),
    .S_AXI_RVALID                     (sc_sf_rvalid         ),
    .S_AXI_RREADY                     (sc_sf_rready         ),
    .S_AXI_AWREGION                   ({C_NUM_SLAVE_SLOTS{4'b0}}),  // SI has no REGION ports
    .S_AXI_ARREGION                   ({C_NUM_SLAVE_SLOTS{4'b0}}),  // SI has no REGION ports
    .M_AXI_AWID                       (sf_cb_awid           ),
    .M_AXI_AWADDR                     (sf_cb_awaddr         ),
    .M_AXI_AWLEN                      (sf_cb_awlen          ),
    .M_AXI_AWSIZE                     (sf_cb_awsize         ),
    .M_AXI_AWBURST                    (sf_cb_awburst        ),
    .M_AXI_AWLOCK                     (sf_cb_awlock         ),
    .M_AXI_AWCACHE                    (sf_cb_awcache        ),
    .M_AXI_AWPROT                     (sf_cb_awprot         ),
    .M_AXI_AWREGION                   (                     ),  // SI has no REGION ports
    .M_AXI_AWQOS                      (sf_cb_awqos          ),
    .M_AXI_AWUSER                     (sf_cb_awuser         ),
    .M_AXI_AWVALID                    (sf_cb_awvalid        ),
    .M_AXI_AWREADY                    (sf_cb_awready        ),
    .M_AXI_WDATA                      (sf_cb_wdata          ),
    .M_AXI_WSTRB                      (sf_cb_wstrb          ),
    .M_AXI_WLAST                      (sf_cb_wlast          ),
    .M_AXI_WUSER                      (sf_cb_wuser          ),
    .M_AXI_WVALID                     (sf_cb_wvalid         ),
    .M_AXI_WREADY                     (sf_cb_wready         ),
    .M_AXI_BID                        (sf_cb_bid            ),
    .M_AXI_BRESP                      (sf_cb_bresp          ),
    .M_AXI_BUSER                      (sf_cb_buser          ),
    .M_AXI_BVALID                     (sf_cb_bvalid         ),
    .M_AXI_BREADY                     (sf_cb_bready         ),
    .M_AXI_ARID                       (sf_cb_arid           ),
    .M_AXI_ARADDR                     (sf_cb_araddr         ),
    .M_AXI_ARLEN                      (sf_cb_arlen          ),
    .M_AXI_ARSIZE                     (sf_cb_arsize         ),
    .M_AXI_ARBURST                    (sf_cb_arburst        ),
    .M_AXI_ARLOCK                     (sf_cb_arlock         ),
    .M_AXI_ARCACHE                    (sf_cb_arcache        ),
    .M_AXI_ARPROT                     (sf_cb_arprot         ),
    .M_AXI_ARREGION                   (                     ),  // SI has no REGION ports
    .M_AXI_ARQOS                      (sf_cb_arqos          ),
    .M_AXI_ARUSER                     (sf_cb_aruser         ),
    .M_AXI_ARVALID                    (sf_cb_arvalid        ),
    .M_AXI_ARREADY                    (sf_cb_arready        ),
    .M_AXI_RID                        (sf_cb_rid            ),
    .M_AXI_RDATA                      (sf_cb_rdata          ),
    .M_AXI_RRESP                      (sf_cb_rresp          ),
    .M_AXI_RLAST                      (sf_cb_rlast          ),
    .M_AXI_RUSER                      (sf_cb_ruser          ),
    .M_AXI_RVALID                     (sf_cb_rvalid         ),
    .M_AXI_RREADY                     (sf_cb_rready         )
  );

  axi_interconnect_v1_7_13_data_fifo_bank #
  (
    .C_FAMILY                         (P_FAMILY),
    .C_NUM_SLOTS                (C_NUM_MASTER_SLOTS),
    .C_AXI_ID_WIDTH                 (P_M_AXI_ID_WIDTH),
    .C_AXI_ID_MAX_WIDTH                 (C_AXI_ID_WIDTH),
    .C_AXI_ADDR_WIDTH                 (C_AXI_ADDR_WIDTH),
    .C_AXI_DATA_MAX_WIDTH           (C_AXI_DATA_MAX_WIDTH),
    .C_AXI_DATA_WIDTH               ({C_NUM_MASTER_SLOTS{f_bit32_qual(C_INTERCONNECT_DATA_WIDTH,1,0)}}),
    .C_AXI_SUPPORTS_WRITE           (C_M_AXI_SUPPORTS_WRITE),
    .C_AXI_SUPPORTS_READ            (C_M_AXI_SUPPORTS_READ),
    .C_AXI_SUPPORTS_USER_SIGNALS      (C_AXI_SUPPORTS_USER_SIGNALS),
    .C_AXI_AWUSER_WIDTH               (C_AXI_AWUSER_WIDTH),
    .C_AXI_ARUSER_WIDTH               (C_AXI_ARUSER_WIDTH),
    .C_AXI_WUSER_WIDTH                (C_AXI_WUSER_WIDTH),
    .C_AXI_RUSER_WIDTH                (C_AXI_RUSER_WIDTH),
    .C_AXI_BUSER_WIDTH                (C_AXI_BUSER_WIDTH),
    .C_AXI_WRITE_FIFO_DEPTH         (C_M_AXI_WRITE_FIFO_DEPTH),
    .C_AXI_WRITE_FIFO_TYPE          (C_M_AXI_WRITE_FIFO_TYPE),
    .C_AXI_WRITE_FIFO_DELAY         (C_M_AXI_WRITE_FIFO_DELAY),
    .C_AXI_READ_FIFO_DEPTH          (C_M_AXI_READ_FIFO_DEPTH),
    .C_AXI_READ_FIFO_TYPE           (C_M_AXI_READ_FIFO_TYPE),
    .C_AXI_READ_FIFO_DELAY          (C_M_AXI_READ_FIFO_DELAY)
  )
  mi_data_fifo_bank 
  (
    .ARESETN                          (interconnect_aresetn_i),
    .ACLK                             (INTERCONNECT_ACLK),
    .S_AXI_AWID                       (cb_mf_awid           ),
    .S_AXI_AWADDR                     (cb_mf_awaddr         ),
    .S_AXI_AWLEN                      (cb_mf_awlen          ),
    .S_AXI_AWSIZE                     (cb_mf_awsize         ),
    .S_AXI_AWBURST                    (cb_mf_awburst        ),
    .S_AXI_AWLOCK                     (cb_mf_awlock         ),
    .S_AXI_AWCACHE                    (cb_mf_awcache        ),
    .S_AXI_AWPROT                     (cb_mf_awprot         ),
    .S_AXI_AWREGION                   (cb_mf_awregion       ),
    .S_AXI_AWQOS                      (cb_mf_awqos          ),
    .S_AXI_AWUSER                     (cb_mf_awuser         ),
    .S_AXI_AWVALID                    (cb_mf_awvalid        ),
    .S_AXI_AWREADY                    (cb_mf_awready        ),
    .S_AXI_WDATA                      (cb_mf_wdata          ),
    .S_AXI_WSTRB                      (cb_mf_wstrb          ),
    .S_AXI_WLAST                      (cb_mf_wlast          ),
    .S_AXI_WUSER                      (cb_mf_wuser          ),
    .S_AXI_WVALID                     (cb_mf_wvalid         ),
    .S_AXI_WREADY                     (cb_mf_wready         ),
    .S_AXI_BID                        (cb_mf_bid            ),
    .S_AXI_BRESP                      (cb_mf_bresp          ),
    .S_AXI_BUSER                      (cb_mf_buser          ),
    .S_AXI_BVALID                     (cb_mf_bvalid         ),
    .S_AXI_BREADY                     (cb_mf_bready         ),
    .S_AXI_ARID                       (cb_mf_arid           ),
    .S_AXI_ARADDR                     (cb_mf_araddr         ),
    .S_AXI_ARLEN                      (cb_mf_arlen          ),
    .S_AXI_ARSIZE                     (cb_mf_arsize         ),
    .S_AXI_ARBURST                    (cb_mf_arburst        ),
    .S_AXI_ARLOCK                     (cb_mf_arlock         ),
    .S_AXI_ARCACHE                    (cb_mf_arcache        ),
    .S_AXI_ARPROT                     (cb_mf_arprot         ),
    .S_AXI_ARREGION                   (cb_mf_arregion       ),
    .S_AXI_ARQOS                      (cb_mf_arqos          ),
    .S_AXI_ARUSER                     (cb_mf_aruser         ),
    .S_AXI_ARVALID                    (cb_mf_arvalid        ),
    .S_AXI_ARREADY                    (cb_mf_arready        ),
    .S_AXI_RID                        (cb_mf_rid            ),
    .S_AXI_RDATA                      (cb_mf_rdata          ),
    .S_AXI_RRESP                      (cb_mf_rresp          ),
    .S_AXI_RLAST                      (cb_mf_rlast          ),
    .S_AXI_RUSER                      (cb_mf_ruser          ),
    .S_AXI_RVALID                     (cb_mf_rvalid         ),
    .S_AXI_RREADY                     (cb_mf_rready         ),
    .M_AXI_AWID                       (mf_mc_awid           ),
    .M_AXI_AWADDR                     (mf_mc_awaddr         ),
    .M_AXI_AWLEN                      (mf_mc_awlen          ),
    .M_AXI_AWSIZE                     (mf_mc_awsize         ),
    .M_AXI_AWBURST                    (mf_mc_awburst        ),
    .M_AXI_AWLOCK                     (mf_mc_awlock         ),
    .M_AXI_AWCACHE                    (mf_mc_awcache        ),
    .M_AXI_AWPROT                     (mf_mc_awprot         ),
    .M_AXI_AWREGION                   (mf_mc_awregion       ),
    .M_AXI_AWQOS                      (mf_mc_awqos          ),
    .M_AXI_AWUSER                     (mf_mc_awuser         ),
    .M_AXI_AWVALID                    (mf_mc_awvalid        ),
    .M_AXI_AWREADY                    (mf_mc_awready        ),
    .M_AXI_WDATA                      (mf_mc_wdata          ),
    .M_AXI_WSTRB                      (mf_mc_wstrb          ),
    .M_AXI_WLAST                      (mf_mc_wlast          ),
    .M_AXI_WUSER                      (mf_mc_wuser          ),
    .M_AXI_WVALID                     (mf_mc_wvalid         ),
    .M_AXI_WREADY                     (mf_mc_wready         ),
    .M_AXI_BID                        (mf_mc_bid            ),
    .M_AXI_BRESP                      (mf_mc_bresp          ),
    .M_AXI_BUSER                      (mf_mc_buser          ),
    .M_AXI_BVALID                     (mf_mc_bvalid         ),
    .M_AXI_BREADY                     (mf_mc_bready         ),
    .M_AXI_ARID                       (mf_mc_arid           ),
    .M_AXI_ARADDR                     (mf_mc_araddr         ),
    .M_AXI_ARLEN                      (mf_mc_arlen          ),
    .M_AXI_ARSIZE                     (mf_mc_arsize         ),
    .M_AXI_ARBURST                    (mf_mc_arburst        ),
    .M_AXI_ARLOCK                     (mf_mc_arlock         ),
    .M_AXI_ARCACHE                    (mf_mc_arcache        ),
    .M_AXI_ARPROT                     (mf_mc_arprot         ),
    .M_AXI_ARREGION                   (mf_mc_arregion       ),
    .M_AXI_ARQOS                      (mf_mc_arqos          ),
    .M_AXI_ARUSER                     (mf_mc_aruser         ),
    .M_AXI_ARVALID                    (mf_mc_arvalid        ),
    .M_AXI_ARREADY                    (mf_mc_arready        ),
    .M_AXI_RID                        (mf_mc_rid            ),
    .M_AXI_RDATA                      (mf_mc_rdata          ),
    .M_AXI_RRESP                      (mf_mc_rresp          ),
    .M_AXI_RLAST                      (mf_mc_rlast          ),
    .M_AXI_RUSER                      (mf_mc_ruser          ),
    .M_AXI_RVALID                     (mf_mc_rvalid         ),
    .M_AXI_RREADY                     (mf_mc_rready         )
  );



  axi_interconnect_v1_7_13_axi_crossbar #(
    .C_MAX_S                          (`P_MAX_S),
    .C_MAX_M                          (`P_MAX_M),
    .C_NUM_ADDR_RANGES                (`P_NUM_ADDR_RANGES),
    .C_INTERCONNECT_CONNECTIVITY_MODE (C_INTERCONNECT_CONNECTIVITY_MODE),
    .C_FAMILY                         (P_FAMILY),
    .C_NUM_SLAVE_SLOTS                (C_NUM_SLAVE_SLOTS),
    .C_NUM_MASTER_SLOTS               (C_NUM_MASTER_SLOTS),
    .C_AXI_ID_WIDTH                   (C_AXI_ID_WIDTH),
    .C_AXI_ADDR_WIDTH                 (C_AXI_ADDR_WIDTH),
    .C_INTERCONNECT_DATA_WIDTH        (C_INTERCONNECT_DATA_WIDTH),
    .C_AXI_DATA_MAX_WIDTH             (C_AXI_DATA_MAX_WIDTH),
    .C_M_AXI_DATA_WIDTH               (C_M_AXI_DATA_WIDTH),  // Used to determine whether W-channel gets reg-slice
    .C_S_AXI_PROTOCOL                 (C_S_AXI_PROTOCOL),
    .C_M_AXI_PROTOCOL                 (C_M_AXI_PROTOCOL),
    .C_M_AXI_BASE_ADDR                (C_M_AXI_BASE_ADDR),
    .C_M_AXI_HIGH_ADDR                (C_M_AXI_HIGH_ADDR),
    .C_S_AXI_BASE_ID                  (P_S_AXI_BASE_ID),
    .C_S_AXI_HIGH_ID                  (P_S_AXI_HIGH_ID),
    .C_S_AXI_THREAD_ID_WIDTH          (C_S_AXI_THREAD_ID_WIDTH),
    .C_S_AXI_IS_INTERCONNECT          (C_S_AXI_IS_INTERCONNECT),
    .C_S_AXI_SUPPORTS_WRITE           (C_S_AXI_SUPPORTS_WRITE),
    .C_S_AXI_SUPPORTS_READ            (C_S_AXI_SUPPORTS_READ),
    .C_M_AXI_SUPPORTS_WRITE           (C_M_AXI_SUPPORTS_WRITE),
    .C_M_AXI_SUPPORTS_READ            (C_M_AXI_SUPPORTS_READ),
    .C_AXI_SUPPORTS_USER_SIGNALS      (C_AXI_SUPPORTS_USER_SIGNALS),
    .C_AXI_AWUSER_WIDTH               (C_AXI_AWUSER_WIDTH),
    .C_AXI_ARUSER_WIDTH               (C_AXI_ARUSER_WIDTH),
    .C_AXI_WUSER_WIDTH                (C_AXI_WUSER_WIDTH),
    .C_AXI_RUSER_WIDTH                (C_AXI_RUSER_WIDTH),
    .C_AXI_BUSER_WIDTH                (C_AXI_BUSER_WIDTH),
    .C_AXI_CONNECTIVITY               (C_AXI_CONNECTIVITY),
    .C_S_AXI_SINGLE_THREAD            (C_S_AXI_SINGLE_THREAD),
    .C_M_AXI_SUPPORTS_REORDERING      (C_M_AXI_SUPPORTS_REORDERING),
    .C_S_AXI_WRITE_ACCEPTANCE         (C_S_AXI_WRITE_ACCEPTANCE),
    .C_S_AXI_READ_ACCEPTANCE          (C_S_AXI_READ_ACCEPTANCE),
    .C_M_AXI_WRITE_ISSUING            (C_M_AXI_WRITE_ISSUING),
    .C_M_AXI_READ_ISSUING             (C_M_AXI_READ_ISSUING),
//    .C_S_AXI_ARB_METHOD               (C_S_AXI_ARB_METHOD), // Reserved for future
    .C_S_AXI_ARB_PRIORITY             (C_S_AXI_ARB_PRIORITY),
//    .C_S_AXI_ARB_TDM_SLOTS            (C_S_AXI_ARB_TDM_SLOTS), // Reserved for future
//    .C_S_AXI_ARB_TDM_TOTAL            (C_S_AXI_ARB_TDM_TOTAL), // Reserved for future
    .C_M_AXI_SECURE                   (C_M_AXI_SECURE),
    .C_USE_CTRL_PORT                  (C_USE_CTRL_PORT),
    .C_USE_INTERRUPT                  (C_USE_INTERRUPT),
    .C_RANGE_CHECK                    (P_RANGE_CHECK),
    .C_ADDR_DECODE                    (P_ADDR_DECODE),
    .C_INTERCONNECT_R_REGISTER        (C_INTERCONNECT_R_REGISTER),
    .C_S_AXI_CTRL_ADDR_WIDTH          (C_S_AXI_CTRL_ADDR_WIDTH),
    .C_S_AXI_CTRL_DATA_WIDTH          (C_S_AXI_CTRL_DATA_WIDTH),
    .C_W_ISSUE_WIDTH                  (f_write_issue_width_vec(0)),
    .C_R_ISSUE_WIDTH                  (f_read_issue_width_vec(0)),
    .C_W_ACCEPT_WIDTH                 (f_write_accept_width_vec(0)),
    .C_R_ACCEPT_WIDTH                 (f_read_accept_width_vec(0)),
    .C_DEBUG                          (C_DEBUG),
    .C_MAX_DEBUG_THREADS              (C_MAX_DEBUG_THREADS)
  ) crossbar_samd (
    .INTERCONNECT_ACLK                (INTERCONNECT_ACLK),
    .ARESETN                          (interconnect_aresetn_i),
    .IRQ                              (IRQ),
    .S_AXI_AWID                       (sf_cb_awid           ),
    .S_AXI_AWADDR                     (sf_cb_awaddr         ),
    .S_AXI_AWLEN                      (sf_cb_awlen          ),
    .S_AXI_AWSIZE                     (sf_cb_awsize         ),
    .S_AXI_AWBURST                    (sf_cb_awburst        ),
    .S_AXI_AWLOCK                     (sf_cb_awlock         ),
    .S_AXI_AWCACHE                    (sf_cb_awcache        ),
    .S_AXI_AWPROT                     (sf_cb_awprot         ),
    .S_AXI_AWQOS                      (sf_cb_awqos          ),
    .S_AXI_AWUSER                     (sf_cb_awuser         ),
    .S_AXI_AWVALID                    (sf_cb_awvalid        ),
    .S_AXI_AWREADY                    (sf_cb_awready        ),
    .S_AXI_WDATA                      (sf_cb_wdata          ),
    .S_AXI_WSTRB                      (sf_cb_wstrb          ),
    .S_AXI_WLAST                      (sf_cb_wlast          ),
    .S_AXI_WUSER                      (sf_cb_wuser          ),
    .S_AXI_WVALID                     (sf_cb_wvalid         ),
    .S_AXI_WREADY                     (sf_cb_wready         ),
    .S_AXI_BID                        (sf_cb_bid            ),
    .S_AXI_BRESP                      (sf_cb_bresp          ),
    .S_AXI_BUSER                      (sf_cb_buser          ),
    .S_AXI_BVALID                     (sf_cb_bvalid         ),
    .S_AXI_BREADY                     (sf_cb_bready         ),
    .S_AXI_ARID                       (sf_cb_arid           ),
    .S_AXI_ARADDR                     (sf_cb_araddr         ),
    .S_AXI_ARLEN                      (sf_cb_arlen          ),
    .S_AXI_ARSIZE                     (sf_cb_arsize         ),
    .S_AXI_ARBURST                    (sf_cb_arburst        ),
    .S_AXI_ARLOCK                     (sf_cb_arlock         ),
    .S_AXI_ARCACHE                    (sf_cb_arcache        ),
    .S_AXI_ARPROT                     (sf_cb_arprot         ),
    .S_AXI_ARQOS                      (sf_cb_arqos          ),
    .S_AXI_ARUSER                     (sf_cb_aruser         ),
    .S_AXI_ARVALID                    (sf_cb_arvalid        ),
    .S_AXI_ARREADY                    (sf_cb_arready        ),
    .S_AXI_RID                        (sf_cb_rid            ),
    .S_AXI_RDATA                      (sf_cb_rdata          ),
    .S_AXI_RRESP                      (sf_cb_rresp          ),
    .S_AXI_RLAST                      (sf_cb_rlast          ),
    .S_AXI_RUSER                      (sf_cb_ruser          ),
    .S_AXI_RVALID                     (sf_cb_rvalid         ),
    .S_AXI_RREADY                     (sf_cb_rready         ),
    .M_AXI_AWID                       (cb_mf_awid           ),
    .M_AXI_AWADDR                     (cb_mf_awaddr         ),
    .M_AXI_AWLEN                      (cb_mf_awlen          ),
    .M_AXI_AWSIZE                     (cb_mf_awsize         ),
    .M_AXI_AWBURST                    (cb_mf_awburst        ),
    .M_AXI_AWLOCK                     (cb_mf_awlock         ),
    .M_AXI_AWCACHE                    (cb_mf_awcache        ),
    .M_AXI_AWPROT                     (cb_mf_awprot         ),
    .M_AXI_AWREGION                   (cb_mf_awregion       ),
    .M_AXI_AWQOS                      (cb_mf_awqos          ),
    .M_AXI_AWUSER                     (cb_mf_awuser         ),
    .M_AXI_AWVALID                    (cb_mf_awvalid        ),
    .M_AXI_AWREADY                    (cb_mf_awready        ),
    .M_AXI_WDATA                      (cb_mf_wdata          ),
    .M_AXI_WSTRB                      (cb_mf_wstrb          ),
    .M_AXI_WLAST                      (cb_mf_wlast          ),
    .M_AXI_WUSER                      (cb_mf_wuser          ),
    .M_AXI_WVALID                     (cb_mf_wvalid         ),
    .M_AXI_WREADY                     (cb_mf_wready         ),
    .M_AXI_BID                        (cb_mf_bid            ),
    .M_AXI_BRESP                      (cb_mf_bresp          ),
    .M_AXI_BUSER                      (cb_mf_buser          ),
    .M_AXI_BVALID                     (cb_mf_bvalid         ),
    .M_AXI_BREADY                     (cb_mf_bready         ),
    .M_AXI_ARID                       (cb_mf_arid           ),
    .M_AXI_ARADDR                     (cb_mf_araddr         ),
    .M_AXI_ARLEN                      (cb_mf_arlen          ),
    .M_AXI_ARSIZE                     (cb_mf_arsize         ),
    .M_AXI_ARBURST                    (cb_mf_arburst        ),
    .M_AXI_ARLOCK                     (cb_mf_arlock         ),
    .M_AXI_ARCACHE                    (cb_mf_arcache        ),
    .M_AXI_ARPROT                     (cb_mf_arprot         ),
    .M_AXI_ARREGION                   (cb_mf_arregion       ),
    .M_AXI_ARQOS                      (cb_mf_arqos          ),
    .M_AXI_ARUSER                     (cb_mf_aruser         ),
    .M_AXI_ARVALID                    (cb_mf_arvalid        ),
    .M_AXI_ARREADY                    (cb_mf_arready        ),
    .M_AXI_RID                        (cb_mf_rid            ),
    .M_AXI_RDATA                      (cb_mf_rdata          ),
    .M_AXI_RRESP                      (cb_mf_rresp          ),
    .M_AXI_RLAST                      (cb_mf_rlast          ),
    .M_AXI_RUSER                      (cb_mf_ruser          ),
    .M_AXI_RVALID                     (cb_mf_rvalid         ),
    .M_AXI_RREADY                     (cb_mf_rready         ),
    .S_AXI_CTRL_AWADDR                (cb_ctrl_awaddr       ),
    .S_AXI_CTRL_AWVALID               (cb_ctrl_awvalid      ),
    .S_AXI_CTRL_AWREADY               (cb_ctrl_awready      ),
    .S_AXI_CTRL_WDATA                 (cb_ctrl_wdata        ),
    .S_AXI_CTRL_WVALID                (cb_ctrl_wvalid       ),
    .S_AXI_CTRL_WREADY                (cb_ctrl_wready       ),
    .S_AXI_CTRL_BRESP                 (cb_ctrl_bresp        ),
    .S_AXI_CTRL_BVALID                (cb_ctrl_bvalid       ),
    .S_AXI_CTRL_BREADY                (cb_ctrl_bready       ),
    .S_AXI_CTRL_ARADDR                (cb_ctrl_araddr       ),
    .S_AXI_CTRL_ARVALID               (cb_ctrl_arvalid      ),
    .S_AXI_CTRL_ARREADY               (cb_ctrl_arready      ),
    .S_AXI_CTRL_RDATA                 (cb_ctrl_rdata        ),
    .S_AXI_CTRL_RRESP                 (cb_ctrl_rresp        ),
    .S_AXI_CTRL_RVALID                (cb_ctrl_rvalid       ),
    .S_AXI_CTRL_RREADY                (cb_ctrl_rready       ),
    .DEBUG_AW_TRANS_SEQ               (aw_trans_seq         ),
    .DEBUG_AW_TRANS_QUAL              (aw_trans_qual        ),
    .DEBUG_AW_ACCEPT_CNT              (aw_accept_cnt        ),
    .DEBUG_AW_ACTIVE_THREAD           (aw_active_thread     ),
    .DEBUG_AW_ACTIVE_TARGET           (aw_active_target     ),
    .DEBUG_AW_ACTIVE_REGION           (aw_active_region     ),
    .DEBUG_AW_ERROR                   (aw_error             ),
    .DEBUG_AW_TARGET                  (aw_target            ),
    .DEBUG_AW_ISSUING_CNT             (aw_issuing_cnt       ),
    .DEBUG_AW_ARB_GRANT               (aw_arb_grant         ),
    .DEBUG_B_TRANS_SEQ                (b_trans_seq          ),
    .DEBUG_AR_TRANS_SEQ               (ar_trans_seq         ),
    .DEBUG_AR_TRANS_QUAL              (ar_trans_qual        ),
    .DEBUG_AR_ACCEPT_CNT              (ar_accept_cnt        ),
    .DEBUG_AR_ACTIVE_THREAD           (ar_active_thread     ),
    .DEBUG_AR_ACTIVE_TARGET           (ar_active_target     ),
    .DEBUG_AR_ACTIVE_REGION           (ar_active_region     ),
    .DEBUG_AR_ERROR                   (ar_error             ),
    .DEBUG_AR_TARGET                  (ar_target            ),
    .DEBUG_AR_ISSUING_CNT             (ar_issuing_cnt       ),
    .DEBUG_AR_ARB_GRANT               (ar_arb_grant         ),
    .DEBUG_R_BEAT_CNT                 (r_beat_cnt           ),
    .DEBUG_R_TRANS_SEQ                (r_trans_seq          ),
    .DEBUG_RID_TARGET                 (rid_target           ),
    .DEBUG_RID_ERROR                  (rid_error            ),
    .DEBUG_BID_TARGET                 (bid_target           ),
    .DEBUG_BID_ERROR                  (bid_error            ),
    .DEBUG_W_BEAT_CNT                 (w_beat_cnt           ),
    .DEBUG_W_TRANS_SEQ                (w_trans_seq          )
  );
    
  assign cb_ctrl_awaddr      = S_AXI_CTRL_AWADDR     ;
  assign cb_ctrl_awvalid     = S_AXI_CTRL_AWVALID    ;
  assign cb_ctrl_wdata       = S_AXI_CTRL_WDATA      ;
  assign cb_ctrl_wvalid      = S_AXI_CTRL_WVALID     ;
  assign cb_ctrl_bready      = S_AXI_CTRL_BREADY     ;
  assign cb_ctrl_araddr      = S_AXI_CTRL_ARADDR     ;
  assign cb_ctrl_arvalid     = S_AXI_CTRL_ARVALID    ;
  assign cb_ctrl_rready      = S_AXI_CTRL_RREADY     ;
  assign S_AXI_CTRL_AWREADY  = cb_ctrl_awready       ;
  assign S_AXI_CTRL_WREADY   = cb_ctrl_wready        ;
  assign S_AXI_CTRL_BRESP    = cb_ctrl_bresp         ;
  assign S_AXI_CTRL_BVALID   = cb_ctrl_bvalid        ;
  assign S_AXI_CTRL_ARREADY  = cb_ctrl_arready       ;
  assign S_AXI_CTRL_RDATA    = cb_ctrl_rdata         ;
  assign S_AXI_CTRL_RRESP    = cb_ctrl_rresp         ;
  assign S_AXI_CTRL_RVALID   = cb_ctrl_rvalid        ;

endmodule

`default_nettype wire


// -- (c) Copyright 2009 - 2011 Xilinx, Inc. All rights reserved.
// --
// -- This file contains confidential and proprietary information
// -- of Xilinx, Inc. and is protected under U.S. and 
// -- international copyright and other intellectual property
// -- laws.
// --
// -- DISCLAIMER
// -- This disclaimer is not a license and does not grant any
// -- rights to the materials distributed herewith. Except as
// -- otherwise provided in a valid license issued to you by
// -- Xilinx, and to the maximum extent permitted by applicable
// -- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
// -- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
// -- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
// -- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
// -- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
// -- (2) Xilinx shall not be liable (whether in contract or tort,
// -- including negligence, or under any other theory of
// -- liability) for any loss or damage of any kind or nature
// -- related to, arising under or in connection with these
// -- materials, including for any direct, or any indirect,
// -- special, incidental, or consequential loss or damage
// -- (including loss of data, profits, goodwill, or any type of
// -- loss or damage suffered as a result of any action brought
// -- by a third party) even if such damage or loss was
// -- reasonably foreseeable or Xilinx had been advised of the
// -- possibility of the same.
// --
// -- CRITICAL APPLICATIONS
// -- Xilinx products are not designed or intended to be fail-
// -- safe, or for use in any application requiring fail-safe
// -- performance, such as life-support or safety devices or
// -- systems, Class III medical devices, nuclear facilities,
// -- applications related to the deployment of airbags, or any
// -- other applications that could lead to death, personal
// -- injury, or severe property or environmental damage
// -- (individually and collectively, "Critical
// -- Applications"). Customer assumes the sole risk and
// -- liability of any use of Xilinx products in Critical
// -- Applications, subject only to applicable laws and
// -- regulations governing limitations on product liability.
// --
// -- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
// -- PART OF THIS FILE AT ALL TIMES.
//-----------------------------------------------------------------------------
//
// File name: axi_interconnect_v1_7_13_top.v
//
// Description: 
//   This is the top-level module of a N-master to 1-slave AXI Interconnect core.
//   The interface of this module consists of a set of enumerated slave and master 
//     AXI interfaces, plus a set of enumerated parameters associated with each
//     AXI interface and with the core as a whole.
//   This module concatenates the top-level AXI slave interfaces into
//     a vectored slave master interface passed to the axi_interconnect
//     module below. It also concatenates the top-level enumerated parameters 
//     associated with the slave interfaces into vectored parameters.
//
//-----------------------------------------------------------------------------
// Structure:
//   axi_interconnect_v1_7_13_top
//     axi_interconnect
//
`timescale 1ps/1ps
`default_nettype none

(* DowngradeIPIdentifiedWarnings="yes" *) 
module axi_interconnect_v1_7_13_top #
  (
   parameter         C_FAMILY                         = "rtl", 
                       // FPGA Family.
   parameter integer C_NUM_SLAVE_PORTS                = 2, 
                       // RANGE = (1:16)
                       // Number of Slave Interfaces (SI) for connecting 
                       // to master IP.
   parameter integer C_THREAD_ID_WIDTH                = 0, 
                       // Bits of ID signals sampled at each SI (global).
                       // RANGE = (0:8)
   parameter integer C_THREAD_ID_PORT_WIDTH           = 1, 
                       // RANGE = (1:8)
                       // Width of ID ports on each SI (global).
   parameter integer C_AXI_ADDR_WIDTH                 = 32, 
                       // RANGE = (12:64)
                       // Width of S_AXI_AWADDR, S_AXI_ARADDR, M_AXI_AWADDR and 
                       // M_AXI_ARADDR for every SI/MI.
   parameter integer C_SYNCHRONIZER_STAGE             = 3,
   parameter integer C_S00_AXI_DATA_WIDTH             = 32, 
                       // RANGE = (32, 64, 128, 256, 512, 1024)
   parameter integer C_S01_AXI_DATA_WIDTH             = 32, 
                       // RANGE = (32, 64, 128, 256, 512, 1024)
   parameter integer C_S02_AXI_DATA_WIDTH             = 32, 
                       // RANGE = (32, 64, 128, 256, 512, 1024)
   parameter integer C_S03_AXI_DATA_WIDTH             = 32, 
                       // RANGE = (32, 64, 128, 256, 512, 1024)
   parameter integer C_S04_AXI_DATA_WIDTH             = 32, 
                       // RANGE = (32, 64, 128, 256, 512, 1024)
   parameter integer C_S05_AXI_DATA_WIDTH             = 32, 
                       // RANGE = (32, 64, 128, 256, 512, 1024)
   parameter integer C_S06_AXI_DATA_WIDTH             = 32, 
                       // RANGE = (32, 64, 128, 256, 512, 1024)
   parameter integer C_S07_AXI_DATA_WIDTH             = 32, 
                       // RANGE = (32, 64, 128, 256, 512, 1024)
   parameter integer C_S08_AXI_DATA_WIDTH             = 32, 
                       // RANGE = (32, 64, 128, 256, 512, 1024)
   parameter integer C_S09_AXI_DATA_WIDTH             = 32, 
                       // RANGE = (32, 64, 128, 256, 512, 1024)
   parameter integer C_S10_AXI_DATA_WIDTH             = 32, 
                       // RANGE = (32, 64, 128, 256, 512, 1024)
   parameter integer C_S11_AXI_DATA_WIDTH             = 32, 
                       // RANGE = (32, 64, 128, 256, 512, 1024)
   parameter integer C_S12_AXI_DATA_WIDTH             = 32, 
                       // RANGE = (32, 64, 128, 256, 512, 1024)
   parameter integer C_S13_AXI_DATA_WIDTH             = 32, 
                       // RANGE = (32, 64, 128, 256, 512, 1024)
   parameter integer C_S14_AXI_DATA_WIDTH             = 32, 
                       // RANGE = (32, 64, 128, 256, 512, 1024)
   parameter integer C_S15_AXI_DATA_WIDTH             = 32, 
                       // RANGE = (32, 64, 128, 256, 512, 1024)
                       // Width of WDATA and RDATA per SI.
   parameter integer C_M00_AXI_DATA_WIDTH               = 32, 
                       // RANGE = (32, 64, 128, 256, 512, 1024)
                       // Width of WDATA and RDATA on MI.
   parameter integer C_INTERCONNECT_DATA_WIDTH        = 32, 
                       // RANGE = (32, 64, 128, 256, 512, 1024)
                       // Data width of the internal interconnect write and read 
                       // data paths.
   parameter         C_S00_AXI_ACLK_RATIO             = "1:1", 
                       // VALUES = ("1:16", "1:15", "1:14", "1:13", "1:12", "1:11", "1:10", "1:9", "1:8", "1:7", "1:6", "1:5", "1:4", "1:3", "1:2", "1:1", "2:1", "3:1", "4:1", "5:1", "6:1", "7:1", "8:1", "9:1", "10:1", "11:1", "12:1", "13:1", "14:1", "15:1", "16:1")
                       // ISVALID = (C_S00_AXI_IS_ACLK_ASYNC == 0)
   parameter         C_S01_AXI_ACLK_RATIO             = "1:1", 
                       // VALUES = ("1:16", "1:15", "1:14", "1:13", "1:12", "1:11", "1:10", "1:9", "1:8", "1:7", "1:6", "1:5", "1:4", "1:3", "1:2", "1:1", "2:1", "3:1", "4:1", "5:1", "6:1", "7:1", "8:1", "9:1", "10:1", "11:1", "12:1", "13:1", "14:1", "15:1", "16:1")
                       // ISVALID = (C_S01_AXI_IS_ACLK_ASYNC == 0)
   parameter         C_S02_AXI_ACLK_RATIO             = "1:1", 
                       // VALUES = ("1:16", "1:15", "1:14", "1:13", "1:12", "1:11", "1:10", "1:9", "1:8", "1:7", "1:6", "1:5", "1:4", "1:3", "1:2", "1:1", "2:1", "3:1", "4:1", "5:1", "6:1", "7:1", "8:1", "9:1", "10:1", "11:1", "12:1", "13:1", "14:1", "15:1", "16:1")
                       // ISVALID = (C_S02_AXI_IS_ACLK_ASYNC == 0)
   parameter         C_S03_AXI_ACLK_RATIO             = "1:1", 
                       // VALUES = ("1:16", "1:15", "1:14", "1:13", "1:12", "1:11", "1:10", "1:9", "1:8", "1:7", "1:6", "1:5", "1:4", "1:3", "1:2", "1:1", "2:1", "3:1", "4:1", "5:1", "6:1", "7:1", "8:1", "9:1", "10:1", "11:1", "12:1", "13:1", "14:1", "15:1", "16:1")
                       // ISVALID = (C_S03_AXI_IS_ACLK_ASYNC == 0)
   parameter         C_S04_AXI_ACLK_RATIO             = "1:1", 
                       // VALUES = ("1:16", "1:15", "1:14", "1:13", "1:12", "1:11", "1:10", "1:9", "1:8", "1:7", "1:6", "1:5", "1:4", "1:3", "1:2", "1:1", "2:1", "3:1", "4:1", "5:1", "6:1", "7:1", "8:1", "9:1", "10:1", "11:1", "12:1", "13:1", "14:1", "15:1", "16:1")
                       // ISVALID = (C_S04_AXI_IS_ACLK_ASYNC == 0)
   parameter         C_S05_AXI_ACLK_RATIO             = "1:1", 
                       // VALUES = ("1:16", "1:15", "1:14", "1:13", "1:12", "1:11", "1:10", "1:9", "1:8", "1:7", "1:6", "1:5", "1:4", "1:3", "1:2", "1:1", "2:1", "3:1", "4:1", "5:1", "6:1", "7:1", "8:1", "9:1", "10:1", "11:1", "12:1", "13:1", "14:1", "15:1", "16:1")
                       // ISVALID = (C_S05_AXI_IS_ACLK_ASYNC == 0)
   parameter         C_S06_AXI_ACLK_RATIO             = "1:1", 
                       // VALUES = ("1:16", "1:15", "1:14", "1:13", "1:12", "1:11", "1:10", "1:9", "1:8", "1:7", "1:6", "1:5", "1:4", "1:3", "1:2", "1:1", "2:1", "3:1", "4:1", "5:1", "6:1", "7:1", "8:1", "9:1", "10:1", "11:1", "12:1", "13:1", "14:1", "15:1", "16:1")
                       // ISVALID = (C_S06_AXI_IS_ACLK_ASYNC == 0)
   parameter         C_S07_AXI_ACLK_RATIO             = "1:1", 
                       // VALUES = ("1:16", "1:15", "1:14", "1:13", "1:12", "1:11", "1:10", "1:9", "1:8", "1:7", "1:6", "1:5", "1:4", "1:3", "1:2", "1:1", "2:1", "3:1", "4:1", "5:1", "6:1", "7:1", "8:1", "9:1", "10:1", "11:1", "12:1", "13:1", "14:1", "15:1", "16:1")
                       // ISVALID = (C_S07_AXI_IS_ACLK_ASYNC == 0)
   parameter         C_S08_AXI_ACLK_RATIO             = "1:1", 
                       // VALUES = ("1:16", "1:15", "1:14", "1:13", "1:12", "1:11", "1:10", "1:9", "1:8", "1:7", "1:6", "1:5", "1:4", "1:3", "1:2", "1:1", "2:1", "3:1", "4:1", "5:1", "6:1", "7:1", "8:1", "9:1", "10:1", "11:1", "12:1", "13:1", "14:1", "15:1", "16:1")
                       // ISVALID = (C_S08_AXI_IS_ACLK_ASYNC == 0)
   parameter         C_S09_AXI_ACLK_RATIO             = "1:1", 
                       // VALUES = ("1:16", "1:15", "1:14", "1:13", "1:12", "1:11", "1:10", "1:9", "1:8", "1:7", "1:6", "1:5", "1:4", "1:3", "1:2", "1:1", "2:1", "3:1", "4:1", "5:1", "6:1", "7:1", "8:1", "9:1", "10:1", "11:1", "12:1", "13:1", "14:1", "15:1", "16:1")
                       // ISVALID = (C_S09_AXI_IS_ACLK_ASYNC == 0)
   parameter         C_S10_AXI_ACLK_RATIO             = "1:1", 
                       // VALUES = ("1:16", "1:15", "1:14", "1:13", "1:12", "1:11", "1:10", "1:9", "1:8", "1:7", "1:6", "1:5", "1:4", "1:3", "1:2", "1:1", "2:1", "3:1", "4:1", "5:1", "6:1", "7:1", "8:1", "9:1", "10:1", "11:1", "12:1", "13:1", "14:1", "15:1", "16:1")
                       // ISVALID = (C_S10_AXI_IS_ACLK_ASYNC == 0)
   parameter         C_S11_AXI_ACLK_RATIO             = "1:1", 
                       // VALUES = ("1:16", "1:15", "1:14", "1:13", "1:12", "1:11", "1:10", "1:9", "1:8", "1:7", "1:6", "1:5", "1:4", "1:3", "1:2", "1:1", "2:1", "3:1", "4:1", "5:1", "6:1", "7:1", "8:1", "9:1", "10:1", "11:1", "12:1", "13:1", "14:1", "15:1", "16:1")
                       // ISVALID = (C_S11_AXI_IS_ACLK_ASYNC == 0)
   parameter         C_S12_AXI_ACLK_RATIO             = "1:1", 
                       // VALUES = ("1:16", "1:15", "1:14", "1:13", "1:12", "1:11", "1:10", "1:9", "1:8", "1:7", "1:6", "1:5", "1:4", "1:3", "1:2", "1:1", "2:1", "3:1", "4:1", "5:1", "6:1", "7:1", "8:1", "9:1", "10:1", "11:1", "12:1", "13:1", "14:1", "15:1", "16:1")
                       // ISVALID = (C_S12_AXI_IS_ACLK_ASYNC == 0)
   parameter         C_S13_AXI_ACLK_RATIO             = "1:1", 
                       // VALUES = ("1:16", "1:15", "1:14", "1:13", "1:12", "1:11", "1:10", "1:9", "1:8", "1:7", "1:6", "1:5", "1:4", "1:3", "1:2", "1:1", "2:1", "3:1", "4:1", "5:1", "6:1", "7:1", "8:1", "9:1", "10:1", "11:1", "12:1", "13:1", "14:1", "15:1", "16:1")
                       // ISVALID = (C_S13_AXI_IS_ACLK_ASYNC == 0)
   parameter         C_S14_AXI_ACLK_RATIO             = "1:1", 
                       // VALUES = ("1:16", "1:15", "1:14", "1:13", "1:12", "1:11", "1:10", "1:9", "1:8", "1:7", "1:6", "1:5", "1:4", "1:3", "1:2", "1:1", "2:1", "3:1", "4:1", "5:1", "6:1", "7:1", "8:1", "9:1", "10:1", "11:1", "12:1", "13:1", "14:1", "15:1", "16:1")
                       // ISVALID = (C_S14_AXI_IS_ACLK_ASYNC == 0)
   parameter         C_S15_AXI_ACLK_RATIO             = "1:1", 
                       // VALUES = ("1:16", "1:15", "1:14", "1:13", "1:12", "1:11", "1:10", "1:9", "1:8", "1:7", "1:6", "1:5", "1:4", "1:3", "1:2", "1:1", "2:1", "3:1", "4:1", "5:1", "6:1", "7:1", "8:1", "9:1", "10:1", "11:1", "12:1", "13:1", "14:1", "15:1", "16:1")
                       // ISVALID = (C_S15_AXI_IS_ACLK_ASYNC == 0)
                       // Clock frequency ratio of each SI w.r.t. internal interconnect.
                       // Ignored if SI clock is async.
   parameter         C_S00_AXI_IS_ACLK_ASYNC        = 1'b0,
   parameter         C_S01_AXI_IS_ACLK_ASYNC        = 1'b0,
   parameter         C_S02_AXI_IS_ACLK_ASYNC        = 1'b0,
   parameter         C_S03_AXI_IS_ACLK_ASYNC        = 1'b0,
   parameter         C_S04_AXI_IS_ACLK_ASYNC        = 1'b0,
   parameter         C_S05_AXI_IS_ACLK_ASYNC        = 1'b0,
   parameter         C_S06_AXI_IS_ACLK_ASYNC        = 1'b0,
   parameter         C_S07_AXI_IS_ACLK_ASYNC        = 1'b0,
   parameter         C_S08_AXI_IS_ACLK_ASYNC        = 1'b0,
   parameter         C_S09_AXI_IS_ACLK_ASYNC        = 1'b0,
   parameter         C_S10_AXI_IS_ACLK_ASYNC        = 1'b0,
   parameter         C_S11_AXI_IS_ACLK_ASYNC        = 1'b0,
   parameter         C_S12_AXI_IS_ACLK_ASYNC        = 1'b0,
   parameter         C_S13_AXI_IS_ACLK_ASYNC        = 1'b0,
   parameter         C_S14_AXI_IS_ACLK_ASYNC        = 1'b0,
   parameter         C_S15_AXI_IS_ACLK_ASYNC        = 1'b0,
                       // SI clock is asynchronous w.r.t. Interconnect clock (Boolean)
   parameter         C_M00_AXI_ACLK_RATIO             = "1:1", 
                       // VALUES = ("1:16", "1:15", "1:14", "1:13", "1:12", "1:11", "1:10", "1:9", "1:8", "1:7", "1:6", "1:5", "1:4", "1:3", "1:2", "1:1", "2:1", "3:1", "4:1", "5:1", "6:1", "7:1", "8:1", "9:1", "10:1", "11:1", "12:1", "13:1", "14:1", "15:1", "16:1")
                       // ISVALID = (C_M00_AXI_IS_ACLK_ASYNC == 0)
                       // Clock frequency ratio of each MI w.r.t. internal interconnect.
                       // Ignored if MI clock is async.
   parameter         C_M00_AXI_IS_ACLK_ASYNC          = 1'b0,
                       // MI clock is asynchronous w.r.t. Interconnect clock (Boolean)
   parameter         C_S00_AXI_READ_WRITE_SUPPORT     = "READ/WRITE", 
                       // VALUES = ("READ/WRITE", "READ-ONLY", "WRITE-ONLY")
   parameter         C_S01_AXI_READ_WRITE_SUPPORT     = "READ/WRITE", 
                       // VALUES = ("READ/WRITE", "READ-ONLY", "WRITE-ONLY")
   parameter         C_S02_AXI_READ_WRITE_SUPPORT     = "READ/WRITE", 
                       // VALUES = ("READ/WRITE", "READ-ONLY", "WRITE-ONLY")
   parameter         C_S03_AXI_READ_WRITE_SUPPORT     = "READ/WRITE", 
                       // VALUES = ("READ/WRITE", "READ-ONLY", "WRITE-ONLY")
   parameter         C_S04_AXI_READ_WRITE_SUPPORT     = "READ/WRITE", 
                       // VALUES = ("READ/WRITE", "READ-ONLY", "WRITE-ONLY")
   parameter         C_S05_AXI_READ_WRITE_SUPPORT     = "READ/WRITE", 
                       // VALUES = ("READ/WRITE", "READ-ONLY", "WRITE-ONLY")
   parameter         C_S06_AXI_READ_WRITE_SUPPORT     = "READ/WRITE", 
                       // VALUES = ("READ/WRITE", "READ-ONLY", "WRITE-ONLY")
   parameter         C_S07_AXI_READ_WRITE_SUPPORT     = "READ/WRITE", 
                       // VALUES = ("READ/WRITE", "READ-ONLY", "WRITE-ONLY")
   parameter         C_S08_AXI_READ_WRITE_SUPPORT     = "READ/WRITE", 
                       // VALUES = ("READ/WRITE", "READ-ONLY", "WRITE-ONLY")
   parameter         C_S09_AXI_READ_WRITE_SUPPORT     = "READ/WRITE", 
                       // VALUES = ("READ/WRITE", "READ-ONLY", "WRITE-ONLY")
   parameter         C_S10_AXI_READ_WRITE_SUPPORT     = "READ/WRITE", 
                       // VALUES = ("READ/WRITE", "READ-ONLY", "WRITE-ONLY")
   parameter         C_S11_AXI_READ_WRITE_SUPPORT     = "READ/WRITE", 
                       // VALUES = ("READ/WRITE", "READ-ONLY", "WRITE-ONLY")
   parameter         C_S12_AXI_READ_WRITE_SUPPORT     = "READ/WRITE", 
                       // VALUES = ("READ/WRITE", "READ-ONLY", "WRITE-ONLY")
   parameter         C_S13_AXI_READ_WRITE_SUPPORT     = "READ/WRITE", 
                       // VALUES = ("READ/WRITE", "READ-ONLY", "WRITE-ONLY")
   parameter         C_S14_AXI_READ_WRITE_SUPPORT     = "READ/WRITE", 
                       // VALUES = ("READ/WRITE", "READ-ONLY", "WRITE-ONLY")
   parameter         C_S15_AXI_READ_WRITE_SUPPORT     = "READ/WRITE", 
                       // VALUES = ("READ/WRITE", "READ-ONLY", "WRITE-ONLY")
                       // Indicates whether each SI supports read/write transactions.
   parameter integer C_S00_AXI_WRITE_ACCEPTANCE       = 1,
                       // RANGE = (1, 2, 4, 8, 16, 32)
   parameter integer C_S01_AXI_WRITE_ACCEPTANCE       = 1,
                       // RANGE = (1, 2, 4, 8, 16, 32)
   parameter integer C_S02_AXI_WRITE_ACCEPTANCE       = 1,
                       // RANGE = (1, 2, 4, 8, 16, 32)
   parameter integer C_S03_AXI_WRITE_ACCEPTANCE       = 1,
                       // RANGE = (1, 2, 4, 8, 16, 32)
   parameter integer C_S04_AXI_WRITE_ACCEPTANCE       = 1,
                       // RANGE = (1, 2, 4, 8, 16, 32)
   parameter integer C_S05_AXI_WRITE_ACCEPTANCE       = 1,
                       // RANGE = (1, 2, 4, 8, 16, 32)
   parameter integer C_S06_AXI_WRITE_ACCEPTANCE       = 1,
                       // RANGE = (1, 2, 4, 8, 16, 32)
   parameter integer C_S07_AXI_WRITE_ACCEPTANCE       = 1,
                       // RANGE = (1, 2, 4, 8, 16, 32)
   parameter integer C_S08_AXI_WRITE_ACCEPTANCE       = 1,
                       // RANGE = (1, 2, 4, 8, 16, 32)
   parameter integer C_S09_AXI_WRITE_ACCEPTANCE       = 1,
                       // RANGE = (1, 2, 4, 8, 16, 32)
   parameter integer C_S10_AXI_WRITE_ACCEPTANCE       = 1,
                       // RANGE = (1, 2, 4, 8, 16, 32)
   parameter integer C_S11_AXI_WRITE_ACCEPTANCE       = 1,
                       // RANGE = (1, 2, 4, 8, 16, 32)
   parameter integer C_S12_AXI_WRITE_ACCEPTANCE       = 1,
                       // RANGE = (1, 2, 4, 8, 16, 32)
   parameter integer C_S13_AXI_WRITE_ACCEPTANCE       = 1,
                       // RANGE = (1, 2, 4, 8, 16, 32)
   parameter integer C_S14_AXI_WRITE_ACCEPTANCE       = 1,
                       // RANGE = (1, 2, 4, 8, 16, 32)
   parameter integer C_S15_AXI_WRITE_ACCEPTANCE       = 1,
                       // RANGE = (1, 2, 4, 8, 16, 32)
                       // Maximum number of active write transactions that each SI 
                       // can accept.
   parameter integer C_S00_AXI_READ_ACCEPTANCE        = 1,
                       // RANGE = (1, 2, 4, 8, 16, 32)
   parameter integer C_S01_AXI_READ_ACCEPTANCE        = 1,
                       // RANGE = (1, 2, 4, 8, 16, 32)
   parameter integer C_S02_AXI_READ_ACCEPTANCE        = 1,
                       // RANGE = (1, 2, 4, 8, 16, 32)
   parameter integer C_S03_AXI_READ_ACCEPTANCE        = 1,
                       // RANGE = (1, 2, 4, 8, 16, 32)
   parameter integer C_S04_AXI_READ_ACCEPTANCE        = 1,
                       // RANGE = (1, 2, 4, 8, 16, 32)
   parameter integer C_S05_AXI_READ_ACCEPTANCE        = 1,
                       // RANGE = (1, 2, 4, 8, 16, 32)
   parameter integer C_S06_AXI_READ_ACCEPTANCE        = 1,
                       // RANGE = (1, 2, 4, 8, 16, 32)
   parameter integer C_S07_AXI_READ_ACCEPTANCE        = 1,
                       // RANGE = (1, 2, 4, 8, 16, 32)
   parameter integer C_S08_AXI_READ_ACCEPTANCE        = 1,
                       // RANGE = (1, 2, 4, 8, 16, 32)
   parameter integer C_S09_AXI_READ_ACCEPTANCE        = 1,
                       // RANGE = (1, 2, 4, 8, 16, 32)
   parameter integer C_S10_AXI_READ_ACCEPTANCE        = 1,
                       // RANGE = (1, 2, 4, 8, 16, 32)
   parameter integer C_S11_AXI_READ_ACCEPTANCE        = 1,
                       // RANGE = (1, 2, 4, 8, 16, 32)
   parameter integer C_S12_AXI_READ_ACCEPTANCE        = 1,
                       // RANGE = (1, 2, 4, 8, 16, 32)
   parameter integer C_S13_AXI_READ_ACCEPTANCE        = 1,
                       // RANGE = (1, 2, 4, 8, 16, 32)
   parameter integer C_S14_AXI_READ_ACCEPTANCE        = 1,
                       // RANGE = (1, 2, 4, 8, 16, 32)
   parameter integer C_S15_AXI_READ_ACCEPTANCE        = 1,
                       // RANGE = (1, 2, 4, 8, 16, 32)
                       // Maximum number of active read transactions that each SI 
                       // can accept.
   parameter integer C_M00_AXI_WRITE_ISSUING          = 1,
                       // RANGE = (1, 2, 4, 8, 16, 32)
                       // Maximum number of data-active write transactions that 
                       // the MI can generate at any one time.
   parameter integer C_M00_AXI_READ_ISSUING           = 1,
                       // RANGE = (1, 2, 4, 8, 16, 32)
                       // Maximum number of active read transactions that 
                       // the MI can generate at any one time.
   parameter integer C_S00_AXI_ARB_PRIORITY           = 0,
                       // RANGE = (0:15)
   parameter integer C_S01_AXI_ARB_PRIORITY           = 0,
                       // RANGE = (0:15)
   parameter integer C_S02_AXI_ARB_PRIORITY           = 0,
                       // RANGE = (0:15)
   parameter integer C_S03_AXI_ARB_PRIORITY           = 0,
                       // RANGE = (0:15)
   parameter integer C_S04_AXI_ARB_PRIORITY           = 0,
                       // RANGE = (0:15)
   parameter integer C_S05_AXI_ARB_PRIORITY           = 0,
                       // RANGE = (0:15)
   parameter integer C_S06_AXI_ARB_PRIORITY           = 0,
                       // RANGE = (0:15)
   parameter integer C_S07_AXI_ARB_PRIORITY           = 0,
                       // RANGE = (0:15)
   parameter integer C_S08_AXI_ARB_PRIORITY           = 0,
                       // RANGE = (0:15)
   parameter integer C_S09_AXI_ARB_PRIORITY           = 0,
                       // RANGE = (0:15)
   parameter integer C_S10_AXI_ARB_PRIORITY           = 0,
                       // RANGE = (0:15)
   parameter integer C_S11_AXI_ARB_PRIORITY           = 0,
                       // RANGE = (0:15)
   parameter integer C_S12_AXI_ARB_PRIORITY           = 0,
                       // RANGE = (0:15)
   parameter integer C_S13_AXI_ARB_PRIORITY           = 0,
                       // RANGE = (0:15)
   parameter integer C_S14_AXI_ARB_PRIORITY           = 0,
                       // RANGE = (0:15)
   parameter integer C_S15_AXI_ARB_PRIORITY           = 0,
                       // RANGE = (0:15)
                       // Arbitration priority among each SI. 
                       // Higher values indicate higher priority.
   parameter integer C_S00_AXI_WRITE_FIFO_DEPTH       = 0,
                       // RANGE = (0, 32, 512)
   parameter integer C_S01_AXI_WRITE_FIFO_DEPTH       = 0,
                       // RANGE = (0, 32, 512)
   parameter integer C_S02_AXI_WRITE_FIFO_DEPTH       = 0,
                       // RANGE = (0, 32, 512)
   parameter integer C_S03_AXI_WRITE_FIFO_DEPTH       = 0,
                       // RANGE = (0, 32, 512)
   parameter integer C_S04_AXI_WRITE_FIFO_DEPTH       = 0,
                       // RANGE = (0, 32, 512)
   parameter integer C_S05_AXI_WRITE_FIFO_DEPTH       = 0,
                       // RANGE = (0, 32, 512)
   parameter integer C_S06_AXI_WRITE_FIFO_DEPTH       = 0,
                       // RANGE = (0, 32, 512)
   parameter integer C_S07_AXI_WRITE_FIFO_DEPTH       = 0,
                       // RANGE = (0, 32, 512)
   parameter integer C_S08_AXI_WRITE_FIFO_DEPTH       = 0,
                       // RANGE = (0, 32, 512)
   parameter integer C_S09_AXI_WRITE_FIFO_DEPTH       = 0,
                       // RANGE = (0, 32, 512)
   parameter integer C_S10_AXI_WRITE_FIFO_DEPTH       = 0,
                       // RANGE = (0, 32, 512)
   parameter integer C_S11_AXI_WRITE_FIFO_DEPTH       = 0,
                       // RANGE = (0, 32, 512)
   parameter integer C_S12_AXI_WRITE_FIFO_DEPTH       = 0,
                       // RANGE = (0, 32, 512)
   parameter integer C_S13_AXI_WRITE_FIFO_DEPTH       = 0,
                       // RANGE = (0, 32, 512)
   parameter integer C_S14_AXI_WRITE_FIFO_DEPTH       = 0,
                       // RANGE = (0, 32, 512)
   parameter integer C_S15_AXI_WRITE_FIFO_DEPTH       = 0,
                       // RANGE = (0, 32, 512)
                       // Depth of SI-side write data FIFO per SI.
   parameter integer C_S00_AXI_READ_FIFO_DEPTH        = 0,
                       // RANGE = (0, 32, 512)
   parameter integer C_S01_AXI_READ_FIFO_DEPTH        = 0,
                       // RANGE = (0, 32, 512)
   parameter integer C_S02_AXI_READ_FIFO_DEPTH        = 0,
                       // RANGE = (0, 32, 512)
   parameter integer C_S03_AXI_READ_FIFO_DEPTH        = 0,
                       // RANGE = (0, 32, 512)
   parameter integer C_S04_AXI_READ_FIFO_DEPTH        = 0,
                       // RANGE = (0, 32, 512)
   parameter integer C_S05_AXI_READ_FIFO_DEPTH        = 0,
                       // RANGE = (0, 32, 512)
   parameter integer C_S06_AXI_READ_FIFO_DEPTH        = 0,
                       // RANGE = (0, 32, 512)
   parameter integer C_S07_AXI_READ_FIFO_DEPTH        = 0,
                       // RANGE = (0, 32, 512)
   parameter integer C_S08_AXI_READ_FIFO_DEPTH        = 0,
                       // RANGE = (0, 32, 512)
   parameter integer C_S09_AXI_READ_FIFO_DEPTH        = 0,
                       // RANGE = (0, 32, 512)
   parameter integer C_S10_AXI_READ_FIFO_DEPTH        = 0,
                       // RANGE = (0, 32, 512)
   parameter integer C_S11_AXI_READ_FIFO_DEPTH        = 0,
                       // RANGE = (0, 32, 512)
   parameter integer C_S12_AXI_READ_FIFO_DEPTH        = 0,
                       // RANGE = (0, 32, 512)
   parameter integer C_S13_AXI_READ_FIFO_DEPTH        = 0,
                       // RANGE = (0, 32, 512)
   parameter integer C_S14_AXI_READ_FIFO_DEPTH        = 0,
                       // RANGE = (0, 32, 512)
   parameter integer C_S15_AXI_READ_FIFO_DEPTH        = 0,
                       // RANGE = (0, 32, 512)
                       // Depth of SI-side read data FIFO per SI.
   parameter integer C_M00_AXI_WRITE_FIFO_DEPTH       = 0,
                       // RANGE = (0, 32, 512)
                       // Depth of MI-side write data FIFO.
   parameter integer C_M00_AXI_READ_FIFO_DEPTH        = 0,
                       // RANGE = (0, 32, 512)
                       // Depth of MI-side read data FIFO.
   parameter integer C_S00_AXI_WRITE_FIFO_DELAY       = 1'b0,
   parameter integer C_S01_AXI_WRITE_FIFO_DELAY       = 1'b0,
   parameter integer C_S02_AXI_WRITE_FIFO_DELAY       = 1'b0,
   parameter integer C_S03_AXI_WRITE_FIFO_DELAY       = 1'b0,
   parameter integer C_S04_AXI_WRITE_FIFO_DELAY       = 1'b0,
   parameter integer C_S05_AXI_WRITE_FIFO_DELAY       = 1'b0,
   parameter integer C_S06_AXI_WRITE_FIFO_DELAY       = 1'b0,
   parameter integer C_S07_AXI_WRITE_FIFO_DELAY       = 1'b0,
   parameter integer C_S08_AXI_WRITE_FIFO_DELAY       = 1'b0,
   parameter integer C_S09_AXI_WRITE_FIFO_DELAY       = 1'b0,
   parameter integer C_S10_AXI_WRITE_FIFO_DELAY       = 1'b0,
   parameter integer C_S11_AXI_WRITE_FIFO_DELAY       = 1'b0,
   parameter integer C_S12_AXI_WRITE_FIFO_DELAY       = 1'b0,
   parameter integer C_S13_AXI_WRITE_FIFO_DELAY       = 1'b0,
   parameter integer C_S14_AXI_WRITE_FIFO_DELAY       = 1'b0,
   parameter integer C_S15_AXI_WRITE_FIFO_DELAY       = 1'b0,
                       // SI-side write channel packet FIFO, per SI.
   parameter integer C_S00_AXI_READ_FIFO_DELAY        = 1'b0,
   parameter integer C_S01_AXI_READ_FIFO_DELAY        = 1'b0,
   parameter integer C_S02_AXI_READ_FIFO_DELAY        = 1'b0,
   parameter integer C_S03_AXI_READ_FIFO_DELAY        = 1'b0,
   parameter integer C_S04_AXI_READ_FIFO_DELAY        = 1'b0,
   parameter integer C_S05_AXI_READ_FIFO_DELAY        = 1'b0,
   parameter integer C_S06_AXI_READ_FIFO_DELAY        = 1'b0,
   parameter integer C_S07_AXI_READ_FIFO_DELAY        = 1'b0,
   parameter integer C_S08_AXI_READ_FIFO_DELAY        = 1'b0,
   parameter integer C_S09_AXI_READ_FIFO_DELAY        = 1'b0,
   parameter integer C_S10_AXI_READ_FIFO_DELAY        = 1'b0,
   parameter integer C_S11_AXI_READ_FIFO_DELAY        = 1'b0,
   parameter integer C_S12_AXI_READ_FIFO_DELAY        = 1'b0,
   parameter integer C_S13_AXI_READ_FIFO_DELAY        = 1'b0,
   parameter integer C_S14_AXI_READ_FIFO_DELAY        = 1'b0,
   parameter integer C_S15_AXI_READ_FIFO_DELAY        = 1'b0,
                       // SI-side read channel packet FIFO, per SI.
   parameter integer C_M00_AXI_WRITE_FIFO_DELAY       = 1'b0,
                       // MI-side write channel packet FIFO.
   parameter integer C_M00_AXI_READ_FIFO_DELAY        = 1'b0,
                       // MI-side read channel packet FIFO.
   parameter         C_S00_AXI_REGISTER            = 1'b0,
   parameter         C_S01_AXI_REGISTER            = 1'b0,
   parameter         C_S02_AXI_REGISTER            = 1'b0,
   parameter         C_S03_AXI_REGISTER            = 1'b0,
   parameter         C_S04_AXI_REGISTER            = 1'b0,
   parameter         C_S05_AXI_REGISTER            = 1'b0,
   parameter         C_S06_AXI_REGISTER            = 1'b0,
   parameter         C_S07_AXI_REGISTER            = 1'b0,
   parameter         C_S08_AXI_REGISTER            = 1'b0,
   parameter         C_S09_AXI_REGISTER            = 1'b0,
   parameter         C_S10_AXI_REGISTER            = 1'b0,
   parameter         C_S11_AXI_REGISTER            = 1'b0,
   parameter         C_S12_AXI_REGISTER            = 1'b0,
   parameter         C_S13_AXI_REGISTER            = 1'b0,
   parameter         C_S14_AXI_REGISTER            = 1'b0,
   parameter         C_S15_AXI_REGISTER            = 1'b0,
                       // Insert register slice on all channels at each SI (Boolean).
   parameter         C_M00_AXI_REGISTER           = 1'b0
                       // Insert register slice on all channels at the MI (Boolean).
   )
  (
   // System Signals
   input  wire                                 INTERCONNECT_ACLK,
   input  wire                                 INTERCONNECT_ARESETN,

   // Slave Interface S00
   output wire                                 S00_AXI_ARESET_OUT_N,
   // ISVALID = (C_NUM_SLAVE_PORTS > 0)
   input  wire                                 S00_AXI_ACLK,
   input  wire [C_THREAD_ID_PORT_WIDTH-1:0]    S00_AXI_AWID,
   input  wire [C_AXI_ADDR_WIDTH-1:0]          S00_AXI_AWADDR,
   input  wire [7:0]                           S00_AXI_AWLEN,
   input  wire [2:0]                           S00_AXI_AWSIZE,
   input  wire [1:0]                           S00_AXI_AWBURST,
   input  wire                                 S00_AXI_AWLOCK,
   input  wire [3:0]                           S00_AXI_AWCACHE,
   input  wire [2:0]                           S00_AXI_AWPROT,
   input  wire [3:0]                           S00_AXI_AWQOS,
   input  wire                                 S00_AXI_AWVALID,
   output wire                                 S00_AXI_AWREADY,
   input  wire [C_S00_AXI_DATA_WIDTH-1:0]      S00_AXI_WDATA,
   input  wire [C_S00_AXI_DATA_WIDTH/8-1:0]    S00_AXI_WSTRB,
   input  wire                                 S00_AXI_WLAST,
   input  wire                                 S00_AXI_WVALID,
   output wire                                 S00_AXI_WREADY,
   output wire [C_THREAD_ID_PORT_WIDTH-1:0]    S00_AXI_BID,
   output wire [1:0]                           S00_AXI_BRESP,
   output wire                                 S00_AXI_BVALID,
   input  wire                                 S00_AXI_BREADY,
   input  wire [C_THREAD_ID_PORT_WIDTH-1:0]    S00_AXI_ARID,
   input  wire [C_AXI_ADDR_WIDTH-1:0]          S00_AXI_ARADDR,
   input  wire [7:0]                           S00_AXI_ARLEN,
   input  wire [2:0]                           S00_AXI_ARSIZE,
   input  wire [1:0]                           S00_AXI_ARBURST,
   input  wire                                 S00_AXI_ARLOCK,
   input  wire [3:0]                           S00_AXI_ARCACHE,
   input  wire [2:0]                           S00_AXI_ARPROT,
   input  wire [3:0]                           S00_AXI_ARQOS,
   input  wire                                 S00_AXI_ARVALID,
   output wire                                 S00_AXI_ARREADY,
   output wire [C_THREAD_ID_PORT_WIDTH-1:0]    S00_AXI_RID,
   output wire [C_S00_AXI_DATA_WIDTH-1:0]      S00_AXI_RDATA,
   output wire [1:0]                           S00_AXI_RRESP,
   output wire                                 S00_AXI_RLAST,
   output wire                                 S00_AXI_RVALID,
   input  wire                                 S00_AXI_RREADY,
   
   // Slave Interface S01
   output wire                                 S01_AXI_ARESET_OUT_N,
   // ISVALID = (C_NUM_SLAVE_PORTS > 1)
   input  wire                                 S01_AXI_ACLK,
   input  wire [C_THREAD_ID_PORT_WIDTH-1:0]    S01_AXI_AWID,
   input  wire [C_AXI_ADDR_WIDTH-1:0]          S01_AXI_AWADDR,
   input  wire [7:0]                           S01_AXI_AWLEN,
   input  wire [2:0]                           S01_AXI_AWSIZE,
   input  wire [1:0]                           S01_AXI_AWBURST,
   input  wire                                 S01_AXI_AWLOCK,
   input  wire [3:0]                           S01_AXI_AWCACHE,
   input  wire [2:0]                           S01_AXI_AWPROT,
   input  wire [3:0]                           S01_AXI_AWQOS,
   input  wire                                 S01_AXI_AWVALID,
   output wire                                 S01_AXI_AWREADY,
   input  wire [C_S01_AXI_DATA_WIDTH-1:0]      S01_AXI_WDATA,
   input  wire [C_S01_AXI_DATA_WIDTH/8-1:0]    S01_AXI_WSTRB,
   input  wire                                 S01_AXI_WLAST,
   input  wire                                 S01_AXI_WVALID,
   output wire                                 S01_AXI_WREADY,
   output wire [C_THREAD_ID_PORT_WIDTH-1:0]    S01_AXI_BID,
   output wire [1:0]                           S01_AXI_BRESP,
   output wire                                 S01_AXI_BVALID,
   input  wire                                 S01_AXI_BREADY,
   input  wire [C_THREAD_ID_PORT_WIDTH-1:0]    S01_AXI_ARID,
   input  wire [C_AXI_ADDR_WIDTH-1:0]          S01_AXI_ARADDR,
   input  wire [7:0]                           S01_AXI_ARLEN,
   input  wire [2:0]                           S01_AXI_ARSIZE,
   input  wire [1:0]                           S01_AXI_ARBURST,
   input  wire                                 S01_AXI_ARLOCK,
   input  wire [3:0]                           S01_AXI_ARCACHE,
   input  wire [2:0]                           S01_AXI_ARPROT,
   input  wire [3:0]                           S01_AXI_ARQOS,
   input  wire                                 S01_AXI_ARVALID,
   output wire                                 S01_AXI_ARREADY,
   output wire [C_THREAD_ID_PORT_WIDTH-1:0]    S01_AXI_RID,
   output wire [C_S01_AXI_DATA_WIDTH-1:0]      S01_AXI_RDATA,
   output wire [1:0]                           S01_AXI_RRESP,
   output wire                                 S01_AXI_RLAST,
   output wire                                 S01_AXI_RVALID,
   input  wire                                 S01_AXI_RREADY,
   
   // Slave Interface S02
   output wire                                 S02_AXI_ARESET_OUT_N,
   // ISVALID = (C_NUM_SLAVE_PORTS > 2)
   input  wire                                 S02_AXI_ACLK,
   input  wire [C_THREAD_ID_PORT_WIDTH-1:0]    S02_AXI_AWID,
   input  wire [C_AXI_ADDR_WIDTH-1:0]          S02_AXI_AWADDR,
   input  wire [7:0]                           S02_AXI_AWLEN,
   input  wire [2:0]                           S02_AXI_AWSIZE,
   input  wire [1:0]                           S02_AXI_AWBURST,
   input  wire                                 S02_AXI_AWLOCK,
   input  wire [3:0]                           S02_AXI_AWCACHE,
   input  wire [2:0]                           S02_AXI_AWPROT,
   input  wire [3:0]                           S02_AXI_AWQOS,
   input  wire                                 S02_AXI_AWVALID,
   output wire                                 S02_AXI_AWREADY,
   input  wire [C_S02_AXI_DATA_WIDTH-1:0]      S02_AXI_WDATA,
   input  wire [C_S02_AXI_DATA_WIDTH/8-1:0]    S02_AXI_WSTRB,
   input  wire                                 S02_AXI_WLAST,
   input  wire                                 S02_AXI_WVALID,
   output wire                                 S02_AXI_WREADY,
   output wire [C_THREAD_ID_PORT_WIDTH-1:0]    S02_AXI_BID,
   output wire [1:0]                           S02_AXI_BRESP,
   output wire                                 S02_AXI_BVALID,
   input  wire                                 S02_AXI_BREADY,
   input  wire [C_THREAD_ID_PORT_WIDTH-1:0]    S02_AXI_ARID,
   input  wire [C_AXI_ADDR_WIDTH-1:0]          S02_AXI_ARADDR,
   input  wire [7:0]                           S02_AXI_ARLEN,
   input  wire [2:0]                           S02_AXI_ARSIZE,
   input  wire [1:0]                           S02_AXI_ARBURST,
   input  wire                                 S02_AXI_ARLOCK,
   input  wire [3:0]                           S02_AXI_ARCACHE,
   input  wire [2:0]                           S02_AXI_ARPROT,
   input  wire [3:0]                           S02_AXI_ARQOS,
   input  wire                                 S02_AXI_ARVALID,
   output wire                                 S02_AXI_ARREADY,
   output wire [C_THREAD_ID_PORT_WIDTH-1:0]    S02_AXI_RID,
   output wire [C_S02_AXI_DATA_WIDTH-1:0]      S02_AXI_RDATA,
   output wire [1:0]                           S02_AXI_RRESP,
   output wire                                 S02_AXI_RLAST,
   output wire                                 S02_AXI_RVALID,
   input  wire                                 S02_AXI_RREADY,
   
   // Slave Interface S03
   output wire                                 S03_AXI_ARESET_OUT_N,
   // ISVALID = (C_NUM_SLAVE_PORTS > 3)
   input  wire                                 S03_AXI_ACLK,
   input  wire [C_THREAD_ID_PORT_WIDTH-1:0]    S03_AXI_AWID,
   input  wire [C_AXI_ADDR_WIDTH-1:0]          S03_AXI_AWADDR,
   input  wire [7:0]                           S03_AXI_AWLEN,
   input  wire [2:0]                           S03_AXI_AWSIZE,
   input  wire [1:0]                           S03_AXI_AWBURST,
   input  wire                                 S03_AXI_AWLOCK,
   input  wire [3:0]                           S03_AXI_AWCACHE,
   input  wire [2:0]                           S03_AXI_AWPROT,
   input  wire [3:0]                           S03_AXI_AWQOS,
   input  wire                                 S03_AXI_AWVALID,
   output wire                                 S03_AXI_AWREADY,
   input  wire [C_S03_AXI_DATA_WIDTH-1:0]      S03_AXI_WDATA,
   input  wire [C_S03_AXI_DATA_WIDTH/8-1:0]    S03_AXI_WSTRB,
   input  wire                                 S03_AXI_WLAST,
   input  wire                                 S03_AXI_WVALID,
   output wire                                 S03_AXI_WREADY,
   output wire [C_THREAD_ID_PORT_WIDTH-1:0]    S03_AXI_BID,
   output wire [1:0]                           S03_AXI_BRESP,
   output wire                                 S03_AXI_BVALID,
   input  wire                                 S03_AXI_BREADY,
   input  wire [C_THREAD_ID_PORT_WIDTH-1:0]    S03_AXI_ARID,
   input  wire [C_AXI_ADDR_WIDTH-1:0]          S03_AXI_ARADDR,
   input  wire [7:0]                           S03_AXI_ARLEN,
   input  wire [2:0]                           S03_AXI_ARSIZE,
   input  wire [1:0]                           S03_AXI_ARBURST,
   input  wire                                 S03_AXI_ARLOCK,
   input  wire [3:0]                           S03_AXI_ARCACHE,
   input  wire [2:0]                           S03_AXI_ARPROT,
   input  wire [3:0]                           S03_AXI_ARQOS,
   input  wire                                 S03_AXI_ARVALID,
   output wire                                 S03_AXI_ARREADY,
   output wire [C_THREAD_ID_PORT_WIDTH-1:0]    S03_AXI_RID,
   output wire [C_S03_AXI_DATA_WIDTH-1:0]      S03_AXI_RDATA,
   output wire [1:0]                           S03_AXI_RRESP,
   output wire                                 S03_AXI_RLAST,
   output wire                                 S03_AXI_RVALID,
   input  wire                                 S03_AXI_RREADY,
   
   // Slave Interface S04
   output wire                                 S04_AXI_ARESET_OUT_N,
   // ISVALID = (C_NUM_SLAVE_PORTS > 4)
   input  wire                                 S04_AXI_ACLK,
   input  wire [C_THREAD_ID_PORT_WIDTH-1:0]    S04_AXI_AWID,
   input  wire [C_AXI_ADDR_WIDTH-1:0]          S04_AXI_AWADDR,
   input  wire [7:0]                           S04_AXI_AWLEN,
   input  wire [2:0]                           S04_AXI_AWSIZE,
   input  wire [1:0]                           S04_AXI_AWBURST,
   input  wire                                 S04_AXI_AWLOCK,
   input  wire [3:0]                           S04_AXI_AWCACHE,
   input  wire [2:0]                           S04_AXI_AWPROT,
   input  wire [3:0]                           S04_AXI_AWQOS,
   input  wire                                 S04_AXI_AWVALID,
   output wire                                 S04_AXI_AWREADY,
   input  wire [C_S04_AXI_DATA_WIDTH-1:0]      S04_AXI_WDATA,
   input  wire [C_S04_AXI_DATA_WIDTH/8-1:0]    S04_AXI_WSTRB,
   input  wire                                 S04_AXI_WLAST,
   input  wire                                 S04_AXI_WVALID,
   output wire                                 S04_AXI_WREADY,
   output wire [C_THREAD_ID_PORT_WIDTH-1:0]    S04_AXI_BID,
   output wire [1:0]                           S04_AXI_BRESP,
   output wire                                 S04_AXI_BVALID,
   input  wire                                 S04_AXI_BREADY,
   input  wire [C_THREAD_ID_PORT_WIDTH-1:0]    S04_AXI_ARID,
   input  wire [C_AXI_ADDR_WIDTH-1:0]          S04_AXI_ARADDR,
   input  wire [7:0]                           S04_AXI_ARLEN,
   input  wire [2:0]                           S04_AXI_ARSIZE,
   input  wire [1:0]                           S04_AXI_ARBURST,
   input  wire                                 S04_AXI_ARLOCK,
   input  wire [3:0]                           S04_AXI_ARCACHE,
   input  wire [2:0]                           S04_AXI_ARPROT,
   input  wire [3:0]                           S04_AXI_ARQOS,
   input  wire                                 S04_AXI_ARVALID,
   output wire                                 S04_AXI_ARREADY,
   output wire [C_THREAD_ID_PORT_WIDTH-1:0]    S04_AXI_RID,
   output wire [C_S04_AXI_DATA_WIDTH-1:0]      S04_AXI_RDATA,
   output wire [1:0]                           S04_AXI_RRESP,
   output wire                                 S04_AXI_RLAST,
   output wire                                 S04_AXI_RVALID,
   input  wire                                 S04_AXI_RREADY,
   
   // Slave Interface S05
   output wire                                 S05_AXI_ARESET_OUT_N,
   // ISVALID = (C_NUM_SLAVE_PORTS > 5)
   input  wire                                 S05_AXI_ACLK,
   input  wire [C_THREAD_ID_PORT_WIDTH-1:0]    S05_AXI_AWID,
   input  wire [C_AXI_ADDR_WIDTH-1:0]          S05_AXI_AWADDR,
   input  wire [7:0]                           S05_AXI_AWLEN,
   input  wire [2:0]                           S05_AXI_AWSIZE,
   input  wire [1:0]                           S05_AXI_AWBURST,
   input  wire                                 S05_AXI_AWLOCK,
   input  wire [3:0]                           S05_AXI_AWCACHE,
   input  wire [2:0]                           S05_AXI_AWPROT,
   input  wire [3:0]                           S05_AXI_AWQOS,
   input  wire                                 S05_AXI_AWVALID,
   output wire                                 S05_AXI_AWREADY,
   input  wire [C_S05_AXI_DATA_WIDTH-1:0]      S05_AXI_WDATA,
   input  wire [C_S05_AXI_DATA_WIDTH/8-1:0]    S05_AXI_WSTRB,
   input  wire                                 S05_AXI_WLAST,
   input  wire                                 S05_AXI_WVALID,
   output wire                                 S05_AXI_WREADY,
   output wire [C_THREAD_ID_PORT_WIDTH-1:0]    S05_AXI_BID,
   output wire [1:0]                           S05_AXI_BRESP,
   output wire                                 S05_AXI_BVALID,
   input  wire                                 S05_AXI_BREADY,
   input  wire [C_THREAD_ID_PORT_WIDTH-1:0]    S05_AXI_ARID,
   input  wire [C_AXI_ADDR_WIDTH-1:0]          S05_AXI_ARADDR,
   input  wire [7:0]                           S05_AXI_ARLEN,
   input  wire [2:0]                           S05_AXI_ARSIZE,
   input  wire [1:0]                           S05_AXI_ARBURST,
   input  wire                                 S05_AXI_ARLOCK,
   input  wire [3:0]                           S05_AXI_ARCACHE,
   input  wire [2:0]                           S05_AXI_ARPROT,
   input  wire [3:0]                           S05_AXI_ARQOS,
   input  wire                                 S05_AXI_ARVALID,
   output wire                                 S05_AXI_ARREADY,
   output wire [C_THREAD_ID_PORT_WIDTH-1:0]    S05_AXI_RID,
   output wire [C_S05_AXI_DATA_WIDTH-1:0]      S05_AXI_RDATA,
   output wire [1:0]                           S05_AXI_RRESP,
   output wire                                 S05_AXI_RLAST,
   output wire                                 S05_AXI_RVALID,
   input  wire                                 S05_AXI_RREADY,
   
   // Slave Interface S06
   output wire                                 S06_AXI_ARESET_OUT_N,
   // ISVALID = (C_NUM_SLAVE_PORTS > 6)
   input  wire                                 S06_AXI_ACLK,
   input  wire [C_THREAD_ID_PORT_WIDTH-1:0]    S06_AXI_AWID,
   input  wire [C_AXI_ADDR_WIDTH-1:0]          S06_AXI_AWADDR,
   input  wire [7:0]                           S06_AXI_AWLEN,
   input  wire [2:0]                           S06_AXI_AWSIZE,
   input  wire [1:0]                           S06_AXI_AWBURST,
   input  wire                                 S06_AXI_AWLOCK,
   input  wire [3:0]                           S06_AXI_AWCACHE,
   input  wire [2:0]                           S06_AXI_AWPROT,
   input  wire [3:0]                           S06_AXI_AWQOS,
   input  wire                                 S06_AXI_AWVALID,
   output wire                                 S06_AXI_AWREADY,
   input  wire [C_S06_AXI_DATA_WIDTH-1:0]      S06_AXI_WDATA,
   input  wire [C_S06_AXI_DATA_WIDTH/8-1:0]    S06_AXI_WSTRB,
   input  wire                                 S06_AXI_WLAST,
   input  wire                                 S06_AXI_WVALID,
   output wire                                 S06_AXI_WREADY,
   output wire [C_THREAD_ID_PORT_WIDTH-1:0]    S06_AXI_BID,
   output wire [1:0]                           S06_AXI_BRESP,
   output wire                                 S06_AXI_BVALID,
   input  wire                                 S06_AXI_BREADY,
   input  wire [C_THREAD_ID_PORT_WIDTH-1:0]    S06_AXI_ARID,
   input  wire [C_AXI_ADDR_WIDTH-1:0]          S06_AXI_ARADDR,
   input  wire [7:0]                           S06_AXI_ARLEN,
   input  wire [2:0]                           S06_AXI_ARSIZE,
   input  wire [1:0]                           S06_AXI_ARBURST,
   input  wire                                 S06_AXI_ARLOCK,
   input  wire [3:0]                           S06_AXI_ARCACHE,
   input  wire [2:0]                           S06_AXI_ARPROT,
   input  wire [3:0]                           S06_AXI_ARQOS,
   input  wire                                 S06_AXI_ARVALID,
   output wire                                 S06_AXI_ARREADY,
   output wire [C_THREAD_ID_PORT_WIDTH-1:0]    S06_AXI_RID,
   output wire [C_S06_AXI_DATA_WIDTH-1:0]      S06_AXI_RDATA,
   output wire [1:0]                           S06_AXI_RRESP,
   output wire                                 S06_AXI_RLAST,
   output wire                                 S06_AXI_RVALID,
   input  wire                                 S06_AXI_RREADY,
   
   // Slave Interface S07
   output wire                                 S07_AXI_ARESET_OUT_N,
   // ISVALID = (C_NUM_SLAVE_PORTS > 7)
   input  wire                                 S07_AXI_ACLK,
   input  wire [C_THREAD_ID_PORT_WIDTH-1:0]    S07_AXI_AWID,
   input  wire [C_AXI_ADDR_WIDTH-1:0]          S07_AXI_AWADDR,
   input  wire [7:0]                           S07_AXI_AWLEN,
   input  wire [2:0]                           S07_AXI_AWSIZE,
   input  wire [1:0]                           S07_AXI_AWBURST,
   input  wire                                 S07_AXI_AWLOCK,
   input  wire [3:0]                           S07_AXI_AWCACHE,
   input  wire [2:0]                           S07_AXI_AWPROT,
   input  wire [3:0]                           S07_AXI_AWQOS,
   input  wire                                 S07_AXI_AWVALID,
   output wire                                 S07_AXI_AWREADY,
   input  wire [C_S07_AXI_DATA_WIDTH-1:0]      S07_AXI_WDATA,
   input  wire [C_S07_AXI_DATA_WIDTH/8-1:0]    S07_AXI_WSTRB,
   input  wire                                 S07_AXI_WLAST,
   input  wire                                 S07_AXI_WVALID,
   output wire                                 S07_AXI_WREADY,
   output wire [C_THREAD_ID_PORT_WIDTH-1:0]    S07_AXI_BID,
   output wire [1:0]                           S07_AXI_BRESP,
   output wire                                 S07_AXI_BVALID,
   input  wire                                 S07_AXI_BREADY,
   input  wire [C_THREAD_ID_PORT_WIDTH-1:0]    S07_AXI_ARID,
   input  wire [C_AXI_ADDR_WIDTH-1:0]          S07_AXI_ARADDR,
   input  wire [7:0]                           S07_AXI_ARLEN,
   input  wire [2:0]                           S07_AXI_ARSIZE,
   input  wire [1:0]                           S07_AXI_ARBURST,
   input  wire                                 S07_AXI_ARLOCK,
   input  wire [3:0]                           S07_AXI_ARCACHE,
   input  wire [2:0]                           S07_AXI_ARPROT,
   input  wire [3:0]                           S07_AXI_ARQOS,
   input  wire                                 S07_AXI_ARVALID,
   output wire                                 S07_AXI_ARREADY,
   output wire [C_THREAD_ID_PORT_WIDTH-1:0]    S07_AXI_RID,
   output wire [C_S07_AXI_DATA_WIDTH-1:0]      S07_AXI_RDATA,
   output wire [1:0]                           S07_AXI_RRESP,
   output wire                                 S07_AXI_RLAST,
   output wire                                 S07_AXI_RVALID,
   input  wire                                 S07_AXI_RREADY,
   
   // Slave Interface S08
   output wire                                 S08_AXI_ARESET_OUT_N,
   // ISVALID = (C_NUM_SLAVE_PORTS > 8)
   input  wire                                 S08_AXI_ACLK,
   input  wire [C_THREAD_ID_PORT_WIDTH-1:0]    S08_AXI_AWID,
   input  wire [C_AXI_ADDR_WIDTH-1:0]          S08_AXI_AWADDR,
   input  wire [7:0]                           S08_AXI_AWLEN,
   input  wire [2:0]                           S08_AXI_AWSIZE,
   input  wire [1:0]                           S08_AXI_AWBURST,
   input  wire                                 S08_AXI_AWLOCK,
   input  wire [3:0]                           S08_AXI_AWCACHE,
   input  wire [2:0]                           S08_AXI_AWPROT,
   input  wire [3:0]                           S08_AXI_AWQOS,
   input  wire                                 S08_AXI_AWVALID,
   output wire                                 S08_AXI_AWREADY,
   input  wire [C_S08_AXI_DATA_WIDTH-1:0]      S08_AXI_WDATA,
   input  wire [C_S08_AXI_DATA_WIDTH/8-1:0]    S08_AXI_WSTRB,
   input  wire                                 S08_AXI_WLAST,
   input  wire                                 S08_AXI_WVALID,
   output wire                                 S08_AXI_WREADY,
   output wire [C_THREAD_ID_PORT_WIDTH-1:0]    S08_AXI_BID,
   output wire [1:0]                           S08_AXI_BRESP,
   output wire                                 S08_AXI_BVALID,
   input  wire                                 S08_AXI_BREADY,
   input  wire [C_THREAD_ID_PORT_WIDTH-1:0]    S08_AXI_ARID,
   input  wire [C_AXI_ADDR_WIDTH-1:0]          S08_AXI_ARADDR,
   input  wire [7:0]                           S08_AXI_ARLEN,
   input  wire [2:0]                           S08_AXI_ARSIZE,
   input  wire [1:0]                           S08_AXI_ARBURST,
   input  wire                                 S08_AXI_ARLOCK,
   input  wire [3:0]                           S08_AXI_ARCACHE,
   input  wire [2:0]                           S08_AXI_ARPROT,
   input  wire [3:0]                           S08_AXI_ARQOS,
   input  wire                                 S08_AXI_ARVALID,
   output wire                                 S08_AXI_ARREADY,
   output wire [C_THREAD_ID_PORT_WIDTH-1:0]    S08_AXI_RID,
   output wire [C_S08_AXI_DATA_WIDTH-1:0]      S08_AXI_RDATA,
   output wire [1:0]                           S08_AXI_RRESP,
   output wire                                 S08_AXI_RLAST,
   output wire                                 S08_AXI_RVALID,
   input  wire                                 S08_AXI_RREADY,
   
   // Slave Interface S09
   output wire                                 S09_AXI_ARESET_OUT_N,
   // ISVALID = (C_NUM_SLAVE_PORTS > 9)
   input  wire                                 S09_AXI_ACLK,
   input  wire [C_THREAD_ID_PORT_WIDTH-1:0]    S09_AXI_AWID,
   input  wire [C_AXI_ADDR_WIDTH-1:0]          S09_AXI_AWADDR,
   input  wire [7:0]                           S09_AXI_AWLEN,
   input  wire [2:0]                           S09_AXI_AWSIZE,
   input  wire [1:0]                           S09_AXI_AWBURST,
   input  wire                                 S09_AXI_AWLOCK,
   input  wire [3:0]                           S09_AXI_AWCACHE,
   input  wire [2:0]                           S09_AXI_AWPROT,
   input  wire [3:0]                           S09_AXI_AWQOS,
   input  wire                                 S09_AXI_AWVALID,
   output wire                                 S09_AXI_AWREADY,
   input  wire [C_S09_AXI_DATA_WIDTH-1:0]      S09_AXI_WDATA,
   input  wire [C_S09_AXI_DATA_WIDTH/8-1:0]    S09_AXI_WSTRB,
   input  wire                                 S09_AXI_WLAST,
   input  wire                                 S09_AXI_WVALID,
   output wire                                 S09_AXI_WREADY,
   output wire [C_THREAD_ID_PORT_WIDTH-1:0]    S09_AXI_BID,
   output wire [1:0]                           S09_AXI_BRESP,
   output wire                                 S09_AXI_BVALID,
   input  wire                                 S09_AXI_BREADY,
   input  wire [C_THREAD_ID_PORT_WIDTH-1:0]    S09_AXI_ARID,
   input  wire [C_AXI_ADDR_WIDTH-1:0]          S09_AXI_ARADDR,
   input  wire [7:0]                           S09_AXI_ARLEN,
   input  wire [2:0]                           S09_AXI_ARSIZE,
   input  wire [1:0]                           S09_AXI_ARBURST,
   input  wire                                 S09_AXI_ARLOCK,
   input  wire [3:0]                           S09_AXI_ARCACHE,
   input  wire [2:0]                           S09_AXI_ARPROT,
   input  wire [3:0]                           S09_AXI_ARQOS,
   input  wire                                 S09_AXI_ARVALID,
   output wire                                 S09_AXI_ARREADY,
   output wire [C_THREAD_ID_PORT_WIDTH-1:0]    S09_AXI_RID,
   output wire [C_S09_AXI_DATA_WIDTH-1:0]      S09_AXI_RDATA,
   output wire [1:0]                           S09_AXI_RRESP,
   output wire                                 S09_AXI_RLAST,
   output wire                                 S09_AXI_RVALID,
   input  wire                                 S09_AXI_RREADY,
   
   // Slave Interface S10
   output wire                                 S10_AXI_ARESET_OUT_N,
   // ISVALID = (C_NUM_SLAVE_PORTS > 10)
   input  wire                                 S10_AXI_ACLK,
   input  wire [C_THREAD_ID_PORT_WIDTH-1:0]    S10_AXI_AWID,
   input  wire [C_AXI_ADDR_WIDTH-1:0]          S10_AXI_AWADDR,
   input  wire [7:0]                           S10_AXI_AWLEN,
   input  wire [2:0]                           S10_AXI_AWSIZE,
   input  wire [1:0]                           S10_AXI_AWBURST,
   input  wire                                 S10_AXI_AWLOCK,
   input  wire [3:0]                           S10_AXI_AWCACHE,
   input  wire [2:0]                           S10_AXI_AWPROT,
   input  wire [3:0]                           S10_AXI_AWQOS,
   input  wire                                 S10_AXI_AWVALID,
   output wire                                 S10_AXI_AWREADY,
   input  wire [C_S10_AXI_DATA_WIDTH-1:0]      S10_AXI_WDATA,
   input  wire [C_S10_AXI_DATA_WIDTH/8-1:0]    S10_AXI_WSTRB,
   input  wire                                 S10_AXI_WLAST,
   input  wire                                 S10_AXI_WVALID,
   output wire                                 S10_AXI_WREADY,
   output wire [C_THREAD_ID_PORT_WIDTH-1:0]    S10_AXI_BID,
   output wire [1:0]                           S10_AXI_BRESP,
   output wire                                 S10_AXI_BVALID,
   input  wire                                 S10_AXI_BREADY,
   input  wire [C_THREAD_ID_PORT_WIDTH-1:0]    S10_AXI_ARID,
   input  wire [C_AXI_ADDR_WIDTH-1:0]          S10_AXI_ARADDR,
   input  wire [7:0]                           S10_AXI_ARLEN,
   input  wire [2:0]                           S10_AXI_ARSIZE,
   input  wire [1:0]                           S10_AXI_ARBURST,
   input  wire                                 S10_AXI_ARLOCK,
   input  wire [3:0]                           S10_AXI_ARCACHE,
   input  wire [2:0]                           S10_AXI_ARPROT,
   input  wire [3:0]                           S10_AXI_ARQOS,
   input  wire                                 S10_AXI_ARVALID,
   output wire                                 S10_AXI_ARREADY,
   output wire [C_THREAD_ID_PORT_WIDTH-1:0]    S10_AXI_RID,
   output wire [C_S10_AXI_DATA_WIDTH-1:0]      S10_AXI_RDATA,
   output wire [1:0]                           S10_AXI_RRESP,
   output wire                                 S10_AXI_RLAST,
   output wire                                 S10_AXI_RVALID,
   input  wire                                 S10_AXI_RREADY,
   
   // Slave Interface S11
   output wire                                 S11_AXI_ARESET_OUT_N,
   // ISVALID = (C_NUM_SLAVE_PORTS > 11)
   input  wire                                 S11_AXI_ACLK,
   input  wire [C_THREAD_ID_PORT_WIDTH-1:0]    S11_AXI_AWID,
   input  wire [C_AXI_ADDR_WIDTH-1:0]          S11_AXI_AWADDR,
   input  wire [7:0]                           S11_AXI_AWLEN,
   input  wire [2:0]                           S11_AXI_AWSIZE,
   input  wire [1:0]                           S11_AXI_AWBURST,
   input  wire                                 S11_AXI_AWLOCK,
   input  wire [3:0]                           S11_AXI_AWCACHE,
   input  wire [2:0]                           S11_AXI_AWPROT,
   input  wire [3:0]                           S11_AXI_AWQOS,
   input  wire                                 S11_AXI_AWVALID,
   output wire                                 S11_AXI_AWREADY,
   input  wire [C_S11_AXI_DATA_WIDTH-1:0]      S11_AXI_WDATA,
   input  wire [C_S11_AXI_DATA_WIDTH/8-1:0]    S11_AXI_WSTRB,
   input  wire                                 S11_AXI_WLAST,
   input  wire                                 S11_AXI_WVALID,
   output wire                                 S11_AXI_WREADY,
   output wire [C_THREAD_ID_PORT_WIDTH-1:0]    S11_AXI_BID,
   output wire [1:0]                           S11_AXI_BRESP,
   output wire                                 S11_AXI_BVALID,
   input  wire                                 S11_AXI_BREADY,
   input  wire [C_THREAD_ID_PORT_WIDTH-1:0]    S11_AXI_ARID,
   input  wire [C_AXI_ADDR_WIDTH-1:0]          S11_AXI_ARADDR,
   input  wire [7:0]                           S11_AXI_ARLEN,
   input  wire [2:0]                           S11_AXI_ARSIZE,
   input  wire [1:0]                           S11_AXI_ARBURST,
   input  wire                                 S11_AXI_ARLOCK,
   input  wire [3:0]                           S11_AXI_ARCACHE,
   input  wire [2:0]                           S11_AXI_ARPROT,
   input  wire [3:0]                           S11_AXI_ARQOS,
   input  wire                                 S11_AXI_ARVALID,
   output wire                                 S11_AXI_ARREADY,
   output wire [C_THREAD_ID_PORT_WIDTH-1:0]    S11_AXI_RID,
   output wire [C_S11_AXI_DATA_WIDTH-1:0]      S11_AXI_RDATA,
   output wire [1:0]                           S11_AXI_RRESP,
   output wire                                 S11_AXI_RLAST,
   output wire                                 S11_AXI_RVALID,
   input  wire                                 S11_AXI_RREADY,
   
   // Slave Interface S12
   output wire                                 S12_AXI_ARESET_OUT_N,
   // ISVALID = (C_NUM_SLAVE_PORTS > 12)
   input  wire                                 S12_AXI_ACLK,
   input  wire [C_THREAD_ID_PORT_WIDTH-1:0]    S12_AXI_AWID,
   input  wire [C_AXI_ADDR_WIDTH-1:0]          S12_AXI_AWADDR,
   input  wire [7:0]                           S12_AXI_AWLEN,
   input  wire [2:0]                           S12_AXI_AWSIZE,
   input  wire [1:0]                           S12_AXI_AWBURST,
   input  wire                                 S12_AXI_AWLOCK,
   input  wire [3:0]                           S12_AXI_AWCACHE,
   input  wire [2:0]                           S12_AXI_AWPROT,
   input  wire [3:0]                           S12_AXI_AWQOS,
   input  wire                                 S12_AXI_AWVALID,
   output wire                                 S12_AXI_AWREADY,
   input  wire [C_S12_AXI_DATA_WIDTH-1:0]      S12_AXI_WDATA,
   input  wire [C_S12_AXI_DATA_WIDTH/8-1:0]    S12_AXI_WSTRB,
   input  wire                                 S12_AXI_WLAST,
   input  wire                                 S12_AXI_WVALID,
   output wire                                 S12_AXI_WREADY,
   output wire [C_THREAD_ID_PORT_WIDTH-1:0]    S12_AXI_BID,
   output wire [1:0]                           S12_AXI_BRESP,
   output wire                                 S12_AXI_BVALID,
   input  wire                                 S12_AXI_BREADY,
   input  wire [C_THREAD_ID_PORT_WIDTH-1:0]    S12_AXI_ARID,
   input  wire [C_AXI_ADDR_WIDTH-1:0]          S12_AXI_ARADDR,
   input  wire [7:0]                           S12_AXI_ARLEN,
   input  wire [2:0]                           S12_AXI_ARSIZE,
   input  wire [1:0]                           S12_AXI_ARBURST,
   input  wire                                 S12_AXI_ARLOCK,
   input  wire [3:0]                           S12_AXI_ARCACHE,
   input  wire [2:0]                           S12_AXI_ARPROT,
   input  wire [3:0]                           S12_AXI_ARQOS,
   input  wire                                 S12_AXI_ARVALID,
   output wire                                 S12_AXI_ARREADY,
   output wire [C_THREAD_ID_PORT_WIDTH-1:0]    S12_AXI_RID,
   output wire [C_S12_AXI_DATA_WIDTH-1:0]      S12_AXI_RDATA,
   output wire [1:0]                           S12_AXI_RRESP,
   output wire                                 S12_AXI_RLAST,
   output wire                                 S12_AXI_RVALID,
   input  wire                                 S12_AXI_RREADY,
   
   // Slave Interface S13
   output wire                                 S13_AXI_ARESET_OUT_N,
   // ISVALID = (C_NUM_SLAVE_PORTS > 13)
   input  wire                                 S13_AXI_ACLK,
   input  wire [C_THREAD_ID_PORT_WIDTH-1:0]    S13_AXI_AWID,
   input  wire [C_AXI_ADDR_WIDTH-1:0]          S13_AXI_AWADDR,
   input  wire [7:0]                           S13_AXI_AWLEN,
   input  wire [2:0]                           S13_AXI_AWSIZE,
   input  wire [1:0]                           S13_AXI_AWBURST,
   input  wire                                 S13_AXI_AWLOCK,
   input  wire [3:0]                           S13_AXI_AWCACHE,
   input  wire [2:0]                           S13_AXI_AWPROT,
   input  wire [3:0]                           S13_AXI_AWQOS,
   input  wire                                 S13_AXI_AWVALID,
   output wire                                 S13_AXI_AWREADY,
   input  wire [C_S13_AXI_DATA_WIDTH-1:0]      S13_AXI_WDATA,
   input  wire [C_S13_AXI_DATA_WIDTH/8-1:0]    S13_AXI_WSTRB,
   input  wire                                 S13_AXI_WLAST,
   input  wire                                 S13_AXI_WVALID,
   output wire                                 S13_AXI_WREADY,
   output wire [C_THREAD_ID_PORT_WIDTH-1:0]    S13_AXI_BID,
   output wire [1:0]                           S13_AXI_BRESP,
   output wire                                 S13_AXI_BVALID,
   input  wire                                 S13_AXI_BREADY,
   input  wire [C_THREAD_ID_PORT_WIDTH-1:0]    S13_AXI_ARID,
   input  wire [C_AXI_ADDR_WIDTH-1:0]          S13_AXI_ARADDR,
   input  wire [7:0]                           S13_AXI_ARLEN,
   input  wire [2:0]                           S13_AXI_ARSIZE,
   input  wire [1:0]                           S13_AXI_ARBURST,
   input  wire                                 S13_AXI_ARLOCK,
   input  wire [3:0]                           S13_AXI_ARCACHE,
   input  wire [2:0]                           S13_AXI_ARPROT,
   input  wire [3:0]                           S13_AXI_ARQOS,
   input  wire                                 S13_AXI_ARVALID,
   output wire                                 S13_AXI_ARREADY,
   output wire [C_THREAD_ID_PORT_WIDTH-1:0]    S13_AXI_RID,
   output wire [C_S13_AXI_DATA_WIDTH-1:0]      S13_AXI_RDATA,
   output wire [1:0]                           S13_AXI_RRESP,
   output wire                                 S13_AXI_RLAST,
   output wire                                 S13_AXI_RVALID,
   input  wire                                 S13_AXI_RREADY,
   
   // Slave Interface S14
   output wire                                 S14_AXI_ARESET_OUT_N,
   // ISVALID = (C_NUM_SLAVE_PORTS > 14)
   input  wire                                 S14_AXI_ACLK,
   input  wire [C_THREAD_ID_PORT_WIDTH-1:0]    S14_AXI_AWID,
   input  wire [C_AXI_ADDR_WIDTH-1:0]          S14_AXI_AWADDR,
   input  wire [7:0]                           S14_AXI_AWLEN,
   input  wire [2:0]                           S14_AXI_AWSIZE,
   input  wire [1:0]                           S14_AXI_AWBURST,
   input  wire                                 S14_AXI_AWLOCK,
   input  wire [3:0]                           S14_AXI_AWCACHE,
   input  wire [2:0]                           S14_AXI_AWPROT,
   input  wire [3:0]                           S14_AXI_AWQOS,
   input  wire                                 S14_AXI_AWVALID,
   output wire                                 S14_AXI_AWREADY,
   input  wire [C_S14_AXI_DATA_WIDTH-1:0]      S14_AXI_WDATA,
   input  wire [C_S14_AXI_DATA_WIDTH/8-1:0]    S14_AXI_WSTRB,
   input  wire                                 S14_AXI_WLAST,
   input  wire                                 S14_AXI_WVALID,
   output wire                                 S14_AXI_WREADY,
   output wire [C_THREAD_ID_PORT_WIDTH-1:0]    S14_AXI_BID,
   output wire [1:0]                           S14_AXI_BRESP,
   output wire                                 S14_AXI_BVALID,
   input  wire                                 S14_AXI_BREADY,
   input  wire [C_THREAD_ID_PORT_WIDTH-1:0]    S14_AXI_ARID,
   input  wire [C_AXI_ADDR_WIDTH-1:0]          S14_AXI_ARADDR,
   input  wire [7:0]                           S14_AXI_ARLEN,
   input  wire [2:0]                           S14_AXI_ARSIZE,
   input  wire [1:0]                           S14_AXI_ARBURST,
   input  wire                                 S14_AXI_ARLOCK,
   input  wire [3:0]                           S14_AXI_ARCACHE,
   input  wire [2:0]                           S14_AXI_ARPROT,
   input  wire [3:0]                           S14_AXI_ARQOS,
   input  wire                                 S14_AXI_ARVALID,
   output wire                                 S14_AXI_ARREADY,
   output wire [C_THREAD_ID_PORT_WIDTH-1:0]    S14_AXI_RID,
   output wire [C_S14_AXI_DATA_WIDTH-1:0]      S14_AXI_RDATA,
   output wire [1:0]                           S14_AXI_RRESP,
   output wire                                 S14_AXI_RLAST,
   output wire                                 S14_AXI_RVALID,
   input  wire                                 S14_AXI_RREADY,
   
   // Slave Interface S15
   output wire                                 S15_AXI_ARESET_OUT_N,
   // ISVALID = (C_NUM_SLAVE_PORTS > 15)
   input  wire                                 S15_AXI_ACLK,
   input  wire [C_THREAD_ID_PORT_WIDTH-1:0]    S15_AXI_AWID,
   input  wire [C_AXI_ADDR_WIDTH-1:0]          S15_AXI_AWADDR,
   input  wire [7:0]                           S15_AXI_AWLEN,
   input  wire [2:0]                           S15_AXI_AWSIZE,
   input  wire [1:0]                           S15_AXI_AWBURST,
   input  wire                                 S15_AXI_AWLOCK,
   input  wire [3:0]                           S15_AXI_AWCACHE,
   input  wire [2:0]                           S15_AXI_AWPROT,
   input  wire [3:0]                           S15_AXI_AWQOS,
   input  wire                                 S15_AXI_AWVALID,
   output wire                                 S15_AXI_AWREADY,
   input  wire [C_S15_AXI_DATA_WIDTH-1:0]      S15_AXI_WDATA,
   input  wire [C_S15_AXI_DATA_WIDTH/8-1:0]    S15_AXI_WSTRB,
   input  wire                                 S15_AXI_WLAST,
   input  wire                                 S15_AXI_WVALID,
   output wire                                 S15_AXI_WREADY,
   output wire [C_THREAD_ID_PORT_WIDTH-1:0]    S15_AXI_BID,
   output wire [1:0]                           S15_AXI_BRESP,
   output wire                                 S15_AXI_BVALID,
   input  wire                                 S15_AXI_BREADY,
   input  wire [C_THREAD_ID_PORT_WIDTH-1:0]    S15_AXI_ARID,
   input  wire [C_AXI_ADDR_WIDTH-1:0]          S15_AXI_ARADDR,
   input  wire [7:0]                           S15_AXI_ARLEN,
   input  wire [2:0]                           S15_AXI_ARSIZE,
   input  wire [1:0]                           S15_AXI_ARBURST,
   input  wire                                 S15_AXI_ARLOCK,
   input  wire [3:0]                           S15_AXI_ARCACHE,
   input  wire [2:0]                           S15_AXI_ARPROT,
   input  wire [3:0]                           S15_AXI_ARQOS,
   input  wire                                 S15_AXI_ARVALID,
   output wire                                 S15_AXI_ARREADY,
   output wire [C_THREAD_ID_PORT_WIDTH-1:0]    S15_AXI_RID,
   output wire [C_S15_AXI_DATA_WIDTH-1:0]      S15_AXI_RDATA,
   output wire [1:0]                           S15_AXI_RRESP,
   output wire                                 S15_AXI_RLAST,
   output wire                                 S15_AXI_RVALID,
   input  wire                                 S15_AXI_RREADY,
   
   // Master Interface
   output wire                                 M00_AXI_ARESET_OUT_N,
   input  wire                                 M00_AXI_ACLK,
   output wire [C_THREAD_ID_WIDTH+3:0]         M00_AXI_AWID,
   output wire [C_AXI_ADDR_WIDTH-1:0]          M00_AXI_AWADDR,
   output wire [7:0]                           M00_AXI_AWLEN,
   output wire [2:0]                           M00_AXI_AWSIZE,
   output wire [1:0]                           M00_AXI_AWBURST,
   output wire                                 M00_AXI_AWLOCK,
   output wire [3:0]                           M00_AXI_AWCACHE,
   output wire [2:0]                           M00_AXI_AWPROT,
   output wire [3:0]                           M00_AXI_AWQOS,
   output wire                                 M00_AXI_AWVALID,
   input  wire                                 M00_AXI_AWREADY,
   output wire [C_M00_AXI_DATA_WIDTH-1:0]        M00_AXI_WDATA,
   output wire [C_M00_AXI_DATA_WIDTH/8-1:0]      M00_AXI_WSTRB,
   output wire                                 M00_AXI_WLAST,
   output wire                                 M00_AXI_WVALID,
   input  wire                                 M00_AXI_WREADY,
   input  wire [C_THREAD_ID_WIDTH+3:0]         M00_AXI_BID,
   input  wire [1:0]                           M00_AXI_BRESP,
   input  wire                                 M00_AXI_BVALID,
   output wire                                 M00_AXI_BREADY,
   output wire [C_THREAD_ID_WIDTH+3:0]         M00_AXI_ARID,
   output wire [C_AXI_ADDR_WIDTH-1:0]          M00_AXI_ARADDR,
   output wire [7:0]                           M00_AXI_ARLEN,
   output wire [2:0]                           M00_AXI_ARSIZE,
   output wire [1:0]                           M00_AXI_ARBURST,
   output wire                                 M00_AXI_ARLOCK,
   output wire [3:0]                           M00_AXI_ARCACHE,
   output wire [2:0]                           M00_AXI_ARPROT,
   output wire [3:0]                           M00_AXI_ARQOS,
   output wire                                 M00_AXI_ARVALID,
   input  wire                                 M00_AXI_ARREADY,
   input  wire [C_THREAD_ID_WIDTH+3:0]         M00_AXI_RID,
   input  wire [C_M00_AXI_DATA_WIDTH-1:0]        M00_AXI_RDATA,
   input  wire [1:0]                           M00_AXI_RRESP,
   input  wire                                 M00_AXI_RLAST,
   input  wire                                 M00_AXI_RVALID,
   output wire                                 M00_AXI_RREADY
   );
   
  function integer f_log2
    (
     input integer x
     );
    integer acc;
    begin
      acc=0;
      while (x >> (acc+1))
        acc = acc + 1;
      f_log2 = acc;
    end
  endfunction

  function f_bit1(
  // Cast as bit1.
      input  arg
    );
    begin
      f_bit1 = arg ? 1'b1 : 1'b0;
    end
  endfunction

  function [31:0] f_bit32_qual(
  // Cast as bit32. Replace with null_value if not qualified.
      input [31:0] arg,
      input        qual, // boolean
      input [31:0] null_val
    );
    begin
      f_bit32_qual = qual ? arg : null_val;
    end
  endfunction

  localparam         P_S_AXI_DATA_WIDTH = {
    f_bit32_qual(C_S15_AXI_DATA_WIDTH, (C_NUM_SLAVE_PORTS > 15), 32),
    f_bit32_qual(C_S14_AXI_DATA_WIDTH, (C_NUM_SLAVE_PORTS > 14), 32),
    f_bit32_qual(C_S13_AXI_DATA_WIDTH, (C_NUM_SLAVE_PORTS > 13), 32),
    f_bit32_qual(C_S12_AXI_DATA_WIDTH, (C_NUM_SLAVE_PORTS > 12), 32),
    f_bit32_qual(C_S11_AXI_DATA_WIDTH, (C_NUM_SLAVE_PORTS > 11), 32),
    f_bit32_qual(C_S10_AXI_DATA_WIDTH, (C_NUM_SLAVE_PORTS > 10), 32),
    f_bit32_qual(C_S09_AXI_DATA_WIDTH, (C_NUM_SLAVE_PORTS > 09), 32),
    f_bit32_qual(C_S08_AXI_DATA_WIDTH, (C_NUM_SLAVE_PORTS > 08), 32),
    f_bit32_qual(C_S07_AXI_DATA_WIDTH, (C_NUM_SLAVE_PORTS > 07), 32),
    f_bit32_qual(C_S06_AXI_DATA_WIDTH, (C_NUM_SLAVE_PORTS > 06), 32),
    f_bit32_qual(C_S05_AXI_DATA_WIDTH, (C_NUM_SLAVE_PORTS > 05), 32),
    f_bit32_qual(C_S04_AXI_DATA_WIDTH, (C_NUM_SLAVE_PORTS > 04), 32),
    f_bit32_qual(C_S03_AXI_DATA_WIDTH, (C_NUM_SLAVE_PORTS > 03), 32),
    f_bit32_qual(C_S02_AXI_DATA_WIDTH, (C_NUM_SLAVE_PORTS > 02), 32),
    f_bit32_qual(C_S01_AXI_DATA_WIDTH, (C_NUM_SLAVE_PORTS > 01), 32),
    f_bit32_qual(C_S00_AXI_DATA_WIDTH, (C_NUM_SLAVE_PORTS > 00), 32)
    };
  localparam         P_M_AXI_DATA_WIDTH = {{15{32'h32}}, f_bit32_qual(C_M00_AXI_DATA_WIDTH, 1, 0)};
  localparam         P_OR_DATA_WIDTHS = 
    f_bit32_qual(C_S00_AXI_DATA_WIDTH, (C_NUM_SLAVE_PORTS > 00), 0) |
    f_bit32_qual(C_S01_AXI_DATA_WIDTH, (C_NUM_SLAVE_PORTS > 01), 0) |
    f_bit32_qual(C_S02_AXI_DATA_WIDTH, (C_NUM_SLAVE_PORTS > 02), 0) |
    f_bit32_qual(C_S03_AXI_DATA_WIDTH, (C_NUM_SLAVE_PORTS > 03), 0) |
    f_bit32_qual(C_S04_AXI_DATA_WIDTH, (C_NUM_SLAVE_PORTS > 04), 0) |
    f_bit32_qual(C_S05_AXI_DATA_WIDTH, (C_NUM_SLAVE_PORTS > 05), 0) |
    f_bit32_qual(C_S06_AXI_DATA_WIDTH, (C_NUM_SLAVE_PORTS > 06), 0) |
    f_bit32_qual(C_S07_AXI_DATA_WIDTH, (C_NUM_SLAVE_PORTS > 07), 0) |
    f_bit32_qual(C_S08_AXI_DATA_WIDTH, (C_NUM_SLAVE_PORTS > 08), 0) |
    f_bit32_qual(C_S09_AXI_DATA_WIDTH, (C_NUM_SLAVE_PORTS > 09), 0) |
    f_bit32_qual(C_S10_AXI_DATA_WIDTH, (C_NUM_SLAVE_PORTS > 10), 0) |
    f_bit32_qual(C_S11_AXI_DATA_WIDTH, (C_NUM_SLAVE_PORTS > 11), 0) |
    f_bit32_qual(C_S12_AXI_DATA_WIDTH, (C_NUM_SLAVE_PORTS > 12), 0) |
    f_bit32_qual(C_S13_AXI_DATA_WIDTH, (C_NUM_SLAVE_PORTS > 13), 0) |
    f_bit32_qual(C_S14_AXI_DATA_WIDTH, (C_NUM_SLAVE_PORTS > 14), 0) |
    f_bit32_qual(C_S15_AXI_DATA_WIDTH, (C_NUM_SLAVE_PORTS > 15), 0) |
    f_bit32_qual(C_M00_AXI_DATA_WIDTH, 1, 0) |
    f_bit32_qual(C_INTERCONNECT_DATA_WIDTH, 1, 0);
  localparam integer P_AXI_DATA_MAX_WIDTH = 1 << f_log2(P_OR_DATA_WIDTHS);
  localparam         P_M_AXI_BASE_ADDR = {{240{64'hFFFFFFFFFFFFFFFF}}, {15{64'hFFFFFFFFFFFFFFFF}}, 64'h0000000000000000};
  localparam         P_M_AXI_HIGH_ADDR = 64'hFFFFFFFFFFFFFFFF;
  localparam         P_S_AXI_BASE_ID = 
    (C_THREAD_ID_WIDTH == 0) ? {32'hF<<0, 32'hE<<0, 32'hD<<0, 32'hC<<0, 32'hB<<0, 32'hA<<0, 32'h9<<0, 32'h8<<0, 32'h7<<0, 32'h6<<0, 32'h5<<0, 32'h4<<0, 32'h3<<0, 32'h2<<0, 32'h1<<0, 32'h0} :
    (C_THREAD_ID_WIDTH == 1) ? {32'hF<<1, 32'hE<<1, 32'hD<<1, 32'hC<<1, 32'hB<<1, 32'hA<<1, 32'h9<<1, 32'h8<<1, 32'h7<<1, 32'h6<<1, 32'h5<<1, 32'h4<<1, 32'h3<<1, 32'h2<<1, 32'h1<<1, 32'h0} :
    (C_THREAD_ID_WIDTH == 2) ? {32'hF<<2, 32'hE<<2, 32'hD<<2, 32'hC<<2, 32'hB<<2, 32'hA<<2, 32'h9<<2, 32'h8<<2, 32'h7<<2, 32'h6<<2, 32'h5<<2, 32'h4<<2, 32'h3<<2, 32'h2<<2, 32'h1<<2, 32'h0} :
    (C_THREAD_ID_WIDTH == 3) ? {32'hF<<3, 32'hE<<3, 32'hD<<3, 32'hC<<3, 32'hB<<3, 32'hA<<3, 32'h9<<3, 32'h8<<3, 32'h7<<3, 32'h6<<3, 32'h5<<3, 32'h4<<3, 32'h3<<3, 32'h2<<3, 32'h1<<3, 32'h0} :
    (C_THREAD_ID_WIDTH == 4) ? {32'hF<<4, 32'hE<<4, 32'hD<<4, 32'hC<<4, 32'hB<<4, 32'hA<<4, 32'h9<<4, 32'h8<<4, 32'h7<<4, 32'h6<<4, 32'h5<<4, 32'h4<<4, 32'h3<<4, 32'h2<<4, 32'h1<<4, 32'h0} :
    (C_THREAD_ID_WIDTH == 5) ? {32'hF<<5, 32'hE<<5, 32'hD<<5, 32'hC<<5, 32'hB<<5, 32'hA<<5, 32'h9<<5, 32'h8<<5, 32'h7<<5, 32'h6<<5, 32'h5<<5, 32'h4<<5, 32'h3<<5, 32'h2<<5, 32'h1<<5, 32'h0} :
    (C_THREAD_ID_WIDTH == 6) ? {32'hF<<6, 32'hE<<6, 32'hD<<6, 32'hC<<6, 32'hB<<6, 32'hA<<6, 32'h9<<6, 32'h8<<6, 32'h7<<6, 32'h6<<6, 32'h5<<6, 32'h4<<6, 32'h3<<6, 32'h2<<6, 32'h1<<6, 32'h0} :
    (C_THREAD_ID_WIDTH == 7) ? {32'hF<<7, 32'hE<<7, 32'hD<<7, 32'hC<<7, 32'hB<<7, 32'hA<<7, 32'h9<<7, 32'h8<<7, 32'h7<<7, 32'h6<<7, 32'h5<<7, 32'h4<<7, 32'h3<<7, 32'h2<<7, 32'h1<<7, 32'h0} :
                               {32'hF<<8, 32'hE<<8, 32'hD<<8, 32'hC<<8, 32'hB<<8, 32'hA<<8, 32'h9<<8, 32'h8<<8, 32'h7<<8, 32'h6<<8, 32'h5<<8, 32'h4<<8, 32'h3<<8, 32'h2<<8, 32'h1<<8, 32'h0} ;
  localparam integer P_AXI_ID_WIDTH = C_THREAD_ID_WIDTH + 4;
  localparam         P_S_AXI_THREAD_ID_WIDTH = {C_NUM_SLAVE_PORTS{f_bit32_qual(C_THREAD_ID_WIDTH, 1, 0)}};
  localparam integer K = 720720;  // Least_common_multiple(2...16)
  localparam         P_S_AXI_ACLK_RATIO = {
    f_bit32_qual((
      (C_S15_AXI_ACLK_RATIO == "1:16") ? (K / 16) :
      (C_S15_AXI_ACLK_RATIO == "1:15") ? (K / 15) :
      (C_S15_AXI_ACLK_RATIO == "1:14") ? (K / 14) :
      (C_S15_AXI_ACLK_RATIO == "1:13") ? (K / 13) :
      (C_S15_AXI_ACLK_RATIO == "1:12") ? (K / 12) :
      (C_S15_AXI_ACLK_RATIO == "1:11") ? (K / 11) :
      (C_S15_AXI_ACLK_RATIO == "1:10") ? (K / 10) :
      (C_S15_AXI_ACLK_RATIO == "1:9")  ? (K / 9 ) :
      (C_S15_AXI_ACLK_RATIO == "1:8")  ? (K / 8 ) :
      (C_S15_AXI_ACLK_RATIO == "1:7")  ? (K / 7 ) :
      (C_S15_AXI_ACLK_RATIO == "1:6")  ? (K / 6 ) :
      (C_S15_AXI_ACLK_RATIO == "1:5")  ? (K / 5 ) :
      (C_S15_AXI_ACLK_RATIO == "1:4")  ? (K / 4 ) :
      (C_S15_AXI_ACLK_RATIO == "1:3")  ? (K / 3 ) :
      (C_S15_AXI_ACLK_RATIO == "1:2")  ? (K / 2 ) :
      (C_S15_AXI_ACLK_RATIO ==  "2:1") ? (K * 2 ) :
      (C_S15_AXI_ACLK_RATIO ==  "3:1") ? (K * 3 ) :
      (C_S15_AXI_ACLK_RATIO ==  "4:1") ? (K * 4 ) :
      (C_S15_AXI_ACLK_RATIO ==  "5:1") ? (K * 5 ) :
      (C_S15_AXI_ACLK_RATIO ==  "6:1") ? (K * 6 ) :
      (C_S15_AXI_ACLK_RATIO ==  "7:1") ? (K * 7 ) :
      (C_S15_AXI_ACLK_RATIO ==  "8:1") ? (K * 8 ) :
      (C_S15_AXI_ACLK_RATIO ==  "9:1") ? (K * 9 ) :
      (C_S15_AXI_ACLK_RATIO == "10:1") ? (K * 10) :
      (C_S15_AXI_ACLK_RATIO == "11:1") ? (K * 11) :
      (C_S15_AXI_ACLK_RATIO == "12:1") ? (K * 12) :
      (C_S15_AXI_ACLK_RATIO == "13:1") ? (K * 13) :
      (C_S15_AXI_ACLK_RATIO == "14:1") ? (K * 14) :
      (C_S15_AXI_ACLK_RATIO == "15:1") ? (K * 15) :
      (C_S15_AXI_ACLK_RATIO == "16:1") ? (K * 16) :
      K), (C_NUM_SLAVE_PORTS > 15), 1),
    f_bit32_qual((
      (C_S14_AXI_ACLK_RATIO == "1:16") ? (K / 16) :
      (C_S14_AXI_ACLK_RATIO == "1:15") ? (K / 15) :
      (C_S14_AXI_ACLK_RATIO == "1:14") ? (K / 14) :
      (C_S14_AXI_ACLK_RATIO == "1:13") ? (K / 13) :
      (C_S14_AXI_ACLK_RATIO == "1:12") ? (K / 12) :
      (C_S14_AXI_ACLK_RATIO == "1:11") ? (K / 11) :
      (C_S14_AXI_ACLK_RATIO == "1:10") ? (K / 10) :
      (C_S14_AXI_ACLK_RATIO == "1:9")  ? (K / 9 ) :
      (C_S14_AXI_ACLK_RATIO == "1:8")  ? (K / 8 ) :
      (C_S14_AXI_ACLK_RATIO == "1:7")  ? (K / 7 ) :
      (C_S14_AXI_ACLK_RATIO == "1:6")  ? (K / 6 ) :
      (C_S14_AXI_ACLK_RATIO == "1:5")  ? (K / 5 ) :
      (C_S14_AXI_ACLK_RATIO == "1:4")  ? (K / 4 ) :
      (C_S14_AXI_ACLK_RATIO == "1:3")  ? (K / 3 ) :
      (C_S14_AXI_ACLK_RATIO == "1:2")  ? (K / 2 ) :
      (C_S14_AXI_ACLK_RATIO ==  "2:1") ? (K * 2 ) :
      (C_S14_AXI_ACLK_RATIO ==  "3:1") ? (K * 3 ) :
      (C_S14_AXI_ACLK_RATIO ==  "4:1") ? (K * 4 ) :
      (C_S14_AXI_ACLK_RATIO ==  "5:1") ? (K * 5 ) :
      (C_S14_AXI_ACLK_RATIO ==  "6:1") ? (K * 6 ) :
      (C_S14_AXI_ACLK_RATIO ==  "7:1") ? (K * 7 ) :
      (C_S14_AXI_ACLK_RATIO ==  "8:1") ? (K * 8 ) :
      (C_S14_AXI_ACLK_RATIO ==  "9:1") ? (K * 9 ) :
      (C_S14_AXI_ACLK_RATIO == "10:1") ? (K * 10) :
      (C_S14_AXI_ACLK_RATIO == "11:1") ? (K * 11) :
      (C_S14_AXI_ACLK_RATIO == "12:1") ? (K * 12) :
      (C_S14_AXI_ACLK_RATIO == "13:1") ? (K * 13) :
      (C_S14_AXI_ACLK_RATIO == "14:1") ? (K * 14) :
      (C_S14_AXI_ACLK_RATIO == "15:1") ? (K * 15) :
      (C_S14_AXI_ACLK_RATIO == "16:1") ? (K * 16) :
      K), (C_NUM_SLAVE_PORTS > 14), 1),
    f_bit32_qual((
      (C_S13_AXI_ACLK_RATIO == "1:16") ? (K / 16) :
      (C_S13_AXI_ACLK_RATIO == "1:15") ? (K / 15) :
      (C_S13_AXI_ACLK_RATIO == "1:14") ? (K / 14) :
      (C_S13_AXI_ACLK_RATIO == "1:13") ? (K / 13) :
      (C_S13_AXI_ACLK_RATIO == "1:12") ? (K / 12) :
      (C_S13_AXI_ACLK_RATIO == "1:11") ? (K / 11) :
      (C_S13_AXI_ACLK_RATIO == "1:10") ? (K / 10) :
      (C_S13_AXI_ACLK_RATIO == "1:9")  ? (K / 9 ) :
      (C_S13_AXI_ACLK_RATIO == "1:8")  ? (K / 8 ) :
      (C_S13_AXI_ACLK_RATIO == "1:7")  ? (K / 7 ) :
      (C_S13_AXI_ACLK_RATIO == "1:6")  ? (K / 6 ) :
      (C_S13_AXI_ACLK_RATIO == "1:5")  ? (K / 5 ) :
      (C_S13_AXI_ACLK_RATIO == "1:4")  ? (K / 4 ) :
      (C_S13_AXI_ACLK_RATIO == "1:3")  ? (K / 3 ) :
      (C_S13_AXI_ACLK_RATIO == "1:2")  ? (K / 2 ) :
      (C_S13_AXI_ACLK_RATIO ==  "2:1") ? (K * 2 ) :
      (C_S13_AXI_ACLK_RATIO ==  "3:1") ? (K * 3 ) :
      (C_S13_AXI_ACLK_RATIO ==  "4:1") ? (K * 4 ) :
      (C_S13_AXI_ACLK_RATIO ==  "5:1") ? (K * 5 ) :
      (C_S13_AXI_ACLK_RATIO ==  "6:1") ? (K * 6 ) :
      (C_S13_AXI_ACLK_RATIO ==  "7:1") ? (K * 7 ) :
      (C_S13_AXI_ACLK_RATIO ==  "8:1") ? (K * 8 ) :
      (C_S13_AXI_ACLK_RATIO ==  "9:1") ? (K * 9 ) :
      (C_S13_AXI_ACLK_RATIO == "10:1") ? (K * 10) :
      (C_S13_AXI_ACLK_RATIO == "11:1") ? (K * 11) :
      (C_S13_AXI_ACLK_RATIO == "12:1") ? (K * 12) :
      (C_S13_AXI_ACLK_RATIO == "13:1") ? (K * 13) :
      (C_S13_AXI_ACLK_RATIO == "14:1") ? (K * 14) :
      (C_S13_AXI_ACLK_RATIO == "15:1") ? (K * 15) :
      (C_S13_AXI_ACLK_RATIO == "16:1") ? (K * 16) :
      K), (C_NUM_SLAVE_PORTS > 13), 1),
    f_bit32_qual((
      (C_S12_AXI_ACLK_RATIO == "1:16") ? (K / 16) :
      (C_S12_AXI_ACLK_RATIO == "1:15") ? (K / 15) :
      (C_S12_AXI_ACLK_RATIO == "1:14") ? (K / 14) :
      (C_S12_AXI_ACLK_RATIO == "1:13") ? (K / 13) :
      (C_S12_AXI_ACLK_RATIO == "1:12") ? (K / 12) :
      (C_S12_AXI_ACLK_RATIO == "1:11") ? (K / 11) :
      (C_S12_AXI_ACLK_RATIO == "1:10") ? (K / 10) :
      (C_S12_AXI_ACLK_RATIO == "1:9")  ? (K / 9 ) :
      (C_S12_AXI_ACLK_RATIO == "1:8")  ? (K / 8 ) :
      (C_S12_AXI_ACLK_RATIO == "1:7")  ? (K / 7 ) :
      (C_S12_AXI_ACLK_RATIO == "1:6")  ? (K / 6 ) :
      (C_S12_AXI_ACLK_RATIO == "1:5")  ? (K / 5 ) :
      (C_S12_AXI_ACLK_RATIO == "1:4")  ? (K / 4 ) :
      (C_S12_AXI_ACLK_RATIO == "1:3")  ? (K / 3 ) :
      (C_S12_AXI_ACLK_RATIO == "1:2")  ? (K / 2 ) :
      (C_S12_AXI_ACLK_RATIO ==  "2:1") ? (K * 2 ) :
      (C_S12_AXI_ACLK_RATIO ==  "3:1") ? (K * 3 ) :
      (C_S12_AXI_ACLK_RATIO ==  "4:1") ? (K * 4 ) :
      (C_S12_AXI_ACLK_RATIO ==  "5:1") ? (K * 5 ) :
      (C_S12_AXI_ACLK_RATIO ==  "6:1") ? (K * 6 ) :
      (C_S12_AXI_ACLK_RATIO ==  "7:1") ? (K * 7 ) :
      (C_S12_AXI_ACLK_RATIO ==  "8:1") ? (K * 8 ) :
      (C_S12_AXI_ACLK_RATIO ==  "9:1") ? (K * 9 ) :
      (C_S12_AXI_ACLK_RATIO == "10:1") ? (K * 10) :
      (C_S12_AXI_ACLK_RATIO == "11:1") ? (K * 11) :
      (C_S12_AXI_ACLK_RATIO == "12:1") ? (K * 12) :
      (C_S12_AXI_ACLK_RATIO == "13:1") ? (K * 13) :
      (C_S12_AXI_ACLK_RATIO == "14:1") ? (K * 14) :
      (C_S12_AXI_ACLK_RATIO == "15:1") ? (K * 15) :
      (C_S12_AXI_ACLK_RATIO == "16:1") ? (K * 16) :
      K), (C_NUM_SLAVE_PORTS > 12), 1),
    f_bit32_qual((
      (C_S11_AXI_ACLK_RATIO == "1:16") ? (K / 16) :
      (C_S11_AXI_ACLK_RATIO == "1:15") ? (K / 15) :
      (C_S11_AXI_ACLK_RATIO == "1:14") ? (K / 14) :
      (C_S11_AXI_ACLK_RATIO == "1:13") ? (K / 13) :
      (C_S11_AXI_ACLK_RATIO == "1:12") ? (K / 12) :
      (C_S11_AXI_ACLK_RATIO == "1:11") ? (K / 11) :
      (C_S11_AXI_ACLK_RATIO == "1:10") ? (K / 10) :
      (C_S11_AXI_ACLK_RATIO == "1:9")  ? (K / 9 ) :
      (C_S11_AXI_ACLK_RATIO == "1:8")  ? (K / 8 ) :
      (C_S11_AXI_ACLK_RATIO == "1:7")  ? (K / 7 ) :
      (C_S11_AXI_ACLK_RATIO == "1:6")  ? (K / 6 ) :
      (C_S11_AXI_ACLK_RATIO == "1:5")  ? (K / 5 ) :
      (C_S11_AXI_ACLK_RATIO == "1:4")  ? (K / 4 ) :
      (C_S11_AXI_ACLK_RATIO == "1:3")  ? (K / 3 ) :
      (C_S11_AXI_ACLK_RATIO == "1:2")  ? (K / 2 ) :
      (C_S11_AXI_ACLK_RATIO ==  "2:1") ? (K * 2 ) :
      (C_S11_AXI_ACLK_RATIO ==  "3:1") ? (K * 3 ) :
      (C_S11_AXI_ACLK_RATIO ==  "4:1") ? (K * 4 ) :
      (C_S11_AXI_ACLK_RATIO ==  "5:1") ? (K * 5 ) :
      (C_S11_AXI_ACLK_RATIO ==  "6:1") ? (K * 6 ) :
      (C_S11_AXI_ACLK_RATIO ==  "7:1") ? (K * 7 ) :
      (C_S11_AXI_ACLK_RATIO ==  "8:1") ? (K * 8 ) :
      (C_S11_AXI_ACLK_RATIO ==  "9:1") ? (K * 9 ) :
      (C_S11_AXI_ACLK_RATIO == "10:1") ? (K * 10) :
      (C_S11_AXI_ACLK_RATIO == "11:1") ? (K * 11) :
      (C_S11_AXI_ACLK_RATIO == "12:1") ? (K * 12) :
      (C_S11_AXI_ACLK_RATIO == "13:1") ? (K * 13) :
      (C_S11_AXI_ACLK_RATIO == "14:1") ? (K * 14) :
      (C_S11_AXI_ACLK_RATIO == "15:1") ? (K * 15) :
      (C_S11_AXI_ACLK_RATIO == "16:1") ? (K * 16) :
      K), (C_NUM_SLAVE_PORTS > 11), 1),
    f_bit32_qual((
      (C_S10_AXI_ACLK_RATIO == "1:16") ? (K / 16) :
      (C_S10_AXI_ACLK_RATIO == "1:15") ? (K / 15) :
      (C_S10_AXI_ACLK_RATIO == "1:14") ? (K / 14) :
      (C_S10_AXI_ACLK_RATIO == "1:13") ? (K / 13) :
      (C_S10_AXI_ACLK_RATIO == "1:12") ? (K / 12) :
      (C_S10_AXI_ACLK_RATIO == "1:11") ? (K / 11) :
      (C_S10_AXI_ACLK_RATIO == "1:10") ? (K / 10) :
      (C_S10_AXI_ACLK_RATIO == "1:9")  ? (K / 9 ) :
      (C_S10_AXI_ACLK_RATIO == "1:8")  ? (K / 8 ) :
      (C_S10_AXI_ACLK_RATIO == "1:7")  ? (K / 7 ) :
      (C_S10_AXI_ACLK_RATIO == "1:6")  ? (K / 6 ) :
      (C_S10_AXI_ACLK_RATIO == "1:5")  ? (K / 5 ) :
      (C_S10_AXI_ACLK_RATIO == "1:4")  ? (K / 4 ) :
      (C_S10_AXI_ACLK_RATIO == "1:3")  ? (K / 3 ) :
      (C_S10_AXI_ACLK_RATIO == "1:2")  ? (K / 2 ) :
      (C_S10_AXI_ACLK_RATIO ==  "2:1") ? (K * 2 ) :
      (C_S10_AXI_ACLK_RATIO ==  "3:1") ? (K * 3 ) :
      (C_S10_AXI_ACLK_RATIO ==  "4:1") ? (K * 4 ) :
      (C_S10_AXI_ACLK_RATIO ==  "5:1") ? (K * 5 ) :
      (C_S10_AXI_ACLK_RATIO ==  "6:1") ? (K * 6 ) :
      (C_S10_AXI_ACLK_RATIO ==  "7:1") ? (K * 7 ) :
      (C_S10_AXI_ACLK_RATIO ==  "8:1") ? (K * 8 ) :
      (C_S10_AXI_ACLK_RATIO ==  "9:1") ? (K * 9 ) :
      (C_S10_AXI_ACLK_RATIO == "10:1") ? (K * 10) :
      (C_S10_AXI_ACLK_RATIO == "11:1") ? (K * 11) :
      (C_S10_AXI_ACLK_RATIO == "12:1") ? (K * 12) :
      (C_S10_AXI_ACLK_RATIO == "13:1") ? (K * 13) :
      (C_S10_AXI_ACLK_RATIO == "14:1") ? (K * 14) :
      (C_S10_AXI_ACLK_RATIO == "15:1") ? (K * 15) :
      (C_S10_AXI_ACLK_RATIO == "16:1") ? (K * 16) :
      K), (C_NUM_SLAVE_PORTS > 10), 1),
    f_bit32_qual((
      (C_S09_AXI_ACLK_RATIO == "1:16") ? (K / 16) :
      (C_S09_AXI_ACLK_RATIO == "1:15") ? (K / 15) :
      (C_S09_AXI_ACLK_RATIO == "1:14") ? (K / 14) :
      (C_S09_AXI_ACLK_RATIO == "1:13") ? (K / 13) :
      (C_S09_AXI_ACLK_RATIO == "1:12") ? (K / 12) :
      (C_S09_AXI_ACLK_RATIO == "1:11") ? (K / 11) :
      (C_S09_AXI_ACLK_RATIO == "1:10") ? (K / 10) :
      (C_S09_AXI_ACLK_RATIO == "1:9")  ? (K / 9 ) :
      (C_S09_AXI_ACLK_RATIO == "1:8")  ? (K / 8 ) :
      (C_S09_AXI_ACLK_RATIO == "1:7")  ? (K / 7 ) :
      (C_S09_AXI_ACLK_RATIO == "1:6")  ? (K / 6 ) :
      (C_S09_AXI_ACLK_RATIO == "1:5")  ? (K / 5 ) :
      (C_S09_AXI_ACLK_RATIO == "1:4")  ? (K / 4 ) :
      (C_S09_AXI_ACLK_RATIO == "1:3")  ? (K / 3 ) :
      (C_S09_AXI_ACLK_RATIO == "1:2")  ? (K / 2 ) :
      (C_S09_AXI_ACLK_RATIO ==  "2:1") ? (K * 2 ) :
      (C_S09_AXI_ACLK_RATIO ==  "3:1") ? (K * 3 ) :
      (C_S09_AXI_ACLK_RATIO ==  "4:1") ? (K * 4 ) :
      (C_S09_AXI_ACLK_RATIO ==  "5:1") ? (K * 5 ) :
      (C_S09_AXI_ACLK_RATIO ==  "6:1") ? (K * 6 ) :
      (C_S09_AXI_ACLK_RATIO ==  "7:1") ? (K * 7 ) :
      (C_S09_AXI_ACLK_RATIO ==  "8:1") ? (K * 8 ) :
      (C_S09_AXI_ACLK_RATIO ==  "9:1") ? (K * 9 ) :
      (C_S09_AXI_ACLK_RATIO == "10:1") ? (K * 10) :
      (C_S09_AXI_ACLK_RATIO == "11:1") ? (K * 11) :
      (C_S09_AXI_ACLK_RATIO == "12:1") ? (K * 12) :
      (C_S09_AXI_ACLK_RATIO == "13:1") ? (K * 13) :
      (C_S09_AXI_ACLK_RATIO == "14:1") ? (K * 14) :
      (C_S09_AXI_ACLK_RATIO == "15:1") ? (K * 15) :
      (C_S09_AXI_ACLK_RATIO == "16:1") ? (K * 16) :
      K), (C_NUM_SLAVE_PORTS > 09), 1),
    f_bit32_qual((
      (C_S08_AXI_ACLK_RATIO == "1:16") ? (K / 16) :
      (C_S08_AXI_ACLK_RATIO == "1:15") ? (K / 15) :
      (C_S08_AXI_ACLK_RATIO == "1:14") ? (K / 14) :
      (C_S08_AXI_ACLK_RATIO == "1:13") ? (K / 13) :
      (C_S08_AXI_ACLK_RATIO == "1:12") ? (K / 12) :
      (C_S08_AXI_ACLK_RATIO == "1:11") ? (K / 11) :
      (C_S08_AXI_ACLK_RATIO == "1:10") ? (K / 10) :
      (C_S08_AXI_ACLK_RATIO == "1:9")  ? (K / 9 ) :
      (C_S08_AXI_ACLK_RATIO == "1:8")  ? (K / 8 ) :
      (C_S08_AXI_ACLK_RATIO == "1:7")  ? (K / 7 ) :
      (C_S08_AXI_ACLK_RATIO == "1:6")  ? (K / 6 ) :
      (C_S08_AXI_ACLK_RATIO == "1:5")  ? (K / 5 ) :
      (C_S08_AXI_ACLK_RATIO == "1:4")  ? (K / 4 ) :
      (C_S08_AXI_ACLK_RATIO == "1:3")  ? (K / 3 ) :
      (C_S08_AXI_ACLK_RATIO == "1:2")  ? (K / 2 ) :
      (C_S08_AXI_ACLK_RATIO ==  "2:1") ? (K * 2 ) :
      (C_S08_AXI_ACLK_RATIO ==  "3:1") ? (K * 3 ) :
      (C_S08_AXI_ACLK_RATIO ==  "4:1") ? (K * 4 ) :
      (C_S08_AXI_ACLK_RATIO ==  "5:1") ? (K * 5 ) :
      (C_S08_AXI_ACLK_RATIO ==  "6:1") ? (K * 6 ) :
      (C_S08_AXI_ACLK_RATIO ==  "7:1") ? (K * 7 ) :
      (C_S08_AXI_ACLK_RATIO ==  "8:1") ? (K * 8 ) :
      (C_S08_AXI_ACLK_RATIO ==  "9:1") ? (K * 9 ) :
      (C_S08_AXI_ACLK_RATIO == "10:1") ? (K * 10) :
      (C_S08_AXI_ACLK_RATIO == "11:1") ? (K * 11) :
      (C_S08_AXI_ACLK_RATIO == "12:1") ? (K * 12) :
      (C_S08_AXI_ACLK_RATIO == "13:1") ? (K * 13) :
      (C_S08_AXI_ACLK_RATIO == "14:1") ? (K * 14) :
      (C_S08_AXI_ACLK_RATIO == "15:1") ? (K * 15) :
      (C_S08_AXI_ACLK_RATIO == "16:1") ? (K * 16) :
      K), (C_NUM_SLAVE_PORTS > 08), 1),
    f_bit32_qual((
      (C_S07_AXI_ACLK_RATIO == "1:16") ? (K / 16) :
      (C_S07_AXI_ACLK_RATIO == "1:15") ? (K / 15) :
      (C_S07_AXI_ACLK_RATIO == "1:14") ? (K / 14) :
      (C_S07_AXI_ACLK_RATIO == "1:13") ? (K / 13) :
      (C_S07_AXI_ACLK_RATIO == "1:12") ? (K / 12) :
      (C_S07_AXI_ACLK_RATIO == "1:11") ? (K / 11) :
      (C_S07_AXI_ACLK_RATIO == "1:10") ? (K / 10) :
      (C_S07_AXI_ACLK_RATIO == "1:9")  ? (K / 9 ) :
      (C_S07_AXI_ACLK_RATIO == "1:8")  ? (K / 8 ) :
      (C_S07_AXI_ACLK_RATIO == "1:7")  ? (K / 7 ) :
      (C_S07_AXI_ACLK_RATIO == "1:6")  ? (K / 6 ) :
      (C_S07_AXI_ACLK_RATIO == "1:5")  ? (K / 5 ) :
      (C_S07_AXI_ACLK_RATIO == "1:4")  ? (K / 4 ) :
      (C_S07_AXI_ACLK_RATIO == "1:3")  ? (K / 3 ) :
      (C_S07_AXI_ACLK_RATIO == "1:2")  ? (K / 2 ) :
      (C_S07_AXI_ACLK_RATIO ==  "2:1") ? (K * 2 ) :
      (C_S07_AXI_ACLK_RATIO ==  "3:1") ? (K * 3 ) :
      (C_S07_AXI_ACLK_RATIO ==  "4:1") ? (K * 4 ) :
      (C_S07_AXI_ACLK_RATIO ==  "5:1") ? (K * 5 ) :
      (C_S07_AXI_ACLK_RATIO ==  "6:1") ? (K * 6 ) :
      (C_S07_AXI_ACLK_RATIO ==  "7:1") ? (K * 7 ) :
      (C_S07_AXI_ACLK_RATIO ==  "8:1") ? (K * 8 ) :
      (C_S07_AXI_ACLK_RATIO ==  "9:1") ? (K * 9 ) :
      (C_S07_AXI_ACLK_RATIO == "10:1") ? (K * 10) :
      (C_S07_AXI_ACLK_RATIO == "11:1") ? (K * 11) :
      (C_S07_AXI_ACLK_RATIO == "12:1") ? (K * 12) :
      (C_S07_AXI_ACLK_RATIO == "13:1") ? (K * 13) :
      (C_S07_AXI_ACLK_RATIO == "14:1") ? (K * 14) :
      (C_S07_AXI_ACLK_RATIO == "15:1") ? (K * 15) :
      (C_S07_AXI_ACLK_RATIO == "16:1") ? (K * 16) :
      K), (C_NUM_SLAVE_PORTS > 07), 1),
    f_bit32_qual((
      (C_S06_AXI_ACLK_RATIO == "1:16") ? (K / 16) :
      (C_S06_AXI_ACLK_RATIO == "1:15") ? (K / 15) :
      (C_S06_AXI_ACLK_RATIO == "1:14") ? (K / 14) :
      (C_S06_AXI_ACLK_RATIO == "1:13") ? (K / 13) :
      (C_S06_AXI_ACLK_RATIO == "1:12") ? (K / 12) :
      (C_S06_AXI_ACLK_RATIO == "1:11") ? (K / 11) :
      (C_S06_AXI_ACLK_RATIO == "1:10") ? (K / 10) :
      (C_S06_AXI_ACLK_RATIO == "1:9")  ? (K / 9 ) :
      (C_S06_AXI_ACLK_RATIO == "1:8")  ? (K / 8 ) :
      (C_S06_AXI_ACLK_RATIO == "1:7")  ? (K / 7 ) :
      (C_S06_AXI_ACLK_RATIO == "1:6")  ? (K / 6 ) :
      (C_S06_AXI_ACLK_RATIO == "1:5")  ? (K / 5 ) :
      (C_S06_AXI_ACLK_RATIO == "1:4")  ? (K / 4 ) :
      (C_S06_AXI_ACLK_RATIO == "1:3")  ? (K / 3 ) :
      (C_S06_AXI_ACLK_RATIO == "1:2")  ? (K / 2 ) :
      (C_S06_AXI_ACLK_RATIO ==  "2:1") ? (K * 2 ) :
      (C_S06_AXI_ACLK_RATIO ==  "3:1") ? (K * 3 ) :
      (C_S06_AXI_ACLK_RATIO ==  "4:1") ? (K * 4 ) :
      (C_S06_AXI_ACLK_RATIO ==  "5:1") ? (K * 5 ) :
      (C_S06_AXI_ACLK_RATIO ==  "6:1") ? (K * 6 ) :
      (C_S06_AXI_ACLK_RATIO ==  "7:1") ? (K * 7 ) :
      (C_S06_AXI_ACLK_RATIO ==  "8:1") ? (K * 8 ) :
      (C_S06_AXI_ACLK_RATIO ==  "9:1") ? (K * 9 ) :
      (C_S06_AXI_ACLK_RATIO == "10:1") ? (K * 10) :
      (C_S06_AXI_ACLK_RATIO == "11:1") ? (K * 11) :
      (C_S06_AXI_ACLK_RATIO == "12:1") ? (K * 12) :
      (C_S06_AXI_ACLK_RATIO == "13:1") ? (K * 13) :
      (C_S06_AXI_ACLK_RATIO == "14:1") ? (K * 14) :
      (C_S06_AXI_ACLK_RATIO == "15:1") ? (K * 15) :
      (C_S06_AXI_ACLK_RATIO == "16:1") ? (K * 16) :
      K), (C_NUM_SLAVE_PORTS > 06), 1),
    f_bit32_qual((
      (C_S05_AXI_ACLK_RATIO == "1:16") ? (K / 16) :
      (C_S05_AXI_ACLK_RATIO == "1:15") ? (K / 15) :
      (C_S05_AXI_ACLK_RATIO == "1:14") ? (K / 14) :
      (C_S05_AXI_ACLK_RATIO == "1:13") ? (K / 13) :
      (C_S05_AXI_ACLK_RATIO == "1:12") ? (K / 12) :
      (C_S05_AXI_ACLK_RATIO == "1:11") ? (K / 11) :
      (C_S05_AXI_ACLK_RATIO == "1:10") ? (K / 10) :
      (C_S05_AXI_ACLK_RATIO == "1:9")  ? (K / 9 ) :
      (C_S05_AXI_ACLK_RATIO == "1:8")  ? (K / 8 ) :
      (C_S05_AXI_ACLK_RATIO == "1:7")  ? (K / 7 ) :
      (C_S05_AXI_ACLK_RATIO == "1:6")  ? (K / 6 ) :
      (C_S05_AXI_ACLK_RATIO == "1:5")  ? (K / 5 ) :
      (C_S05_AXI_ACLK_RATIO == "1:4")  ? (K / 4 ) :
      (C_S05_AXI_ACLK_RATIO == "1:3")  ? (K / 3 ) :
      (C_S05_AXI_ACLK_RATIO == "1:2")  ? (K / 2 ) :
      (C_S05_AXI_ACLK_RATIO ==  "2:1") ? (K * 2 ) :
      (C_S05_AXI_ACLK_RATIO ==  "3:1") ? (K * 3 ) :
      (C_S05_AXI_ACLK_RATIO ==  "4:1") ? (K * 4 ) :
      (C_S05_AXI_ACLK_RATIO ==  "5:1") ? (K * 5 ) :
      (C_S05_AXI_ACLK_RATIO ==  "6:1") ? (K * 6 ) :
      (C_S05_AXI_ACLK_RATIO ==  "7:1") ? (K * 7 ) :
      (C_S05_AXI_ACLK_RATIO ==  "8:1") ? (K * 8 ) :
      (C_S05_AXI_ACLK_RATIO ==  "9:1") ? (K * 9 ) :
      (C_S05_AXI_ACLK_RATIO == "10:1") ? (K * 10) :
      (C_S05_AXI_ACLK_RATIO == "11:1") ? (K * 11) :
      (C_S05_AXI_ACLK_RATIO == "12:1") ? (K * 12) :
      (C_S05_AXI_ACLK_RATIO == "13:1") ? (K * 13) :
      (C_S05_AXI_ACLK_RATIO == "14:1") ? (K * 14) :
      (C_S05_AXI_ACLK_RATIO == "15:1") ? (K * 15) :
      (C_S05_AXI_ACLK_RATIO == "16:1") ? (K * 16) :
      K), (C_NUM_SLAVE_PORTS > 05), 1),
    f_bit32_qual((
      (C_S04_AXI_ACLK_RATIO == "1:16") ? (K / 16) :
      (C_S04_AXI_ACLK_RATIO == "1:15") ? (K / 15) :
      (C_S04_AXI_ACLK_RATIO == "1:14") ? (K / 14) :
      (C_S04_AXI_ACLK_RATIO == "1:13") ? (K / 13) :
      (C_S04_AXI_ACLK_RATIO == "1:12") ? (K / 12) :
      (C_S04_AXI_ACLK_RATIO == "1:11") ? (K / 11) :
      (C_S04_AXI_ACLK_RATIO == "1:10") ? (K / 10) :
      (C_S04_AXI_ACLK_RATIO == "1:9")  ? (K / 9 ) :
      (C_S04_AXI_ACLK_RATIO == "1:8")  ? (K / 8 ) :
      (C_S04_AXI_ACLK_RATIO == "1:7")  ? (K / 7 ) :
      (C_S04_AXI_ACLK_RATIO == "1:6")  ? (K / 6 ) :
      (C_S04_AXI_ACLK_RATIO == "1:5")  ? (K / 5 ) :
      (C_S04_AXI_ACLK_RATIO == "1:4")  ? (K / 4 ) :
      (C_S04_AXI_ACLK_RATIO == "1:3")  ? (K / 3 ) :
      (C_S04_AXI_ACLK_RATIO == "1:2")  ? (K / 2 ) :
      (C_S04_AXI_ACLK_RATIO ==  "2:1") ? (K * 2 ) :
      (C_S04_AXI_ACLK_RATIO ==  "3:1") ? (K * 3 ) :
      (C_S04_AXI_ACLK_RATIO ==  "4:1") ? (K * 4 ) :
      (C_S04_AXI_ACLK_RATIO ==  "5:1") ? (K * 5 ) :
      (C_S04_AXI_ACLK_RATIO ==  "6:1") ? (K * 6 ) :
      (C_S04_AXI_ACLK_RATIO ==  "7:1") ? (K * 7 ) :
      (C_S04_AXI_ACLK_RATIO ==  "8:1") ? (K * 8 ) :
      (C_S04_AXI_ACLK_RATIO ==  "9:1") ? (K * 9 ) :
      (C_S04_AXI_ACLK_RATIO == "10:1") ? (K * 10) :
      (C_S04_AXI_ACLK_RATIO == "11:1") ? (K * 11) :
      (C_S04_AXI_ACLK_RATIO == "12:1") ? (K * 12) :
      (C_S04_AXI_ACLK_RATIO == "13:1") ? (K * 13) :
      (C_S04_AXI_ACLK_RATIO == "14:1") ? (K * 14) :
      (C_S04_AXI_ACLK_RATIO == "15:1") ? (K * 15) :
      (C_S04_AXI_ACLK_RATIO == "16:1") ? (K * 16) :
      K), (C_NUM_SLAVE_PORTS > 04), 1),
    f_bit32_qual((
      (C_S03_AXI_ACLK_RATIO == "1:16") ? (K / 16) :
      (C_S03_AXI_ACLK_RATIO == "1:15") ? (K / 15) :
      (C_S03_AXI_ACLK_RATIO == "1:14") ? (K / 14) :
      (C_S03_AXI_ACLK_RATIO == "1:13") ? (K / 13) :
      (C_S03_AXI_ACLK_RATIO == "1:12") ? (K / 12) :
      (C_S03_AXI_ACLK_RATIO == "1:11") ? (K / 11) :
      (C_S03_AXI_ACLK_RATIO == "1:10") ? (K / 10) :
      (C_S03_AXI_ACLK_RATIO == "1:9")  ? (K / 9 ) :
      (C_S03_AXI_ACLK_RATIO == "1:8")  ? (K / 8 ) :
      (C_S03_AXI_ACLK_RATIO == "1:7")  ? (K / 7 ) :
      (C_S03_AXI_ACLK_RATIO == "1:6")  ? (K / 6 ) :
      (C_S03_AXI_ACLK_RATIO == "1:5")  ? (K / 5 ) :
      (C_S03_AXI_ACLK_RATIO == "1:4")  ? (K / 4 ) :
      (C_S03_AXI_ACLK_RATIO == "1:3")  ? (K / 3 ) :
      (C_S03_AXI_ACLK_RATIO == "1:2")  ? (K / 2 ) :
      (C_S03_AXI_ACLK_RATIO ==  "2:1") ? (K * 2 ) :
      (C_S03_AXI_ACLK_RATIO ==  "3:1") ? (K * 3 ) :
      (C_S03_AXI_ACLK_RATIO ==  "4:1") ? (K * 4 ) :
      (C_S03_AXI_ACLK_RATIO ==  "5:1") ? (K * 5 ) :
      (C_S03_AXI_ACLK_RATIO ==  "6:1") ? (K * 6 ) :
      (C_S03_AXI_ACLK_RATIO ==  "7:1") ? (K * 7 ) :
      (C_S03_AXI_ACLK_RATIO ==  "8:1") ? (K * 8 ) :
      (C_S03_AXI_ACLK_RATIO ==  "9:1") ? (K * 9 ) :
      (C_S03_AXI_ACLK_RATIO == "10:1") ? (K * 10) :
      (C_S03_AXI_ACLK_RATIO == "11:1") ? (K * 11) :
      (C_S03_AXI_ACLK_RATIO == "12:1") ? (K * 12) :
      (C_S03_AXI_ACLK_RATIO == "13:1") ? (K * 13) :
      (C_S03_AXI_ACLK_RATIO == "14:1") ? (K * 14) :
      (C_S03_AXI_ACLK_RATIO == "15:1") ? (K * 15) :
      (C_S03_AXI_ACLK_RATIO == "16:1") ? (K * 16) :
      K), (C_NUM_SLAVE_PORTS > 03), 1),
    f_bit32_qual((
      (C_S02_AXI_ACLK_RATIO == "1:16") ? (K / 16) :
      (C_S02_AXI_ACLK_RATIO == "1:15") ? (K / 15) :
      (C_S02_AXI_ACLK_RATIO == "1:14") ? (K / 14) :
      (C_S02_AXI_ACLK_RATIO == "1:13") ? (K / 13) :
      (C_S02_AXI_ACLK_RATIO == "1:12") ? (K / 12) :
      (C_S02_AXI_ACLK_RATIO == "1:11") ? (K / 11) :
      (C_S02_AXI_ACLK_RATIO == "1:10") ? (K / 10) :
      (C_S02_AXI_ACLK_RATIO == "1:9")  ? (K / 9 ) :
      (C_S02_AXI_ACLK_RATIO == "1:8")  ? (K / 8 ) :
      (C_S02_AXI_ACLK_RATIO == "1:7")  ? (K / 7 ) :
      (C_S02_AXI_ACLK_RATIO == "1:6")  ? (K / 6 ) :
      (C_S02_AXI_ACLK_RATIO == "1:5")  ? (K / 5 ) :
      (C_S02_AXI_ACLK_RATIO == "1:4")  ? (K / 4 ) :
      (C_S02_AXI_ACLK_RATIO == "1:3")  ? (K / 3 ) :
      (C_S02_AXI_ACLK_RATIO == "1:2")  ? (K / 2 ) :
      (C_S02_AXI_ACLK_RATIO ==  "2:1") ? (K * 2 ) :
      (C_S02_AXI_ACLK_RATIO ==  "3:1") ? (K * 3 ) :
      (C_S02_AXI_ACLK_RATIO ==  "4:1") ? (K * 4 ) :
      (C_S02_AXI_ACLK_RATIO ==  "5:1") ? (K * 5 ) :
      (C_S02_AXI_ACLK_RATIO ==  "6:1") ? (K * 6 ) :
      (C_S02_AXI_ACLK_RATIO ==  "7:1") ? (K * 7 ) :
      (C_S02_AXI_ACLK_RATIO ==  "8:1") ? (K * 8 ) :
      (C_S02_AXI_ACLK_RATIO ==  "9:1") ? (K * 9 ) :
      (C_S02_AXI_ACLK_RATIO == "10:1") ? (K * 10) :
      (C_S02_AXI_ACLK_RATIO == "11:1") ? (K * 11) :
      (C_S02_AXI_ACLK_RATIO == "12:1") ? (K * 12) :
      (C_S02_AXI_ACLK_RATIO == "13:1") ? (K * 13) :
      (C_S02_AXI_ACLK_RATIO == "14:1") ? (K * 14) :
      (C_S02_AXI_ACLK_RATIO == "15:1") ? (K * 15) :
      (C_S02_AXI_ACLK_RATIO == "16:1") ? (K * 16) :
      K), (C_NUM_SLAVE_PORTS > 02), 1),
    f_bit32_qual((
      (C_S01_AXI_ACLK_RATIO == "1:16") ? (K / 16) :
      (C_S01_AXI_ACLK_RATIO == "1:15") ? (K / 15) :
      (C_S01_AXI_ACLK_RATIO == "1:14") ? (K / 14) :
      (C_S01_AXI_ACLK_RATIO == "1:13") ? (K / 13) :
      (C_S01_AXI_ACLK_RATIO == "1:12") ? (K / 12) :
      (C_S01_AXI_ACLK_RATIO == "1:11") ? (K / 11) :
      (C_S01_AXI_ACLK_RATIO == "1:10") ? (K / 10) :
      (C_S01_AXI_ACLK_RATIO == "1:9")  ? (K / 9 ) :
      (C_S01_AXI_ACLK_RATIO == "1:8")  ? (K / 8 ) :
      (C_S01_AXI_ACLK_RATIO == "1:7")  ? (K / 7 ) :
      (C_S01_AXI_ACLK_RATIO == "1:6")  ? (K / 6 ) :
      (C_S01_AXI_ACLK_RATIO == "1:5")  ? (K / 5 ) :
      (C_S01_AXI_ACLK_RATIO == "1:4")  ? (K / 4 ) :
      (C_S01_AXI_ACLK_RATIO == "1:3")  ? (K / 3 ) :
      (C_S01_AXI_ACLK_RATIO == "1:2")  ? (K / 2 ) :
      (C_S01_AXI_ACLK_RATIO ==  "2:1") ? (K * 2 ) :
      (C_S01_AXI_ACLK_RATIO ==  "3:1") ? (K * 3 ) :
      (C_S01_AXI_ACLK_RATIO ==  "4:1") ? (K * 4 ) :
      (C_S01_AXI_ACLK_RATIO ==  "5:1") ? (K * 5 ) :
      (C_S01_AXI_ACLK_RATIO ==  "6:1") ? (K * 6 ) :
      (C_S01_AXI_ACLK_RATIO ==  "7:1") ? (K * 7 ) :
      (C_S01_AXI_ACLK_RATIO ==  "8:1") ? (K * 8 ) :
      (C_S01_AXI_ACLK_RATIO ==  "9:1") ? (K * 9 ) :
      (C_S01_AXI_ACLK_RATIO == "10:1") ? (K * 10) :
      (C_S01_AXI_ACLK_RATIO == "11:1") ? (K * 11) :
      (C_S01_AXI_ACLK_RATIO == "12:1") ? (K * 12) :
      (C_S01_AXI_ACLK_RATIO == "13:1") ? (K * 13) :
      (C_S01_AXI_ACLK_RATIO == "14:1") ? (K * 14) :
      (C_S01_AXI_ACLK_RATIO == "15:1") ? (K * 15) :
      (C_S01_AXI_ACLK_RATIO == "16:1") ? (K * 16) :
      K), (C_NUM_SLAVE_PORTS > 01), 1),
    f_bit32_qual((
      (C_S00_AXI_ACLK_RATIO == "1:16") ? (K / 16) :
      (C_S00_AXI_ACLK_RATIO == "1:15") ? (K / 15) :
      (C_S00_AXI_ACLK_RATIO == "1:14") ? (K / 14) :
      (C_S00_AXI_ACLK_RATIO == "1:13") ? (K / 13) :
      (C_S00_AXI_ACLK_RATIO == "1:12") ? (K / 12) :
      (C_S00_AXI_ACLK_RATIO == "1:11") ? (K / 11) :
      (C_S00_AXI_ACLK_RATIO == "1:10") ? (K / 10) :
      (C_S00_AXI_ACLK_RATIO == "1:9")  ? (K / 9 ) :
      (C_S00_AXI_ACLK_RATIO == "1:8")  ? (K / 8 ) :
      (C_S00_AXI_ACLK_RATIO == "1:7")  ? (K / 7 ) :
      (C_S00_AXI_ACLK_RATIO == "1:6")  ? (K / 6 ) :
      (C_S00_AXI_ACLK_RATIO == "1:5")  ? (K / 5 ) :
      (C_S00_AXI_ACLK_RATIO == "1:4")  ? (K / 4 ) :
      (C_S00_AXI_ACLK_RATIO == "1:3")  ? (K / 3 ) :
      (C_S00_AXI_ACLK_RATIO == "1:2")  ? (K / 2 ) :
      (C_S00_AXI_ACLK_RATIO ==  "2:1") ? (K * 2 ) :
      (C_S00_AXI_ACLK_RATIO ==  "3:1") ? (K * 3 ) :
      (C_S00_AXI_ACLK_RATIO ==  "4:1") ? (K * 4 ) :
      (C_S00_AXI_ACLK_RATIO ==  "5:1") ? (K * 5 ) :
      (C_S00_AXI_ACLK_RATIO ==  "6:1") ? (K * 6 ) :
      (C_S00_AXI_ACLK_RATIO ==  "7:1") ? (K * 7 ) :
      (C_S00_AXI_ACLK_RATIO ==  "8:1") ? (K * 8 ) :
      (C_S00_AXI_ACLK_RATIO ==  "9:1") ? (K * 9 ) :
      (C_S00_AXI_ACLK_RATIO == "10:1") ? (K * 10) :
      (C_S00_AXI_ACLK_RATIO == "11:1") ? (K * 11) :
      (C_S00_AXI_ACLK_RATIO == "12:1") ? (K * 12) :
      (C_S00_AXI_ACLK_RATIO == "13:1") ? (K * 13) :
      (C_S00_AXI_ACLK_RATIO == "14:1") ? (K * 14) :
      (C_S00_AXI_ACLK_RATIO == "15:1") ? (K * 15) :
      (C_S00_AXI_ACLK_RATIO == "16:1") ? (K * 16) :
      K), (C_NUM_SLAVE_PORTS > 00), 1)
    };
  localparam         P_S_AXI_IS_ACLK_ASYNC = {
    f_bit1(C_S15_AXI_IS_ACLK_ASYNC),
    f_bit1(C_S14_AXI_IS_ACLK_ASYNC),
    f_bit1(C_S13_AXI_IS_ACLK_ASYNC),
    f_bit1(C_S12_AXI_IS_ACLK_ASYNC),
    f_bit1(C_S11_AXI_IS_ACLK_ASYNC),
    f_bit1(C_S10_AXI_IS_ACLK_ASYNC),
    f_bit1(C_S09_AXI_IS_ACLK_ASYNC),
    f_bit1(C_S08_AXI_IS_ACLK_ASYNC),
    f_bit1(C_S07_AXI_IS_ACLK_ASYNC),
    f_bit1(C_S06_AXI_IS_ACLK_ASYNC),
    f_bit1(C_S05_AXI_IS_ACLK_ASYNC),
    f_bit1(C_S04_AXI_IS_ACLK_ASYNC),
    f_bit1(C_S03_AXI_IS_ACLK_ASYNC),
    f_bit1(C_S02_AXI_IS_ACLK_ASYNC),
    f_bit1(C_S01_AXI_IS_ACLK_ASYNC),
    f_bit1(C_S00_AXI_IS_ACLK_ASYNC)
    };
  localparam         P_M_AXI_ACLK_RATIO = {
    {15{32'h1}},
    f_bit32_qual((
      (C_M00_AXI_ACLK_RATIO == "1:16") ? (K / 16) :
      (C_M00_AXI_ACLK_RATIO == "1:15") ? (K / 15) :
      (C_M00_AXI_ACLK_RATIO == "1:14") ? (K / 14) :
      (C_M00_AXI_ACLK_RATIO == "1:13") ? (K / 13) :
      (C_M00_AXI_ACLK_RATIO == "1:12") ? (K / 12) :
      (C_M00_AXI_ACLK_RATIO == "1:11") ? (K / 11) :
      (C_M00_AXI_ACLK_RATIO == "1:10") ? (K / 10) :
      (C_M00_AXI_ACLK_RATIO == "1:9")  ? (K / 9 ) :
      (C_M00_AXI_ACLK_RATIO == "1:8")  ? (K / 8 ) :
      (C_M00_AXI_ACLK_RATIO == "1:7")  ? (K / 7 ) :
      (C_M00_AXI_ACLK_RATIO == "1:6")  ? (K / 6 ) :
      (C_M00_AXI_ACLK_RATIO == "1:5")  ? (K / 5 ) :
      (C_M00_AXI_ACLK_RATIO == "1:4")  ? (K / 4 ) :
      (C_M00_AXI_ACLK_RATIO == "1:3")  ? (K / 3 ) :
      (C_M00_AXI_ACLK_RATIO == "1:2")  ? (K / 2 ) :
      (C_M00_AXI_ACLK_RATIO ==  "2:1") ? (K * 2 ) :
      (C_M00_AXI_ACLK_RATIO ==  "3:1") ? (K * 3 ) :
      (C_M00_AXI_ACLK_RATIO ==  "4:1") ? (K * 4 ) :
      (C_M00_AXI_ACLK_RATIO ==  "5:1") ? (K * 5 ) :
      (C_M00_AXI_ACLK_RATIO ==  "6:1") ? (K * 6 ) :
      (C_M00_AXI_ACLK_RATIO ==  "7:1") ? (K * 7 ) :
      (C_M00_AXI_ACLK_RATIO ==  "8:1") ? (K * 8 ) :
      (C_M00_AXI_ACLK_RATIO ==  "9:1") ? (K * 9 ) :
      (C_M00_AXI_ACLK_RATIO == "10:1") ? (K * 10) :
      (C_M00_AXI_ACLK_RATIO == "11:1") ? (K * 11) :
      (C_M00_AXI_ACLK_RATIO == "12:1") ? (K * 12) :
      (C_M00_AXI_ACLK_RATIO == "13:1") ? (K * 13) :
      (C_M00_AXI_ACLK_RATIO == "14:1") ? (K * 14) :
      (C_M00_AXI_ACLK_RATIO == "15:1") ? (K * 15) :
      (C_M00_AXI_ACLK_RATIO == "16:1") ? (K * 16) :
      K), 1, 1)
      };
  localparam         P_S_AXI_SUPPORTS_WRITE = {
    f_bit1(C_S15_AXI_READ_WRITE_SUPPORT == "READ/WRITE" || C_S15_AXI_READ_WRITE_SUPPORT == "WRITE-ONLY"),
    f_bit1(C_S14_AXI_READ_WRITE_SUPPORT == "READ/WRITE" || C_S14_AXI_READ_WRITE_SUPPORT == "WRITE-ONLY"),
    f_bit1(C_S13_AXI_READ_WRITE_SUPPORT == "READ/WRITE" || C_S13_AXI_READ_WRITE_SUPPORT == "WRITE-ONLY"),
    f_bit1(C_S12_AXI_READ_WRITE_SUPPORT == "READ/WRITE" || C_S12_AXI_READ_WRITE_SUPPORT == "WRITE-ONLY"),
    f_bit1(C_S11_AXI_READ_WRITE_SUPPORT == "READ/WRITE" || C_S11_AXI_READ_WRITE_SUPPORT == "WRITE-ONLY"),
    f_bit1(C_S10_AXI_READ_WRITE_SUPPORT == "READ/WRITE" || C_S10_AXI_READ_WRITE_SUPPORT == "WRITE-ONLY"),
    f_bit1(C_S09_AXI_READ_WRITE_SUPPORT == "READ/WRITE" || C_S09_AXI_READ_WRITE_SUPPORT == "WRITE-ONLY"),
    f_bit1(C_S08_AXI_READ_WRITE_SUPPORT == "READ/WRITE" || C_S08_AXI_READ_WRITE_SUPPORT == "WRITE-ONLY"),
    f_bit1(C_S07_AXI_READ_WRITE_SUPPORT == "READ/WRITE" || C_S07_AXI_READ_WRITE_SUPPORT == "WRITE-ONLY"),
    f_bit1(C_S06_AXI_READ_WRITE_SUPPORT == "READ/WRITE" || C_S06_AXI_READ_WRITE_SUPPORT == "WRITE-ONLY"),
    f_bit1(C_S05_AXI_READ_WRITE_SUPPORT == "READ/WRITE" || C_S05_AXI_READ_WRITE_SUPPORT == "WRITE-ONLY"),
    f_bit1(C_S04_AXI_READ_WRITE_SUPPORT == "READ/WRITE" || C_S04_AXI_READ_WRITE_SUPPORT == "WRITE-ONLY"),
    f_bit1(C_S03_AXI_READ_WRITE_SUPPORT == "READ/WRITE" || C_S03_AXI_READ_WRITE_SUPPORT == "WRITE-ONLY"),
    f_bit1(C_S02_AXI_READ_WRITE_SUPPORT == "READ/WRITE" || C_S02_AXI_READ_WRITE_SUPPORT == "WRITE-ONLY"),
    f_bit1(C_S01_AXI_READ_WRITE_SUPPORT == "READ/WRITE" || C_S01_AXI_READ_WRITE_SUPPORT == "WRITE-ONLY"),
    f_bit1(C_S00_AXI_READ_WRITE_SUPPORT == "READ/WRITE" || C_S00_AXI_READ_WRITE_SUPPORT == "WRITE-ONLY")
    };
  localparam         P_S_AXI_SUPPORTS_READ = {
    f_bit1(C_S15_AXI_READ_WRITE_SUPPORT == "READ/WRITE" || C_S15_AXI_READ_WRITE_SUPPORT == "READ-ONLY"),
    f_bit1(C_S14_AXI_READ_WRITE_SUPPORT == "READ/WRITE" || C_S14_AXI_READ_WRITE_SUPPORT == "READ-ONLY"),
    f_bit1(C_S13_AXI_READ_WRITE_SUPPORT == "READ/WRITE" || C_S13_AXI_READ_WRITE_SUPPORT == "READ-ONLY"),
    f_bit1(C_S12_AXI_READ_WRITE_SUPPORT == "READ/WRITE" || C_S12_AXI_READ_WRITE_SUPPORT == "READ-ONLY"),
    f_bit1(C_S11_AXI_READ_WRITE_SUPPORT == "READ/WRITE" || C_S11_AXI_READ_WRITE_SUPPORT == "READ-ONLY"),
    f_bit1(C_S10_AXI_READ_WRITE_SUPPORT == "READ/WRITE" || C_S10_AXI_READ_WRITE_SUPPORT == "READ-ONLY"),
    f_bit1(C_S09_AXI_READ_WRITE_SUPPORT == "READ/WRITE" || C_S09_AXI_READ_WRITE_SUPPORT == "READ-ONLY"),
    f_bit1(C_S08_AXI_READ_WRITE_SUPPORT == "READ/WRITE" || C_S08_AXI_READ_WRITE_SUPPORT == "READ-ONLY"),
    f_bit1(C_S07_AXI_READ_WRITE_SUPPORT == "READ/WRITE" || C_S07_AXI_READ_WRITE_SUPPORT == "READ-ONLY"),
    f_bit1(C_S06_AXI_READ_WRITE_SUPPORT == "READ/WRITE" || C_S06_AXI_READ_WRITE_SUPPORT == "READ-ONLY"),
    f_bit1(C_S05_AXI_READ_WRITE_SUPPORT == "READ/WRITE" || C_S05_AXI_READ_WRITE_SUPPORT == "READ-ONLY"),
    f_bit1(C_S04_AXI_READ_WRITE_SUPPORT == "READ/WRITE" || C_S04_AXI_READ_WRITE_SUPPORT == "READ-ONLY"),
    f_bit1(C_S03_AXI_READ_WRITE_SUPPORT == "READ/WRITE" || C_S03_AXI_READ_WRITE_SUPPORT == "READ-ONLY"),
    f_bit1(C_S02_AXI_READ_WRITE_SUPPORT == "READ/WRITE" || C_S02_AXI_READ_WRITE_SUPPORT == "READ-ONLY"),
    f_bit1(C_S01_AXI_READ_WRITE_SUPPORT == "READ/WRITE" || C_S01_AXI_READ_WRITE_SUPPORT == "READ-ONLY"),
    f_bit1(C_S00_AXI_READ_WRITE_SUPPORT == "READ/WRITE" || C_S00_AXI_READ_WRITE_SUPPORT == "READ-ONLY")
    };
  localparam         P_S_AXI_WRITE_ACCEPTANCE = {
    f_bit32_qual(C_S15_AXI_WRITE_ACCEPTANCE, (C_NUM_SLAVE_PORTS > 15), 1),
    f_bit32_qual(C_S14_AXI_WRITE_ACCEPTANCE, (C_NUM_SLAVE_PORTS > 14), 1),
    f_bit32_qual(C_S13_AXI_WRITE_ACCEPTANCE, (C_NUM_SLAVE_PORTS > 13), 1),
    f_bit32_qual(C_S12_AXI_WRITE_ACCEPTANCE, (C_NUM_SLAVE_PORTS > 12), 1),
    f_bit32_qual(C_S11_AXI_WRITE_ACCEPTANCE, (C_NUM_SLAVE_PORTS > 11), 1),
    f_bit32_qual(C_S10_AXI_WRITE_ACCEPTANCE, (C_NUM_SLAVE_PORTS > 10), 1),
    f_bit32_qual(C_S09_AXI_WRITE_ACCEPTANCE, (C_NUM_SLAVE_PORTS > 09), 1),
    f_bit32_qual(C_S08_AXI_WRITE_ACCEPTANCE, (C_NUM_SLAVE_PORTS > 08), 1),
    f_bit32_qual(C_S07_AXI_WRITE_ACCEPTANCE, (C_NUM_SLAVE_PORTS > 07), 1),
    f_bit32_qual(C_S06_AXI_WRITE_ACCEPTANCE, (C_NUM_SLAVE_PORTS > 06), 1),
    f_bit32_qual(C_S05_AXI_WRITE_ACCEPTANCE, (C_NUM_SLAVE_PORTS > 05), 1),
    f_bit32_qual(C_S04_AXI_WRITE_ACCEPTANCE, (C_NUM_SLAVE_PORTS > 04), 1),
    f_bit32_qual(C_S03_AXI_WRITE_ACCEPTANCE, (C_NUM_SLAVE_PORTS > 03), 1),
    f_bit32_qual(C_S02_AXI_WRITE_ACCEPTANCE, (C_NUM_SLAVE_PORTS > 02), 1),
    f_bit32_qual(C_S01_AXI_WRITE_ACCEPTANCE, (C_NUM_SLAVE_PORTS > 01), 1),
    f_bit32_qual(C_S00_AXI_WRITE_ACCEPTANCE, (C_NUM_SLAVE_PORTS > 00), 1)
    };
  localparam         P_S_AXI_READ_ACCEPTANCE = {
    f_bit32_qual(C_S15_AXI_READ_ACCEPTANCE, (C_NUM_SLAVE_PORTS > 15), 1),
    f_bit32_qual(C_S14_AXI_READ_ACCEPTANCE, (C_NUM_SLAVE_PORTS > 14), 1),
    f_bit32_qual(C_S13_AXI_READ_ACCEPTANCE, (C_NUM_SLAVE_PORTS > 13), 1),
    f_bit32_qual(C_S12_AXI_READ_ACCEPTANCE, (C_NUM_SLAVE_PORTS > 12), 1),
    f_bit32_qual(C_S11_AXI_READ_ACCEPTANCE, (C_NUM_SLAVE_PORTS > 11), 1),
    f_bit32_qual(C_S10_AXI_READ_ACCEPTANCE, (C_NUM_SLAVE_PORTS > 10), 1),
    f_bit32_qual(C_S09_AXI_READ_ACCEPTANCE, (C_NUM_SLAVE_PORTS > 09), 1),
    f_bit32_qual(C_S08_AXI_READ_ACCEPTANCE, (C_NUM_SLAVE_PORTS > 08), 1),
    f_bit32_qual(C_S07_AXI_READ_ACCEPTANCE, (C_NUM_SLAVE_PORTS > 07), 1),
    f_bit32_qual(C_S06_AXI_READ_ACCEPTANCE, (C_NUM_SLAVE_PORTS > 06), 1),
    f_bit32_qual(C_S05_AXI_READ_ACCEPTANCE, (C_NUM_SLAVE_PORTS > 05), 1),
    f_bit32_qual(C_S04_AXI_READ_ACCEPTANCE, (C_NUM_SLAVE_PORTS > 04), 1),
    f_bit32_qual(C_S03_AXI_READ_ACCEPTANCE, (C_NUM_SLAVE_PORTS > 03), 1),
    f_bit32_qual(C_S02_AXI_READ_ACCEPTANCE, (C_NUM_SLAVE_PORTS > 02), 1),
    f_bit32_qual(C_S01_AXI_READ_ACCEPTANCE, (C_NUM_SLAVE_PORTS > 01), 1),
    f_bit32_qual(C_S00_AXI_READ_ACCEPTANCE, (C_NUM_SLAVE_PORTS > 00), 1)
    };
  localparam         P_M_AXI_WRITE_ISSUING = {{15{32'h1}}, f_bit32_qual(C_M00_AXI_WRITE_ISSUING, 1, 0)};
  localparam         P_M_AXI_READ_ISSUING = {{15{32'h1}}, f_bit32_qual(C_M00_AXI_READ_ISSUING, 1, 0)};
  localparam         P_S_AXI_ARB_PRIORITY = {
    f_bit32_qual(C_S15_AXI_ARB_PRIORITY, (C_NUM_SLAVE_PORTS > 15), 0),
    f_bit32_qual(C_S14_AXI_ARB_PRIORITY, (C_NUM_SLAVE_PORTS > 14), 0),
    f_bit32_qual(C_S13_AXI_ARB_PRIORITY, (C_NUM_SLAVE_PORTS > 13), 0),
    f_bit32_qual(C_S12_AXI_ARB_PRIORITY, (C_NUM_SLAVE_PORTS > 12), 0),
    f_bit32_qual(C_S11_AXI_ARB_PRIORITY, (C_NUM_SLAVE_PORTS > 11), 0),
    f_bit32_qual(C_S10_AXI_ARB_PRIORITY, (C_NUM_SLAVE_PORTS > 10), 0),
    f_bit32_qual(C_S09_AXI_ARB_PRIORITY, (C_NUM_SLAVE_PORTS > 09), 0),
    f_bit32_qual(C_S08_AXI_ARB_PRIORITY, (C_NUM_SLAVE_PORTS > 08), 0),
    f_bit32_qual(C_S07_AXI_ARB_PRIORITY, (C_NUM_SLAVE_PORTS > 07), 0),
    f_bit32_qual(C_S06_AXI_ARB_PRIORITY, (C_NUM_SLAVE_PORTS > 06), 0),
    f_bit32_qual(C_S05_AXI_ARB_PRIORITY, (C_NUM_SLAVE_PORTS > 05), 0),
    f_bit32_qual(C_S04_AXI_ARB_PRIORITY, (C_NUM_SLAVE_PORTS > 04), 0),
    f_bit32_qual(C_S03_AXI_ARB_PRIORITY, (C_NUM_SLAVE_PORTS > 03), 0),
    f_bit32_qual(C_S02_AXI_ARB_PRIORITY, (C_NUM_SLAVE_PORTS > 02), 0),
    f_bit32_qual(C_S01_AXI_ARB_PRIORITY, (C_NUM_SLAVE_PORTS > 01), 0),
    f_bit32_qual(C_S00_AXI_ARB_PRIORITY, (C_NUM_SLAVE_PORTS > 00), 0)
    };
  localparam         P_S_AXI_WRITE_FIFO_DEPTH = {
    f_bit32_qual(C_S15_AXI_WRITE_FIFO_DEPTH, (C_NUM_SLAVE_PORTS > 15), 0),
    f_bit32_qual(C_S14_AXI_WRITE_FIFO_DEPTH, (C_NUM_SLAVE_PORTS > 14), 0),
    f_bit32_qual(C_S13_AXI_WRITE_FIFO_DEPTH, (C_NUM_SLAVE_PORTS > 13), 0),
    f_bit32_qual(C_S12_AXI_WRITE_FIFO_DEPTH, (C_NUM_SLAVE_PORTS > 12), 0),
    f_bit32_qual(C_S11_AXI_WRITE_FIFO_DEPTH, (C_NUM_SLAVE_PORTS > 11), 0),
    f_bit32_qual(C_S10_AXI_WRITE_FIFO_DEPTH, (C_NUM_SLAVE_PORTS > 10), 0),
    f_bit32_qual(C_S09_AXI_WRITE_FIFO_DEPTH, (C_NUM_SLAVE_PORTS > 09), 0),
    f_bit32_qual(C_S08_AXI_WRITE_FIFO_DEPTH, (C_NUM_SLAVE_PORTS > 08), 0),
    f_bit32_qual(C_S07_AXI_WRITE_FIFO_DEPTH, (C_NUM_SLAVE_PORTS > 07), 0),
    f_bit32_qual(C_S06_AXI_WRITE_FIFO_DEPTH, (C_NUM_SLAVE_PORTS > 06), 0),
    f_bit32_qual(C_S05_AXI_WRITE_FIFO_DEPTH, (C_NUM_SLAVE_PORTS > 05), 0),
    f_bit32_qual(C_S04_AXI_WRITE_FIFO_DEPTH, (C_NUM_SLAVE_PORTS > 04), 0),
    f_bit32_qual(C_S03_AXI_WRITE_FIFO_DEPTH, (C_NUM_SLAVE_PORTS > 03), 0),
    f_bit32_qual(C_S02_AXI_WRITE_FIFO_DEPTH, (C_NUM_SLAVE_PORTS > 02), 0),
    f_bit32_qual(C_S01_AXI_WRITE_FIFO_DEPTH, (C_NUM_SLAVE_PORTS > 01), 0),
    f_bit32_qual(C_S00_AXI_WRITE_FIFO_DEPTH, (C_NUM_SLAVE_PORTS > 00), 0)
    };
  localparam         P_S_AXI_READ_FIFO_DEPTH = {
    f_bit32_qual(C_S15_AXI_READ_FIFO_DEPTH, (C_NUM_SLAVE_PORTS > 15), 0),
    f_bit32_qual(C_S14_AXI_READ_FIFO_DEPTH, (C_NUM_SLAVE_PORTS > 14), 0),
    f_bit32_qual(C_S13_AXI_READ_FIFO_DEPTH, (C_NUM_SLAVE_PORTS > 13), 0),
    f_bit32_qual(C_S12_AXI_READ_FIFO_DEPTH, (C_NUM_SLAVE_PORTS > 12), 0),
    f_bit32_qual(C_S11_AXI_READ_FIFO_DEPTH, (C_NUM_SLAVE_PORTS > 11), 0),
    f_bit32_qual(C_S10_AXI_READ_FIFO_DEPTH, (C_NUM_SLAVE_PORTS > 10), 0),
    f_bit32_qual(C_S09_AXI_READ_FIFO_DEPTH, (C_NUM_SLAVE_PORTS > 09), 0),
    f_bit32_qual(C_S08_AXI_READ_FIFO_DEPTH, (C_NUM_SLAVE_PORTS > 08), 0),
    f_bit32_qual(C_S07_AXI_READ_FIFO_DEPTH, (C_NUM_SLAVE_PORTS > 07), 0),
    f_bit32_qual(C_S06_AXI_READ_FIFO_DEPTH, (C_NUM_SLAVE_PORTS > 06), 0),
    f_bit32_qual(C_S05_AXI_READ_FIFO_DEPTH, (C_NUM_SLAVE_PORTS > 05), 0),
    f_bit32_qual(C_S04_AXI_READ_FIFO_DEPTH, (C_NUM_SLAVE_PORTS > 04), 0),
    f_bit32_qual(C_S03_AXI_READ_FIFO_DEPTH, (C_NUM_SLAVE_PORTS > 03), 0),
    f_bit32_qual(C_S02_AXI_READ_FIFO_DEPTH, (C_NUM_SLAVE_PORTS > 02), 0),
    f_bit32_qual(C_S01_AXI_READ_FIFO_DEPTH, (C_NUM_SLAVE_PORTS > 01), 0),
    f_bit32_qual(C_S00_AXI_READ_FIFO_DEPTH, (C_NUM_SLAVE_PORTS > 00), 0)
    };
  localparam         P_S_AXI_WRITE_FIFO_DELAY = {
    f_bit1(C_S15_AXI_WRITE_FIFO_DELAY),
    f_bit1(C_S14_AXI_WRITE_FIFO_DELAY),
    f_bit1(C_S13_AXI_WRITE_FIFO_DELAY),
    f_bit1(C_S12_AXI_WRITE_FIFO_DELAY),
    f_bit1(C_S11_AXI_WRITE_FIFO_DELAY),
    f_bit1(C_S10_AXI_WRITE_FIFO_DELAY),
    f_bit1(C_S09_AXI_WRITE_FIFO_DELAY),
    f_bit1(C_S08_AXI_WRITE_FIFO_DELAY),
    f_bit1(C_S07_AXI_WRITE_FIFO_DELAY),
    f_bit1(C_S06_AXI_WRITE_FIFO_DELAY),
    f_bit1(C_S05_AXI_WRITE_FIFO_DELAY),
    f_bit1(C_S04_AXI_WRITE_FIFO_DELAY),
    f_bit1(C_S03_AXI_WRITE_FIFO_DELAY),
    f_bit1(C_S02_AXI_WRITE_FIFO_DELAY),
    f_bit1(C_S01_AXI_WRITE_FIFO_DELAY),
    f_bit1(C_S00_AXI_WRITE_FIFO_DELAY)
    };
  localparam         P_S_AXI_READ_FIFO_DELAY = {
    f_bit1(C_S15_AXI_READ_FIFO_DELAY),
    f_bit1(C_S14_AXI_READ_FIFO_DELAY),
    f_bit1(C_S13_AXI_READ_FIFO_DELAY),
    f_bit1(C_S12_AXI_READ_FIFO_DELAY),
    f_bit1(C_S11_AXI_READ_FIFO_DELAY),
    f_bit1(C_S10_AXI_READ_FIFO_DELAY),
    f_bit1(C_S09_AXI_READ_FIFO_DELAY),
    f_bit1(C_S08_AXI_READ_FIFO_DELAY),
    f_bit1(C_S07_AXI_READ_FIFO_DELAY),
    f_bit1(C_S06_AXI_READ_FIFO_DELAY),
    f_bit1(C_S05_AXI_READ_FIFO_DELAY),
    f_bit1(C_S04_AXI_READ_FIFO_DELAY),
    f_bit1(C_S03_AXI_READ_FIFO_DELAY),
    f_bit1(C_S02_AXI_READ_FIFO_DELAY),
    f_bit1(C_S01_AXI_READ_FIFO_DELAY),
    f_bit1(C_S00_AXI_READ_FIFO_DELAY)
    };
  localparam         P_S_AXI_REGISTER = {
    f_bit32_qual((C_S15_AXI_REGISTER ? 8: 0), (C_NUM_SLAVE_PORTS > 15), 0),
    f_bit32_qual((C_S14_AXI_REGISTER ? 8: 0), (C_NUM_SLAVE_PORTS > 14), 0),
    f_bit32_qual((C_S13_AXI_REGISTER ? 8: 0), (C_NUM_SLAVE_PORTS > 13), 0),
    f_bit32_qual((C_S12_AXI_REGISTER ? 8: 0), (C_NUM_SLAVE_PORTS > 12), 0),
    f_bit32_qual((C_S11_AXI_REGISTER ? 8: 0), (C_NUM_SLAVE_PORTS > 11), 0),
    f_bit32_qual((C_S10_AXI_REGISTER ? 8: 0), (C_NUM_SLAVE_PORTS > 10), 0),
    f_bit32_qual((C_S09_AXI_REGISTER ? 8: 0), (C_NUM_SLAVE_PORTS > 09), 0),
    f_bit32_qual((C_S08_AXI_REGISTER ? 8: 0), (C_NUM_SLAVE_PORTS > 08), 0),
    f_bit32_qual((C_S07_AXI_REGISTER ? 8: 0), (C_NUM_SLAVE_PORTS > 07), 0),
    f_bit32_qual((C_S06_AXI_REGISTER ? 8: 0), (C_NUM_SLAVE_PORTS > 06), 0),
    f_bit32_qual((C_S05_AXI_REGISTER ? 8: 0), (C_NUM_SLAVE_PORTS > 05), 0),
    f_bit32_qual((C_S04_AXI_REGISTER ? 8: 0), (C_NUM_SLAVE_PORTS > 04), 0),
    f_bit32_qual((C_S03_AXI_REGISTER ? 8: 0), (C_NUM_SLAVE_PORTS > 03), 0),
    f_bit32_qual((C_S02_AXI_REGISTER ? 8: 0), (C_NUM_SLAVE_PORTS > 02), 0),
    f_bit32_qual((C_S01_AXI_REGISTER ? 8: 0), (C_NUM_SLAVE_PORTS > 01), 0),
    f_bit32_qual((C_S00_AXI_REGISTER ? 8: 0), (C_NUM_SLAVE_PORTS > 00), 0)
    };
  localparam         P_M_AXI_REGISTER = f_bit32_qual((C_M00_AXI_REGISTER ? 8: 0), 1, 0);

  wire [C_NUM_SLAVE_PORTS-1:0]                            s_axi_areset_out_n;
  wire [C_NUM_SLAVE_PORTS-1:0]                            s_axi_aclk;
  wire [C_NUM_SLAVE_PORTS*P_AXI_ID_WIDTH-1:0]             s_axi_awid;
  wire [C_NUM_SLAVE_PORTS*C_AXI_ADDR_WIDTH-1:0]           s_axi_awaddr;
  wire [C_NUM_SLAVE_PORTS*8-1:0]                          s_axi_awlen;
  wire [C_NUM_SLAVE_PORTS*3-1:0]                          s_axi_awsize;
  wire [C_NUM_SLAVE_PORTS*2-1:0]                          s_axi_awburst;
  wire [C_NUM_SLAVE_PORTS*2-1:0]                          s_axi_awlock;
  wire [C_NUM_SLAVE_PORTS*4-1:0]                          s_axi_awcache;
  wire [C_NUM_SLAVE_PORTS*3-1:0]                          s_axi_awprot;
  wire [C_NUM_SLAVE_PORTS*4-1:0]                          s_axi_awqos;
  wire [C_NUM_SLAVE_PORTS-1:0]                            s_axi_awvalid;
  wire [C_NUM_SLAVE_PORTS-1:0]                            s_axi_awready;
  wire [C_NUM_SLAVE_PORTS*P_AXI_DATA_MAX_WIDTH-1:0]       s_axi_wdata;
  wire [C_NUM_SLAVE_PORTS*P_AXI_DATA_MAX_WIDTH/8-1:0]     s_axi_wstrb;
  wire [C_NUM_SLAVE_PORTS-1:0]                            s_axi_wlast;
  wire [C_NUM_SLAVE_PORTS-1:0]                            s_axi_wvalid;
  wire [C_NUM_SLAVE_PORTS-1:0]                            s_axi_wready;
  wire [C_NUM_SLAVE_PORTS*P_AXI_ID_WIDTH-1:0]             s_axi_bid;
  wire [C_NUM_SLAVE_PORTS*2-1:0]                          s_axi_bresp;
  wire [C_NUM_SLAVE_PORTS-1:0]                            s_axi_bvalid;
  wire [C_NUM_SLAVE_PORTS-1:0]                            s_axi_bready;
  wire [C_NUM_SLAVE_PORTS*P_AXI_ID_WIDTH-1:0]             s_axi_arid;
  wire [C_NUM_SLAVE_PORTS*C_AXI_ADDR_WIDTH-1:0]           s_axi_araddr;
  wire [C_NUM_SLAVE_PORTS*8-1:0]                          s_axi_arlen;
  wire [C_NUM_SLAVE_PORTS*3-1:0]                          s_axi_arsize;
  wire [C_NUM_SLAVE_PORTS*2-1:0]                          s_axi_arburst;
  wire [C_NUM_SLAVE_PORTS*2-1:0]                          s_axi_arlock;
  wire [C_NUM_SLAVE_PORTS*4-1:0]                          s_axi_arcache;
  wire [C_NUM_SLAVE_PORTS*3-1:0]                          s_axi_arprot;
  wire [C_NUM_SLAVE_PORTS*4-1:0]                          s_axi_arqos;
  wire [C_NUM_SLAVE_PORTS-1:0]                            s_axi_arvalid;
  wire [C_NUM_SLAVE_PORTS-1:0]                            s_axi_arready;
  wire [C_NUM_SLAVE_PORTS*P_AXI_ID_WIDTH-1:0]             s_axi_rid;
  wire [C_NUM_SLAVE_PORTS*P_AXI_DATA_MAX_WIDTH-1:0]       s_axi_rdata;
  wire [C_NUM_SLAVE_PORTS*2-1:0]                          s_axi_rresp;
  wire [C_NUM_SLAVE_PORTS-1:0]                            s_axi_rlast;
  wire [C_NUM_SLAVE_PORTS-1:0]                            s_axi_rvalid;
  wire [C_NUM_SLAVE_PORTS-1:0]                            s_axi_rready;
                                                          
  wire [1:0]                                              m_axi_awlock_i;
  wire [1:0]                                              m_axi_arlock_i;
  wire [P_AXI_DATA_MAX_WIDTH-1:0]                         m_axi_wdata;
  wire [P_AXI_DATA_MAX_WIDTH-1:0]                         m_axi_rdata;
  wire [P_AXI_DATA_MAX_WIDTH/8-1:0]                       m_axi_wstrb;
                                                                    
  generate
    if (C_NUM_SLAVE_PORTS > 00) begin : gen_si00
      assign s_axi_aclk      [00 +: 1]                                                   = S00_AXI_ACLK      ;
      assign s_axi_awid      [00 *P_AXI_ID_WIDTH +: P_AXI_ID_WIDTH]                      = S00_AXI_AWID      ;
      assign s_axi_awaddr    [00 *C_AXI_ADDR_WIDTH +: C_AXI_ADDR_WIDTH]                  = S00_AXI_AWADDR    ;
      assign s_axi_awlen     [00 *8 +: 8]                                                = S00_AXI_AWLEN     ;
      assign s_axi_awsize    [00 *3 +: 3]                                                = S00_AXI_AWSIZE    ;
      assign s_axi_awburst   [00 *2 +: 2]                                                = S00_AXI_AWBURST   ;
      assign s_axi_awlock    [00 *2 +: 2]                                                = S00_AXI_AWLOCK    ;
      assign s_axi_awcache   [00 *4 +: 4]                                                = S00_AXI_AWCACHE   ;
      assign s_axi_awprot    [00 *3 +: 3]                                                = S00_AXI_AWPROT    ;
      assign s_axi_awqos     [00 *4 +: 4]                                                = S00_AXI_AWQOS     ;
      assign s_axi_awvalid   [00 +: 1]                                                   = S00_AXI_AWVALID   ;
      assign s_axi_wdata     [00 *P_AXI_DATA_MAX_WIDTH +: P_AXI_DATA_MAX_WIDTH]          = S00_AXI_WDATA     ; 
      assign s_axi_wstrb     [00 *P_AXI_DATA_MAX_WIDTH/8 +: P_AXI_DATA_MAX_WIDTH/8]      = S00_AXI_WSTRB     ;    
      assign s_axi_wlast     [00 +: 1]                                                   = S00_AXI_WLAST     ;
      assign s_axi_wvalid    [00 +: 1]                                                   = S00_AXI_WVALID    ;
      assign s_axi_bready    [00 +: 1]                                                   = S00_AXI_BREADY    ;
      assign s_axi_arid      [00 *P_AXI_ID_WIDTH +: P_AXI_ID_WIDTH]                      = S00_AXI_ARID      ;
      assign s_axi_araddr    [00 *C_AXI_ADDR_WIDTH +: C_AXI_ADDR_WIDTH]                  = S00_AXI_ARADDR    ;
      assign s_axi_arlen     [00 *8 +: 8]                                                = S00_AXI_ARLEN     ;
      assign s_axi_arsize    [00 *3 +: 3]                                                = S00_AXI_ARSIZE    ;
      assign s_axi_arburst   [00 *2 +: 2]                                                = S00_AXI_ARBURST   ;
      assign s_axi_arlock    [00 *2 +: 2]                                                = S00_AXI_ARLOCK    ;
      assign s_axi_arcache   [00 *4 +: 4]                                                = S00_AXI_ARCACHE   ;
      assign s_axi_arprot    [00 *3 +: 3]                                                = S00_AXI_ARPROT    ;
      assign s_axi_arqos     [00 *4 +: 4]                                                = S00_AXI_ARQOS     ;
      assign s_axi_arvalid   [00 +: 1]                                                   = S00_AXI_ARVALID   ;
      assign s_axi_rready    [00 +: 1]                                                   = S00_AXI_RREADY    ;
                                                                                         
      assign S00_AXI_ARESET_OUT_N = s_axi_areset_out_n[00 +: 1]                                                   ;
      assign S00_AXI_AWREADY   = s_axi_awready   [00 +: 1]                                                   ;
      assign S00_AXI_WREADY    = s_axi_wready    [00 +: 1]                                                   ;
      assign S00_AXI_BID       = s_axi_bid       [00 *P_AXI_ID_WIDTH +: C_THREAD_ID_PORT_WIDTH]              ;
      assign S00_AXI_BRESP     = s_axi_bresp     [00 *2 +: 2]                                                ;
      assign S00_AXI_BVALID    = s_axi_bvalid    [00 +: 1]                                                   ;
      assign S00_AXI_ARREADY   = s_axi_arready   [00 +: 1]                                                   ;
      assign S00_AXI_RID       = s_axi_rid       [00 *P_AXI_ID_WIDTH +: C_THREAD_ID_PORT_WIDTH]              ;
      assign S00_AXI_RDATA     = s_axi_rdata     [00 *P_AXI_DATA_MAX_WIDTH +: C_S00_AXI_DATA_WIDTH]       ; 
      assign S00_AXI_RRESP     = s_axi_rresp     [00 *2 +: 2]                                                ;
      assign S00_AXI_RLAST     = s_axi_rlast     [00 +: 1]                                                   ;
      assign S00_AXI_RVALID    = s_axi_rvalid    [00 +: 1]                                                   ;
    end else begin : gen_no_si00
      assign S00_AXI_ARESET_OUT_N = 0 ;
      assign S00_AXI_AWREADY   = 0 ;
      assign S00_AXI_WREADY    = 0 ;
      assign S00_AXI_BID       = 0 ;
      assign S00_AXI_BRESP     = 0 ;
      assign S00_AXI_BVALID    = 0 ;
      assign S00_AXI_ARREADY   = 0 ;
      assign S00_AXI_RID       = 0 ;
      assign S00_AXI_RDATA     = 0 ;
      assign S00_AXI_RRESP     = 0 ;
      assign S00_AXI_RLAST     = 0 ;
      assign S00_AXI_RVALID    = 0 ;
    end
  endgenerate
  
  generate
    if (C_NUM_SLAVE_PORTS > 01) begin : gen_si01
      assign s_axi_aclk      [01 +: 1]                                                   = S01_AXI_ACLK      ;
      assign s_axi_awid      [01 *P_AXI_ID_WIDTH +: P_AXI_ID_WIDTH]                      = S01_AXI_AWID      ;
      assign s_axi_awaddr    [01 *C_AXI_ADDR_WIDTH +: C_AXI_ADDR_WIDTH]                  = S01_AXI_AWADDR    ;
      assign s_axi_awlen     [01 *8 +: 8]                                                = S01_AXI_AWLEN     ;
      assign s_axi_awsize    [01 *3 +: 3]                                                = S01_AXI_AWSIZE    ;
      assign s_axi_awburst   [01 *2 +: 2]                                                = S01_AXI_AWBURST   ;
      assign s_axi_awlock    [01 *2 +: 2]                                                = S01_AXI_AWLOCK    ;
      assign s_axi_awcache   [01 *4 +: 4]                                                = S01_AXI_AWCACHE   ;
      assign s_axi_awprot    [01 *3 +: 3]                                                = S01_AXI_AWPROT    ;
      assign s_axi_awqos     [01 *4 +: 4]                                                = S01_AXI_AWQOS     ;
      assign s_axi_awvalid   [01 +: 1]                                                   = S01_AXI_AWVALID   ;
      assign s_axi_wdata     [01 *P_AXI_DATA_MAX_WIDTH +: P_AXI_DATA_MAX_WIDTH]          = S01_AXI_WDATA     ; 
      assign s_axi_wstrb     [01 *P_AXI_DATA_MAX_WIDTH/8 +: P_AXI_DATA_MAX_WIDTH/8]      = S01_AXI_WSTRB     ;    
      assign s_axi_wlast     [01 +: 1]                                                   = S01_AXI_WLAST     ;
      assign s_axi_wvalid    [01 +: 1]                                                   = S01_AXI_WVALID    ;
      assign s_axi_bready    [01 +: 1]                                                   = S01_AXI_BREADY    ;
      assign s_axi_arid      [01 *P_AXI_ID_WIDTH +: P_AXI_ID_WIDTH]                      = S01_AXI_ARID      ;
      assign s_axi_araddr    [01 *C_AXI_ADDR_WIDTH +: C_AXI_ADDR_WIDTH]                  = S01_AXI_ARADDR    ;
      assign s_axi_arlen     [01 *8 +: 8]                                                = S01_AXI_ARLEN     ;
      assign s_axi_arsize    [01 *3 +: 3]                                                = S01_AXI_ARSIZE    ;
      assign s_axi_arburst   [01 *2 +: 2]                                                = S01_AXI_ARBURST   ;
      assign s_axi_arlock    [01 *2 +: 2]                                                = S01_AXI_ARLOCK    ;
      assign s_axi_arcache   [01 *4 +: 4]                                                = S01_AXI_ARCACHE   ;
      assign s_axi_arprot    [01 *3 +: 3]                                                = S01_AXI_ARPROT    ;
      assign s_axi_arqos     [01 *4 +: 4]                                                = S01_AXI_ARQOS     ;
      assign s_axi_arvalid   [01 +: 1]                                                   = S01_AXI_ARVALID   ;
      assign s_axi_rready    [01 +: 1]                                                   = S01_AXI_RREADY    ;
                                                                                         
      assign S01_AXI_ARESET_OUT_N = s_axi_areset_out_n[01 +: 1]                                                   ;
      assign S01_AXI_AWREADY   = s_axi_awready   [01 +: 1]                                                   ;
      assign S01_AXI_WREADY    = s_axi_wready    [01 +: 1]                                                   ;
      assign S01_AXI_BID       = s_axi_bid       [01 *P_AXI_ID_WIDTH +: C_THREAD_ID_PORT_WIDTH]              ;
      assign S01_AXI_BRESP     = s_axi_bresp     [01 *2 +: 2]                                                ;
      assign S01_AXI_BVALID    = s_axi_bvalid    [01 +: 1]                                                   ;
      assign S01_AXI_ARREADY   = s_axi_arready   [01 +: 1]                                                   ;
      assign S01_AXI_RID       = s_axi_rid       [01 *P_AXI_ID_WIDTH +: C_THREAD_ID_PORT_WIDTH]              ;
      assign S01_AXI_RDATA     = s_axi_rdata     [01 *P_AXI_DATA_MAX_WIDTH +: C_S01_AXI_DATA_WIDTH]       ; 
      assign S01_AXI_RRESP     = s_axi_rresp     [01 *2 +: 2]                                                ;
      assign S01_AXI_RLAST     = s_axi_rlast     [01 +: 1]                                                   ;
      assign S01_AXI_RVALID    = s_axi_rvalid    [01 +: 1]                                                   ;
    end else begin : gen_no_si01
      assign S01_AXI_ARESET_OUT_N = 0 ;
      assign S01_AXI_AWREADY   = 0 ;
      assign S01_AXI_WREADY    = 0 ;
      assign S01_AXI_BID       = 0 ;
      assign S01_AXI_BRESP     = 0 ;
      assign S01_AXI_BVALID    = 0 ;
      assign S01_AXI_ARREADY   = 0 ;
      assign S01_AXI_RID       = 0 ;
      assign S01_AXI_RDATA     = 0 ;
      assign S01_AXI_RRESP     = 0 ;
      assign S01_AXI_RLAST     = 0 ;
      assign S01_AXI_RVALID    = 0 ;
    end
  endgenerate
  
  generate
    if (C_NUM_SLAVE_PORTS > 02) begin : gen_si02
      assign s_axi_aclk      [02 +: 1]                                                   = S02_AXI_ACLK      ;
      assign s_axi_awid      [02 *P_AXI_ID_WIDTH +: P_AXI_ID_WIDTH]                      = S02_AXI_AWID      ;
      assign s_axi_awaddr    [02 *C_AXI_ADDR_WIDTH +: C_AXI_ADDR_WIDTH]                  = S02_AXI_AWADDR    ;
      assign s_axi_awlen     [02 *8 +: 8]                                                = S02_AXI_AWLEN     ;
      assign s_axi_awsize    [02 *3 +: 3]                                                = S02_AXI_AWSIZE    ;
      assign s_axi_awburst   [02 *2 +: 2]                                                = S02_AXI_AWBURST   ;
      assign s_axi_awlock    [02 *2 +: 2]                                                = S02_AXI_AWLOCK    ;
      assign s_axi_awcache   [02 *4 +: 4]                                                = S02_AXI_AWCACHE   ;
      assign s_axi_awprot    [02 *3 +: 3]                                                = S02_AXI_AWPROT    ;
      assign s_axi_awqos     [02 *4 +: 4]                                                = S02_AXI_AWQOS     ;
      assign s_axi_awvalid   [02 +: 1]                                                   = S02_AXI_AWVALID   ;
      assign s_axi_wdata     [02 *P_AXI_DATA_MAX_WIDTH +: P_AXI_DATA_MAX_WIDTH]          = S02_AXI_WDATA     ; 
      assign s_axi_wstrb     [02 *P_AXI_DATA_MAX_WIDTH/8 +: P_AXI_DATA_MAX_WIDTH/8]      = S02_AXI_WSTRB     ;    
      assign s_axi_wlast     [02 +: 1]                                                   = S02_AXI_WLAST     ;
      assign s_axi_wvalid    [02 +: 1]                                                   = S02_AXI_WVALID    ;
      assign s_axi_bready    [02 +: 1]                                                   = S02_AXI_BREADY    ;
      assign s_axi_arid      [02 *P_AXI_ID_WIDTH +: P_AXI_ID_WIDTH]                      = S02_AXI_ARID      ;
      assign s_axi_araddr    [02 *C_AXI_ADDR_WIDTH +: C_AXI_ADDR_WIDTH]                  = S02_AXI_ARADDR    ;
      assign s_axi_arlen     [02 *8 +: 8]                                                = S02_AXI_ARLEN     ;
      assign s_axi_arsize    [02 *3 +: 3]                                                = S02_AXI_ARSIZE    ;
      assign s_axi_arburst   [02 *2 +: 2]                                                = S02_AXI_ARBURST   ;
      assign s_axi_arlock    [02 *2 +: 2]                                                = S02_AXI_ARLOCK    ;
      assign s_axi_arcache   [02 *4 +: 4]                                                = S02_AXI_ARCACHE   ;
      assign s_axi_arprot    [02 *3 +: 3]                                                = S02_AXI_ARPROT    ;
      assign s_axi_arqos     [02 *4 +: 4]                                                = S02_AXI_ARQOS     ;
      assign s_axi_arvalid   [02 +: 1]                                                   = S02_AXI_ARVALID   ;
      assign s_axi_rready    [02 +: 1]                                                   = S02_AXI_RREADY    ;
                                                                                         
      assign S02_AXI_ARESET_OUT_N = s_axi_areset_out_n[02 +: 1]                                                   ;
      assign S02_AXI_AWREADY   = s_axi_awready   [02 +: 1]                                                   ;
      assign S02_AXI_WREADY    = s_axi_wready    [02 +: 1]                                                   ;
      assign S02_AXI_BID       = s_axi_bid       [02 *P_AXI_ID_WIDTH +: C_THREAD_ID_PORT_WIDTH]              ;
      assign S02_AXI_BRESP     = s_axi_bresp     [02 *2 +: 2]                                                ;
      assign S02_AXI_BVALID    = s_axi_bvalid    [02 +: 1]                                                   ;
      assign S02_AXI_ARREADY   = s_axi_arready   [02 +: 1]                                                   ;
      assign S02_AXI_RID       = s_axi_rid       [02 *P_AXI_ID_WIDTH +: C_THREAD_ID_PORT_WIDTH]              ;
      assign S02_AXI_RDATA     = s_axi_rdata     [02 *P_AXI_DATA_MAX_WIDTH +: C_S02_AXI_DATA_WIDTH]       ; 
      assign S02_AXI_RRESP     = s_axi_rresp     [02 *2 +: 2]                                                ;
      assign S02_AXI_RLAST     = s_axi_rlast     [02 +: 1]                                                   ;
      assign S02_AXI_RVALID    = s_axi_rvalid    [02 +: 1]                                                   ;
    end else begin : gen_no_si02
      assign S02_AXI_ARESET_OUT_N = 0 ;
      assign S02_AXI_AWREADY   = 0 ;
      assign S02_AXI_WREADY    = 0 ;
      assign S02_AXI_BID       = 0 ;
      assign S02_AXI_BRESP     = 0 ;
      assign S02_AXI_BVALID    = 0 ;
      assign S02_AXI_ARREADY   = 0 ;
      assign S02_AXI_RID       = 0 ;
      assign S02_AXI_RDATA     = 0 ;
      assign S02_AXI_RRESP     = 0 ;
      assign S02_AXI_RLAST     = 0 ;
      assign S02_AXI_RVALID    = 0 ;
    end
  endgenerate
  
  generate
    if (C_NUM_SLAVE_PORTS > 03) begin : gen_si03
      assign s_axi_aclk      [03 +: 1]                                                   = S03_AXI_ACLK      ;
      assign s_axi_awid      [03 *P_AXI_ID_WIDTH +: P_AXI_ID_WIDTH]                      = S03_AXI_AWID      ;
      assign s_axi_awaddr    [03 *C_AXI_ADDR_WIDTH +: C_AXI_ADDR_WIDTH]                  = S03_AXI_AWADDR    ;
      assign s_axi_awlen     [03 *8 +: 8]                                                = S03_AXI_AWLEN     ;
      assign s_axi_awsize    [03 *3 +: 3]                                                = S03_AXI_AWSIZE    ;
      assign s_axi_awburst   [03 *2 +: 2]                                                = S03_AXI_AWBURST   ;
      assign s_axi_awlock    [03 *2 +: 2]                                                = S03_AXI_AWLOCK    ;
      assign s_axi_awcache   [03 *4 +: 4]                                                = S03_AXI_AWCACHE   ;
      assign s_axi_awprot    [03 *3 +: 3]                                                = S03_AXI_AWPROT    ;
      assign s_axi_awqos     [03 *4 +: 4]                                                = S03_AXI_AWQOS     ;
      assign s_axi_awvalid   [03 +: 1]                                                   = S03_AXI_AWVALID   ;
      assign s_axi_wdata     [03 *P_AXI_DATA_MAX_WIDTH +: P_AXI_DATA_MAX_WIDTH]          = S03_AXI_WDATA     ; 
      assign s_axi_wstrb     [03 *P_AXI_DATA_MAX_WIDTH/8 +: P_AXI_DATA_MAX_WIDTH/8]      = S03_AXI_WSTRB     ;    
      assign s_axi_wlast     [03 +: 1]                                                   = S03_AXI_WLAST     ;
      assign s_axi_wvalid    [03 +: 1]                                                   = S03_AXI_WVALID    ;
      assign s_axi_bready    [03 +: 1]                                                   = S03_AXI_BREADY    ;
      assign s_axi_arid      [03 *P_AXI_ID_WIDTH +: P_AXI_ID_WIDTH]                      = S03_AXI_ARID      ;
      assign s_axi_araddr    [03 *C_AXI_ADDR_WIDTH +: C_AXI_ADDR_WIDTH]                  = S03_AXI_ARADDR    ;
      assign s_axi_arlen     [03 *8 +: 8]                                                = S03_AXI_ARLEN     ;
      assign s_axi_arsize    [03 *3 +: 3]                                                = S03_AXI_ARSIZE    ;
      assign s_axi_arburst   [03 *2 +: 2]                                                = S03_AXI_ARBURST   ;
      assign s_axi_arlock    [03 *2 +: 2]                                                = S03_AXI_ARLOCK    ;
      assign s_axi_arcache   [03 *4 +: 4]                                                = S03_AXI_ARCACHE   ;
      assign s_axi_arprot    [03 *3 +: 3]                                                = S03_AXI_ARPROT    ;
      assign s_axi_arqos     [03 *4 +: 4]                                                = S03_AXI_ARQOS     ;
      assign s_axi_arvalid   [03 +: 1]                                                   = S03_AXI_ARVALID   ;
      assign s_axi_rready    [03 +: 1]                                                   = S03_AXI_RREADY    ;
                                                                                         
      assign S03_AXI_ARESET_OUT_N = s_axi_areset_out_n[03 +: 1]                                                   ;
      assign S03_AXI_AWREADY   = s_axi_awready   [03 +: 1]                                                   ;
      assign S03_AXI_WREADY    = s_axi_wready    [03 +: 1]                                                   ;
      assign S03_AXI_BID       = s_axi_bid       [03 *P_AXI_ID_WIDTH +: C_THREAD_ID_PORT_WIDTH]              ;
      assign S03_AXI_BRESP     = s_axi_bresp     [03 *2 +: 2]                                                ;
      assign S03_AXI_BVALID    = s_axi_bvalid    [03 +: 1]                                                   ;
      assign S03_AXI_ARREADY   = s_axi_arready   [03 +: 1]                                                   ;
      assign S03_AXI_RID       = s_axi_rid       [03 *P_AXI_ID_WIDTH +: C_THREAD_ID_PORT_WIDTH]              ;
      assign S03_AXI_RDATA     = s_axi_rdata     [03 *P_AXI_DATA_MAX_WIDTH +: C_S03_AXI_DATA_WIDTH]       ; 
      assign S03_AXI_RRESP     = s_axi_rresp     [03 *2 +: 2]                                                ;
      assign S03_AXI_RLAST     = s_axi_rlast     [03 +: 1]                                                   ;
      assign S03_AXI_RVALID    = s_axi_rvalid    [03 +: 1]                                                   ;
    end else begin : gen_no_si03
      assign S03_AXI_ARESET_OUT_N = 0 ;
      assign S03_AXI_AWREADY   = 0 ;
      assign S03_AXI_WREADY    = 0 ;
      assign S03_AXI_BID       = 0 ;
      assign S03_AXI_BRESP     = 0 ;
      assign S03_AXI_BVALID    = 0 ;
      assign S03_AXI_ARREADY   = 0 ;
      assign S03_AXI_RID       = 0 ;
      assign S03_AXI_RDATA     = 0 ;
      assign S03_AXI_RRESP     = 0 ;
      assign S03_AXI_RLAST     = 0 ;
      assign S03_AXI_RVALID    = 0 ;
    end
  endgenerate
  
  generate
    if (C_NUM_SLAVE_PORTS > 04) begin : gen_si04
      assign s_axi_aclk      [04 +: 1]                                                   = S04_AXI_ACLK      ;
      assign s_axi_awid      [04 *P_AXI_ID_WIDTH +: P_AXI_ID_WIDTH]                      = S04_AXI_AWID      ;
      assign s_axi_awaddr    [04 *C_AXI_ADDR_WIDTH +: C_AXI_ADDR_WIDTH]                  = S04_AXI_AWADDR    ;
      assign s_axi_awlen     [04 *8 +: 8]                                                = S04_AXI_AWLEN     ;
      assign s_axi_awsize    [04 *3 +: 3]                                                = S04_AXI_AWSIZE    ;
      assign s_axi_awburst   [04 *2 +: 2]                                                = S04_AXI_AWBURST   ;
      assign s_axi_awlock    [04 *2 +: 2]                                                = S04_AXI_AWLOCK    ;
      assign s_axi_awcache   [04 *4 +: 4]                                                = S04_AXI_AWCACHE   ;
      assign s_axi_awprot    [04 *3 +: 3]                                                = S04_AXI_AWPROT    ;
      assign s_axi_awqos     [04 *4 +: 4]                                                = S04_AXI_AWQOS     ;
      assign s_axi_awvalid   [04 +: 1]                                                   = S04_AXI_AWVALID   ;
      assign s_axi_wdata     [04 *P_AXI_DATA_MAX_WIDTH +: P_AXI_DATA_MAX_WIDTH]          = S04_AXI_WDATA     ; 
      assign s_axi_wstrb     [04 *P_AXI_DATA_MAX_WIDTH/8 +: P_AXI_DATA_MAX_WIDTH/8]      = S04_AXI_WSTRB     ;    
      assign s_axi_wlast     [04 +: 1]                                                   = S04_AXI_WLAST     ;
      assign s_axi_wvalid    [04 +: 1]                                                   = S04_AXI_WVALID    ;
      assign s_axi_bready    [04 +: 1]                                                   = S04_AXI_BREADY    ;
      assign s_axi_arid      [04 *P_AXI_ID_WIDTH +: P_AXI_ID_WIDTH]                      = S04_AXI_ARID      ;
      assign s_axi_araddr    [04 *C_AXI_ADDR_WIDTH +: C_AXI_ADDR_WIDTH]                  = S04_AXI_ARADDR    ;
      assign s_axi_arlen     [04 *8 +: 8]                                                = S04_AXI_ARLEN     ;
      assign s_axi_arsize    [04 *3 +: 3]                                                = S04_AXI_ARSIZE    ;
      assign s_axi_arburst   [04 *2 +: 2]                                                = S04_AXI_ARBURST   ;
      assign s_axi_arlock    [04 *2 +: 2]                                                = S04_AXI_ARLOCK    ;
      assign s_axi_arcache   [04 *4 +: 4]                                                = S04_AXI_ARCACHE   ;
      assign s_axi_arprot    [04 *3 +: 3]                                                = S04_AXI_ARPROT    ;
      assign s_axi_arqos     [04 *4 +: 4]                                                = S04_AXI_ARQOS     ;
      assign s_axi_arvalid   [04 +: 1]                                                   = S04_AXI_ARVALID   ;
      assign s_axi_rready    [04 +: 1]                                                   = S04_AXI_RREADY    ;
                                                                                         
      assign S04_AXI_ARESET_OUT_N = s_axi_areset_out_n[04 +: 1]                                                   ;
      assign S04_AXI_AWREADY   = s_axi_awready   [04 +: 1]                                                   ;
      assign S04_AXI_WREADY    = s_axi_wready    [04 +: 1]                                                   ;
      assign S04_AXI_BID       = s_axi_bid       [04 *P_AXI_ID_WIDTH +: C_THREAD_ID_PORT_WIDTH]              ;
      assign S04_AXI_BRESP     = s_axi_bresp     [04 *2 +: 2]                                                ;
      assign S04_AXI_BVALID    = s_axi_bvalid    [04 +: 1]                                                   ;
      assign S04_AXI_ARREADY   = s_axi_arready   [04 +: 1]                                                   ;
      assign S04_AXI_RID       = s_axi_rid       [04 *P_AXI_ID_WIDTH +: C_THREAD_ID_PORT_WIDTH]              ;
      assign S04_AXI_RDATA     = s_axi_rdata     [04 *P_AXI_DATA_MAX_WIDTH +: C_S04_AXI_DATA_WIDTH]       ; 
      assign S04_AXI_RRESP     = s_axi_rresp     [04 *2 +: 2]                                                ;
      assign S04_AXI_RLAST     = s_axi_rlast     [04 +: 1]                                                   ;
      assign S04_AXI_RVALID    = s_axi_rvalid    [04 +: 1]                                                   ;
    end else begin : gen_no_si04
      assign S04_AXI_ARESET_OUT_N = 0 ;
      assign S04_AXI_AWREADY   = 0 ;
      assign S04_AXI_WREADY    = 0 ;
      assign S04_AXI_BID       = 0 ;
      assign S04_AXI_BRESP     = 0 ;
      assign S04_AXI_BVALID    = 0 ;
      assign S04_AXI_ARREADY   = 0 ;
      assign S04_AXI_RID       = 0 ;
      assign S04_AXI_RDATA     = 0 ;
      assign S04_AXI_RRESP     = 0 ;
      assign S04_AXI_RLAST     = 0 ;
      assign S04_AXI_RVALID    = 0 ;
    end
  endgenerate
  
  generate
    if (C_NUM_SLAVE_PORTS > 05) begin : gen_si05
      assign s_axi_aclk      [05 +: 1]                                                   = S05_AXI_ACLK      ;
      assign s_axi_awid      [05 *P_AXI_ID_WIDTH +: P_AXI_ID_WIDTH]                      = S05_AXI_AWID      ;
      assign s_axi_awaddr    [05 *C_AXI_ADDR_WIDTH +: C_AXI_ADDR_WIDTH]                  = S05_AXI_AWADDR    ;
      assign s_axi_awlen     [05 *8 +: 8]                                                = S05_AXI_AWLEN     ;
      assign s_axi_awsize    [05 *3 +: 3]                                                = S05_AXI_AWSIZE    ;
      assign s_axi_awburst   [05 *2 +: 2]                                                = S05_AXI_AWBURST   ;
      assign s_axi_awlock    [05 *2 +: 2]                                                = S05_AXI_AWLOCK    ;
      assign s_axi_awcache   [05 *4 +: 4]                                                = S05_AXI_AWCACHE   ;
      assign s_axi_awprot    [05 *3 +: 3]                                                = S05_AXI_AWPROT    ;
      assign s_axi_awqos     [05 *4 +: 4]                                                = S05_AXI_AWQOS     ;
      assign s_axi_awvalid   [05 +: 1]                                                   = S05_AXI_AWVALID   ;
      assign s_axi_wdata     [05 *P_AXI_DATA_MAX_WIDTH +: P_AXI_DATA_MAX_WIDTH]          = S05_AXI_WDATA     ; 
      assign s_axi_wstrb     [05 *P_AXI_DATA_MAX_WIDTH/8 +: P_AXI_DATA_MAX_WIDTH/8]      = S05_AXI_WSTRB     ;    
      assign s_axi_wlast     [05 +: 1]                                                   = S05_AXI_WLAST     ;
      assign s_axi_wvalid    [05 +: 1]                                                   = S05_AXI_WVALID    ;
      assign s_axi_bready    [05 +: 1]                                                   = S05_AXI_BREADY    ;
      assign s_axi_arid      [05 *P_AXI_ID_WIDTH +: P_AXI_ID_WIDTH]                      = S05_AXI_ARID      ;
      assign s_axi_araddr    [05 *C_AXI_ADDR_WIDTH +: C_AXI_ADDR_WIDTH]                  = S05_AXI_ARADDR    ;
      assign s_axi_arlen     [05 *8 +: 8]                                                = S05_AXI_ARLEN     ;
      assign s_axi_arsize    [05 *3 +: 3]                                                = S05_AXI_ARSIZE    ;
      assign s_axi_arburst   [05 *2 +: 2]                                                = S05_AXI_ARBURST   ;
      assign s_axi_arlock    [05 *2 +: 2]                                                = S05_AXI_ARLOCK    ;
      assign s_axi_arcache   [05 *4 +: 4]                                                = S05_AXI_ARCACHE   ;
      assign s_axi_arprot    [05 *3 +: 3]                                                = S05_AXI_ARPROT    ;
      assign s_axi_arqos     [05 *4 +: 4]                                                = S05_AXI_ARQOS     ;
      assign s_axi_arvalid   [05 +: 1]                                                   = S05_AXI_ARVALID   ;
      assign s_axi_rready    [05 +: 1]                                                   = S05_AXI_RREADY    ;
                                                                                         
      assign S05_AXI_ARESET_OUT_N = s_axi_areset_out_n[05 +: 1]                                                   ;
      assign S05_AXI_AWREADY   = s_axi_awready   [05 +: 1]                                                   ;
      assign S05_AXI_WREADY    = s_axi_wready    [05 +: 1]                                                   ;
      assign S05_AXI_BID       = s_axi_bid       [05 *P_AXI_ID_WIDTH +: C_THREAD_ID_PORT_WIDTH]              ;
      assign S05_AXI_BRESP     = s_axi_bresp     [05 *2 +: 2]                                                ;
      assign S05_AXI_BVALID    = s_axi_bvalid    [05 +: 1]                                                   ;
      assign S05_AXI_ARREADY   = s_axi_arready   [05 +: 1]                                                   ;
      assign S05_AXI_RID       = s_axi_rid       [05 *P_AXI_ID_WIDTH +: C_THREAD_ID_PORT_WIDTH]              ;
      assign S05_AXI_RDATA     = s_axi_rdata     [05 *P_AXI_DATA_MAX_WIDTH +: C_S05_AXI_DATA_WIDTH]       ; 
      assign S05_AXI_RRESP     = s_axi_rresp     [05 *2 +: 2]                                                ;
      assign S05_AXI_RLAST     = s_axi_rlast     [05 +: 1]                                                   ;
      assign S05_AXI_RVALID    = s_axi_rvalid    [05 +: 1]                                                   ;
    end else begin : gen_no_si05
      assign S05_AXI_ARESET_OUT_N = 0 ;
      assign S05_AXI_AWREADY   = 0 ;
      assign S05_AXI_WREADY    = 0 ;
      assign S05_AXI_BID       = 0 ;
      assign S05_AXI_BRESP     = 0 ;
      assign S05_AXI_BVALID    = 0 ;
      assign S05_AXI_ARREADY   = 0 ;
      assign S05_AXI_RID       = 0 ;
      assign S05_AXI_RDATA     = 0 ;
      assign S05_AXI_RRESP     = 0 ;
      assign S05_AXI_RLAST     = 0 ;
      assign S05_AXI_RVALID    = 0 ;
    end
  endgenerate
  
  generate
    if (C_NUM_SLAVE_PORTS > 06) begin : gen_si06
      assign s_axi_aclk      [06 +: 1]                                                   = S06_AXI_ACLK      ;
      assign s_axi_awid      [06 *P_AXI_ID_WIDTH +: P_AXI_ID_WIDTH]                      = S06_AXI_AWID      ;
      assign s_axi_awaddr    [06 *C_AXI_ADDR_WIDTH +: C_AXI_ADDR_WIDTH]                  = S06_AXI_AWADDR    ;
      assign s_axi_awlen     [06 *8 +: 8]                                                = S06_AXI_AWLEN     ;
      assign s_axi_awsize    [06 *3 +: 3]                                                = S06_AXI_AWSIZE    ;
      assign s_axi_awburst   [06 *2 +: 2]                                                = S06_AXI_AWBURST   ;
      assign s_axi_awlock    [06 *2 +: 2]                                                = S06_AXI_AWLOCK    ;
      assign s_axi_awcache   [06 *4 +: 4]                                                = S06_AXI_AWCACHE   ;
      assign s_axi_awprot    [06 *3 +: 3]                                                = S06_AXI_AWPROT    ;
      assign s_axi_awqos     [06 *4 +: 4]                                                = S06_AXI_AWQOS     ;
      assign s_axi_awvalid   [06 +: 1]                                                   = S06_AXI_AWVALID   ;
      assign s_axi_wdata     [06 *P_AXI_DATA_MAX_WIDTH +: P_AXI_DATA_MAX_WIDTH]          = S06_AXI_WDATA     ; 
      assign s_axi_wstrb     [06 *P_AXI_DATA_MAX_WIDTH/8 +: P_AXI_DATA_MAX_WIDTH/8]      = S06_AXI_WSTRB     ;    
      assign s_axi_wlast     [06 +: 1]                                                   = S06_AXI_WLAST     ;
      assign s_axi_wvalid    [06 +: 1]                                                   = S06_AXI_WVALID    ;
      assign s_axi_bready    [06 +: 1]                                                   = S06_AXI_BREADY    ;
      assign s_axi_arid      [06 *P_AXI_ID_WIDTH +: P_AXI_ID_WIDTH]                      = S06_AXI_ARID      ;
      assign s_axi_araddr    [06 *C_AXI_ADDR_WIDTH +: C_AXI_ADDR_WIDTH]                  = S06_AXI_ARADDR    ;
      assign s_axi_arlen     [06 *8 +: 8]                                                = S06_AXI_ARLEN     ;
      assign s_axi_arsize    [06 *3 +: 3]                                                = S06_AXI_ARSIZE    ;
      assign s_axi_arburst   [06 *2 +: 2]                                                = S06_AXI_ARBURST   ;
      assign s_axi_arlock    [06 *2 +: 2]                                                = S06_AXI_ARLOCK    ;
      assign s_axi_arcache   [06 *4 +: 4]                                                = S06_AXI_ARCACHE   ;
      assign s_axi_arprot    [06 *3 +: 3]                                                = S06_AXI_ARPROT    ;
      assign s_axi_arqos     [06 *4 +: 4]                                                = S06_AXI_ARQOS     ;
      assign s_axi_arvalid   [06 +: 1]                                                   = S06_AXI_ARVALID   ;
      assign s_axi_rready    [06 +: 1]                                                   = S06_AXI_RREADY    ;
                                                                                         
      assign S06_AXI_ARESET_OUT_N = s_axi_areset_out_n[06 +: 1]                                                   ;
      assign S06_AXI_AWREADY   = s_axi_awready   [06 +: 1]                                                   ;
      assign S06_AXI_WREADY    = s_axi_wready    [06 +: 1]                                                   ;
      assign S06_AXI_BID       = s_axi_bid       [06 *P_AXI_ID_WIDTH +: C_THREAD_ID_PORT_WIDTH]              ;
      assign S06_AXI_BRESP     = s_axi_bresp     [06 *2 +: 2]                                                ;
      assign S06_AXI_BVALID    = s_axi_bvalid    [06 +: 1]                                                   ;
      assign S06_AXI_ARREADY   = s_axi_arready   [06 +: 1]                                                   ;
      assign S06_AXI_RID       = s_axi_rid       [06 *P_AXI_ID_WIDTH +: C_THREAD_ID_PORT_WIDTH]              ;
      assign S06_AXI_RDATA     = s_axi_rdata     [06 *P_AXI_DATA_MAX_WIDTH +: C_S06_AXI_DATA_WIDTH]       ; 
      assign S06_AXI_RRESP     = s_axi_rresp     [06 *2 +: 2]                                                ;
      assign S06_AXI_RLAST     = s_axi_rlast     [06 +: 1]                                                   ;
      assign S06_AXI_RVALID    = s_axi_rvalid    [06 +: 1]                                                   ;
    end else begin : gen_no_si06
      assign S06_AXI_ARESET_OUT_N = 0 ;
      assign S06_AXI_AWREADY   = 0 ;
      assign S06_AXI_WREADY    = 0 ;
      assign S06_AXI_BID       = 0 ;
      assign S06_AXI_BRESP     = 0 ;
      assign S06_AXI_BVALID    = 0 ;
      assign S06_AXI_ARREADY   = 0 ;
      assign S06_AXI_RID       = 0 ;
      assign S06_AXI_RDATA     = 0 ;
      assign S06_AXI_RRESP     = 0 ;
      assign S06_AXI_RLAST     = 0 ;
      assign S06_AXI_RVALID    = 0 ;
    end
  endgenerate
  
  generate
    if (C_NUM_SLAVE_PORTS > 07) begin : gen_si07
      assign s_axi_aclk      [07 +: 1]                                                   = S07_AXI_ACLK      ;
      assign s_axi_awid      [07 *P_AXI_ID_WIDTH +: P_AXI_ID_WIDTH]                      = S07_AXI_AWID      ;
      assign s_axi_awaddr    [07 *C_AXI_ADDR_WIDTH +: C_AXI_ADDR_WIDTH]                  = S07_AXI_AWADDR    ;
      assign s_axi_awlen     [07 *8 +: 8]                                                = S07_AXI_AWLEN     ;
      assign s_axi_awsize    [07 *3 +: 3]                                                = S07_AXI_AWSIZE    ;
      assign s_axi_awburst   [07 *2 +: 2]                                                = S07_AXI_AWBURST   ;
      assign s_axi_awlock    [07 *2 +: 2]                                                = S07_AXI_AWLOCK    ;
      assign s_axi_awcache   [07 *4 +: 4]                                                = S07_AXI_AWCACHE   ;
      assign s_axi_awprot    [07 *3 +: 3]                                                = S07_AXI_AWPROT    ;
      assign s_axi_awqos     [07 *4 +: 4]                                                = S07_AXI_AWQOS     ;
      assign s_axi_awvalid   [07 +: 1]                                                   = S07_AXI_AWVALID   ;
      assign s_axi_wdata     [07 *P_AXI_DATA_MAX_WIDTH +: P_AXI_DATA_MAX_WIDTH]          = S07_AXI_WDATA     ; 
      assign s_axi_wstrb     [07 *P_AXI_DATA_MAX_WIDTH/8 +: P_AXI_DATA_MAX_WIDTH/8]      = S07_AXI_WSTRB     ;    
      assign s_axi_wlast     [07 +: 1]                                                   = S07_AXI_WLAST     ;
      assign s_axi_wvalid    [07 +: 1]                                                   = S07_AXI_WVALID    ;
      assign s_axi_bready    [07 +: 1]                                                   = S07_AXI_BREADY    ;
      assign s_axi_arid      [07 *P_AXI_ID_WIDTH +: P_AXI_ID_WIDTH]                      = S07_AXI_ARID      ;
      assign s_axi_araddr    [07 *C_AXI_ADDR_WIDTH +: C_AXI_ADDR_WIDTH]                  = S07_AXI_ARADDR    ;
      assign s_axi_arlen     [07 *8 +: 8]                                                = S07_AXI_ARLEN     ;
      assign s_axi_arsize    [07 *3 +: 3]                                                = S07_AXI_ARSIZE    ;
      assign s_axi_arburst   [07 *2 +: 2]                                                = S07_AXI_ARBURST   ;
      assign s_axi_arlock    [07 *2 +: 2]                                                = S07_AXI_ARLOCK    ;
      assign s_axi_arcache   [07 *4 +: 4]                                                = S07_AXI_ARCACHE   ;
      assign s_axi_arprot    [07 *3 +: 3]                                                = S07_AXI_ARPROT    ;
      assign s_axi_arqos     [07 *4 +: 4]                                                = S07_AXI_ARQOS     ;
      assign s_axi_arvalid   [07 +: 1]                                                   = S07_AXI_ARVALID   ;
      assign s_axi_rready    [07 +: 1]                                                   = S07_AXI_RREADY    ;
                                                                                         
      assign S07_AXI_ARESET_OUT_N = s_axi_areset_out_n[07 +: 1]                                                   ;
      assign S07_AXI_AWREADY   = s_axi_awready   [07 +: 1]                                                   ;
      assign S07_AXI_WREADY    = s_axi_wready    [07 +: 1]                                                   ;
      assign S07_AXI_BID       = s_axi_bid       [07 *P_AXI_ID_WIDTH +: C_THREAD_ID_PORT_WIDTH]              ;
      assign S07_AXI_BRESP     = s_axi_bresp     [07 *2 +: 2]                                                ;
      assign S07_AXI_BVALID    = s_axi_bvalid    [07 +: 1]                                                   ;
      assign S07_AXI_ARREADY   = s_axi_arready   [07 +: 1]                                                   ;
      assign S07_AXI_RID       = s_axi_rid       [07 *P_AXI_ID_WIDTH +: C_THREAD_ID_PORT_WIDTH]              ;
      assign S07_AXI_RDATA     = s_axi_rdata     [07 *P_AXI_DATA_MAX_WIDTH +: C_S07_AXI_DATA_WIDTH]       ; 
      assign S07_AXI_RRESP     = s_axi_rresp     [07 *2 +: 2]                                                ;
      assign S07_AXI_RLAST     = s_axi_rlast     [07 +: 1]                                                   ;
      assign S07_AXI_RVALID    = s_axi_rvalid    [07 +: 1]                                                   ;
    end else begin : gen_no_si07
      assign S07_AXI_ARESET_OUT_N = 0 ;
      assign S07_AXI_AWREADY   = 0 ;
      assign S07_AXI_WREADY    = 0 ;
      assign S07_AXI_BID       = 0 ;
      assign S07_AXI_BRESP     = 0 ;
      assign S07_AXI_BVALID    = 0 ;
      assign S07_AXI_ARREADY   = 0 ;
      assign S07_AXI_RID       = 0 ;
      assign S07_AXI_RDATA     = 0 ;
      assign S07_AXI_RRESP     = 0 ;
      assign S07_AXI_RLAST     = 0 ;
      assign S07_AXI_RVALID    = 0 ;
    end
  endgenerate
  
  generate
    if (C_NUM_SLAVE_PORTS > 08) begin : gen_si08
      assign s_axi_aclk      [08 +: 1]                                                   = S08_AXI_ACLK      ;
      assign s_axi_awid      [08 *P_AXI_ID_WIDTH +: P_AXI_ID_WIDTH]                      = S08_AXI_AWID      ;
      assign s_axi_awaddr    [08 *C_AXI_ADDR_WIDTH +: C_AXI_ADDR_WIDTH]                  = S08_AXI_AWADDR    ;
      assign s_axi_awlen     [08 *8 +: 8]                                                = S08_AXI_AWLEN     ;
      assign s_axi_awsize    [08 *3 +: 3]                                                = S08_AXI_AWSIZE    ;
      assign s_axi_awburst   [08 *2 +: 2]                                                = S08_AXI_AWBURST   ;
      assign s_axi_awlock    [08 *2 +: 2]                                                = S08_AXI_AWLOCK    ;
      assign s_axi_awcache   [08 *4 +: 4]                                                = S08_AXI_AWCACHE   ;
      assign s_axi_awprot    [08 *3 +: 3]                                                = S08_AXI_AWPROT    ;
      assign s_axi_awqos     [08 *4 +: 4]                                                = S08_AXI_AWQOS     ;
      assign s_axi_awvalid   [08 +: 1]                                                   = S08_AXI_AWVALID   ;
      assign s_axi_wdata     [08 *P_AXI_DATA_MAX_WIDTH +: P_AXI_DATA_MAX_WIDTH]          = S08_AXI_WDATA     ; 
      assign s_axi_wstrb     [08 *P_AXI_DATA_MAX_WIDTH/8 +: P_AXI_DATA_MAX_WIDTH/8]      = S08_AXI_WSTRB     ;    
      assign s_axi_wlast     [08 +: 1]                                                   = S08_AXI_WLAST     ;
      assign s_axi_wvalid    [08 +: 1]                                                   = S08_AXI_WVALID    ;
      assign s_axi_bready    [08 +: 1]                                                   = S08_AXI_BREADY    ;
      assign s_axi_arid      [08 *P_AXI_ID_WIDTH +: P_AXI_ID_WIDTH]                      = S08_AXI_ARID      ;
      assign s_axi_araddr    [08 *C_AXI_ADDR_WIDTH +: C_AXI_ADDR_WIDTH]                  = S08_AXI_ARADDR    ;
      assign s_axi_arlen     [08 *8 +: 8]                                                = S08_AXI_ARLEN     ;
      assign s_axi_arsize    [08 *3 +: 3]                                                = S08_AXI_ARSIZE    ;
      assign s_axi_arburst   [08 *2 +: 2]                                                = S08_AXI_ARBURST   ;
      assign s_axi_arlock    [08 *2 +: 2]                                                = S08_AXI_ARLOCK    ;
      assign s_axi_arcache   [08 *4 +: 4]                                                = S08_AXI_ARCACHE   ;
      assign s_axi_arprot    [08 *3 +: 3]                                                = S08_AXI_ARPROT    ;
      assign s_axi_arqos     [08 *4 +: 4]                                                = S08_AXI_ARQOS     ;
      assign s_axi_arvalid   [08 +: 1]                                                   = S08_AXI_ARVALID   ;
      assign s_axi_rready    [08 +: 1]                                                   = S08_AXI_RREADY    ;
                                                                                         
      assign S08_AXI_ARESET_OUT_N = s_axi_areset_out_n[08 +: 1]                                                   ;
      assign S08_AXI_AWREADY   = s_axi_awready   [08 +: 1]                                                   ;
      assign S08_AXI_WREADY    = s_axi_wready    [08 +: 1]                                                   ;
      assign S08_AXI_BID       = s_axi_bid       [08 *P_AXI_ID_WIDTH +: C_THREAD_ID_PORT_WIDTH]              ;
      assign S08_AXI_BRESP     = s_axi_bresp     [08 *2 +: 2]                                                ;
      assign S08_AXI_BVALID    = s_axi_bvalid    [08 +: 1]                                                   ;
      assign S08_AXI_ARREADY   = s_axi_arready   [08 +: 1]                                                   ;
      assign S08_AXI_RID       = s_axi_rid       [08 *P_AXI_ID_WIDTH +: C_THREAD_ID_PORT_WIDTH]              ;
      assign S08_AXI_RDATA     = s_axi_rdata     [08 *P_AXI_DATA_MAX_WIDTH +: C_S08_AXI_DATA_WIDTH]       ; 
      assign S08_AXI_RRESP     = s_axi_rresp     [08 *2 +: 2]                                                ;
      assign S08_AXI_RLAST     = s_axi_rlast     [08 +: 1]                                                   ;
      assign S08_AXI_RVALID    = s_axi_rvalid    [08 +: 1]                                                   ;
    end else begin : gen_no_si08
      assign S08_AXI_ARESET_OUT_N = 0 ;
      assign S08_AXI_AWREADY   = 0 ;
      assign S08_AXI_WREADY    = 0 ;
      assign S08_AXI_BID       = 0 ;
      assign S08_AXI_BRESP     = 0 ;
      assign S08_AXI_BVALID    = 0 ;
      assign S08_AXI_ARREADY   = 0 ;
      assign S08_AXI_RID       = 0 ;
      assign S08_AXI_RDATA     = 0 ;
      assign S08_AXI_RRESP     = 0 ;
      assign S08_AXI_RLAST     = 0 ;
      assign S08_AXI_RVALID    = 0 ;
    end
  endgenerate
  
  generate
    if (C_NUM_SLAVE_PORTS > 09) begin : gen_si09
      assign s_axi_aclk      [09 +: 1]                                                   = S09_AXI_ACLK      ;
      assign s_axi_awid      [09 *P_AXI_ID_WIDTH +: P_AXI_ID_WIDTH]                      = S09_AXI_AWID      ;
      assign s_axi_awaddr    [09 *C_AXI_ADDR_WIDTH +: C_AXI_ADDR_WIDTH]                  = S09_AXI_AWADDR    ;
      assign s_axi_awlen     [09 *8 +: 8]                                                = S09_AXI_AWLEN     ;
      assign s_axi_awsize    [09 *3 +: 3]                                                = S09_AXI_AWSIZE    ;
      assign s_axi_awburst   [09 *2 +: 2]                                                = S09_AXI_AWBURST   ;
      assign s_axi_awlock    [09 *2 +: 2]                                                = S09_AXI_AWLOCK    ;
      assign s_axi_awcache   [09 *4 +: 4]                                                = S09_AXI_AWCACHE   ;
      assign s_axi_awprot    [09 *3 +: 3]                                                = S09_AXI_AWPROT    ;
      assign s_axi_awqos     [09 *4 +: 4]                                                = S09_AXI_AWQOS     ;
      assign s_axi_awvalid   [09 +: 1]                                                   = S09_AXI_AWVALID   ;
      assign s_axi_wdata     [09 *P_AXI_DATA_MAX_WIDTH +: P_AXI_DATA_MAX_WIDTH]          = S09_AXI_WDATA     ; 
      assign s_axi_wstrb     [09 *P_AXI_DATA_MAX_WIDTH/8 +: P_AXI_DATA_MAX_WIDTH/8]      = S09_AXI_WSTRB     ;    
      assign s_axi_wlast     [09 +: 1]                                                   = S09_AXI_WLAST     ;
      assign s_axi_wvalid    [09 +: 1]                                                   = S09_AXI_WVALID    ;
      assign s_axi_bready    [09 +: 1]                                                   = S09_AXI_BREADY    ;
      assign s_axi_arid      [09 *P_AXI_ID_WIDTH +: P_AXI_ID_WIDTH]                      = S09_AXI_ARID      ;
      assign s_axi_araddr    [09 *C_AXI_ADDR_WIDTH +: C_AXI_ADDR_WIDTH]                  = S09_AXI_ARADDR    ;
      assign s_axi_arlen     [09 *8 +: 8]                                                = S09_AXI_ARLEN     ;
      assign s_axi_arsize    [09 *3 +: 3]                                                = S09_AXI_ARSIZE    ;
      assign s_axi_arburst   [09 *2 +: 2]                                                = S09_AXI_ARBURST   ;
      assign s_axi_arlock    [09 *2 +: 2]                                                = S09_AXI_ARLOCK    ;
      assign s_axi_arcache   [09 *4 +: 4]                                                = S09_AXI_ARCACHE   ;
      assign s_axi_arprot    [09 *3 +: 3]                                                = S09_AXI_ARPROT    ;
      assign s_axi_arqos     [09 *4 +: 4]                                                = S09_AXI_ARQOS     ;
      assign s_axi_arvalid   [09 +: 1]                                                   = S09_AXI_ARVALID   ;
      assign s_axi_rready    [09 +: 1]                                                   = S09_AXI_RREADY    ;
                                                                                         
      assign S09_AXI_ARESET_OUT_N = s_axi_areset_out_n[09 +: 1]                                                   ;
      assign S09_AXI_AWREADY   = s_axi_awready   [09 +: 1]                                                   ;
      assign S09_AXI_WREADY    = s_axi_wready    [09 +: 1]                                                   ;
      assign S09_AXI_BID       = s_axi_bid       [09 *P_AXI_ID_WIDTH +: C_THREAD_ID_PORT_WIDTH]              ;
      assign S09_AXI_BRESP     = s_axi_bresp     [09 *2 +: 2]                                                ;
      assign S09_AXI_BVALID    = s_axi_bvalid    [09 +: 1]                                                   ;
      assign S09_AXI_ARREADY   = s_axi_arready   [09 +: 1]                                                   ;
      assign S09_AXI_RID       = s_axi_rid       [09 *P_AXI_ID_WIDTH +: C_THREAD_ID_PORT_WIDTH]              ;
      assign S09_AXI_RDATA     = s_axi_rdata     [09 *P_AXI_DATA_MAX_WIDTH +: C_S09_AXI_DATA_WIDTH]       ; 
      assign S09_AXI_RRESP     = s_axi_rresp     [09 *2 +: 2]                                                ;
      assign S09_AXI_RLAST     = s_axi_rlast     [09 +: 1]                                                   ;
      assign S09_AXI_RVALID    = s_axi_rvalid    [09 +: 1]                                                   ;
    end else begin : gen_no_si09
      assign S09_AXI_ARESET_OUT_N = 0 ;
      assign S09_AXI_AWREADY   = 0 ;
      assign S09_AXI_WREADY    = 0 ;
      assign S09_AXI_BID       = 0 ;
      assign S09_AXI_BRESP     = 0 ;
      assign S09_AXI_BVALID    = 0 ;
      assign S09_AXI_ARREADY   = 0 ;
      assign S09_AXI_RID       = 0 ;
      assign S09_AXI_RDATA     = 0 ;
      assign S09_AXI_RRESP     = 0 ;
      assign S09_AXI_RLAST     = 0 ;
      assign S09_AXI_RVALID    = 0 ;
    end
  endgenerate
  
  generate
    if (C_NUM_SLAVE_PORTS > 10) begin : gen_si10
      assign s_axi_aclk      [10 +: 1]                                                   = S10_AXI_ACLK      ;
      assign s_axi_awid      [10 *P_AXI_ID_WIDTH +: P_AXI_ID_WIDTH]                      = S10_AXI_AWID      ;
      assign s_axi_awaddr    [10 *C_AXI_ADDR_WIDTH +: C_AXI_ADDR_WIDTH]                  = S10_AXI_AWADDR    ;
      assign s_axi_awlen     [10 *8 +: 8]                                                = S10_AXI_AWLEN     ;
      assign s_axi_awsize    [10 *3 +: 3]                                                = S10_AXI_AWSIZE    ;
      assign s_axi_awburst   [10 *2 +: 2]                                                = S10_AXI_AWBURST   ;
      assign s_axi_awlock    [10 *2 +: 2]                                                = S10_AXI_AWLOCK    ;
      assign s_axi_awcache   [10 *4 +: 4]                                                = S10_AXI_AWCACHE   ;
      assign s_axi_awprot    [10 *3 +: 3]                                                = S10_AXI_AWPROT    ;
      assign s_axi_awqos     [10 *4 +: 4]                                                = S10_AXI_AWQOS     ;
      assign s_axi_awvalid   [10 +: 1]                                                   = S10_AXI_AWVALID   ;
      assign s_axi_wdata     [10 *P_AXI_DATA_MAX_WIDTH +: P_AXI_DATA_MAX_WIDTH]          = S10_AXI_WDATA     ; 
      assign s_axi_wstrb     [10 *P_AXI_DATA_MAX_WIDTH/8 +: P_AXI_DATA_MAX_WIDTH/8]      = S10_AXI_WSTRB     ;    
      assign s_axi_wlast     [10 +: 1]                                                   = S10_AXI_WLAST     ;
      assign s_axi_wvalid    [10 +: 1]                                                   = S10_AXI_WVALID    ;
      assign s_axi_bready    [10 +: 1]                                                   = S10_AXI_BREADY    ;
      assign s_axi_arid      [10 *P_AXI_ID_WIDTH +: P_AXI_ID_WIDTH]                      = S10_AXI_ARID      ;
      assign s_axi_araddr    [10 *C_AXI_ADDR_WIDTH +: C_AXI_ADDR_WIDTH]                  = S10_AXI_ARADDR    ;
      assign s_axi_arlen     [10 *8 +: 8]                                                = S10_AXI_ARLEN     ;
      assign s_axi_arsize    [10 *3 +: 3]                                                = S10_AXI_ARSIZE    ;
      assign s_axi_arburst   [10 *2 +: 2]                                                = S10_AXI_ARBURST   ;
      assign s_axi_arlock    [10 *2 +: 2]                                                = S10_AXI_ARLOCK    ;
      assign s_axi_arcache   [10 *4 +: 4]                                                = S10_AXI_ARCACHE   ;
      assign s_axi_arprot    [10 *3 +: 3]                                                = S10_AXI_ARPROT    ;
      assign s_axi_arqos     [10 *4 +: 4]                                                = S10_AXI_ARQOS     ;
      assign s_axi_arvalid   [10 +: 1]                                                   = S10_AXI_ARVALID   ;
      assign s_axi_rready    [10 +: 1]                                                   = S10_AXI_RREADY    ;
                                                                                         
      assign S10_AXI_ARESET_OUT_N = s_axi_areset_out_n[10 +: 1]                                                   ;
      assign S10_AXI_AWREADY   = s_axi_awready   [10 +: 1]                                                   ;
      assign S10_AXI_WREADY    = s_axi_wready    [10 +: 1]                                                   ;
      assign S10_AXI_BID       = s_axi_bid       [10 *P_AXI_ID_WIDTH +: C_THREAD_ID_PORT_WIDTH]              ;
      assign S10_AXI_BRESP     = s_axi_bresp     [10 *2 +: 2]                                                ;
      assign S10_AXI_BVALID    = s_axi_bvalid    [10 +: 1]                                                   ;
      assign S10_AXI_ARREADY   = s_axi_arready   [10 +: 1]                                                   ;
      assign S10_AXI_RID       = s_axi_rid       [10 *P_AXI_ID_WIDTH +: C_THREAD_ID_PORT_WIDTH]              ;
      assign S10_AXI_RDATA     = s_axi_rdata     [10 *P_AXI_DATA_MAX_WIDTH +: C_S10_AXI_DATA_WIDTH]       ; 
      assign S10_AXI_RRESP     = s_axi_rresp     [10 *2 +: 2]                                                ;
      assign S10_AXI_RLAST     = s_axi_rlast     [10 +: 1]                                                   ;
      assign S10_AXI_RVALID    = s_axi_rvalid    [10 +: 1]                                                   ;
    end else begin : gen_no_si10
      assign S10_AXI_ARESET_OUT_N = 0 ;
      assign S10_AXI_AWREADY   = 0 ;
      assign S10_AXI_WREADY    = 0 ;
      assign S10_AXI_BID       = 0 ;
      assign S10_AXI_BRESP     = 0 ;
      assign S10_AXI_BVALID    = 0 ;
      assign S10_AXI_ARREADY   = 0 ;
      assign S10_AXI_RID       = 0 ;
      assign S10_AXI_RDATA     = 0 ;
      assign S10_AXI_RRESP     = 0 ;
      assign S10_AXI_RLAST     = 0 ;
      assign S10_AXI_RVALID    = 0 ;
    end
  endgenerate
  
  generate
    if (C_NUM_SLAVE_PORTS > 11) begin : gen_si11
      assign s_axi_aclk      [11 +: 1]                                                   = S11_AXI_ACLK      ;
      assign s_axi_awid      [11 *P_AXI_ID_WIDTH +: P_AXI_ID_WIDTH]                      = S11_AXI_AWID      ;
      assign s_axi_awaddr    [11 *C_AXI_ADDR_WIDTH +: C_AXI_ADDR_WIDTH]                  = S11_AXI_AWADDR    ;
      assign s_axi_awlen     [11 *8 +: 8]                                                = S11_AXI_AWLEN     ;
      assign s_axi_awsize    [11 *3 +: 3]                                                = S11_AXI_AWSIZE    ;
      assign s_axi_awburst   [11 *2 +: 2]                                                = S11_AXI_AWBURST   ;
      assign s_axi_awlock    [11 *2 +: 2]                                                = S11_AXI_AWLOCK    ;
      assign s_axi_awcache   [11 *4 +: 4]                                                = S11_AXI_AWCACHE   ;
      assign s_axi_awprot    [11 *3 +: 3]                                                = S11_AXI_AWPROT    ;
      assign s_axi_awqos     [11 *4 +: 4]                                                = S11_AXI_AWQOS     ;
      assign s_axi_awvalid   [11 +: 1]                                                   = S11_AXI_AWVALID   ;
      assign s_axi_wdata     [11 *P_AXI_DATA_MAX_WIDTH +: P_AXI_DATA_MAX_WIDTH]          = S11_AXI_WDATA     ; 
      assign s_axi_wstrb     [11 *P_AXI_DATA_MAX_WIDTH/8 +: P_AXI_DATA_MAX_WIDTH/8]      = S11_AXI_WSTRB     ;    
      assign s_axi_wlast     [11 +: 1]                                                   = S11_AXI_WLAST     ;
      assign s_axi_wvalid    [11 +: 1]                                                   = S11_AXI_WVALID    ;
      assign s_axi_bready    [11 +: 1]                                                   = S11_AXI_BREADY    ;
      assign s_axi_arid      [11 *P_AXI_ID_WIDTH +: P_AXI_ID_WIDTH]                      = S11_AXI_ARID      ;
      assign s_axi_araddr    [11 *C_AXI_ADDR_WIDTH +: C_AXI_ADDR_WIDTH]                  = S11_AXI_ARADDR    ;
      assign s_axi_arlen     [11 *8 +: 8]                                                = S11_AXI_ARLEN     ;
      assign s_axi_arsize    [11 *3 +: 3]                                                = S11_AXI_ARSIZE    ;
      assign s_axi_arburst   [11 *2 +: 2]                                                = S11_AXI_ARBURST   ;
      assign s_axi_arlock    [11 *2 +: 2]                                                = S11_AXI_ARLOCK    ;
      assign s_axi_arcache   [11 *4 +: 4]                                                = S11_AXI_ARCACHE   ;
      assign s_axi_arprot    [11 *3 +: 3]                                                = S11_AXI_ARPROT    ;
      assign s_axi_arqos     [11 *4 +: 4]                                                = S11_AXI_ARQOS     ;
      assign s_axi_arvalid   [11 +: 1]                                                   = S11_AXI_ARVALID   ;
      assign s_axi_rready    [11 +: 1]                                                   = S11_AXI_RREADY    ;
                                                                                         
      assign S11_AXI_ARESET_OUT_N = s_axi_areset_out_n[11 +: 1]                                                   ;
      assign S11_AXI_AWREADY   = s_axi_awready   [11 +: 1]                                                   ;
      assign S11_AXI_WREADY    = s_axi_wready    [11 +: 1]                                                   ;
      assign S11_AXI_BID       = s_axi_bid       [11 *P_AXI_ID_WIDTH +: C_THREAD_ID_PORT_WIDTH]              ;
      assign S11_AXI_BRESP     = s_axi_bresp     [11 *2 +: 2]                                                ;
      assign S11_AXI_BVALID    = s_axi_bvalid    [11 +: 1]                                                   ;
      assign S11_AXI_ARREADY   = s_axi_arready   [11 +: 1]                                                   ;
      assign S11_AXI_RID       = s_axi_rid       [11 *P_AXI_ID_WIDTH +: C_THREAD_ID_PORT_WIDTH]              ;
      assign S11_AXI_RDATA     = s_axi_rdata     [11 *P_AXI_DATA_MAX_WIDTH +: C_S11_AXI_DATA_WIDTH]       ; 
      assign S11_AXI_RRESP     = s_axi_rresp     [11 *2 +: 2]                                                ;
      assign S11_AXI_RLAST     = s_axi_rlast     [11 +: 1]                                                   ;
      assign S11_AXI_RVALID    = s_axi_rvalid    [11 +: 1]                                                   ;
    end else begin : gen_no_si11
      assign S11_AXI_ARESET_OUT_N = 0 ;
      assign S11_AXI_AWREADY   = 0 ;
      assign S11_AXI_WREADY    = 0 ;
      assign S11_AXI_BID       = 0 ;
      assign S11_AXI_BRESP     = 0 ;
      assign S11_AXI_BVALID    = 0 ;
      assign S11_AXI_ARREADY   = 0 ;
      assign S11_AXI_RID       = 0 ;
      assign S11_AXI_RDATA     = 0 ;
      assign S11_AXI_RRESP     = 0 ;
      assign S11_AXI_RLAST     = 0 ;
      assign S11_AXI_RVALID    = 0 ;
    end
  endgenerate
  
  generate
    if (C_NUM_SLAVE_PORTS > 12) begin : gen_si12
      assign s_axi_aclk      [12 +: 1]                                                   = S12_AXI_ACLK      ;
      assign s_axi_awid      [12 *P_AXI_ID_WIDTH +: P_AXI_ID_WIDTH]                      = S12_AXI_AWID      ;
      assign s_axi_awaddr    [12 *C_AXI_ADDR_WIDTH +: C_AXI_ADDR_WIDTH]                  = S12_AXI_AWADDR    ;
      assign s_axi_awlen     [12 *8 +: 8]                                                = S12_AXI_AWLEN     ;
      assign s_axi_awsize    [12 *3 +: 3]                                                = S12_AXI_AWSIZE    ;
      assign s_axi_awburst   [12 *2 +: 2]                                                = S12_AXI_AWBURST   ;
      assign s_axi_awlock    [12 *2 +: 2]                                                = S12_AXI_AWLOCK    ;
      assign s_axi_awcache   [12 *4 +: 4]                                                = S12_AXI_AWCACHE   ;
      assign s_axi_awprot    [12 *3 +: 3]                                                = S12_AXI_AWPROT    ;
      assign s_axi_awqos     [12 *4 +: 4]                                                = S12_AXI_AWQOS     ;
      assign s_axi_awvalid   [12 +: 1]                                                   = S12_AXI_AWVALID   ;
      assign s_axi_wdata     [12 *P_AXI_DATA_MAX_WIDTH +: P_AXI_DATA_MAX_WIDTH]          = S12_AXI_WDATA     ; 
      assign s_axi_wstrb     [12 *P_AXI_DATA_MAX_WIDTH/8 +: P_AXI_DATA_MAX_WIDTH/8]      = S12_AXI_WSTRB     ;    
      assign s_axi_wlast     [12 +: 1]                                                   = S12_AXI_WLAST     ;
      assign s_axi_wvalid    [12 +: 1]                                                   = S12_AXI_WVALID    ;
      assign s_axi_bready    [12 +: 1]                                                   = S12_AXI_BREADY    ;
      assign s_axi_arid      [12 *P_AXI_ID_WIDTH +: P_AXI_ID_WIDTH]                      = S12_AXI_ARID      ;
      assign s_axi_araddr    [12 *C_AXI_ADDR_WIDTH +: C_AXI_ADDR_WIDTH]                  = S12_AXI_ARADDR    ;
      assign s_axi_arlen     [12 *8 +: 8]                                                = S12_AXI_ARLEN     ;
      assign s_axi_arsize    [12 *3 +: 3]                                                = S12_AXI_ARSIZE    ;
      assign s_axi_arburst   [12 *2 +: 2]                                                = S12_AXI_ARBURST   ;
      assign s_axi_arlock    [12 *2 +: 2]                                                = S12_AXI_ARLOCK    ;
      assign s_axi_arcache   [12 *4 +: 4]                                                = S12_AXI_ARCACHE   ;
      assign s_axi_arprot    [12 *3 +: 3]                                                = S12_AXI_ARPROT    ;
      assign s_axi_arqos     [12 *4 +: 4]                                                = S12_AXI_ARQOS     ;
      assign s_axi_arvalid   [12 +: 1]                                                   = S12_AXI_ARVALID   ;
      assign s_axi_rready    [12 +: 1]                                                   = S12_AXI_RREADY    ;
                                                                                         
      assign S12_AXI_ARESET_OUT_N = s_axi_areset_out_n[12 +: 1]                                                   ;
      assign S12_AXI_AWREADY   = s_axi_awready   [12 +: 1]                                                   ;
      assign S12_AXI_WREADY    = s_axi_wready    [12 +: 1]                                                   ;
      assign S12_AXI_BID       = s_axi_bid       [12 *P_AXI_ID_WIDTH +: C_THREAD_ID_PORT_WIDTH]              ;
      assign S12_AXI_BRESP     = s_axi_bresp     [12 *2 +: 2]                                                ;
      assign S12_AXI_BVALID    = s_axi_bvalid    [12 +: 1]                                                   ;
      assign S12_AXI_ARREADY   = s_axi_arready   [12 +: 1]                                                   ;
      assign S12_AXI_RID       = s_axi_rid       [12 *P_AXI_ID_WIDTH +: C_THREAD_ID_PORT_WIDTH]              ;
      assign S12_AXI_RDATA     = s_axi_rdata     [12 *P_AXI_DATA_MAX_WIDTH +: C_S12_AXI_DATA_WIDTH]       ; 
      assign S12_AXI_RRESP     = s_axi_rresp     [12 *2 +: 2]                                                ;
      assign S12_AXI_RLAST     = s_axi_rlast     [12 +: 1]                                                   ;
      assign S12_AXI_RVALID    = s_axi_rvalid    [12 +: 1]                                                   ;
    end else begin : gen_no_si12
      assign S12_AXI_ARESET_OUT_N = 0 ;
      assign S12_AXI_AWREADY   = 0 ;
      assign S12_AXI_WREADY    = 0 ;
      assign S12_AXI_BID       = 0 ;
      assign S12_AXI_BRESP     = 0 ;
      assign S12_AXI_BVALID    = 0 ;
      assign S12_AXI_ARREADY   = 0 ;
      assign S12_AXI_RID       = 0 ;
      assign S12_AXI_RDATA     = 0 ;
      assign S12_AXI_RRESP     = 0 ;
      assign S12_AXI_RLAST     = 0 ;
      assign S12_AXI_RVALID    = 0 ;
    end
  endgenerate
  
  generate
    if (C_NUM_SLAVE_PORTS > 13) begin : gen_si13
      assign s_axi_aclk      [13 +: 1]                                                   = S13_AXI_ACLK      ;
      assign s_axi_awid      [13 *P_AXI_ID_WIDTH +: P_AXI_ID_WIDTH]                      = S13_AXI_AWID      ;
      assign s_axi_awaddr    [13 *C_AXI_ADDR_WIDTH +: C_AXI_ADDR_WIDTH]                  = S13_AXI_AWADDR    ;
      assign s_axi_awlen     [13 *8 +: 8]                                                = S13_AXI_AWLEN     ;
      assign s_axi_awsize    [13 *3 +: 3]                                                = S13_AXI_AWSIZE    ;
      assign s_axi_awburst   [13 *2 +: 2]                                                = S13_AXI_AWBURST   ;
      assign s_axi_awlock    [13 *2 +: 2]                                                = S13_AXI_AWLOCK    ;
      assign s_axi_awcache   [13 *4 +: 4]                                                = S13_AXI_AWCACHE   ;
      assign s_axi_awprot    [13 *3 +: 3]                                                = S13_AXI_AWPROT    ;
      assign s_axi_awqos     [13 *4 +: 4]                                                = S13_AXI_AWQOS     ;
      assign s_axi_awvalid   [13 +: 1]                                                   = S13_AXI_AWVALID   ;
      assign s_axi_wdata     [13 *P_AXI_DATA_MAX_WIDTH +: P_AXI_DATA_MAX_WIDTH]          = S13_AXI_WDATA     ; 
      assign s_axi_wstrb     [13 *P_AXI_DATA_MAX_WIDTH/8 +: P_AXI_DATA_MAX_WIDTH/8]      = S13_AXI_WSTRB     ;    
      assign s_axi_wlast     [13 +: 1]                                                   = S13_AXI_WLAST     ;
      assign s_axi_wvalid    [13 +: 1]                                                   = S13_AXI_WVALID    ;
      assign s_axi_bready    [13 +: 1]                                                   = S13_AXI_BREADY    ;
      assign s_axi_arid      [13 *P_AXI_ID_WIDTH +: P_AXI_ID_WIDTH]                      = S13_AXI_ARID      ;
      assign s_axi_araddr    [13 *C_AXI_ADDR_WIDTH +: C_AXI_ADDR_WIDTH]                  = S13_AXI_ARADDR    ;
      assign s_axi_arlen     [13 *8 +: 8]                                                = S13_AXI_ARLEN     ;
      assign s_axi_arsize    [13 *3 +: 3]                                                = S13_AXI_ARSIZE    ;
      assign s_axi_arburst   [13 *2 +: 2]                                                = S13_AXI_ARBURST   ;
      assign s_axi_arlock    [13 *2 +: 2]                                                = S13_AXI_ARLOCK    ;
      assign s_axi_arcache   [13 *4 +: 4]                                                = S13_AXI_ARCACHE   ;
      assign s_axi_arprot    [13 *3 +: 3]                                                = S13_AXI_ARPROT    ;
      assign s_axi_arqos     [13 *4 +: 4]                                                = S13_AXI_ARQOS     ;
      assign s_axi_arvalid   [13 +: 1]                                                   = S13_AXI_ARVALID   ;
      assign s_axi_rready    [13 +: 1]                                                   = S13_AXI_RREADY    ;
                                                                                         
      assign S13_AXI_ARESET_OUT_N = s_axi_areset_out_n[13 +: 1]                                                   ;
      assign S13_AXI_AWREADY   = s_axi_awready   [13 +: 1]                                                   ;
      assign S13_AXI_WREADY    = s_axi_wready    [13 +: 1]                                                   ;
      assign S13_AXI_BID       = s_axi_bid       [13 *P_AXI_ID_WIDTH +: C_THREAD_ID_PORT_WIDTH]              ;
      assign S13_AXI_BRESP     = s_axi_bresp     [13 *2 +: 2]                                                ;
      assign S13_AXI_BVALID    = s_axi_bvalid    [13 +: 1]                                                   ;
      assign S13_AXI_ARREADY   = s_axi_arready   [13 +: 1]                                                   ;
      assign S13_AXI_RID       = s_axi_rid       [13 *P_AXI_ID_WIDTH +: C_THREAD_ID_PORT_WIDTH]              ;
      assign S13_AXI_RDATA     = s_axi_rdata     [13 *P_AXI_DATA_MAX_WIDTH +: C_S13_AXI_DATA_WIDTH]       ; 
      assign S13_AXI_RRESP     = s_axi_rresp     [13 *2 +: 2]                                                ;
      assign S13_AXI_RLAST     = s_axi_rlast     [13 +: 1]                                                   ;
      assign S13_AXI_RVALID    = s_axi_rvalid    [13 +: 1]                                                   ;
    end else begin : gen_no_si13
      assign S13_AXI_ARESET_OUT_N = 0 ;
      assign S13_AXI_AWREADY   = 0 ;
      assign S13_AXI_WREADY    = 0 ;
      assign S13_AXI_BID       = 0 ;
      assign S13_AXI_BRESP     = 0 ;
      assign S13_AXI_BVALID    = 0 ;
      assign S13_AXI_ARREADY   = 0 ;
      assign S13_AXI_RID       = 0 ;
      assign S13_AXI_RDATA     = 0 ;
      assign S13_AXI_RRESP     = 0 ;
      assign S13_AXI_RLAST     = 0 ;
      assign S13_AXI_RVALID    = 0 ;
    end
  endgenerate
  
  generate
    if (C_NUM_SLAVE_PORTS > 14) begin : gen_si14
      assign s_axi_aclk      [14 +: 1]                                                   = S14_AXI_ACLK      ;
      assign s_axi_awid      [14 *P_AXI_ID_WIDTH +: P_AXI_ID_WIDTH]                      = S14_AXI_AWID      ;
      assign s_axi_awaddr    [14 *C_AXI_ADDR_WIDTH +: C_AXI_ADDR_WIDTH]                  = S14_AXI_AWADDR    ;
      assign s_axi_awlen     [14 *8 +: 8]                                                = S14_AXI_AWLEN     ;
      assign s_axi_awsize    [14 *3 +: 3]                                                = S14_AXI_AWSIZE    ;
      assign s_axi_awburst   [14 *2 +: 2]                                                = S14_AXI_AWBURST   ;
      assign s_axi_awlock    [14 *2 +: 2]                                                = S14_AXI_AWLOCK    ;
      assign s_axi_awcache   [14 *4 +: 4]                                                = S14_AXI_AWCACHE   ;
      assign s_axi_awprot    [14 *3 +: 3]                                                = S14_AXI_AWPROT    ;
      assign s_axi_awqos     [14 *4 +: 4]                                                = S14_AXI_AWQOS     ;
      assign s_axi_awvalid   [14 +: 1]                                                   = S14_AXI_AWVALID   ;
      assign s_axi_wdata     [14 *P_AXI_DATA_MAX_WIDTH +: P_AXI_DATA_MAX_WIDTH]          = S14_AXI_WDATA     ; 
      assign s_axi_wstrb     [14 *P_AXI_DATA_MAX_WIDTH/8 +: P_AXI_DATA_MAX_WIDTH/8]      = S14_AXI_WSTRB     ;    
      assign s_axi_wlast     [14 +: 1]                                                   = S14_AXI_WLAST     ;
      assign s_axi_wvalid    [14 +: 1]                                                   = S14_AXI_WVALID    ;
      assign s_axi_bready    [14 +: 1]                                                   = S14_AXI_BREADY    ;
      assign s_axi_arid      [14 *P_AXI_ID_WIDTH +: P_AXI_ID_WIDTH]                      = S14_AXI_ARID      ;
      assign s_axi_araddr    [14 *C_AXI_ADDR_WIDTH +: C_AXI_ADDR_WIDTH]                  = S14_AXI_ARADDR    ;
      assign s_axi_arlen     [14 *8 +: 8]                                                = S14_AXI_ARLEN     ;
      assign s_axi_arsize    [14 *3 +: 3]                                                = S14_AXI_ARSIZE    ;
      assign s_axi_arburst   [14 *2 +: 2]                                                = S14_AXI_ARBURST   ;
      assign s_axi_arlock    [14 *2 +: 2]                                                = S14_AXI_ARLOCK    ;
      assign s_axi_arcache   [14 *4 +: 4]                                                = S14_AXI_ARCACHE   ;
      assign s_axi_arprot    [14 *3 +: 3]                                                = S14_AXI_ARPROT    ;
      assign s_axi_arqos     [14 *4 +: 4]                                                = S14_AXI_ARQOS     ;
      assign s_axi_arvalid   [14 +: 1]                                                   = S14_AXI_ARVALID   ;
      assign s_axi_rready    [14 +: 1]                                                   = S14_AXI_RREADY    ;
                                                                                         
      assign S14_AXI_ARESET_OUT_N = s_axi_areset_out_n[14 +: 1]                                                   ;
      assign S14_AXI_AWREADY   = s_axi_awready   [14 +: 1]                                                   ;
      assign S14_AXI_WREADY    = s_axi_wready    [14 +: 1]                                                   ;
      assign S14_AXI_BID       = s_axi_bid       [14 *P_AXI_ID_WIDTH +: C_THREAD_ID_PORT_WIDTH]              ;
      assign S14_AXI_BRESP     = s_axi_bresp     [14 *2 +: 2]                                                ;
      assign S14_AXI_BVALID    = s_axi_bvalid    [14 +: 1]                                                   ;
      assign S14_AXI_ARREADY   = s_axi_arready   [14 +: 1]                                                   ;
      assign S14_AXI_RID       = s_axi_rid       [14 *P_AXI_ID_WIDTH +: C_THREAD_ID_PORT_WIDTH]              ;
      assign S14_AXI_RDATA     = s_axi_rdata     [14 *P_AXI_DATA_MAX_WIDTH +: C_S14_AXI_DATA_WIDTH]       ; 
      assign S14_AXI_RRESP     = s_axi_rresp     [14 *2 +: 2]                                                ;
      assign S14_AXI_RLAST     = s_axi_rlast     [14 +: 1]                                                   ;
      assign S14_AXI_RVALID    = s_axi_rvalid    [14 +: 1]                                                   ;
    end else begin : gen_no_si14
      assign S14_AXI_ARESET_OUT_N = 0 ;
      assign S14_AXI_AWREADY   = 0 ;
      assign S14_AXI_WREADY    = 0 ;
      assign S14_AXI_BID       = 0 ;
      assign S14_AXI_BRESP     = 0 ;
      assign S14_AXI_BVALID    = 0 ;
      assign S14_AXI_ARREADY   = 0 ;
      assign S14_AXI_RID       = 0 ;
      assign S14_AXI_RDATA     = 0 ;
      assign S14_AXI_RRESP     = 0 ;
      assign S14_AXI_RLAST     = 0 ;
      assign S14_AXI_RVALID    = 0 ;
    end
  endgenerate
  
  generate
    if (C_NUM_SLAVE_PORTS > 15) begin : gen_si15
      assign s_axi_aclk      [15 +: 1]                                                   = S15_AXI_ACLK      ;
      assign s_axi_awid      [15 *P_AXI_ID_WIDTH +: P_AXI_ID_WIDTH]                      = S15_AXI_AWID      ;
      assign s_axi_awaddr    [15 *C_AXI_ADDR_WIDTH +: C_AXI_ADDR_WIDTH]                  = S15_AXI_AWADDR    ;
      assign s_axi_awlen     [15 *8 +: 8]                                                = S15_AXI_AWLEN     ;
      assign s_axi_awsize    [15 *3 +: 3]                                                = S15_AXI_AWSIZE    ;
      assign s_axi_awburst   [15 *2 +: 2]                                                = S15_AXI_AWBURST   ;
      assign s_axi_awlock    [15 *2 +: 2]                                                = S15_AXI_AWLOCK    ;
      assign s_axi_awcache   [15 *4 +: 4]                                                = S15_AXI_AWCACHE   ;
      assign s_axi_awprot    [15 *3 +: 3]                                                = S15_AXI_AWPROT    ;
      assign s_axi_awqos     [15 *4 +: 4]                                                = S15_AXI_AWQOS     ;
      assign s_axi_awvalid   [15 +: 1]                                                   = S15_AXI_AWVALID   ;
      assign s_axi_wdata     [15 *P_AXI_DATA_MAX_WIDTH +: P_AXI_DATA_MAX_WIDTH]          = S15_AXI_WDATA     ; 
      assign s_axi_wstrb     [15 *P_AXI_DATA_MAX_WIDTH/8 +: P_AXI_DATA_MAX_WIDTH/8]      = S15_AXI_WSTRB     ;    
      assign s_axi_wlast     [15 +: 1]                                                   = S15_AXI_WLAST     ;
      assign s_axi_wvalid    [15 +: 1]                                                   = S15_AXI_WVALID    ;
      assign s_axi_bready    [15 +: 1]                                                   = S15_AXI_BREADY    ;
      assign s_axi_arid      [15 *P_AXI_ID_WIDTH +: P_AXI_ID_WIDTH]                      = S15_AXI_ARID      ;
      assign s_axi_araddr    [15 *C_AXI_ADDR_WIDTH +: C_AXI_ADDR_WIDTH]                  = S15_AXI_ARADDR    ;
      assign s_axi_arlen     [15 *8 +: 8]                                                = S15_AXI_ARLEN     ;
      assign s_axi_arsize    [15 *3 +: 3]                                                = S15_AXI_ARSIZE    ;
      assign s_axi_arburst   [15 *2 +: 2]                                                = S15_AXI_ARBURST   ;
      assign s_axi_arlock    [15 *2 +: 2]                                                = S15_AXI_ARLOCK    ;
      assign s_axi_arcache   [15 *4 +: 4]                                                = S15_AXI_ARCACHE   ;
      assign s_axi_arprot    [15 *3 +: 3]                                                = S15_AXI_ARPROT    ;
      assign s_axi_arqos     [15 *4 +: 4]                                                = S15_AXI_ARQOS     ;
      assign s_axi_arvalid   [15 +: 1]                                                   = S15_AXI_ARVALID   ;
      assign s_axi_rready    [15 +: 1]                                                   = S15_AXI_RREADY    ;
                                                                                         
      assign S15_AXI_ARESET_OUT_N = s_axi_areset_out_n[15 +: 1]                                                   ;
      assign S15_AXI_AWREADY   = s_axi_awready   [15 +: 1]                                                   ;
      assign S15_AXI_WREADY    = s_axi_wready    [15 +: 1]                                                   ;
      assign S15_AXI_BID       = s_axi_bid       [15 *P_AXI_ID_WIDTH +: C_THREAD_ID_PORT_WIDTH]              ;
      assign S15_AXI_BRESP     = s_axi_bresp     [15 *2 +: 2]                                                ;
      assign S15_AXI_BVALID    = s_axi_bvalid    [15 +: 1]                                                   ;
      assign S15_AXI_ARREADY   = s_axi_arready   [15 +: 1]                                                   ;
      assign S15_AXI_RID       = s_axi_rid       [15 *P_AXI_ID_WIDTH +: C_THREAD_ID_PORT_WIDTH]              ;
      assign S15_AXI_RDATA     = s_axi_rdata     [15 *P_AXI_DATA_MAX_WIDTH +: C_S15_AXI_DATA_WIDTH]       ; 
      assign S15_AXI_RRESP     = s_axi_rresp     [15 *2 +: 2]                                                ;
      assign S15_AXI_RLAST     = s_axi_rlast     [15 +: 1]                                                   ;
      assign S15_AXI_RVALID    = s_axi_rvalid    [15 +: 1]                                                   ;
    end else begin : gen_no_si15
      assign S15_AXI_ARESET_OUT_N = 0 ;
      assign S15_AXI_AWREADY   = 0 ;
      assign S15_AXI_WREADY    = 0 ;
      assign S15_AXI_BID       = 0 ;
      assign S15_AXI_BRESP     = 0 ;
      assign S15_AXI_BVALID    = 0 ;
      assign S15_AXI_ARREADY   = 0 ;
      assign S15_AXI_RID       = 0 ;
      assign S15_AXI_RDATA     = 0 ;
      assign S15_AXI_RRESP     = 0 ;
      assign S15_AXI_RLAST     = 0 ;
      assign S15_AXI_RVALID    = 0 ;
    end
  endgenerate
  
      assign M00_AXI_AWLOCK         = m_axi_awlock_i[0];
      assign M00_AXI_ARLOCK         = m_axi_arlock_i[0];
      assign M00_AXI_WDATA          = m_axi_wdata[C_M00_AXI_DATA_WIDTH-1:0];
      assign M00_AXI_WSTRB          = m_axi_wstrb[C_M00_AXI_DATA_WIDTH/8-1:0];
      assign m_axi_rdata            = M00_AXI_RDATA;

axi_interconnect_v1_7_13_axi_interconnect
  #(
    .C_BASEFAMILY                     (C_FAMILY),
    .C_NUM_SLAVE_SLOTS                (C_NUM_SLAVE_PORTS),
    .C_NUM_MASTER_SLOTS               (1),
    .C_AXI_ID_WIDTH                   (P_AXI_ID_WIDTH),
    .C_AXI_ADDR_WIDTH                 (C_AXI_ADDR_WIDTH),
    .C_AXI_DATA_MAX_WIDTH             (P_AXI_DATA_MAX_WIDTH),
    .C_S_AXI_DATA_WIDTH               (P_S_AXI_DATA_WIDTH),
    .C_M_AXI_DATA_WIDTH               (P_M_AXI_DATA_WIDTH),
    .C_INTERCONNECT_DATA_WIDTH        (C_INTERCONNECT_DATA_WIDTH),
    .C_S_AXI_PROTOCOL                 (0),
    .C_M_AXI_PROTOCOL                 (0),
    .C_M_AXI_BASE_ADDR                (P_M_AXI_BASE_ADDR),
    .C_M_AXI_HIGH_ADDR                (P_M_AXI_HIGH_ADDR),
    .C_S_AXI_BASE_ID                  (P_S_AXI_BASE_ID),
    .C_S_AXI_THREAD_ID_WIDTH          (P_S_AXI_THREAD_ID_WIDTH),
    .C_S_AXI_IS_INTERCONNECT          (0),
    .C_S_AXI_ACLK_RATIO               (P_S_AXI_ACLK_RATIO),
    .C_S_AXI_IS_ACLK_ASYNC            (P_S_AXI_IS_ACLK_ASYNC),
    .C_M_AXI_ACLK_RATIO               (P_M_AXI_ACLK_RATIO),
    .C_M_AXI_IS_ACLK_ASYNC            (C_M00_AXI_IS_ACLK_ASYNC),
    .C_INTERCONNECT_ACLK_RATIO        (K),
    .C_S_AXI_SUPPORTS_WRITE           (P_S_AXI_SUPPORTS_WRITE),
    .C_S_AXI_SUPPORTS_READ            (P_S_AXI_SUPPORTS_READ),
    .C_M_AXI_SUPPORTS_WRITE           (16'hFFFF),
    .C_M_AXI_SUPPORTS_READ            (16'hFFFF),
    .C_AXI_SUPPORTS_USER_SIGNALS      (0),
    .C_AXI_CONNECTIVITY               (32'hFFFFFFFF),
    .C_S_AXI_SINGLE_THREAD            (0),
    .C_S_AXI_WRITE_ACCEPTANCE         (P_S_AXI_WRITE_ACCEPTANCE),
    .C_S_AXI_READ_ACCEPTANCE          (P_S_AXI_READ_ACCEPTANCE),
    .C_M_AXI_WRITE_ISSUING            (P_M_AXI_WRITE_ISSUING),
    .C_M_AXI_READ_ISSUING             (P_M_AXI_READ_ISSUING),
    .C_S_AXI_ARB_PRIORITY             (P_S_AXI_ARB_PRIORITY),
    .C_M_AXI_SECURE                   (0),
    .C_S_AXI_WRITE_FIFO_DEPTH         (P_S_AXI_WRITE_FIFO_DEPTH),
    .C_S_AXI_READ_FIFO_DEPTH          (P_S_AXI_READ_FIFO_DEPTH),
    .C_M_AXI_WRITE_FIFO_DEPTH         (C_M00_AXI_WRITE_FIFO_DEPTH),
    .C_M_AXI_READ_FIFO_DEPTH          (C_M00_AXI_READ_FIFO_DEPTH),
    .C_S_AXI_WRITE_FIFO_DELAY         (P_S_AXI_WRITE_FIFO_DELAY),
    .C_S_AXI_READ_FIFO_DELAY          (P_S_AXI_READ_FIFO_DELAY),
    .C_M_AXI_WRITE_FIFO_DELAY         (C_M00_AXI_WRITE_FIFO_DELAY),
    .C_M_AXI_READ_FIFO_DELAY          (C_M00_AXI_READ_FIFO_DELAY),
    .C_S_AXI_AW_REGISTER              (P_S_AXI_REGISTER),
    .C_S_AXI_AR_REGISTER              (P_S_AXI_REGISTER),
    .C_S_AXI_W_REGISTER               (P_S_AXI_REGISTER),
    .C_S_AXI_R_REGISTER               (P_S_AXI_REGISTER),
    .C_S_AXI_B_REGISTER               (P_S_AXI_REGISTER),
    .C_M_AXI_AW_REGISTER              (P_M_AXI_REGISTER),
    .C_M_AXI_AR_REGISTER              (P_M_AXI_REGISTER),
    .C_M_AXI_W_REGISTER               (P_M_AXI_REGISTER),
    .C_M_AXI_R_REGISTER               (P_M_AXI_REGISTER),
    .C_M_AXI_B_REGISTER               (P_M_AXI_REGISTER),
    .C_INTERCONNECT_CONNECTIVITY_MODE (1),
    .C_SYNCHRONIZER_STAGE             (C_SYNCHRONIZER_STAGE),
    .C_USE_CTRL_PORT                  (0),
    .C_RANGE_CHECK                    (0),
    .C_DEBUG                          (0)
  ) axi_interconnect_inst (
    .INTERCONNECT_ACLK        (INTERCONNECT_ACLK  ),
    .INTERCONNECT_ARESETN     (INTERCONNECT_ARESETN ),
    .S_AXI_ARESET_OUT_N       (s_axi_areset_out_n ),
    .S_AXI_ACLK               (s_axi_aclk         ),
    .S_AXI_AWID               (s_axi_awid         ),
    .S_AXI_AWADDR             (s_axi_awaddr       ),
    .S_AXI_AWLEN              (s_axi_awlen        ),
    .S_AXI_AWSIZE             (s_axi_awsize       ),
    .S_AXI_AWBURST            (s_axi_awburst      ),
    .S_AXI_AWLOCK             (s_axi_awlock       ),
    .S_AXI_AWCACHE            (s_axi_awcache      ),
    .S_AXI_AWPROT             (s_axi_awprot       ),
    .S_AXI_AWQOS              (s_axi_awqos        ),
    .S_AXI_AWUSER             ({C_NUM_SLAVE_PORTS{1'b0}}),
    .S_AXI_AWVALID            (s_axi_awvalid      ),
    .S_AXI_AWREADY            (s_axi_awready      ),
    .S_AXI_WID                ({(P_AXI_ID_WIDTH*C_NUM_SLAVE_PORTS){1'b0}}),
    .S_AXI_WDATA              (s_axi_wdata        ),
    .S_AXI_WSTRB              (s_axi_wstrb        ),
    .S_AXI_WLAST              (s_axi_wlast        ),
    .S_AXI_WUSER              ({C_NUM_SLAVE_PORTS{1'b0}}),
    .S_AXI_WVALID             (s_axi_wvalid       ),
    .S_AXI_WREADY             (s_axi_wready       ),
    .S_AXI_BID                (s_axi_bid          ),
    .S_AXI_BRESP              (s_axi_bresp        ),
    .S_AXI_BUSER             (),
    .S_AXI_BVALID             (s_axi_bvalid       ),
    .S_AXI_BREADY             (s_axi_bready       ),
    .S_AXI_ARID               (s_axi_arid         ),
    .S_AXI_ARADDR             (s_axi_araddr       ),
    .S_AXI_ARLEN              (s_axi_arlen        ),
    .S_AXI_ARSIZE             (s_axi_arsize       ),
    .S_AXI_ARBURST            (s_axi_arburst      ),
    .S_AXI_ARLOCK             (s_axi_arlock       ),
    .S_AXI_ARCACHE            (s_axi_arcache      ),
    .S_AXI_ARPROT             (s_axi_arprot       ),
    .S_AXI_ARQOS              (s_axi_arqos        ),
    .S_AXI_ARUSER             ({C_NUM_SLAVE_PORTS{1'b0}}),
    .S_AXI_ARVALID            (s_axi_arvalid      ),
    .S_AXI_ARREADY            (s_axi_arready      ),
    .S_AXI_RID                (s_axi_rid          ),
    .S_AXI_RDATA              (s_axi_rdata        ),
    .S_AXI_RRESP              (s_axi_rresp        ),
    .S_AXI_RLAST              (s_axi_rlast        ),
    .S_AXI_RVALID             (s_axi_rvalid       ),
    .S_AXI_RUSER             (),
    .S_AXI_RREADY             (s_axi_rready       ),
    .M_AXI_ARESET_OUT_N       (M00_AXI_ARESET_OUT_N ),
    .M_AXI_ACLK               (M00_AXI_ACLK         ),
    .M_AXI_AWID               (M00_AXI_AWID         ),
    .M_AXI_AWADDR             (M00_AXI_AWADDR       ),
    .M_AXI_AWLEN              (M00_AXI_AWLEN        ),
    .M_AXI_AWSIZE             (M00_AXI_AWSIZE       ),
    .M_AXI_AWBURST            (M00_AXI_AWBURST      ),
    .M_AXI_AWLOCK             (m_axi_awlock_i     ),
    .M_AXI_AWCACHE            (M00_AXI_AWCACHE      ),
    .M_AXI_AWPROT             (M00_AXI_AWPROT       ),
    .M_AXI_AWQOS              (M00_AXI_AWQOS        ),
    .M_AXI_AWREGION           (),
    .M_AXI_AWUSER             (),
    .M_AXI_AWVALID            (M00_AXI_AWVALID      ),
    .M_AXI_AWREADY            (M00_AXI_AWREADY      ),
    .M_AXI_WID                (),
    .M_AXI_WDATA              (m_axi_wdata          ),
    .M_AXI_WSTRB              (m_axi_wstrb          ),
    .M_AXI_WLAST              (M00_AXI_WLAST        ),
    .M_AXI_WUSER             (),
    .M_AXI_WVALID             (M00_AXI_WVALID       ),
    .M_AXI_WREADY             (M00_AXI_WREADY       ),
    .M_AXI_BID                (M00_AXI_BID          ),
    .M_AXI_BRESP              (M00_AXI_BRESP        ),
    .M_AXI_BUSER              (1'b0               ),
    .M_AXI_BVALID             (M00_AXI_BVALID       ),
    .M_AXI_BREADY             (M00_AXI_BREADY       ),
    .M_AXI_ARID               (M00_AXI_ARID         ),
    .M_AXI_ARADDR             (M00_AXI_ARADDR       ),
    .M_AXI_ARLEN              (M00_AXI_ARLEN        ),
    .M_AXI_ARSIZE             (M00_AXI_ARSIZE       ),
    .M_AXI_ARBURST            (M00_AXI_ARBURST      ),
    .M_AXI_ARLOCK             (m_axi_arlock_i     ),
    .M_AXI_ARCACHE            (M00_AXI_ARCACHE      ),
    .M_AXI_ARPROT             (M00_AXI_ARPROT       ),
    .M_AXI_ARQOS              (M00_AXI_ARQOS        ),
    .M_AXI_ARREGION           (),
    .M_AXI_ARUSER             (),
    .M_AXI_ARVALID            (M00_AXI_ARVALID      ),
    .M_AXI_ARREADY            (M00_AXI_ARREADY      ),
    .M_AXI_RID                (M00_AXI_RID          ),
    .M_AXI_RDATA              (m_axi_rdata          ),
    .M_AXI_RRESP              (M00_AXI_RRESP        ),
    .M_AXI_RLAST              (M00_AXI_RLAST        ),
    .M_AXI_RUSER              (1'b0               ),
    .M_AXI_RVALID             (M00_AXI_RVALID       ),
    .M_AXI_RREADY             (M00_AXI_RREADY       ),
    .S_AXI_CTRL_AWADDR        (32'h0              ),
    .S_AXI_CTRL_AWVALID       (1'b0               ),
    .S_AXI_CTRL_WDATA         (32'h0              ),
    .S_AXI_CTRL_WVALID        (1'b0               ),
    .S_AXI_CTRL_BREADY        (1'b0               ),
    .S_AXI_CTRL_ARADDR        (32'h0              ),
    .S_AXI_CTRL_ARVALID       (1'b0               ),
    .S_AXI_CTRL_RREADY        (1'b0               ),
    .S_AXI_CTRL_AWREADY (),
    .S_AXI_CTRL_WREADY (),
    .S_AXI_CTRL_BRESP (),
    .S_AXI_CTRL_BVALID (),
    .S_AXI_CTRL_ARREADY (),
    .S_AXI_CTRL_RDATA (),
    .S_AXI_CTRL_RRESP (),
    .S_AXI_CTRL_RVALID (),
    .IRQ (),
    .INTERCONNECT_ARESET_OUT_N (),
    .DEBUG_AW_TRANS_SEQ (),
    .DEBUG_AW_ARB_GRANT (),
    .DEBUG_AR_TRANS_SEQ (),
    .DEBUG_AR_ARB_GRANT (),
    .DEBUG_AW_TRANS_QUAL (),
    .DEBUG_AW_ACCEPT_CNT (),
    .DEBUG_AW_ACTIVE_THREAD (),
    .DEBUG_AW_ACTIVE_TARGET (),
    .DEBUG_AW_ACTIVE_REGION (),
    .DEBUG_AW_ERROR (),
    .DEBUG_AW_TARGET (),
    .DEBUG_AR_TRANS_QUAL (),
    .DEBUG_AR_ACCEPT_CNT (),
    .DEBUG_AR_ACTIVE_THREAD (),
    .DEBUG_AR_ACTIVE_TARGET (),
    .DEBUG_AR_ACTIVE_REGION (),
    .DEBUG_AR_ERROR (),
    .DEBUG_AR_TARGET (),
    .DEBUG_B_TRANS_SEQ (),
    .DEBUG_R_BEAT_CNT (),
    .DEBUG_R_TRANS_SEQ (),
    .DEBUG_AW_ISSUING_CNT (),
    .DEBUG_AR_ISSUING_CNT (),
    .DEBUG_W_BEAT_CNT (),
    .DEBUG_W_TRANS_SEQ (),
    .DEBUG_BID_TARGET (),
    .DEBUG_BID_ERROR (),
    .DEBUG_RID_TARGET (),
    .DEBUG_RID_ERROR (),
    .DEBUG_SR_SC_ARADDR (),
    .DEBUG_SR_SC_ARADDRCONTROL (),
    .DEBUG_SR_SC_AWADDR (),
    .DEBUG_SR_SC_AWADDRCONTROL (),
    .DEBUG_SR_SC_BRESP (),
    .DEBUG_SR_SC_RDATA (),
    .DEBUG_SR_SC_RDATACONTROL (),
    .DEBUG_SR_SC_WDATA (),
    .DEBUG_SR_SC_WDATACONTROL (),
    .DEBUG_SC_SF_ARADDR (),
    .DEBUG_SC_SF_ARADDRCONTROL (),
    .DEBUG_SC_SF_AWADDR (),
    .DEBUG_SC_SF_AWADDRCONTROL (),
    .DEBUG_SC_SF_BRESP (),
    .DEBUG_SC_SF_RDATA (),
    .DEBUG_SC_SF_RDATACONTROL (),
    .DEBUG_SC_SF_WDATA (),
    .DEBUG_SC_SF_WDATACONTROL (),
    .DEBUG_SF_CB_ARADDR (),
    .DEBUG_SF_CB_ARADDRCONTROL (),
    .DEBUG_SF_CB_AWADDR (),
    .DEBUG_SF_CB_AWADDRCONTROL (),
    .DEBUG_SF_CB_BRESP (),
    .DEBUG_SF_CB_RDATA (),
    .DEBUG_SF_CB_RDATACONTROL (),
    .DEBUG_SF_CB_WDATA (),
    .DEBUG_SF_CB_WDATACONTROL (),
    .DEBUG_CB_MF_ARADDR (),
    .DEBUG_CB_MF_ARADDRCONTROL (),
    .DEBUG_CB_MF_AWADDR (),
    .DEBUG_CB_MF_AWADDRCONTROL (),
    .DEBUG_CB_MF_BRESP (),
    .DEBUG_CB_MF_RDATA (),
    .DEBUG_CB_MF_RDATACONTROL (),
    .DEBUG_CB_MF_WDATA (),
    .DEBUG_CB_MF_WDATACONTROL (),
    .DEBUG_MF_MC_ARADDR (),
    .DEBUG_MF_MC_ARADDRCONTROL (),
    .DEBUG_MF_MC_AWADDR (),
    .DEBUG_MF_MC_AWADDRCONTROL (),
    .DEBUG_MF_MC_BRESP (),
    .DEBUG_MF_MC_RDATA (),
    .DEBUG_MF_MC_RDATACONTROL (),
    .DEBUG_MF_MC_WDATA (),
    .DEBUG_MF_MC_WDATACONTROL (),
    .DEBUG_MC_MP_ARADDR (),
    .DEBUG_MC_MP_ARADDRCONTROL (),
    .DEBUG_MC_MP_AWADDR (),
    .DEBUG_MC_MP_AWADDRCONTROL (),
    .DEBUG_MC_MP_BRESP (),
    .DEBUG_MC_MP_RDATA (),
    .DEBUG_MC_MP_RDATACONTROL (),
    .DEBUG_MC_MP_WDATA (),
    .DEBUG_MC_MP_WDATACONTROL (),
    .DEBUG_MP_MR_ARADDR (),
    .DEBUG_MP_MR_ARADDRCONTROL (),
    .DEBUG_MP_MR_AWADDR (),
    .DEBUG_MP_MR_AWADDRCONTROL (),
    .DEBUG_MP_MR_BRESP (),
    .DEBUG_MP_MR_RDATA (),
    .DEBUG_MP_MR_RDATACONTROL (),
    .DEBUG_MP_MR_WDATA (),
    .DEBUG_MP_MR_WDATACONTROL ()
    );

endmodule

`default_nettype wire


